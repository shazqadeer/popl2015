\section{Experience}
\label{sec:experience}

The \civl verifier has been under development for around two years.  
Over that period, we have developed a collection of 32 benchmarks, 
ranging in size from 17 to 324 LOC, to illustrate various features of
\civl and for regression testing as we evolved the verifier.
In addition to microbenchmarks, this collection also includes
standard benchmarks from the literature such as a multiset implementation~\cite{ElmasTQ05}, 
the ticket algorithm~\cite{FarzanKP14}, 
Treiber stack~\cite{Herlihy2008}, work-stealing queue~\cite{Blumofe1999},
device cache~\cite{ElmasQT09}, and lock-protected increment~\cite{FlanaganQ03}. 
The \civl verifier is fast; the entire benchmark set verifies in 17 seconds on a standard Windows machine with no benchmark 
requiring more than a couple of seconds.

\subsection{Garbage collector}
This combination of techniques helps manage the complexity of our verification of a realistic GC algorithm.  
In particular, although our algorithm is based on an earlier algorithm by Dijkstra et al~\cite{dijk78}, 
it extends the earlier algorithm with various modern optimizations and embellishments to improve generality and performance.  
These extensions include lower write barrier overhead, phase-based synchronization and handshaking, 
and coordination between the GC and mutator threads during root scanning; our use of linearity aids the proof of root scanning, 
while our rely-guarantee encoding aids management of colors inside the write barrier.  
Furthermore, our encoding of the algorithm in \civl spans a wide range of abstraction, 
from low-level memory operations all the way up to high-level specifications; 
we used six levels of refinement to help hide low-level details from the high-level portions of the verification.
We believe that \civl's combination of features makes practical, for the first time, verification across such a wide range of abstraction.

