\section{Experience}
\label{sec:experience}

The \civl verifier has been under development for around two years.  
Over that period, we have developed a collection of 32 benchmarks, 
ranging in size from 17 to 539 LOC, to illustrate various features of
\civl and for regression testing as we evolved the verifier.
In addition to microbenchmarks, this collection also includes
standard benchmarks from the literature such as a multiset implementation~\cite{ElmasTQ05}, 
the ticket algorithm~\cite{FarzanKP14}, 
Treiber stack~\cite{Herlihy2008}, work-stealing queue~\cite{Blumofe1999},
device cache~\cite{ElmasQT09}, and lock-protected increment~\cite{FlanaganQ03}. 
The \civl verifier is fast; the entire benchmark set verifies in 20 seconds on a standard 4-core Windows PC 
with no benchmark requiring more than a few seconds.

\subsection{Garbage collector}
This combination of techniques helps manage the complexity of our verification of a realistic GC algorithm.  
In particular, although our algorithm is based on an earlier algorithm by Dijkstra et al~\cite{dijk78}, 
it extends the earlier algorithm with various modern optimizations and embellishments to improve generality and performance.  
These extensions include lower write barrier overhead, phase-based synchronization and handshaking, 
and coordination between the GC and mutator threads during root scanning; our use of linearity aids the proof of root scanning, 
while our rely-guarantee encoding aids management of colors inside the write barrier.  
Furthermore, our encoding of the algorithm in \civl spans a wide range of abstraction, 
from low-level memory operations all the way up to high-level specifications; 
we used six levels of refinement to help hide low-level details from the high-level portions of the verification.
We believe that \civl's combination of features makes practical, for the first time, verification across such a wide range of abstraction.

The GC verification takes 60 seconds on the same 4-core Windows PC, generating and verifying 667 proof obligations. 
Should we provide more statistics about these proof obligations, e.g., their breakdown into commutativity and refinement checks?
Should we mention that verification time is dominated by the theorem prover; the time taken for the automata-theoretic simulation check is trivial.

