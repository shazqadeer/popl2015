\section{Introduction}
\label{sec:introduction}

What is refinement?  What distinguishes refinement from other approaches to verification? 
The big functional correctness proofs are all refinement proofs, e.g., Sel4 verification 
assuming no concurrency inside the kernel. or the works in hardware verification.  sel4 verification in the first paragraph and hardware verification in the second paragraph.

Hardware, although concurrent, is different from concurrent software.  
Control structures are different.  Hence refinement verification techniques in hardware don't work.
TLA+ drops down to logic but proofs are tedious, do not scale because of lack of software structuring.

Hallmarks of our refinement approach:
- Annotations respect the most important software abstraction of procedures; atomic actions are refined by procedures.
We develop techniques to manipulate multiple representations of a single program just as classical program verifiers manipulate programs and annotations such as types.


- Refinement supported by hiding to eliminate details due to data and reduction to eliminate details due to control.  

- Explicit non-interference reasoning based on assertions and a linear type system for encoding permissions disjoint memory, permissions, etc. logically.


This combination of techniques helps manage the complexity of our verification of a realistic GC algorithm.  
In particular, although our algorithm is based on an earlier algorithm by Dijkstra et al~\cite{dijk78}, 
it extends the earlier algorithm with various modern optimizations and embellishments to improve generality and performance.  
These extensions include lower write barrier overhead, phase-based synchronization and handshaking, 
and coordination between the GC and mutator threads during root scanning; our use of linearity aids the proof of root scanning, 
while our rely-guarantee encoding aids management of colors inside the write barrier.  
Furthermore, our encoding of the algorithm in \civl spans a wide range of abstraction, 
from low-level memory operations all the way up to high-level specifications; 
we used six levels of refinement to help hide low-level details from the high-level portions of the verification.
We believe that \civl's combination of features makes practical, for the first time, verification across such a wide range of abstraction.

