\section{Introduction}
\label{sec:introduction}

We present a technique for verifying a refinement relation between two concurrent, shared-memory multithreaded programs. 
Our work is inspired by stepwise refinement~\cite{Wirth1971}, an approach in which a high-level description is systematically refined, 
potentially via several intermediate descriptions, down to a detailed implementation. 
Refinement checking is a classical problem in verification and has been investigated in many contexts, 
including hardware verification~\cite{Eiriksson2000} and verification of cache-coherence protocols and distributed algorithms~\cite{Lamport2004}.
In the realm of sequential software, notable successes using the refinement approach include the work of Abrial et al.~\cite{AbrialBHHMV10} 
and the proof of full functional correctness of the seL4 microkernel~\cite{KleinAEMSKH14}. 
This paper presents the first general and automated proof system for refinement verification of shared-memory multithreaded software. 

We present our verification approach in the context of \civl, an idealized concurrent programming language.
In \civl, a program is described as a collection of procedures whose implementation 
can use the standard features such as assignment, conditionals, loops, procedure calls, and thread creation. 
Each procedure accesses shared global variables only through invocations of atomic actions.
During a refinement step, a subset of the atomic actions may be refined by new procedures and a new program is 
obtained by replacing the invocation of an atomic action by a call to the corresponding procedure refining the action.
Several such steps may be performed one after another until all atomic actions in the final program are directly implementable primitives.
%This process may be carried out in a bottom-up rather than top-down fashion, in which case an atomic action 
%can be thought of as the specification of the procedure that implements it.
Unlike classical program verifiers based on Floyd-Hoare reasoning~\cite{Floyd67,Hoare69} that manipulate a program and annotations, 
the \civl verifier manipulates multiple operational descriptions of a program, i.e., several levels of refinement are specified and verified at once. 

In \civl, a program refines another when there is a simulation relation connecting the two programs. 
The existence of such a simulation relation is inferred from per-procedure checks that relate the atomic specification for a procedure to the code implementing it. 
The verifier checks that each control path from the beginning to the end of the implementation can be divided into ``steps''
such that one step behaves like the atomic specification and all other steps have no effect on the visible state.
To carry out this reasoning, the \civl verifier needs to address two problems.
Firt, the notion of a ``step'' in the implementation must be defined.
The definition of a step can deeply affect the number of checks that need to be performed and the number of user annotations.
Second, it is typically not possible to show the correctness of a step from an arbitrary state.
A pre-condition for the step in terms of shared variables must be supplied by the programmer and mechanically checked by the verifier.

To address the first problem, \civl lets the programmer define a cooperative operational semantics
that is a subset of the usual preemptive semantics of a multithreaded program.
The {\em preemptive\/} semantics is sequentially consistent execution; all threads are imagined
to execute on a single processor and preemption, which causes a thread to be scheduled out and a nondeterministically chosen thread to 
be scheduled in, may occur before any instruction.\footnote{In this paper, 
we focus our attention on sequential consistency and leave consideration of weak memory models to future work.}
The {\em cooperative\/} semantics is explicitly introduced by the programmer through the use of a new primitive {\em yield\/} statement;
in this semantics a thread can be scheduled out only when it is about to execute a yield statement.
Given a program $P$, \civl verifies that the safety of the cooperative semantics of $P$ implies the safety of the preemptive semantics of $P$.
This verification is done by computing an automata-theoretic simulation check~\cite{HenzingerHK95} 
on an abstraction of $P$ in which each atomic action of $P$ is represented by only its mover type~\cite{Lipton75,FlanaganFLQ08}. 
The mover types themselves are verified separately and automatically using an automated theorem prover~\cite{MouraB08}.

To address the second problem that per-step refinement verification typically requires invariants about the program execution, 
\civl allows the programmer to specify location-specific invariants, attached either to a yield statement
or as a precondition or a postcondition of a procedure. 
Each location invariant must be correct for all executions and must continue to hold in spite of potential interference from concurrently executing threads.
We build upon classical work~\cite{OwickiG76,Jones83} on reasoning about non-interference
with two distinct innovations.
First, we do not require the annotations to be strong enough to prove program correctness but only strong enough to provide the context for per-procedure, per-step refinement checking. 
Program correctness is established as the culmination of a sequence of refinement steps leading to an abstract program that cannot fail.
Second, to establish a post-condition of a procedure, we do not need to propagate a pre-condition through all the yield annotations in the procedure body. 
The correctness of an atomic action specification gives us a simple frame rule---the pre-condition only needs to be propagated across the atomic action specification. 
\civl further simplifies the manual annotations required for logical non-interference checking
by providing a linear type system~\cite{Wadler90lineartypes} that enables logical encoding of thread identifiers, permissions~\cite{boyland:03fractions}, 
and disjoint memory~\cite{LahiriQW11}.

We have implemented \civl as a conservative extension of the \boogie verifier.  
We have used it to verify a collection of microbenchmarks and benchmarks from the literature such as 
a multiset implementation~\cite{ElmasTQ05},
the ticket algorithm~\cite{FarzanKP14}, 
Treiber stack~\cite{Herlihy2008}, work-stealing queue~\cite{Blumofe1999},
device cache~\cite{ElmasQT09}, and lock-protected increment~\cite{FlanaganQ03}. 
The most challenging case study with \civl was carried out concurrently with \civl's development and served as a design driver. 
We verified a concurrent garbage collector, through six levels of refinement, down to atomic actions corresponding to individual memory accesses. 
The level of granularity of the lowest-level implementation distinguishes this verification effort, 
detailed in a technical report~\cite{gc-techreport}, from previous attempts in the literature. 

We conclude this section by summarizing the novel features of the \civl verifier:
\begin{itemize}
\item Automated refinement checking of atomic action specifications against imperative code.
\item A combination of automata-theoretic checking based on simulation relations and logical checking based on verification conditions.
\item Powerful and flexible invariant reasoning based on location-specific invariants and linear variables.
\end{itemize}
The \civl verifier is the first to put these features together and use them to verify a collection of realistic and challenging shared-memory
concurrent programs.
