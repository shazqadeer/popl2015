\section{Introduction}
\label{sec:introduction}

A popular approach to software verification is based on the method of Floyd~\cite{Floyd} and Hoare~\cite{Hoare}.
In this method, the verification of a large software component is performed modularly by verifying each procedure in it separately.
This modularity is enabled by the use of interface specifications (preconditions and postconditions) constraining the behavior of each procedure.
It is well-known that the Floyd-Hoare method is inadequate for reasoning about concurrent shared-memory programs,
primarily because the execution of a procedure may be interfered with by concurrently executing threads.
Over the years, several attempts have been made to extend Floyd-Hoare reasoning to deal with concurrent interference, 
including classical approaches such as location invariants~\cite{Ashcroft,OwickiGries} and rely-guarantee~\cite{Jones},
and other more recent approaches~\cite{concurrent-separation-logic,deny-guarantee,hoare-type-theory}.
However, in spite of these efforts, scalable and automated reasoning about shared-memory concurrent programs remains difficult.
This paper presents a new approach to this problem.

Our approach to reasoning about shared-memory concurrency is inspired by stepwise refinement~\cite{Dijkstra}, 
an approach in which a high-level description is systematically refined, 
potentially via several intermediate descriptions, down to a detailed implementation.
In the realm of sequential software, notable successes using the refinement approach include Abrial's work on blah-blah~\cite{Abrial}
and the proof of full functional correctness of the seL4 microkernel~\cite{seL4}.
Yet, compared to the Floyd-Hoare approach, 
the refinement approach has received considerably less attention from researchers in software verification.

In this paper, we introduce the \civl approach to reasoning about a concurrent software component.
In the \civl approach, such a component is described as a collection of procedures whose implementation 
can use the standard features such as assignment, conditionals, loops, procedure calls, and thread creation. 
In addition, each procedure can also access shared global variables but only through invocations of atomic actions.
During a refinement step, a subset of the atomic actions may be refined by new procedures and a new program is 
obtained by replacing the invocation of an atomic action by a call to the corresponding procedure refining the action.
Several such steps may be performed one after another until all atomic actions in the final program are directly implementable primitives.
This process may be carried out in a bottom-up rather than top-down fashion, in which case an atomic action 
can be thought of as the specification of the procedure that implements it.
Unlike classical program verifiers based on Floyd-Hoare reasoning that manipulate a program and annotations on it, 
the \civl verifier manipulates multiple operational descriptions of a single program. 

An important innovation in \civl is that refinement is proved not on cooperative not preemptive semantics.

Each refinement step requires invariants. 
Explicit non-interference reasoning based on assertions and a linear type system for encoding permissions disjoint memory, 
permissions, etc. logically.

We have implemented \civl as a conservative extension of the \boogie verifier.  
We have used it to verify a collection of microbenchmarks and benchmarks from the literature such as
the ticket algorithm~\cite{ticket}, Treiber stack~\cite{treiber}, work-stealing queue~\cite{wsq},
device cache~\cite{device-cache}, and lock-protected increment~\cite{incr}.
We have also verified a concurrent garbage collector algorithm (say something more here).
