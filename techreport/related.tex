\section{Related work}
\label{sec:related}

In this section, we discuss related work on verification of concurrent systems.
We first discuss approaches based on refinement and later approaches more directly inspired 
by Floyd-Hoare reasoning.

{\bf Refinement-oriented verification.}
Atomic action specifications have been used by the Calvin~\cite{FlanaganFQS05} verifier previously.
Unlike \civl which makes a distinction between preemptive and cooperative semantics,
Calvin attempts to verify refinement directly on the preemptive semantics.
The ability to reason on cooperative semantics lowers the complexity of annotations 
required for the refinement proof; consequently, we believe that \civl is more usable.
Calvin does not support location invariants and linear variables. 

Reduction has been used for program simplification by the QED~\cite{ElmasQT09} verifier.
A proof step in QED is a small rewrite in the concurrent program
that must be justified by potentially expensive reduction and invariant reasoning;
the number of these small proof steps directly affect both programmer and computer effort.
On the other hand, \civl supports large proof steps, in each of which the bodies of several procedures
are automatically replaced by atomic actions, thereby lowering the cost of both interaction and automation.
The increased scalability and usability of \civl is key to the construction of proofs spanning a large abstraction gap
between specification and implementation.
QED does not support location invariants and linear variables. 

This paragraph needs to be improved.
TLA+~\cite{Lamport2004} has been used for performing refinement proofs between implementation and specification of protocols.
TLA+ drops down to logic but proofs are tedious and do not scale because of lack of software structuring.

We need a paragraph on refinement proofs in hardware, citing use of SMV~\cite{McMillan00} to verify protocol processor~\cite{Eiriksson2000} 
and Mocha~\cite{AlurHMQRT98} verification of VGI processor~\cite{Henzinger1999}.

{\bf Other approaches.}
VCC~\cite{VCC} is a tool for verifying concurrent C programs.  
Chalice~\cite{LM09} is a language and modular verification tool for concurrent programs. 
VCC does not support refinement and Chalice does so only for sequential programs;
unlike these tools, \civl is designed to verify refinement for concurrent programs.  
VCC and Chalice base their invariant reasoning on objects, object ownership, and type invariants. 
Invariant reasoning in \civl is more primitive and based on assertions in yield statements. 
Although the approach in VCC and Chalice is more convenient when applicable, \civl's approach is more flexible. 
VCC and Chalice can reason sequentially about objects exclusively owned by a thread;
\civl accomplishes the same using linear variables.
Neither VCC nor Chalice support movers and reduction reasoning.

Concurrent separation logic~\cite{OHearn07} reasons about concurrency without 
explicitly checking for non-interference between threads. 
Recently, tools based on this logic that blend in explicit non-interference reasoning have been developed~\cite{SAGL,RGSep}. 
\civl's combination of interference checking and linear variables is an extreme example of this trend,
supplying very primitive abstractions and letting programmers mix and match these abstractions freely.

Is there any other POPL-style work that needs to be cited?
