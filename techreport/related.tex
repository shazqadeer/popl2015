
\section{Related work}
\label{sec:related}

The key design goal for \civl is automated refinement of a concurrent software system,
via intermediate descriptions, down to a detailed implementation in terms of primitive atomic operations.
\civl verifies that each description correctly refines the description
at the level above, which requires a collection of correlated
whole-program refinement proofs. 
By contrast, existing work on atomicity refinement for concurrent software is
targeted at a single refinement proof, and not between two whole
programs, rather, between procedure implementations and
specifications. 
The \civl theory and verification tool are the first to
enable multiple layered whole-program refinement proofs
within a single unifying theory and automate this process with tool support.
While many of the verification techniques available in \civl appear in
the literature, \civl is the first to make sound, joint use of them to
support multiple layers of refinement. 

\subsection{Refinement-oriented verification}
Atomic action specifications have been explored by the
\calvin~\cite{FlanaganFQS05,FreundQ04} verifier previously. 
\civl makes a distinction between preemptive and cooperative
semantics, and carries out refinement verification on a procedure body
with cooperative semantics as enabled by movers types and reduction.
\calvin attempts to verify refinement directly on the preemptive
semantics, making only limited use of movers at the lowest-level
representation. 
\calvin, unlike \civl, does not support location invariants and linear
variables. 
It instead requires that a two-state rely predicate modeling all possible
interference on the shared state by other threads be supplied. 
Location invariants can encode rely-guarantee reasoning vice versa. 
However, in practice, carrying out non-interference reasoning only
using rely-guarantee reasoning can be significantly harder from a
human interactive proof standpoint. We discuss this point further on
the garbage collector below. 

\QED~\cite{ElmasQT09} is a simplifier for concurrent programs and is close in spirit to the 
refinement-oriented approach of \civl.
A key distinction between \civl and \QED is the fact that a proof step in \QED is a small rewrite in the concurrent program
that must be justified by potentially expensive reduction and invariant reasoning.
In \QED, abstract versions of a program are obtained by transforming the initial
version by applying a proof script. 
This makes it difficult to organize a proof in \QED by providing a
description of a program at several different levels of abstraction. 
Further, the number of small proof steps directly affect both programmer
and computer effort. 
By contrast, \civl supports large proof steps, in each of which the bodies of several procedures
are automatically replaced by atomic actions, thereby lowering the cost of both interaction and automation.
The non-interference reasoning in \QED is even more limited than \calvin.
\QED supports only global invariants and does not support rely-guarantee reasoning or linear variables.

Liang et al.~\cite{LiangRGSim} present a method for verifying that procedure
bodies refine atomic specifications. 
The key verification approach is
rely-guarantee reasoning and the refinement (simulation) relation between
a procedure and its specification is constrained so it is preserved under
parallel composition. 
This work also lists a concurrent garbage collector as one of the case
studies. 
Their proof corresponds to a few layers of our proof, in particular,
does not refine the implementation to the level of hardware
instructions. 
Since this work uses different languages to describe the high-level
and low-level programs, it is not immediately possible to carry out a
multi-level stepwise refinement proof. 
This work does not provide any tool support for verifying refinement. 

Turon and Wand~\cite{TuronM11} use ownership disciplines and
separation logic to verify refinement of atomic specifications by 
concurrent data structure implementations. 
Rely-guarantee reasoning is
supported to provide compositionality and non-interference
arguments. 
This work targets a single refinement step between atomic
specifications for methods and their implementations. 
No tool support for this verification method is provided. 

Verifying linearizability of concurrent data structures (see, e.g.,
\cite{tacasLin,aliLin}) can be viewed as an instance of one-level of
refinement in our setting. 
\civl can be used for mechanical
verification of linearizability, as we did for the Treiber stack, for
instance. 
Tools and techniques specific to verifying linearizability
cannot, however, be easily generalized for stepwise refinement proofs
through multiple levels. 

Refinement proofs
between implementations and specifications of protocols have been
investigated using the TLA+~\cite{Lamport2004} specification
language. 
Compositional proofs between specifications and
implementations consisting of modules~\cite{AbadiAssumeGuarantee} have
been investigated in this context. 
Modular refinement proofs for hardware systems have been investigated extensively
(e.g.,~\cite{Henzinger1999,Eiriksson2000}) using the SMV~\cite{McMillan00} and Mocha~\cite{AlurHMQRT98} 
model checking tools.
For concurrent, shared-memory
software, there is a significant cognitive gap between the imperative
multithreaded program text as written in, e.g., \civl, and the TLA+,
SMV or Mocha descriptions for the program. 
The latter encode the
semantics of an imperative concurrent program as a
state-transition relation. 
Proofs in TLA+, SMV and Mocha, whether modular or not, are
distinguished from proofs in \civl and other techniques that operate
off of the imperative program text in this key regard. 
Reasoning on a
semantic model of a program rather than the program text itself, for
shared-memory concurrent programs, adds a significant amount of
cognitive load to the user. 
It also makes it difficult to structure a
proof along the syntactic structure of the imperative program. 

\subsection{Reasoning about concurrency}
In this section, we briefly discuss foundational techniques
for combating the complexity of concurrent program verification. 
\civl has common ideas with tools and formalisms
discussed in this section, but the primary purpose of the latter 
is the verification of safety properties of a {\em single} concurrent program rather than refinement. 
These techniques are orthogonal and complementary to \civl.
Refinement in \civl is orthogonal to these techniques and can potentially be combined with them.
Conversely, these techniques can be aided significantly by \civl's 
ability to connect a complex concurrent program to a simpler abstraction.

VCC~\cite{VCC} is a tool for verifying concurrent C programs.  
Chalice~\cite{LM09} is a language and modular verification tool for concurrent programs. 
VCC does not support refinement and Chalice does so only for sequential programs.  
VCC and Chalice base their invariant reasoning on objects, object ownership, and type invariants. 
Invariant reasoning in \civl is more primitive and based on predicates in yield statements. 
Although the approach in VCC and Chalice is more convenient when applicable, \civl's approach is more flexible. 
VCC and Chalice can reason sequentially about objects exclusively owned by a thread;
\civl accomplishes the same using linear variables.
Neither VCC nor Chalice support movers and reduction reasoning.

Concurrent separation logic~\cite{OHearn07} reasons about concurrency without 
explicitly checking for non-interference between threads. 
Recently, tools based on this logic that blend in explicit non-interference reasoning have been developed~\cite{SAGL,RGSep}. 
\civl's combination of interference checking and linear variables is
an extreme example of this trend, is very general and agnostic. We supply very primitive abstractions and let programmers mix and
match these abstractions freely to encode the non-interference
reasoning style of their choice. 

\subsection{Discussion}
We now put atomicity refinement techniques from the literature and
\civl in context by presenting an overview of our design
driver, the stepwise refinement of a garbage collector~\cite{gc-techreport}.
The refinement proof spans six levels of abstraction. 
Each of refinement proof relating two consecutive levels is made feasible by a different
blend of the techniques in \civl. 
While other refinement techniques have also used garbage collectors as
case studies, the refinement tasks tackled there bridge only one or two of the levels in 
our refinement proof\footnote{A more specific discussion of this point
  can be found in the technical report on the verification of the
  garbage collector\cite{gc-techreport}.} and only target the refinement verification
challenges apparent at those levels of the proof. 

The topmost-level description of the garbage collector provides an
idealized, abstract view of memory. 
At this level, none of the lowest-level implementation variables are
visible -- variable hiding has been used to project them away. 
In the top few levels of the garbage collector proof, invariant-based
non-interference reasonig was the key tool we used, while reduction
simplified verification by enabling us to use coarser atomic actions and fewer
location invariants.  
Linear variables were used throughout the proof to model the distinct
thread identifiers for the garbage collector thread and mutator
threads, but were most instrumental in encoding the fact that during
the initialization phase of the program there is no concurrency.
As exemplified by the
garbage collector proof of Liang et al.~\cite{LiangRGSim} (which
{\em assumes} the atomicity of actions in the lower levels our proof),
for these top few levels of our proof, rely-guarantee and separation-logic-based
approaches would have also performed well. 
One important distinction is \civl's capability to use location invariants rather than pure rely-guarantee reasoning.
This helped interactive proof at the top levels significantly.
For the mark phase of the garbage collector, we made critical use of different invariants at different
locations in procedure bodies. 
While the same non-interference argument could have been encoded in
rely-guarantee reasoning, as we had done ourselves in an earlier
version of our proof, 
it would have required the use of several additional auxiliary shared variables. 
Invariants, rely and guarantee conditions referring to such auxiliary
variables throughout the program made interactive invariant reasoning more difficult to manage. 

In the lowest few levels of the garbage collector proof, where
correctness of concurrent data structures and synchronization primitives were proven, we made
relatively little use of location invariants, and made heavier use of
linear variables and reduction.
Our proof at all levels was aided significantly because
reduction (which also used linearity while proving commutativity)
enabled us to reason about coarser atomic blocks, fewer interleaving
locations, and therefore fewer location invariants and fewer 
yield-to-yield refinement checks. 
But in the lower levels of the proof, reduction and variable hiding were our primary
tools. 
For one of these lower-leve refinement tasks, for instance, when verifying the correctness of a
lock-protected concurrently-accessed stack, ownership
arguments, separation logic, or \QED-style atomicity would have been
sufficient. 
But, at the higher levels of our proof, where non-interference
reasoning via invariants and linear variables was indispensable, 
atomicity alone, or ownership or separation logic arguments alone
would have run into difficulty. 

To sum up, while existing techniques in the literature have as their
``sweet spot'' a few of the refinement proofs in our garbage collector
proof, they run into difficulty in others. 
More critically, they
do not facilitate layering refinement proofs, which is required for stepwise
refinement. 
Using a realistic top-down proof as \civl's design driver led us to
combine in one tool and consistent theory, the verification techniques
of linearity, reduction and non-interference reasoning in the service
of a modular refinement proof directed by the syntactic structure of
the imperative concurrent program. 
For this purpose, we also devised
novel ways to combine automata-theoretic and assertion-based
verification, and encode the component techniques, e.g., linearity, in
assertion-based verification. 
%%%%%%%%% SHAZ PLEASE REFINE OR REMOVE THIS FINAL SENTENCE %%%%%%%%%%%

