\section{Related work}
\label{sec:related}

In this section, we discuss related work on verification of concurrent systems.
We first discuss approaches based on refinement and later approaches more directly inspired 
by Floyd-Hoare reasoning.

{\bf Refinement-oriented verification.}
Atomic action specifications have been used by the Calvin~\cite{FlanaganFQS05} verifier previously.
Unlike \civl which makes a distinction between preemptive and cooperative semantics,
Calvin attempts to verify refinement directly on the preemptive semantics.
The ability to reason on cooperative semantics lowers the complexity of annotations 
required for the refinement proof; consequently, we believe that \civl is more usable.
Calvin does not support location invariants and linear variables. 

Reduction has been used for program simplification by the QED~\cite{ElmasQT09} verifier.
A proof step in QED is a small rewrite in the concurrent program
that must be justified by potentially expensive reduction and invariant reasoning;
the number of these small proof steps directly affect both programmer and computer effort.
On the other hand, \civl supports large proof steps, in each of which the bodies of several procedures
are automatically replaced by atomic actions, thereby lowering the cost of both interaction and automation.
The increased scalability and usability of \civl is key to the construction of proofs spanning a large abstraction gap
between specification and implementation.
QED does not support location invariants and linear variables. 

This paragraph needs to be improved.
TLA+~\cite{Lamport2004} has been used for performing refinement proofs between implementation and specification of protocols.
TLA+ drops down to logic but proofs are tedious and do not scale because of lack of software structuring.

We need a paragraph on refinement proofs in hardware, citing use of SMV~\cite{McMillan00} to verify protocol processor~\cite{Eiriksson2000} 
and Mocha~\cite{AlurHMQRT98} verification of VGI processor~\cite{Henzinger1999}.

{\bf Other approaches.}
VCC~\cite{VCC} is a tool for verifying concurrent C programs.  
Chalice~\cite{LM09} is a language and modular verification tool for concurrent programs. 
VCC does not support refinement and Chalice does so only for sequential programs;
unlike these tools, \civl is designed to verify refinement for concurrent programs.  
VCC and Chalice base their invariant reasoning on objects, object ownership, and type invariants. 
Invariant reasoning in \civl is more primitive and based on assertions in yield statements. 
Although the approach in VCC and Chalice is more convenient when applicable, \civl's approach is more flexible. 
VCC and Chalice can reason sequentially about objects exclusively owned by a thread;
\civl accomplishes the same using linear variables.
Neither VCC nor Chalice support movers and reduction reasoning.

Concurrent separation logic~\cite{OHearn07} reasons about concurrency without 
explicitly checking for non-interference between threads. 
Recently, tools based on this logic that blend in explicit non-interference reasoning have been developed~\cite{SAGL,RGSep}. 
\civl's combination of interference checking and linear variables is an extreme example of this trend,
supplying very primitive abstractions and letting programmers mix and match these abstractions freely.

Is there any other POPL-style work that needs to be cited?


%% A key challenge in specifying and verifying multi-threaded software, differently from sequential software, is that procedures do not provide a clean factoring of a program into modules. 
%% For sequential software, in the popular software verification approach based on the method of Floyd~\cite{Floyd67} and Hoare~\cite{Hoare69}, 
%% the verification of a large software component is performed modularly by verifying each procedure in it separately.
%% This modularity is enabled by the use of interface specifications (preconditions and postconditions) constraining the behavior of each procedure.
%% It is well-known that the Floyd-Hoare method is difficult to generalize to reasoning about concurrent shared-memory programs,
%% primarily because the execution of a procedure may be interfered with by concurrently executing threads.
%% Several attempts have been made to extend Floyd-Hoare reasoning to deal with concurrent interference, 
%% including classical approaches such as location invariants~\cite{Ashcroft75,OwickiG76} and rely-guarantee~\cite{Jones83},
%% and other more recent approaches~\cite{OHearn07,RGSep}. 
%% In this paper, our goal is orthogonal and complementary to these approaches to combating the complexity of verifying safety properties.
%% We provide a methodology in which the {\em refinement} problem can be stated in a modular way guided by the syntactic structure of the program as in the Floyd-Hoare method. 
%% We check refinement by reasoning about the code of a single procedure at a time, in fact, one interference-free step of the implementation at a time. 

