\section{Verification}
\label{sec:verification}

\begin{figure*}[t]
\scriptsize{
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
}
{
\lins \jl \skipstmt : \lins
}
{\textsc{Skip}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\ProcLins(A) = (\lins,\lins')
}
{
\lins \jl \call{A} : \lins'
}
{\textsc{Atomic}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\lins_y \subseteq \lins
}
{
\lins \jl \yield{e,\lins_y} : \lins
}
{\textsc{Yield}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\lins \jl \stmt : \lins' \\
\lins_a \subseteq \lins
}
{
\lins \jl \ablock{e,\lins_a}{\stmt} : \lins'
}
{\textsc{Ablock}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\ProcLins(P) = (\lins,\lins') \\
}
{
\lins \jl \call{P} : \lins'
}
{\textsc{Call}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\lins_G \subseteq \Global \\
\lins \cup \lins_P \cup \lins_P' \subseteq \ThreadLocal \\
\ProcLins(P) = ((\lins_G,\lins_P),(\lins_G,\lins_P')) \\
}
{
\lins_G,\lins,\lins_P \jl \async{P} : \lins_G,\lins
}
{\textsc{Async}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\lins \jl \stmt_1 : \lins' \\
\lins' \jl \stmt_2 : \lins''
}
{
\lins \jl \stmt_1;\stmt_2 : \lins''
}
{\textsc{Seq}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\lins \jl \stmt_1 : \lins' \\
\lins \jl \stmt_2 : \lins'
}
{
\lins \jl \ite{\locExpr}{\stmt_1}{\stmt_2} : \lins'
}
{\textsc{Ite}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\lins \jl \stmt : \lins
}
{
\lins \jl \while{e,\alpha}{\locExpr}{\stmt} : \lins
}
{\textsc{While}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\ProcLins(P) = (\lins,\lins') \\
\procs(P) = (\phi, \mods, \psi, \stmt) \\
\lins \jl \stmt : \lins'
}
{
\jl P
}
{\textsc{Procedure}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\ProcLins(A) = (\lins,\lins') \\
\lins \cap \Global = \lins' \cap \Global \\
\actions(A) = (\rho, \alpha, m) \\\\
\forall (\sigma,\sigma') \in \rho \circ \alpha.\ 
  \Collect(\sigma', \lins') \subseteq \Collect(\sigma, \lins)
}
{
\jl A
}
{\textsc{Action}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\lins \jl \stmt : \lins'
}
{
\lins \jl (P, \varsL, \stmt) : \lins'
}
{\textsc{StackFrame}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\forall 1 \le i \le n.\ \lins_i \jl F_i : \lins_{i+1}
}
{
\lins_1 \jl (\varsTL, F_1 \ldots F_n)
}
{\textsc{Thread}}
$
\medskip\\
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\forall P \in \ProcName.\ \jl P \\
\forall A \in \ActionName.\ \jl A \\
\lins_G \subseteq \Global \\
\forall 1 \le i \le n.\ \lins_i \subseteq \ThreadLocal \\
\forall 1 \le i \le n.\ \lins_G,\lins_i \jl T_i \\
\forall 1 \le i \le n.\ T_i = (\varsTL_i, \ldots) \\
\IsSet(\cup_{1 \le i \le n} \Collect(\varsTL_i, \lins_i) \cup \Collect(\varsG, \lins_G))
}
{
\jl (\procs, \actions, \ProcLins, \varsG, T_1 \ldots T_n)
}
{\textsc{Program}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
}
\caption{Linear variables}
\label{fig:linearity}
\end{figure*}

Suppose a program $\Prog'$ has been proved to be safe.
However, it is implemented using atomic actions that are too coarse to be directly implementable.  
To carry over the safety of $\Prog'$ to a realizable implementation $\Prog$, 
these coarse atomic actions must be refined down to lower-level actions.
During this refinement, an invocation $\call{A}$ of a high-level atomic action $A$ is transformed into an 
invocation $\call{P}$ of a procedure that is implemented using low-level actions.
The main contribution of this paper is a verification method that allows us to safely refine
program $\Prog'$ to another program $\Prog$ (or abstract $\Prog$ to $\Prog'$) so that 
safety properties proved on $\Prog'$ continue to hold on $\Prog$ as well.

The safety of the program $\Prog$, defined in Section~\ref{sec:language} as $\Safe^*(\Prog)$, depends on 
the preemptive semantics of $\Prog$.
Our overall goal is to conclude $\Safe^*(\Prog)$ from $\Safe^*(\Prog')$;
we decompose this goal into two sub-goals:
\begin{enumerate}
\item
We establish a simulation relation from the cooperative semantics of $\Prog$ 
to the preemptive semantics of $\Prog'$, which ensures that $\Safe^*(Prog')$ is sufficient for $\CSafe^*(\Prog)$.
\item
We exploit commutativity reasoning to compute a simulation relation from $\Prog$ to $\YSA$ (Figure~\ref{fig:ysa}),
which ensures that $\CSafe^*(\Prog)$ is sufficient for $\Safe^*(\Prog)$
\end{enumerate}
Both sub-goals depend on the auxiliary judgment $\jl \Prog$ for checking that $\Prog$ uses linear variables appropriately.
This judgment computes available linear variables at each program location;
this information is encoded logically as free disjointness assumptions that increase precision of non-interference
and commutativity reasoning at low annotatation overhead.

The first sub-goal is discharged by 
the judgments $\Refines;\HiddenProcs;\HiddenVars;\HiddenActions;\bs{b} \vdash \Prog \leadsto \Prog'$,
$\Refines;\HiddenProcs;\HiddenVars;\bs{b} \jr \Prog$, and $\InterferenceSafe(\Prog)$.
The first judgment performs a rewrite of $\Prog$ to $\Prog'$;
the second judgment checks each procedure separately against location invariants and atomic action specifications;
the third judgment checks that the location invariants are stable against interference from concurrently-executing threads.
The map $\Refines \in \ProcName \pf \ActionName$ indicates for a procedure $P \in \dom(\Refines)$ 
the action $\Refines(P)$ that abstracts it;
in $\Prog'$, every occurrence of $\call{P}$ is replaced by $\call{\Refines(P)}$.
The sets $\HiddenProcs \in 2^{\ProcName}$, $\HiddenVars \in 2^\Global$, and $\HiddenActions \in 2^{\ActionName}$ 
are, respectively, the procedure, the global variables, and atomic actions 
that are introduced for refining $\Prog'$ to $\Prog$;
we can also think that these entities are hidden in the abstract program $\Prog'$.
The set $\HiddenProcs$ includes $\dom(\Refines)$ but may also contain other procedures whose invocations 
are replaced by $\skipstmt$ in $\Prog'$.
The vector $\bs{b}$ contains a $\Boolean$ value $b_i$ for each thread $T_i$ in $\Prog$.
If $b_i$ is true, it indicates that there is a partially executed procedure on the stack of $T_i$ 
such that $P \in \dom(\Refines)$ but the code inside $P$ that corresponds to the execution of the atomic action $\Refines(P)$
has yet to be executed.
The value of $b_i$ is used to rewrite the stack of $T_i$ while transforming $\Prog$ to $\Prog'$.

The validity of the transformation from $\Prog$ to $\Prog'$ depends on establishing a simulation relation between them.
The base case of the simulation must check that $\CSafe(\Prog)$;
The inductive case must check that if $\Prog$ can evolve to $\Prog_1$ (via cooperative semantics)
by executing from the current yield statement to the next yield statement, 
then there is $\Prog'_1$ and $b_1$ such that $\Prog'$ can evolve in zero or more steps to $\Prog'_1$ 
and $\Refines;\HiddenProcs;\HiddenVars;\HiddenActions;\bs{b_1} \vdash \Prog_1 \leadsto \Prog'_1$.
The judgments $\Refines;\HiddenProcs;\HiddenVars;\bs{b} \jr \Prog$ and $\InterferenceSafe(\Prog)$ 
establish this property via a collection of verification conditions, one for each procedure and 
one for each pair of yield statement and atomic block in the program.

The second sub-goal is discharged by the two judgments $\Refines \jy \Prog$ and $\CommutativitySafe(\Prog)$.
Suppose $\Prog = (\procs, \actions, \ProcLins, \varsG, \TS)$.
To justify that $\CSafe^*(\Prog)$ is sufficient for $\Safe^*(\Prog)$,
we exploit commutativity information available from the mover types of atomic actions.
The {\em Yield Sufficiency Automaton\/} ($\YSA$) from Figure~\ref{fig:ysa} encodes 
all sequences of atomic actions and yields for which reasoning about cooperative semantics is sufficient.
For example, the $\YSA$ automaton indicates that a yield after a right mover or a yield before a left mover is unnecessary.
The judgment $\jy \Prog$ checks that the code of $\Prog$ can be simulated by $\YSA$;
it depends on the judgment $\CommutativitySafe(\Prog)$ which checks that all mover annotations are correct.

\begin{theorem}
\label{thm:correctness}
Let $\Prog,\Prog' \in \CProgram$ be such that $\Cooperative^*(\Prog)$ and $\Safe^*(\Prog')$.
Let $\Refines \in \ProcName \pf \ActionName$, $\HiddenProcs \in 2^{\ProcName}$, 
$\HiddenVars \in 2^{\Global}$, $\HiddenActions \in 2^{\ActionName}$,
and $\bs{b} \in \overrightarrow{\Boolean}$ be such that the following hold:
\begin{enumerate}
\item
$\jl \Prog$.
\item
$\Refines;\HiddenProcs;\HiddenVars;\HiddenActions;\bs{b} \vdash \Prog \leadsto \Prog'$,\\
$\Refines;\HiddenProcs;\HiddenVars;\bs{b} \jr \Prog$,\\ and $\InterferenceSafe(\Prog)$.
\item
$\jy \Prog$ and $\CommutativitySafe(\Prog)$.
\end{enumerate}
Then, we have $\Safe^*(\Prog)$.
\end{theorem}

Theorem~\ref{thm:correctness} is our main soundness theorem;
it concludes the safety of $\Prog$ from the safety of $\Prog'$.
In general, the correctness proof of a large program is obtained by chaining together
multiple instances of this theorem connecting a sequence of programs.  

\subsection{Using linear variables}
\label{sec:linearity}

In this section, we formalize the judgment $\jl \Prog$.
The goal of this judgment is to check that
linear variables and atomic blocks are used appropriately in $\Prog$.
The judgment $\jl \Prog$ enforces that linear permissions are never duplicated during the 
execution of $\Prog$.
Rule \textsc{Program} checks that the disjointness invariant holds in the initial state of $\Prog$.
Rule \textsc{Action} checks that each action $A$ preserves the disjointness invariant.
Consequently, the invariant holds throughout the execution of $\Prog$.
There are three conditions being checked by rule \textsc{Action}.
First, the set of global linear permissions does not change.
Second, if the disjointness invariant holds for input permissions it also holds for output permissions.
Finally, the union of the sets constructed from output permissions is a subset of the union of sets
constructed from input permissions.  
This last condition is important because it allows via local checking to conclude that the disjointness invariant holds globally
for linear permissions held by all threads.
The rule \textsc{Async} splits the thread-local permissions $\lins$ of the caller of $\async{P}$ into $\lins$ 
and $\lins_P$, passing $\lins_P$ to the new thread and continuing with $\lins$.
Note that all global permissions in $\lins_G$ are also made available to the new thread;
there is no duplication because all threads refer to the same set of global variables.

The following lemma states that if a program is well-typed it remains remains well-typed after executing a step.
By induction over execution steps, this lemma indirectly ensures that all programs reaachable from a well-typed program 
are well-typed.
\begin{lemma}
\label{lemma:linear-preservation}
Let $Prog, \Prog_1 \in \Program$ such that $\jl \Prog$ and $\Prog \trans \Prog_1$.
Then, we have $\jl \Prog_1$.
\end{lemma}
{\em Proof Sketch}:
Suppose $\Prog = (\procs, \actions, \ProcLins, \varsG, T_1 \ldots T_n)$, 
$T_i = (\varsTL_i,(P_i,\varsL_i,\StmtCtxt[s])\cdot\MakeFrames{F_i})$,
and thread $T_i$ takes a step in going from $\Prog$ to $\Prog_1$.
Suppose the judgment $\jl \Prog$ used available sets $\lins_G$ and $\lins_1,\ldots,\lins_i,\ldots,\lins_n$
to check $\Prog$.
To type check $\Prog_1$ only the available set $\lins_i$ for the thread $T_i$ that took the step needs to change.
To pick $\lins_i$, we perform a case analysis on $s$.
Let us consider a few cases.
Suppose $\stmt = \call{A}$ and $\ProcLins(A) = (\lins,\lins')$.
By rule \textsc{Atomic}, we have $\lins = \lins_i$ and we pick $\lins'$ for typing $\Prog_1$.
Suppose $\stmt = \call{P}$, $\ProcLins(P) = (\lins,\lins')$, and $\procs(P) = (\phi, \mods, \psi, \stmt')$.
Then we push the stack frame $(P,L,\yield{\phi,\lins};\stmt')$ onto the stack of $T_i$.
By rule \textsc{Call}, we have $\lins = \lins_i$,
We exploit the proof of $\jl P$ (rule \textsc{Procedure}) to construct the proof for the new stack.
Suppose $s = \async{P}$, $\ProcLins(P) = (\lins,\lins')$, and $\procs(P) = (\phi, \mods, \psi, \stmt')$.
Then we create a new thread with a single stack frame $(P,L,\yield{\phi,\lins};\stmt')$.
By rule \textsc{Async}, we have $\lins \subseteq \lins_i$;
we pick $\lins$ for the new thread and $\lins_i \setminus \lins$ for thread $T_i$.
Other cases are handled similarly.$\blacksquare$

The following lemma states that in a well-typed program that if two different threads 
are about to execute a yield statement and an atomic block statement, respectively,
the available linear variables annotating these statements have disjoint permissions.
Together with Lemma~\ref{lemma:linear-preservation}, this lemma ensures the soundness of the judgment $\InterferenceSafe(\Prog)$.
\begin{lemma}
Let $\Prog \in \Program$ such that $\jl \Prog$.
Suppose $\Prog = (\procs, \actions, \ProcLins, \varsG, T_1 \ldots T_n)$
and $i,j \in [1,n]$ such that 
$T_i = (\varsTL_i,(P_i,\varsL_i,\StmtCtxt[\ablock{e_i,\lins_i}])\cdot\MakeFrames{F_i})$ and
$T_j = (\varsTL_j,(P_j,\varsL_j,\StmtCtxt[\yield{e_j,\lins_j}])\cdot\MakeFrames{F_j})$.
Then $\IsSet(\Collect(\varsG, \lins_i) \cup \Collect(\varsTL_i, \lins_i) \cup \Collect(\varsTL_j, \lins_j))$.
\end{lemma}
{\em Proof Sketch}:
The proof follows immediately from rule \textsc{Program}.$\blacksquare$

The following lemma states that in a well-typed program that if two different threads 
are each about to execute an atomic action,
the available linear variables at the input of these actions have disjoint permissions.
Together with Lemma~\ref{lemma:linear-preservation}, this lemma ensures the soundness of the judgment $\CommutativitySafe(\Prog)$.
\begin{lemma}
Let $\Prog \in \Program$ such that $\jl \Prog$.
Suppose $\Prog = (\procs, \actions, \ProcLins, \varsG, T_1 \ldots T_n)$
and $i,j \in [1,n]$ such that 
$T_i = (\varsTL_i,(P_i,\varsL_i,\StmtCtxt[\call{A_i}])\cdot\MakeFrames{F_i})$, $\ProcLins(A_i) = (\lins_i,\lins'_i)$,
$T_j = (\varsTL_j,(P_j,\varsL_j,\StmtCtxt[\call{A_j}])\cdot\MakeFrames{F_j})$, and $\ProcLins(A_j) = (\lins_j,\lins'_j)$.
Then $\IsSet(\Collect(\varsG, \lins_i) \cup \Collect(\varsTL_i, \lins_i) \cup \Collect(\varsTL_j, \lins_j))$.
\end{lemma}
{\em Proof Sketch}:
The proof follows immediately from rule \textsc{Program}.$\blacksquare$


\subsection{Reasoning about cooperative semantics}
In this section, we attack the first sub-goal discussed earlier.
We establish a simulation relation from the cooperative semantics of $\Prog$ 
to the preemptive semantics of $\Prog'$, which ensures that $\Safe^*(Prog')$ is sufficient for $\CSafe^*(\Prog)$.
This verification depends on three judgments.
The judgment $\Refines;\HiddenProcs;\HiddenVars;\HiddenActions;\bs{b} \vdash \Prog \leadsto \Prog'$ is discussed in 
Section~\ref{sec:program-transformation}.
The judgments $\Refines;\HiddenProcs;\HiddenVars;\bs{b} \jr \Prog$ and $\InterferenceSafe(\Prog)$
are discussed in Section~\ref{sec:refinement}.

\subsubsection{Program transformation}
\label{sec:program-transformation}

\begin{figure*}
\scriptsize{
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
}
{\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash \skipstmt \leadsto \skipstmt}
{\textsc{Skip}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
A \not \in \HiddenActions
}
{\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash \call{A} \leadsto \call{A}}
{\textsc{Atomic}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
}
{\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash \yield{e,\lins} \leadsto \yield{e',\lins'}}
{\textsc{Yield}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash s \leadsto s'
}
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash \ablock{e,\lins}{s} \leadsto s'
}
{\textsc{Ablock1}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash s \leadsto s'
}
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash s \leadsto \ablock{e,\lins}{s'}
}
{\textsc{Ablock2}}
$
\medskip\\
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
P \not\in \HiddenProcs
}
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash \call{P} \leadsto \call{P}
}
{\textsc{Call1}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
P \in \HiddenProcs \setminus \dom(\Refines)
}
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash \call{P} \leadsto \skipstmt
}
{\textsc{Call2}}
$
%%%%%%%%%%%%%%%%%%%%
\medskip
$
\srule
{
P \in \dom(\Refines)
}
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash \call{P} \leadsto \call{\Refines(P)}
}
{\textsc{Call3}}
$
\medskip\\
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
P \not\in \HiddenProcs
}
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash \async{P} \leadsto \async{P}
}
{\textsc{Async1}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
P \in \HiddenProcs \setminus \dom(\Refines)
}
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash \async{P} \leadsto \skipstmt
}
{\textsc{Async2}}
$
\medskip\\
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash \stmt_1 \leadsto \stmt'_1 \\
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash \stmt_2 \leadsto \stmt'_2
}
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash \stmt_1;\stmt_2 \leadsto \stmt'_1;\stmt'_2
}
{\textsc{Seq}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash s_1 \leadsto s_1' \\
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash s_2 \leadsto s_2'
}
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash \ite{\locExpr}{s_1}{s_2} \leadsto \ite{\locExpr}{s_1'}{s_2'}
}
{\textsc{Ite}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash s \leadsto s'
}
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash \while{e,\alpha}{\locExpr}{s} \leadsto \while{e',\alpha'}{\locExpr}{s'}
}
{\textsc{While}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash \stmt \leadsto \stmt'
}
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash (\phi,\mods,\psi,\stmt) \leadsto (\phi',\mods',\psi',\stmt')
}
{\textsc{Procedure}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash \stmt \leadsto \stmt'
}
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash (P,\varsL,\stmt) \leadsto (P,\varsL,\stmt')
}
{\textsc{StackFrame}}
$
\medskip\\
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\forall 1 \le j \le n.\ F_j = (P_j, \varsL_j, \stmt_j) \\
1 \le i \le n \\
\forall 1 \le j \le n.\ P_j \in \HiddenProcs \Leftrightarrow j \le i \\
\forall i < j \le n.\ \Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash F_j \leadsto F'_j
}
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions;\true \vdash (\varsTL, F_1 \ldots F_{i+1} \ldots F_n) \leadsto (\varsTL, F'_{i+1} \ldots F'_n)
}
{\textsc{Thread1}}
$
\medskip\\
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\forall 1 \le j \le n.\ F_j = (P_j, \varsL_j, \stmt_j) \\
1 < i \le n \\
\forall 1 \le j \le n.\ P_j \in \HiddenProcs \Leftrightarrow j < i \\
\forall i < j \le n.\ \Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash F_j \leadsto F'_j \\\\
P_{i-1} \in \dom(\Refines) \\
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash \stmt_{i} \leadsto \stmt'_{i}
}
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions;\false \vdash (\varsTL, F_1 \ldots F_n) \leadsto (\varsTL, (P_{i}, \varsL_{i}, \call{\Refines(P_{i-1})}; \stmt'_{i}) \cdot F'_{i+1} \ldots F'_n)
}
{\textsc{Thread2}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\dom(\Refines) \subseteq \HiddenProcs \\
\cod(\Refines) \cap \HiddenActions = \{ \} \\
\forall (\rho,\alpha,m) \in \cod((\ActionName\setminus\HiddenActions) \circ \actions).\ (\accessVars(\rho) \cup \accessVars(\alpha)) \cap \HiddenVars = \emptyset \\\\
\forall A \in \ActionName \setminus \HiddenActions.\ \actions(A) = \actions'(A) \\
\forall P \not\in \HiddenProcs.\ \Refines;\HiddenProcs;\HiddenVars;\HiddenActions \vdash \procs(P) \leadsto \procs'(P) \\
\forall g \in \Global\setminus\HiddenVars.\ \varsG(g) = \varsG'(g) \\\\
\forall (\rho,\alpha,m) \in \cod(\Refines \circ \actions).\ (\accessVars(\rho) \cap \Local = \emptyset) \wedge (\alpha = ((\elim{\Local}.\ \alpha) \wedge \Same(\Local))) \\
\forall 1 \le i \le n.\ \Refines;\HiddenProcs;\HiddenVars;\HiddenActions;b_i \vdash T_i \leadsto T_i' \\
T'_1 \ldots T'_n \leadsto \overrightarrow{T'} \\
}
{
\Refines;\HiddenProcs;\HiddenVars;\HiddenActions;b_1;\ldots;b_n \vdash (\procs, \actions, \ProcLins, \varsG, T_1 \ldots T_n) \leadsto (\procs', \actions', \ProcLins', \varsG', \overrightarrow{T'})
}
{\textsc{Program}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
}
\caption{Program transformation}
\label{fig:program-transformation}
\end{figure*}

In this section, we take a closer look at the judgment
$\Refines;\HiddenProcs;\HiddenVars;\HiddenActions;\bs{b} \vdash \Prog \leadsto \Prog'$.
In this judgment, 
$\Refines \in \ProcName \pf \ActionName$ is a partial function from procedure names to action names,
$\HiddenProcs \in 2^{\ProcName}$ is a set of procedure names,
$\HiddenVars \in 2^\Global$ is a set of global variables,
and $\HiddenActions \in 2^{\ActionName}$ is a set of action names.
The map $\Refines$ indicates for a procedure $P \in \dom(\Refines)$ the action $\Refines(P)$ 
that abstracts it;
in the abstract program, every occurrence of $\call{P}$ is replaced by $\call{\Refines(P)}$.
The set $\HiddenProcs$ contains all procedures that are hidden as a result of the abstraction.
This set must include $\dom(\Refines)$ but can also contain other procedures whose invocations 
are replaced by $\skipstmt$ in the abstract program.
The sets $\HiddenVars$ and $\HiddenActions$ are the global variables and atomic actions, 
respectively, that are hidden in the abstract program.\footnote{In our formalization, 
hiding a procedure, global variable, or action simply means that the abstract program is forbidden from using it.
Technically, these hidden entities continue to exist since the sets $\ProcName$, $\Global$, and $\ActionName$ do not change.}
The vector $\bs{b}$ contains a $\Boolean$ value $b_i$ for each thread $T_i$ in $\Prog$.
If $b_i$ is true, it indicates that there is a partially executed procedure on the stack of $T_i$ 
such that $P \in \dom(\Refines)$ but the code inside $P$ that corresponds to the execution of the atomic action $\Refines(P)$
has yet to be executed.
The value of $b_i$ is used to rewrite the stack of $T_i$.

We now discuss the transformation rules in Figure~\ref{fig:program-transformation} starting from the bottom.
Rule \textsc{Program} first checks sanity conditions involving $\Refines$, $\HiddenProcs$, $\HiddenVars$, 
and $\HiddenActions$.  These include checks that $\dom(\Refines)$ is a subset of $\HiddenProcs$,
$\cod(\Refines)$ is disjoint from $\HiddenActions$, and the atomic actions that are 
available in the abstract program do not access any hidden variable in $\HiddenVars$.
Next, it connects actions, procedure bodies, and global state in the concrete and the abstract program;
the hidden procedures, global variables, and actions are unconstrained in the abstract program.
Next, it checks that every action in $\cod(\Refines)$ has a gate 
that is independent of procedure-local variables and a transition relation that leaves 
procedure-local variables unchanged.  
This check is meaningful because the action $\Refines(P)$ is written from the 
perspective of the caller of $P$.
Since the procedure-local variables of the caller of $P$ are distinct from those of $P$,
these variables are quantified out from the transition relation of $\Refines(P)$ when 
the body of $P$ is being checked (see Section~\ref{sec:refinement}).
Finally, this rule rewrites the code of each thread in the program using the auxiliary judgment 
$\overrightarrow{T} \leadsto \overrightarrow{T'}$ that rewrites $\overrightarrow{T}$ by removing all empty threads from it.

{\scriptsize
$
\inferrule
{
}
{
\epsilon \leadsto \epsilon
}
$
\hspace*{2mm}
$
\inferrule
{
\overrightarrow{T} \leadsto \overrightarrow{T'}
}
{
\overrightarrow{T}\cdot(\varsTL,\epsilon) \leadsto \overrightarrow{T'}
}
$
\hspace*{2mm}
$
\inferrule
{
\Frames \neq \epsilon \\
\overrightarrow{T} \leadsto \overrightarrow{T'}
}
{
\overrightarrow{T}\cdot(\varsTL,\Frames) \leadsto \overrightarrow{T'}\cdot(\varsTL,\Frames)
}
$
}

Rules \textsc{Thread1} and \textsc{Thread2} together rewrite a thread
using the judgment $\Refines;\HiddenProcs;\HiddenVars;\HiddenActions;b_i \vdash T_i \leadsto T_i'$.
The verification rules justifying the correctness of the program rewriting transformation, 
described in Section~\ref{sec:refinement},
guarantee that any stack frames for procedures in $\HiddenProcs$ are located contiguously at the top of the stack.
Furthermore, this sub-stack at the top either entirely consists of procedures in $\HiddenProcs \setminus \dom(\Refines)$ 
or it has exactly one procedure $P \in \dom(\Refines)$ at its bottom.
Both these cases have to be appropriately simulated by the rewritten program.
In the former case, there is certainly no pending atomic action in the abstraction.
This case is handled by \textsc{Thread1} by erasing the sub-stack.
In the latter case, if $b_i$ is false then \textsc{Thread1} erases the sub-stack;
otherwise, if $b_i$ is true then \textsc{Thread2} replaces the sub-stack with $\call{\Refines(P)}$.

We discuss the remainder of the rules starting from the top of the figure.
Rule \textsc{Atomic} ensures that the abstract program only uses actions not in $\HiddenActions$ 
but otherwise leaves $\call{A}$ unchanged.
Rule \textsc{Yield} allows the annotations associated with the yield statement to be rewritten arbitrarily.
Rules \textsc{Ablock1} and \textsc{Ablock2} together allow atomic blocks in the concrete program to be eliminated
and new atomic blocks in the abstract programs to be created.
Rules \textsc{Call1}, \textsc{Call2}, and \textsc{Call3} together handle $\call{P}$,
leaving the statement unchanged if $P \not \in \HiddenProcs$, 
rewriting to $\skipstmt$ if $P \in \HiddenProcs \setminus \dom(\Refines)$,
and rewriting to $\call{\Refines(P)}$ if $P \in \dom(\Refines)$.
Rules \textsc{Async1} and \textsc{Async2} together handle $\async{P}$ and are similar 
to rules \textsc{Call1} and \textsc{Call2} respectively.
Rules \textsc{Seq}, \textsc{Ite}, and \textsc{While} rewrite the statement recursively;
the loop annotation in \textsc{While} may be rewritten arbitrarily.
Rule \textsc{Procedure} rewrites the body of a procedure recursively and allows the procedure
specifications to be rewritten arbitrarily.
Rules \textsc{StackFrame} rewrites only the statement in the stack frame and leaves other components unchanged.

\subsubsection{Refinement}
\label{sec:refinement}

In this section, we formalize the judgments $\Refines;\HiddenProcs;\HiddenVars;\bs{b} \jr \Prog$ and $\InterferenceSafe(\Prog)$.
Together these judgments check that the body of each procedure $P$ in $\dom(\Refines)$ behaves like the atomic action $\Refines(P)$.
Our strategy for $P$ is to check that along all control paths in its body, there occurs exactly one atomic block 
$\ablock{e,\lins}{\stmt}$ that is simulated by the atomic action $\Refines(P)$.
All other atomic blocks before or after this unique block are simulated by the transition relation $\Havoc(\HiddenVars \cup \Local)$ 
which allows procedure-local and hidden global variables to be modified arbitrarily but requires that other global variables and thread-local variables are not modified.
In addition, these judgments also check that each atomic block inside a procedure in $\HiddenProcs \setminus \dom(\Refines)$ 
is simulated by the transition relation $\Havoc(\HiddenVars \cup \Local)$.
In general, the appropriate simulation check may not be provable by examining only the body $\stmt$ of the atomic block.
Contextual information such as the predicate $e$ that is expected to hold when the atomic block begins execution may also be required.
Annotations such as preconditions and postconditions, loop invariants, and yield predicates are leveraged to prove 
such predicates throughout the program.

\begin{figure*}
\scriptsize{
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
}
{\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockAny \jr \FH{b,\phi}{\skipstmt}{b,\phi};\{\}}
{\textsc{Skip}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\actions(A) = (\rho, \alpha, m) \\
\mods \subseteq \ThreadLocal \cup \Local \\
(\phi \wedge \rho) \circ \alpha \subseteq \Havoc(\Global \cup \mods) \\\\
P \in \HiddenProcs \Rightarrow \phi \subseteq \rho \\ 
\cod((\phi \wedge \rho) \circ \alpha) \subseteq \psi  \\
}
{\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockInside \jr \FH{b,\phi}{\call{A}}{b,\psi};\mods}
{\textsc{Atomic}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
P \not \in \dom(\Refines)
}
{\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockOutside \jr \FH{b,e}{\yield{e,\lins}}{b,e};\{\}}
{\textsc{Yield1}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
P \in \dom(\Refines) \\ \actions(\Refines(P)) = (\rho, \alpha, m)
}
{\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockOutside \jr \FH{b,e}{\yield{e,\lins}}{b, e \wedge (\rho \vee b)};\{\}}
{\textsc{Yield2}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
P \not \in \HiddenProcs \\\\
\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockInside \jr \FH{b, \phi_1 \wedge e}{\stmt}{b,\phi_2};\mods
}
{\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockOutside \jr \FH{b, \phi_1 \wedge e}{\ablock{e,\lins}{\stmt}}{b, \phi_2};\mods}
{\textsc{Ablock1}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
P \in \HiddenProcs \\ \trel{\stmt} \subseteq \ga{e}{\Havoc(\HiddenVars \cup \Local)} \\\\
\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockInside \jr \FH{b, \phi_1 \wedge e}{\stmt}{b, \phi_2};\mods
}
{\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockOutside \jr \FH{b, \phi_1 \wedge e}{\ablock{e,\lins}{\stmt}}{b, \phi_2};\mods}
{\textsc{Ablock2}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
P \in \dom(\Refines) \\ \actions(\Refines(P)) = (\rho,\alpha,m) \\
\trel{\stmt} \subseteq \ga{e}{\elim{\Local}.\ \alpha} \\
\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockInside \jr \FH{b, \phi_1 \wedge e}{\stmt}{b, \phi_2};\mods
}
{\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockOutside \jr \FH{\false, \phi_1 \wedge e}{\ablock{e,\lins}{\stmt}}{\true, \phi_2};\mods}
{\textsc{Ablock3}}
$
\medskip\\
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
P \in \HiddenProcs \Rightarrow P' \in \HiddenProcs \setminus \dom(\Refines) \\
\procs(P') = (\phi, \mods, \psi, \stmt)
}
{\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockOutside \jr \FH{b,\phi}{\call{P'}}{b,\psi};\mods}
{\textsc{Call}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
P \in \HiddenProcs \Rightarrow P' \in \HiddenProcs \setminus \dom(\Refines) \\
\procs(P') = (\phi, \mods, \psi, \stmt)
}
{\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockOutside \jr \FH{b,\phi}{\async{P'}}{b,\phi};\{\}}
{\textsc{Async}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockAny \jr \FH{b_1, \phi_1}{\stmt_1}{b_2, \phi_2};\mods_1 \\\\ 
\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockAny \jr \FH{b_2, \phi_2}{\stmt_2}{b_3, \phi_3};\mods_2
}
{\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockAny \jr \FH{b_1, \phi_1}{\stmt_1;\stmt_2}{b_3, \phi_3};\mods_1 \cup \mods_2}
{\textsc{Seq}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockAny \jr \FH{b, \locExpr \wedge \phi_1}{s_1}{b', \phi_2};\mods_1 \\\\
\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockAny \jr \FH{b, \neg \locExpr \wedge \phi_1}{s_2}{b', \phi_2};\mods_2
}
{\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockAny \jr \FH{b, \phi_1}{\ite{\locExpr}{s_1}{s_2}}{b', \phi_2};\mods_1 \cup \mods_2}
{\textsc{Ite}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockAny \jr \FH{b, e \wedge \locExpr}{s}{b, e};\mods
}
{\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockAny \jr \FH{b, e}{\while{e,\alpha}{\locExpr}{s}}{b, e \wedge \neg \locExpr};\mods}
{\textsc{While}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\phi \subseteq \phi' \\ \psi' \subseteq \psi \\\\
\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockAny \jr \FH{b,\phi'}{\stmt}{b',\psi'};\mods
}
{\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockAny \jr \FH{b,\phi}{\stmt}{b',\psi};\mods}
{\textsc{Weaken}}
$
\medskip\\
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockAny \jr \FH{b, \phi}{\stmt}{b', \psi};\mods \\\\ \accessVars(\rho) \cap (\Global \cup \mods) = \{\}
}
{\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockAny \jr \FH{b, \rho \wedge \phi}{\stmt}{b', \rho \wedge \psi};\mods}
{\textsc{Frame1}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\Refines;\HiddenProcs;\HiddenVars;\procs;\actions \jr \FH{b, \phi}{F}{b', \psi};\mods \\\\ \accessVars(\rho) \cap (\Global \cup \Local \cup \mods) = \{\}
}
{\Refines;\HiddenProcs;\HiddenVars;\procs;\actions \jr \FH{b, \rho \wedge \phi}{F}{b', \rho \wedge \psi};\mods}
{\textsc{Frame2}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\procs(P) = (\phi, \mods, \psi, \stmt) \\
(\accessVars(\phi) \cup \accessVars(\psi)) \cap \Local = \{\} \\\\
\mods' \cap \ThreadLocal \subseteq \mods \\\\
\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockOutside \jr \FH{P \not \in \dom(\Refines), \phi}{\stmt}{\true, \psi};\mods'
}
{
\Refines;\HiddenProcs;\HiddenVars;\procs;\actions \jr P
}
{\textsc{Procedure}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockOutside \jr \FH{b, \phi'}{\stmt}{b', \psi};\mods \\\\
\forall \varsG,\varsTL,\varsL'.\ \MakeStore{\varsG}{\varsTL}{\varsL'} \in \phi \Rightarrow \MakeStore{\varsG}{\varsTL}{\varsL} \in \phi'
}
{
\Refines;\HiddenProcs;\HiddenVars;\procs;\actions \jr \FH{b, \phi}{(P,\varsL,\stmt)}{b', \psi};\mods \cap \ThreadLocal
}
{\textsc{StackFrame}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\forall 1 \le i \le n.\ \accessVars(\phi_i) \cap \Local = \{\} \\
\forall \varsL.\ \MakeStore{\varsG}{\varsTL}{\varsL} \in \phi_1 \\\\
\forall 1 \le i \le n.\ \Refines;\HiddenProcs;\HiddenVars;\procs;\actions \jr \FH{b_i, \phi_i}{F_i}{b_{i+1}, \phi_{i+1}};\mods_i
}
{
\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;\varsG;b_1 \jr (\varsTL, F_1 \ldots F_n)
}
{\textsc{Thread}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\forall P \in \ProcName.\ \Refines;\HiddenProcs;\HiddenVars;\procs;\actions \jr P \\\\
\forall 1 \le i \le n.\ \Refines;\HiddenProcs;\HiddenVars;\procs;\actions;\varsG;b_i \jr T_i
}
{
\Refines;\HiddenProcs;\HiddenVars;b_1;\ldots;b_n \jr (\procs, \actions, \ProcLins, \varsG, T_1 \ldots T_n)
}
{\textsc{Program}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
}
\caption{Refinement}
\label{fig:refinement}
\end{figure*}

The crux of the rules in Figure~\ref{fig:refinement} is the statement-level judgment 
$\Refines;\HiddenProcs;\HiddenVars;\procs;\actions;P;\ABlockAny \jr \FH{b, \phi}{\stmt}{b', \psi};\mods$.
In this judgment, $P$ is the procedure being checked.
The argument $\ABlockAny$ is either
$\ABlockOutside$ which indicates that $\stmt$ is outside any atomic block or
$\ABlockInside$ which indicates that $\stmt$ is inside some atomic block.
This information enables the verification rules to check two properties.
First, each atomic block must not contain any other atomic block, yield, or (ordinary and asynchronous) call statements inside it,
ensuring that the computation of each $\ablock{e,\lins}{\stmt'}$ can be summarized by a transition relation, denoted by $\trel{\stmt'}$.
Second, any invocation of an atomic action (the only computation that can modify the store) must occur inside an atomic block.
This check ensures that checking non-interference of a yield predicate against all atomic blocks concurrently executing 
in the environment will preserve the yield predicate across the entire computation that happens in the environment during a context switch.

On the right side of the judgment, we have a generalization of the Floyd-Hoare triple---$\FH{b,\phi}{\stmt}{b',\psi}$.
It indicates that $\stmt$ is being verified assuming it executes from a state in $\phi$ and ensuring it ends in a state satisfying $\psi$.
The $\Boolean$ values $b$ and $b'$ are used to track refinement checking, which is performed only if $P \in \HiddenProcs$.
If $b$ is $\true$, then each atomic block in $\stmt$ is expected to be simulated by $\Havoc(\HiddenVars \cup \Local)$ and $b'$ remains $\true$.
A statement in which all atomic blocks refine $\Havoc(\HiddenVars \cup \Local)$ is said to {\em stutter}.
If $b$ is $\false$, then it must be the case that $P \in \dom(\Refines)$, at most one atomic block in $\stmt$ is simulated by $\Refines(P)$
and all other blocks are simulated by $\Havoc(\HiddenVars \cup \Local)$.
The value of $b'$ is allowed to be $\true$ if some atomic block in $\stmt$ is simulated by $\Refines(P)$.
In the discussion below, we will refer to the pair $(b,\phi)$ as the precondition and $(b',\psi)$
as the postcondition of $\stmt$, respectively.
Finally, the set $\mods$ contains thread-local and procedure-local variables that are potentially modified by $\stmt$;
this information is useful in the frame rules, \textsc{Frame1} and \textsc{Frame2}, explained later.

We now examine the rules for the the judgment $\Refines;\HiddenProcs;\HiddenVars;\bs{b} \jr \Prog$ in Figure~\ref{fig:refinement},
starting from the bottom.
In this judgment, the vector $\bs{b}$ contains a $\Boolean$ value $b_i$ for each thread $T_i$.
Rule \textsc{Program} checks each thread and each procedure separately.
The value $b_i$ is passed to the judgment for checking a thread.
The rule \textsc{Thread} checks each frame on the stack of a thread modularly using a sequence of $b_1,\ldots,b_{n+1}$ of 
$\Boolean$ values and a sequence $\phi_1,\ldots,\phi_{n+1}$ of predicates that may not refer to procedure-local variables.
The pair $(b_i,\phi_i)$ acts as the precondition to the $i$-the stack frame (from the top) of the thread.
The rule \textsc{StackFrame} checks a stack frame $(P, L, \stmt)$ by checking $\stmt$ recursively.
The precondition $\phi$ of the stack frame may be specialized to the local state $L$ to obtain the precondition for $\stmt$.
The rule \textsc{Procedure} checks the body of the procedure $P$ with
the precondition $(P \not\in \dom(\Refines),\phi)$ and postcondition $(\true,\psi)$,
where $\phi$ and $\psi$ are the precondition and postconditions of $P$ respectively.
This check ensures that if $P$ has an atomic action specification, the body refines it appropriately.
The rule also checks that the body of $P$ modifies only those thread-local variables mentioned in the 
specification of $P$ and that the precondition and postcondition of $P$ does not refer to procedure-local variables.

The rules \textsc{Weaken}, \textsc{Frame1}, and \textsc{Frame2} are standard.
The rules \textsc{While}, \textsc{Ite}, and \textsc{Seq} extend the analogous Floyd-Hoare rules with refinement checking.
The rule \textsc{While} checks that the body of the loop stutters and concludes that the loop itself stutters.
The rule \textsc{Ite} checks that both branches behave in the same way.
The rule \textsc{Seq} for $\stmt_1;\stmt_2$ chains the refinement behavior of $\stmt_1$ with that of $\stmt_2$.

Rules \textsc{Call} and \textsc{Async} handle procedure calls.
Both rules require that if the procedure $P$ being checked is in $\dom(\Refines)$,
then the called procedure $P'$ must be in $\HiddenProcs \setminus \dom(\Refines)$.
Thus, the call relation over the set of procedures being introduced during refinement (or hidden during abstraction) 
must be a subset of $\HiddenProcs \times (\HiddenProcs\setminus\dom(\Refines))$.
This check is important for ensuring that $\call{P}$ can be rewritten either to $\call{\Refines(P)}$ if $P \in \dom(\Refines)$ 
or to $\skipstmt$ if $P \in \HiddenProcs \setminus \dom(\Refines)$.

Rules \textsc{Ablock1}, \textsc{Ablock2}, and \textsc{Ablock3} handle an atomic block $\ablock{e,\lins}{s}$.
Rule \textsc{Ablock1} considers the case when $P \not \in \HiddenProcs$ and performs only the 
standard sequential correctness check.
Rules \textsc{Ablock2} and \textsc{Ablock3} consider the two cases when $P \in \HiddenProcs$ and handle
the refinement of $\Havoc{\HiddenVars \cup Local}$ and the atomic action $\Refines(P)$, respectively.

Rules \textsc{Yield1} and \textsc{Yield2} handle the yield statement.
Rule \textsc{Yield1} considers the case when $P \not \in \dom(\Refines)$ and is straightforward;
only the yield predicate is available in the postcondition of the statement.
Rule \textsc{Yield2} considers the case when $P \in \dom(\Refines)$ and makes available in the postcondition, in 
addition to the yield predicate, the gate of the action being refined.
This is safe because the simulation relation connecting the concrete program to the abstract program
allows the abstract program to fail more often.

Rule \textsc{Atomic} handles the call of an atomic action.
It computes in $\mods$ the set of thread-local and procedure-local variables possibly modified by the action.
It checks that the gate of the action holds but only when the call occurs inside the body of a procedure in $\HiddenProcs$.
In other words, a gate of an atomic action $A$, the only source of safety assertions in our operational semantics, is discharged 
only when $A$ is invoked inside a procedure that is hidden as a result of abstraction.
Since we are only interested in proving a simulation relation between the concrete and abstract semantics, 
it is safe to leave unverified the gates at all other invocations of atomic actions which are present in both the concrete and abstract program.
Finally, this rule verifies the postcondition $\psi$ from the precondition $\phi$ using the semantics of the atomic action.

We now move on to discuss the judgment $\InterferenceSafe(\Prog)$,
where $\Prog = (\procs, \actions, \ProcLins, \varsG, \TS)$. 
Let $\Yields(\Prog)$ be the union of the following sets:
\begin{itemize}
\item
$\{(\phi,\lins) \mid \yield{\phi,\lins}~\mathrm{appears~in~\Prog}\}$.
\item
$\{(\phi,\lins) \mid P \in \ProcName \wedge \procs(P) = (\phi, \mods, \psi, \stmt) \wedge \ProcLins(P) = (\lins,\lins')\}$.
\item
$\{(\psi,\lins') \mid P \in \ProcName \wedge \procs(P) = (\phi, \mods, \psi, \stmt) \wedge \ProcLins(P) = (\lins,\lins')\}$.
\end{itemize}
Let $\Ablocks(\Prog)$ be the set of atomic blocks in $\Prog$.
The program $\Prog$ is interference-free, denoted by $\InterferenceSafe(\Prog)$,
if for each predicate ($\phi,\lins_y) \in \Yields(\Prog)$ and 
for each atomic block $\ablock{e,\lins}{\stmt} \in \Ablocks(\Prog)$, we have
\[
\scriptsize{
\begin{array}{l}
\forall \varsG,\varsTL,\varsL,\varsG',\varsTL',\varsL',\varsTL_y,\varsL_y.\\ 
\mathit{let}\ \Lambda =
\begin{array}[t]{ll}
\cup & \Collect(\varsG, \lins) \\
\cup & \Collect(\varsTL, \lins) \\
\cup & \Collect(\varsTL_y, \lins_y) 
\end{array} \\
\mathit{in}\
\begin{array}{ll}
\wedge & \IsSet(\Lambda) \\
\wedge & \MakeStore{\varsG}{\varsTL}{\varsL} \in e \\
\wedge & (\MakeStore{\varsG}{\varsTL}{\varsL}, \MakeStore{\varsG'}{\varsTL'}{\varsL'}) \in \trel{\stmt} \\
\wedge & \MakeStore{\varsG}{\varsTL_y}{\varsL_y} \in \phi
\end{array}
\Rightarrow \MakeStore{\varsG'}{\varsTL_y}{\varsL_y} \in \phi.
\end{array}
}
\]

We summarize the contributions of the judgments discussed in this section in the following two lemmas.
\begin{lemma}
Let $\Prog \in \CProgram$, $\Prog' \in \Program$,
$\Refines \in \ProcName \pf \ActionName$, $\HiddenProcs \in 2^{\ProcName}$, $\HiddenVars \in 2^{\Global}$, $\HiddenActions \in 2^{\ActionName}$,
and $\bs{b} \in \overrightarrow{\Boolean}$ be such that 
$\jl \Prog$, $\Safe^*(\Prog')$,
$\Refines;\HiddenProcs;\HiddenVars;\HiddenActions;\bs{b} \vdash \Prog \leadsto \Prog'$, $\Refines;\HiddenProcs;\HiddenVars;\bs{b} \jr \Prog$, and
$\InterferenceSafe(\Prog)$.
Then, we have $\CSafe(\Prog)$.
\end{lemma}

\begin{lemma}
Let $\Prog,\Prog_1 \in \CProgram$, $\Prog' \in \Program$,
$\Refines \in \ProcName \pf \ActionName$, $\HiddenProcs \in 2^{\ProcName}$, $\HiddenVars \in 2^{\Global}$, $\HiddenActions \in 2^{\ActionName}$,
and $\bs{b} \in \overrightarrow{\Boolean}$ be such that $\jl \Prog$, $\Safe^*(\Prog')$, 
$\Refines;\HiddenProcs;\HiddenVars;\HiddenActions;\bs{b} \vdash \Prog \leadsto \Prog'$, $\Refines;\HiddenProcs;\HiddenVars;\bs{b} \jr \Prog$, 
$\InterferenceSafe(\Prog)$, and $\Prog \ctrans \Prog_1$.
Then, there exists $\Prog'_1 \in \Program$ and $\bs{b_1} \in \overrightarrow{\Boolean}$ such that 
$\Refines;\HiddenProcs;\HiddenVars;\HiddenActions;\bs{b_1} \vdash \Prog_1 \leadsto \Prog'_1$, 
$\Refines;\HiddenProcs;\HiddenVars;\bs{b_1} \jr \Prog_1$, $\InterferenceSafe(\Prog_1)$, and $\Prog' \trans^* \Prog'_1$.
\end{lemma}


\subsection{From preemptive to cooperative semantics}
\label{sec:yield-sufficiency}

\begin{figure*}
\scriptsize{
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
}
{\actions \jy \skipstmt : (x, x)}
{\textsc{Skip}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\actions(A) = (\rho, \alpha, B)
}
{\actions \jy \call{A} : (x, x)}
{\textsc{Both}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\actions(A) = (\rho, \alpha, R)
}
{\actions \jy \call{A} : (\RM, \RM)}
{\textsc{Right}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\actions(A) = (\rho, \alpha, L)
}
{\actions \jy \call{A} : (x, \LM)}
{\textsc{Left}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\actions(A) = (\rho, \alpha, N)
}
{\actions \jy \call{A} : (\RM, \LM)}
{\textsc{Non}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
}
{\actions \jy \yield{e,\lins} : (x, \RM)}
{\textsc{Yield}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\actions \jy \stmt : (x, y)
}
{\actions \jy \ablock{e,\lins}{\stmt} : (x, y)}
{\textsc{Ablock}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
}
{\actions \jy \call{P} : (x, \RM)}
{\textsc{Call}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
}
{\actions \jy \async{P} : (x, \LM)}
{\textsc{Async}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\actions \jy \stmt_1 : (x, y) \\ \actions \jy \stmt_2 : (y, z)
}
{\actions \jy \stmt_1;\stmt_2 : (x, z)}
{\textsc{Seq}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\actions \jy \stmt_1 : (x, y) \\ \actions \jy \stmt_2 : (x, y)
}
{\actions \jy \ite{\locExpr}{\stmt_1}{\stmt_2} : (x, y)}
{\textsc{Ite}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\actions \jy \stmt : (x, x)
}
{\actions \jy \while{e,\alpha}{\locExpr}{\stmt} : (x, x)}
{\textsc{While}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\procs(P) = (\phi, \mods, \psi, \stmt) \\
\actions \jy \stmt : (x, y)
}
{
\actions \jy P
}
{\textsc{Procedure}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\actions \jy \stmt : (x,y)
}
{
\actions \jy (P, \varsL, \stmt) : (x,y)
}
{\textsc{StackFrame}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\forall 1 \le i \le n.\ \actions \jy F_i : (x_i, x_{i+1})
}
{
\actions \jy (\varsTL, F_1 \ldots F_n)
}
{\textsc{Thread}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\srule
{
\forall P \in \ProcName.\ \actions \jy P \\
\forall 1 \le i \le n.\ \actions \jy T_i
}
{
\jy (\procs, \actions, \ProcLins, \varsG, T_1 \ldots T_n)
}
{\textsc{Program}}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
}
\caption{Yield sufficiency}
\label{fig:yield-sufficiency}
\end{figure*}

In this section, we outline the verification required for justifying that it suffices to reason about
the cooperative semantics of $\Prog$, which ensures that $\CSafe^*(\Prog)$ is sufficient for $\Safe^*(\Prog)$
Let $\Prog = (\procs, \actions, \ProcLins, \varsG, \TS)$ be a program.
The map $\actions$ maps each atomic action to a triple $(\rho, \alpha, m)$, the last component of which 
denotes type of atomic action---$B$ for {\em both mover}, $R$ for {\em right mover}, $L$ for {\em left mover},
and $N$ for {\em non mover}.
Informally, an action labeled $N$ does not commute with other concurrent actions,
an action labeled $L$ commutes to the left (or earlier in time) of other concurrent actions,
an action labeled $R$ commutes to the right (or later in time) of other concurrent actions,
and an action labeled $B$ commutes both to the left and the right of other concurrent actions.
The {\em Yield Sufficiency Automaton\/} ($\YSA$) from Figure~\ref{fig:ysa} encodes 
all sequences of atomic actions and yields for which reasoning about cooperative semantics is sufficient.
For example, the $\YSA$ automaton indicates that a yield after a right mover or a yield before a left mover is unnecessary.
The judgment $\jy \Prog$ checks that the code of $\Prog$ can be simulated by $\YSA$;
it depends on the judgment $\CommutativitySafe(\Prog)$ which checks that all mover annotations are correct.

The essence of the rules in Figure~\ref{fig:yield-sufficiency}
is to capture the effect of a computation as a pair $(x,y)$ where $x,y \in \{\RM,\LM\}$;
the meaning is that to simulate the computation the automaton moves from state $x$ to state $y$.
Rule \textsc{Program} performs checking for all threads and for all procedures.
Rules \textsc{Thread}, \textsc{StackFrame}, and \textsc{Procedure} are straightforward.
Rule \textsc{While} checks that the body of the loop leaves the state of the automaton unchanged.
Rule \textsc{Ite} checks that the effect both branches is the same.
Rule \textsc{Seq} composes the effect of $\stmt_1$ with the effect of $\stmt_2$.
Rule \textsc{Async} is interesting because it treats an asynchronous call as a left mover.
Rules \textsc{Yield} and \textsc{Call} treat their statements as a yield.
Rule \textsc{Ablock} calculates the effect of the body of the block.
Rules \textsc{Both}, \textsc{Right}, \textsc{Left}, and \textsc{Non} essentially 
examine the available edges in the automaton to validate the statement and calculate its effect.
Rule \textsc{Skip} leave the state of the automaton unchanged.

The judgment $\jy \Prog$ is not quite enough to check the sufficiency of yields soundly.
Consider the following program with a global variable {\tt x} and two threads.
\begin{tabular}{l@{}l@{}l}
\begin{tabular}[t]{l}
{\tt [ x := 0 ];} \\
{\tt [ assert x == 0 ];} \\
\end{tabular} 
&
{\tt ||}
&
\begin{tabular}[t]{l}
{\tt ~~[ x := x + 1 ];} \\
{\tt ~~while (true) ;} \\
\end{tabular} 
\end{tabular}
This program violates the assertion in it.
The first thread sets {\tt x} to $0$ in the atomic action indicated {\tt [x := 0]};
the second thread preempts the first thread and changes {\tt x} to $1$;
the first thread preempts the second thread and fails the assert {\tt x == 0}. 
However, the program does not fail if the second thread is executed without preemption,
even though the code of the second thread satisfies the yield sufficiency check described earlier.
Our verification method is applicable to a program $\Prog$ only if $\Cooperative^*(\Prog)$ holds,
which is false for the program in the example above.
Verifying this condition is similar to proving termination and is orthogonal to the contribution of this paper.

Of course, the judgment $\jy \Prog$ depends on the mover annotations on the atomic actions being correct.
We capture this requirement in the judgmen $\CommutativitySafe(\Prog)$.
Formally, the program $\Prog$ is commutativity-safe, denoted by $\CommutativitySafe(\Prog)$,
if for all $A_1,A_2 \in \ActionName$ such that $\actions(A_1) = (\rho_1,\alpha_1,m_1)$, $\actions(A_2) = (\rho_2,\alpha_2,m_2)$,
$\ProcLins(A_1) = (\lins_1,\lins'_1)$, and $\ProcLins(A_2) = (\lins_2,\lins'_2)$, 
then all of the following conditions are satisfied:
\begin{itemize}
\item {\bf Commutativity.}
This condition checks that if action $A_1$ is a right mover or action $A_2$ is a left mover,
then the effect of executing $A_1$ followed by $A_2$ in two different threads can be achieved by executing $A_2$ followed by $A_1$.
Formally, if $m_1 \in \{B,R\}$ or $m_2 \in \{B,L\}$, then 
\[
\scriptsize{
\begin{array}{l}
\forall \varsG^-,\varsG,\varsG^+,\varsTL_1,\varsL_1,\varsTL'_1,\varsL'_1,\varsTL_2,\varsL_2,\varsTL'_2,\varsL'_2.\ \exists \varsG'. \\
\mathit{let}\ \Lambda =
\begin{array}[t]{ll}
\cup & \Collect(\varsG^-, \lins_1) \\
\cup & \Collect(\varsTL_1, \lins_1) \\
\cup & \Collect(\varsTL_2, \lins_2) 
\end{array} \\
\mathit{in} \\
\begin{array}{ll}
\wedge & \IsSet(\Lambda) \\
\wedge & \MakeStore{\varsG^-}{\varsTL_1}{\varsL_1} \in \rho_1 \\
\wedge & \MakeStore{\varsG^-}{\varsTL_2}{\varsL_2} \in \rho_2 \\
\wedge & (\MakeStore{\varsG^-}{\varsTL_1}{\varsL_1},\MakeStore{\varsG}{\varsTL'_1}{\varsL'_1}) \in \alpha_1 \\
\wedge & (\MakeStore{\varsG}{\varsTL_2}{\varsL_2},\MakeStore{\varsG^+}{\varsTL'_2}{\varsL'_2}) \in \alpha_2 \\
\end{array} \\
\Rightarrow \\
\begin{array}{ll}
\wedge & (\MakeStore{\varsG^-}{\varsTL_2}{\varsL_2},\MakeStore{\varsG'}{\varsTL'_2}{\varsL'_2}) \in \alpha_2 \\
\wedge & (\MakeStore{\varsG'}{\varsTL_1}{\varsL_1},\MakeStore{\varsG^+}{\varsTL'_1}{\varsL'_1}) \in \alpha_1 \\
\end{array}
\end{array}
}
\]

\item {\bf Forward preservation.}
This condition checks that if $A_1$ is a right mover or $A_2$ is a left mover,
the failure of $A_2$ immediately after the execution of $A_1$ is sufficient to imply 
that $A_2$ must also fail before the exection of $A_1$.
This condition is equivalent to forward preservation of the gate of $A_2$ by the execution of $A_1$.
Formally, if $m_1 \in \{B,R\}$ or $m_2 \in \{B,L\}$, then 
\[
\scriptsize{
\begin{array}{l}
\forall \varsG,\varsG',\varsTL_1,\varsL_1,\varsTL'_1,\varsL'_1,\varsTL_2,\varsL_2. \\
\mathit{let}\ \Lambda =
\begin{array}[t]{ll}
\cup & \Collect(\varsG, \lins_1) \\
\cup & \Collect(\varsTL_1, \lins_1) \\
\cup & \Collect(\varsTL_2, \lins_2) 
\end{array} \\
\mathit{in} \\
\begin{array}{ll}
\wedge & \IsSet(\Lambda) \\
\wedge & \MakeStore{\varsG}{\varsTL_1}{\varsL_1} \in \rho_1 \\
\wedge & (\MakeStore{\varsG}{\varsTL_1}{\varsL_1},\MakeStore{\varsG'}{\varsTL'_1}{\varsL'_1}) \in \alpha_1 \\
\wedge & \MakeStore{\varsG}{\varsTL_2}{\varsL_2} \in \rho_2 \\
\end{array} 
\Rightarrow 
\begin{array}{l}
\MakeStore{\varsG'}{\varsTL_2}{\varsL_2} \in \rho_2 
\end{array}
\end{array}
}
\]

\item {\bf Backward preservation.}
This condition checks that if $A_1$ is a left mover and $A_2$ 
is an arbitrary action, then the failure of $A_2$ immediately before the execution of $A_1$ 
is sufficient to imply that $A_2$ must also fail immediately after the execution of $A_1$.
This condition is equivalent to backward preservation of the gate of $A_2$ by the execution of $A_1$.
Formally, if $m_1 \in \{B,L\}$, then 
\[
\scriptsize{
\begin{array}{l}
\forall \varsG,\varsG',\varsTL_1,\varsL_1,\varsTL'_1,\varsL'_1,\varsTL_2,\varsL_2. \\
\mathit{let}\ \Lambda =
\begin{array}[t]{ll}
\cup & \Collect(\varsG, \lins_1) \\
\cup & \Collect(\varsTL_1, \lins_1) \\
\cup & \Collect(\varsTL_2, \lins_2) 
\end{array} \\
\mathit{in} \\
\begin{array}{ll}
\wedge & \IsSet(\Lambda) \\
\wedge & \MakeStore{\varsG}{\varsTL_1}{\varsL_1} \in \rho_1 \\
\wedge & (\MakeStore{\varsG}{\varsTL_1}{\varsL_1},\MakeStore{\varsG'}{\varsTL'_1}{\varsL'_1}) \in \alpha_1 \\
\wedge & \MakeStore{\varsG'}{\varsTL_2}{\varsL_2} \in \rho_2 \\
\end{array} 
\Rightarrow 
\begin{array}{l}
\MakeStore{\varsG}{\varsTL_2}{\varsL_2} \in \rho_2 
\end{array}
\end{array}
}
\]

\item {\bf Nonblocking.}
This condition checks that if $A_1$ is a left mover, then it must be non-blocking.
If $m_1 \in \{B, L\}$, then
$\forall \sigma \in \rho_1.\ \exists \sigma'.\ (\sigma, \sigma') \in \alpha_1$.
\end{itemize}

Finally, we summarize the results of this section in the following lemma connecting the safety
of preemptive and cooperative semantics of $\Prog$.
\begin{lemma}
Let $\Prog \in \CProgram$ be such that $\jl \Prog$, $\CommutativitySafe(\Prog)$, and $\jy \Prog$.
If $\Cooperative^*(\Prog)$ and $\CSafe^*(\Prog)$, then $\Safe^*(\Prog)$.
\end{lemma}
