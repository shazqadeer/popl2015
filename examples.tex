\section{Overview}
\label{sec:overview}
\begin{figure}
\begin{verbatim}
var x:int;
\end{verbatim}
\begin{verbatim}
procedure p()
  requires x >= 5;
  ensures  x >= 8;
{
  yield x >= 5;  x := x + 1;
  yield x >= 6;  x := x + 1;
  yield x >= 7;  x := x + 1;
}
\end{verbatim}
\begin{verbatim}
procedure q() modifies x; { x := x + 3; }
\end{verbatim}
\caption{Program~1}
\label{fig:ex1}
\end{figure}

We present an overview of the \civl language through a sequence of examples.
Figure~\ref{fig:ex1} shows Program~1 containing a procedure {\tt p}
executing concurrently with another procedure {\tt q}. 
An execution of a \civl program is non-preemptive; a thread explicitly yields control to the
scheduler via the {\tt yield} statement following which execution continues on a 
nondeterministically chosen thread.
The {\tt yield} statement has a local assertion $\varphi$ attached to it.
The yielding thread must establish $\varphi$ when it yields and the execution of other threads 
must preserve $\varphi$; these two requirements are usually known as {\em sequential correctness}
and {\em non-interference}, respectively.
To check these requirements, the \civl verifier creates verification conditions, whose number is at most
quadratic in the number of yield statements in the program.
For example, in Program~1 each yield predicate in {\tt p} must be checked against the action 
{\tt x := x + 3} in {\tt q}.

\civl requires that a procedure that may potentially execute a yield statement during its execution 
must be annotated as {\tt yielding}.
This annotation is checked in a manner similar to the checking of modifies clauses; if a procedure is labeled 
as {\tt yielding} so must all of its callers.
A procedure marked as {\tt yielding} is exempt from providing a modifies clause; 
the presence of {\tt yielding} allows the caller to conclude that any global variable could have changed
potentially as a result of modification by a concurrently-executing thread.
A procedure not labeled as {\tt yielding} is called atomic; such a procedure must supply a modifies clause as usual.

\begin{figure}
\begin{verbatim}
var x:int;
\end{verbatim}
\begin{verbatim}
procedure yield_x(n:int)
  requires x >= n;
  ensures  x >= n;
{
  yield x >= n;
}
\end{verbatim}
\begin{verbatim}
procedure p()
  requires x >= 5;
  ensures  x >= 8;
{
  call yield_x(5);  x := x + 1;
  call yield_x(6);  x := x + 1;
  call yield_x(7);  x := x + 1;
}
\end{verbatim}
\caption{Program~2}
\label{fig:ex2}
\end{figure}

{\bf From quadratic to linear verification conditions.}
Figure~\ref{fig:ex2} shows Program~2, a variation of Program~1 in which the procedure {\tt yield\_x} 
contains a single yield statement and {\tt p} calls {\tt yield\_x} instead of yielding directly.
If the calls to {\tt yield\_x} are inlined in Program~2, then we will get Program~1.
Both Program~1 and~2 are verifiable in \civl but the cost of verifying Program~2 is less because it has fewer yield statements.
In fact, if it is possible to capture all interference in a concurrent program in a single yield predicate, 
then the trick in Program~2 can be used to verify the program with a linear number of verification conditions.

\begin{figure}
\begin{verbatim}
procedure yield_x(n: int)
  requires x >= n;
  ensures  x >= n;
{
  yield x >= n;
}
\end{verbatim}
\begin{verbatim}
procedure p()
  requires x >= 5;
  ensures  x >= 8;
{
  call yield_x(x);  x := x + 1;
  call yield_x(x);  x := x + 1;
  call yield_x(x);  x := x + 1;
}
\end{verbatim}
\caption{Program~3}
\label{fig:ex3}
\end{figure}

{\bf Encoding rely-guarantee specifications.}
Figure~\ref{fig:ex3} shows Program~3, yet another variation of Programs~1 and~2 which shows how to encode a rely-guarantee-style~\cite{Jones83} (two-state invariant)
proof using \civl's one-state yield statements. 
The standard rely-guarantee specification to prove the assertions in {\tt p} is that the environment of {\tt p} 
may only increase {\tt x}.
We can encode this in \civl by first exploiting the trick in Program~2 to factor out the yield statement in a separate procedure
and then passing the current value of {\tt x} as a parameter to {\tt yield\_x}.
In fact, our implementation of \civl requires even less work; the value of {\tt x} upon entering {\tt yield\_x} is available 
in the postcondition using the syntax {\tt old(x)}, allowing us to write {\tt yield\_x} without any parameter as follows:
\begin{verbatim}
procedure yield_x()
  ensures  x >= old(x);
{
  yield x >= old(x);
}
\end{verbatim}


\begin{figure}
\begin{verbatim}
type Tid;
var linear alloc:[Tid]bool;
const nil: Tid;
procedure Allocate() returns (linear tid: Tid);
  modifies alloc;
  ensures tid != nil;
\end{verbatim}
\begin{verbatim}
var a:[Tid]int;
\end{verbatim}
\begin{verbatim}
procedure main()
{
  var linear tid: Tid;
  while (true) {
    call tid := Allocate();
    async call P(tid);
    yield true;
  }
}
\end{verbatim}
\begin{verbatim}
procedure P(linear tid: Tid)
  requires tid != nil;
  ensures a[tid] == old(a)[tid] + 1;
{
  var t: int;
  t := a[tid];
  yield t == a[tid];
  a[tid] := t + 1;
}
\end{verbatim}
\caption{Program 4}
\label{fig:ex5}
\end{figure}

{\bf Linear variables.}
Program~5 in Figure~\ref{fig:ex5} introduces linear variables, a feature of \civl 
that is useful for encoding disjointness among values contained in 
different variables.  
This example uses this feature for encoding the concept of an identifier 
that is unique to each thread.
Program~5 contains a shared global array {\tt a} indexed by an uninterpreted type {\tt Tid} 
representing the set of thread identifiers.
A collection of threads are executing procedure {\tt P} concurrently.
The identifier of the thread executing {\tt P} is passed in as the parameter {\tt tid}.
A thread with identifier {\tt tid} owns {\tt a[tid]} and can increment it without danger of interference.
The yield assertion {\tt t == a[tid]} in {\tt P} indicates this expectation, yet it is not possible to prove it 
unless the reasoning engine knows that the value of {\tt tid} in one thread is distinct 
its value in a different thread.

Instead of building a notion of thread identifiers into \civl, we provide a more 
primitive and general notion of linear variables.
The \civl type system ensures that values contained in linear variables cannot be duplicated.
Consequently, the parameter {\tt tid} of distinct concurrent calls to {\tt P} are known to be distinct;
the \civl verifier exploits this invariant while checking for non-interference.

Program~5 also shows the mechanisms of allocation of thread identifiers,
based on the use of global variable {\tt alloc}, the constant {\tt nil}, and the procedure 
{\tt Allocate}.  
Section~\ref{sec:formal} describes values and linear variables like {\tt nil} and {\tt alloc} in more detail.

\begin{figure}
\begin{verbatim}
var Color:[int]int; // 1: WHT(), 2: GRY(), 3: BLK()
var Set:[int]bool;

procedure SetColGrayIfWht({:cnst "tid"} tid:int,
                                       addr:int)
ensures {:atomic} [if (Color[addr] == WHT(){)
                     Color[addr] := GRY();
                     Set[addr] := true;
                   }]
{
  call cNoLock:= GetColorNoLock();
  call YieldColorOnlyGetsDarker();
  if (cNoLock == WHT()) {
       call L_SetColorToGrayIfWht(tid,addr);
  }
}

procedure YieldColorOnlyGetsDarker()
  ensures Color >= old(Color);

procedure L_SetColGrayIfWht({:cnst "tid"} tid:int,
                                         addr:int)
ensures {:atomic} [if (Color[addr] == WHT(){)
                     Color[addr] := GRY();
                     Set[addr] := true;
                   }]
{
  call AcquireLock(tid);
  call cLock := GetColorLocked(tid);
  if (cLock == WHT()) {
    call SetColorLocked(tid, GRY());
    call InsertSetLocked(tid, addr);
  } 
  call ReleaseLock(tid);
}

procedure AcquireLock({:cnst "tid"} tid: X);
  ensures {:right} [ ...]
procedure ReleaseLock({:cnst "tid"} tid: X);
  ensures {:left} [...]
procedure InsertSetLocked(
              {:cnst "tid"} tid:X, addr:int); 
  ensures {:both} [...]
procedure SetColorLocked(
                {:cnst "tid"} tid:X, nC:int); 
  ensures {:both} [...]
procedure GetColorLocked(
       {:cnst "tid"} tid:X) returns (cl:int);
  ensures {:both} [...];

\end{verbatim}
\caption{Program 5}
\label{fig:reft}
\end{figure}

{\bf Refinement.} 

\civl supports the
verification of a refinement relationship between different versions of a
program. In higher-level versions, calls to some procedures in the
lower levels are
replaced by their atomic action specifications. 
Program 5 in Figure~\ref{fig:reft} introduces refinement in \civl. 
Atomic action specifications are shown in square brackets. 

In earlier phases of verification (not shown) \civl has verified that
the implementations of the five procedures called in {\tt
  L\_SetColGrayIfWht} satisfy their atomic action specifications, shown
at the bottom of the figure. In Program 5, in the first refinement
pass, \civl verifies that {\tt L\_SetColGrayIfWhite} is atomic and
satisfies its specification. In the second, higher-level 
pass, using the atomic action specification for {\tt
  L\_SetColGrayIfWhite}, Owicki-Gries-style reasoning using the yield
predicate in {\tt
  YieldColorsGetDarker()} and refinement reasoning, \civl verifies
that {\tt SetColGrayIfWht()} satisfies its atomic action
specification. 

This example is a simplified version of a pattern in the garbage
collector we verified. Here, several threads concurrenty check 
whether the global variable {\tt Color[addr]} has the value {\tt WHITE()}
and set it to {\tt GRAY()} and insert {\tt addr} into a 
set, represented by a map from {\tt addr} to {\tt bool} in this
example. 

 
The procedure  
\exC{L\_SetColGrayIfWhite} holds a global lock while reading
reading and possibly modifying {\tt Color[addr]} and inserting {\tt
  addr} into the set. 
As a performance optimization \exC{SetColGrayIfWhite}, before calling
\exC{L\_SetColGrayIfWhite}, reads \exC{Color[addr]} without holding a lock
and checks if it has the value {\tt WHITE()}. The correctness of this
optimization is not obvious -- if {\tt Color[addr]} is {\tt GRAY()} when
read without holding a lock, but can be set to {\tt WHITE()} by other 
threads before {\tt SetColGrayIfWht()} returns, then the atomic action
specification of the procedure may not be satisfied. The yield
predicate in {\tt YieldColorsOnlyGetDarker()} expresses the fact that
other threads in the environment of the thread running {\tt
  SetColGrayIfWht} can only modify {\tt Color[addr]} to a higher
value. \civl verifies that this is the case, 

Other than phrasing reduction as a type-checking problem, this is
ordinary static reduction reasoning. The verification of atomicity for
\exC{SetColGrayIfWht} highlights the capability of \civl to combine
Owicki-Gries-style reasoning and reduction to verify refinement.

Observe that in the procedure \exC{L\_SetColGrayIfWht}, there are no {\tt
  yield}s between statements. Since threds explicitly yield
control, this means that the entire body of \exC{L\_SetColGrayIfWht}
is executed atomically. In a real execution, control can switch
between threads at any point in the code. The absence of {\tt yield}s,
and treating the entire body of \exC{L\_SetColGrayIfWht} as atomic 
is justified by reasoning about mover types and reduction. The
four procedures called in \exC{L\_SetColGrayIfWht} have the mover
types claimed in their declarations and verified by \civl. Given
the mover types of all statements, including accesses to local
variables, calls to procedures with and without atomic action
specifications, a ``yield type checker'' in the \civl verifier 
(explained in Section~\ref{}) checks whether the absence of yields is
justified using reduction.  \civl then verifies that the body of
\exC{L\_SetColGrayIfWht} satisfies its atomic specification. 


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
