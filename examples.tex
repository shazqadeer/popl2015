\begin{figure}
\begin{verbatim}
var x:int;
\end{verbatim}
\begin{verbatim}
procedure p()
  requires x >= 5;
  ensures  x >= 8;
{
  yield x >= 5;  x := x + 1;
  yield x >= 6;  x := x + 1;
  yield x >= 7;  x := x + 1;
}
\end{verbatim}
\begin{verbatim}
procedure q() modifies x; { x := x + 3; }
\end{verbatim}
\caption{Program~1}
\label{fig:ex1}
\end{figure}

We present an overview of the \civl language through a sequence of examples.
Figure~\ref{fig:ex1} shows Program~1 containing a procedure {\tt p}
executing concurrently with another procedure {\tt q}. 
An execution of a \civl program is non-preemptive; a thread explicitly yields control to the
scheduler via the {\tt yield} statement following which execution continues on a 
nondeterministically chosen thread.
The {\tt yield} statement has a local assertion $\varphi$ attached to it.
The yielding thread must establish $\varphi$ when it yields and the execution of other threads 
must preserve $\varphi$; these two requirements are usually known as {\em sequential correctness}
and {\em non-interference}, respectively.
To check these requirements, the \civl verifier creates verification conditions, whose number is at most
quadratic in the number of yield statements in the program.
For example, in Program~1 each yield predicate in {\tt p} must be checked against the action 
{\tt x := x + 3} in {\tt q}.

\civl requires that a procedure that may potentially execute a yield statement during its execution 
must be annotated as {\tt yielding}.
This annotation is checked in a manner similar to the checking of modifies clauses; if a procedure is labeled 
as {\tt yielding} so must all of its callers.
A procedure marked as {\tt yielding} is exempt from providing a modifies clause; 
the presence of {\tt yielding} allows the caller to conclude that any global variable could have changed
potentially as a result of modification by a concurrently-executing thread.
A procedure not labeled as {\tt yielding} is called atomic; such a procedure must supply a modifies clause as usual.

\begin{figure}
\begin{verbatim}
var x:int;
\end{verbatim}
\begin{verbatim}
procedure yield_x(n:int)
  requires x >= n;
  ensures  x >= n;
{
  yield x >= n;
}
\end{verbatim}
\begin{verbatim}
procedure p()
  requires x >= 5;
  ensures  x >= 8;
{
  call yield_x(5);  x := x + 1;
  call yield_x(6);  x := x + 1;
  call yield_x(7);  x := x + 1;
}
\end{verbatim}
\caption{Program~2}
\label{fig:ex2}
\end{figure}

{\bf From quadratic to linear verification conditions.}
Figure~\ref{fig:ex2} shows Program~2, a variation of Program~1 in which the procedure {\tt yield\_x} 
contains a single yield statement and {\tt p} calls {\tt yield\_x} instead of yielding directly.
If the calls to {\tt yield\_x} are inlined in Program~2, then we will get Program~1.
Both Program~1 and~2 are verifiable in \civl but the cost of verifying Program~2 is less because it has fewer yield statements.
In fact, if it is possible to capture all interference in a concurrent program in a single yield predicate, 
then the trick in Program~2 can be used to verify the program with a linear number of verification conditions.

\begin{figure}
\begin{verbatim}
procedure yield_x(n: int)
  requires x >= n;
  ensures  x >= n;
{
  yield x >= n;
}
\end{verbatim}
\begin{verbatim}
procedure p()
  requires x >= 5;
  ensures  x >= 8;
{
  call yield_x(x);  x := x + 1;
  call yield_x(x);  x := x + 1;
  call yield_x(x);  x := x + 1;
}
\end{verbatim}
\caption{Program~3}
\label{fig:ex3}
\end{figure}

{\bf Encoding rely-guarantee specifications.}
Figure~\ref{fig:ex3} shows Program~3, yet another variation of Programs~1 and~2 which shows how to encode a rely-guarantee-style~\cite{Jones83} (two-state invariant)
proof using \civl's one-state yield statements. 
The standard rely-guarantee specification to prove the assertions in {\tt p} is that the environment of {\tt p} 
may only increase {\tt x}.
We can encode this in \civl by first exploiting the trick in Program~2 to factor out the yield statement in a separate procedure
and then passing the current value of {\tt x} as a parameter to {\tt yield\_x}.
In fact, our implementation of \civl requires even less work; the value of {\tt x} upon entering {\tt yield\_x} is available 
in the postcondition using the syntax {\tt old(x)}, allowing us to write {\tt yield\_x} without any parameter as follows:
\begin{verbatim}
procedure yield_x()
  ensures  x >= old(x);
{
  yield x >= old(x);
}
\end{verbatim}


\begin{figure}
\begin{verbatim}
type Tid;
var linear alloc:[Tid]bool;
const nil: Tid;
procedure Allocate() returns (linear tid: Tid);
  modifies alloc;
  ensures tid != nil;
\end{verbatim}
\begin{verbatim}
var a:[Tid]int;
\end{verbatim}
\begin{verbatim}
procedure main()
{
  var linear tid: Tid;
  while (true) {
    call tid := Allocate();
    async call P(tid);
    yield true;
  }
}
\end{verbatim}
\begin{verbatim}
procedure P(linear tid: Tid)
  requires tid != nil;
  ensures a[tid] == old(a)[tid] + 1;
{
  var t: int;
  t := a[tid];
  yield t == a[tid];
  a[tid] := t + 1;
}
\end{verbatim}
\caption{Program 4}
\label{fig:ex5}
\end{figure}

{\bf Linear variables.}
Program~5 in Figure~\ref{fig:ex5} introduces linear variables, a feature of \civl 
that is useful for encoding disjointness among values contained in 
different variables.  
This example uses this feature for encoding the concept of an identifier 
that is unique to each thread.
Program~5 contains a shared global array {\tt a} indexed by an uninterpreted type {\tt Tid} 
representing the set of thread identifiers.
A collection of threads are executing procedure {\tt P} concurrently.
The identifier of the thread executing {\tt P} is passed in as the parameter {\tt tid}.
A thread with identifier {\tt tid} owns {\tt a[tid]} and can increment it without danger of interference.
The yield assertion {\tt t == a[tid]} in {\tt P} indicates this expectation, yet it is not possible to prove it 
unless the reasoning engine knows that the value of {\tt tid} in one thread is distinct 
its value in a different thread.

Instead of building a notion of thread identifiers into \civl, we provide a more 
primitive and general notion of linear variables.
The \civl type system ensures that values contained in linear variables cannot be duplicated.
Consequently, the parameter {\tt tid} of distinct concurrent calls to {\tt P} are known to be distinct;
the \civl verifier exploits this invariant while checking for non-interference.

Program~5 also shows the mechanisms of allocation of thread identifiers,
based on the use of global variable {\tt alloc}, the constant {\tt nil}, and the procedure 
{\tt Allocate}.  
Section~\ref{sec:formal} describes values and linear variables like {\tt nil} and {\tt alloc} in more detail.

\begin{figure}
\begin{verbatim}
var Color:[int]int; // 1: WHT(), 2: GRY(), 3: BLK()

procedure SetColGryIfWht({:cnst "tid"} tid:int,
                                       addr:int)
ensures {:atomic} [if (Color[addr] == WHT(){)
                     Color[addr] := GRY();
                     Set[addr] := true;
                   }]
{
  call cNoLock:= GetColorNoLock();
  call YieldColorsGetDarker();
  if (cNoLock == WHT()) {
       call LockedSetColGryIfWht(tid,addr);
  }
}

procedure YieldColorsGetDarker()
  ensures forall a:: Color[a] >= old(Color[a]);

procedure LockedSetColGryIfWht({:cnst "tid"} tid:int,
                                         addr:int)
ensures {:atomic} [if (Color[addr] == WHT(){)
                     Color[addr] := GRY();
                     Set[addr] := true;
                   }]
{
  call AcquireLock(tid);
  call cLock := GetColorLocked(tid);
  if (cLock == WHT()) {
    call SetColorLocked(tid, GRY());
  } 
  call ReleaseLock(tid);
}

procedure AcquireLock({:cnst "tid"} tid: X);
  ensures {:right} [ ...]
procedure ReleaseLock({:cnst "tid"} tid: X);
  ensures {:left} [...]
procedure SetColorLocked(
                {:cnst "tid"} tid:X, nC:int); 
  ensures {:both} [...]
procedure GetColorLocked(
       {:cnst "tid"} tid:X) returns (cl:int);
  ensures {:both} [...];

\end{verbatim}
\caption{Program 5}
\label{fig:reft}
\end{figure}

{\bf Refinement.} 
\civl supports the verification of atomic action specification for
procedures. In one refinement verification step, calls to procedures with such
specifications are replaced by the atomic actions, some variables may
be hidden, and a higher-level program is obtained. The higher-level
program preserves assertion violations in the lower-level one. 
Program 5 in Figure~\ref{fig:reft} introduces refinement in \civl. 
Atomic action specifications are shown in square brackets. 

In earlier phases of verification (not shown) \civl has verified that
the implementations of the five procedures called in {\tt
  LockedSetColGryIfWht} satisfy their atomic action specifications shown
at the bottom of the figure. Program 5 illustrates two \civl
refinement passes. In the first pass, \civl verifies that {\tt
  LockedSetColGryIfWht} is atomic and satisfies its specification. In
the second pass, using the atomic action specification for {\tt
  LockedSetColGryIfWht}, Owicki-Gries-style reasoning using the yield
predicate in {\tt YieldColorsGetDarker()} and refinement reasoning,
\civl verifies that {\tt SetColGrayIfWht()} satisfies its atomic
action specification.

This example is a simplified version of a pattern in the garbage
collector we verified. Threads concurrenty check 
if the global variable {\tt Color[addr]} is {\tt WHITE()}
and set it to {\tt GRAY()}. 

The procedure  \exC{LockedSetColGryIfWht} holds a global lock while
manipulating {\tt Color[addr]}. 
As a performance optimization \exC{SetColGryIfWhite} only calls 
\exC{LockedSetColGrayIfWhite} after reading \exC{Color[addr]} without holding a lock
and confirming that it is {\tt WHITE()}. The correctness of this
optimization is not obvious -- if {\tt Color[addr]} is {\tt GRAY()} when
read without holding a lock, but can be set to {\tt WHITE()} by other 
threads when \exC{LockedSetColGryIfWhite} yields immediately after the
lock-free read, then the atomic action
specification of the procedure may not be satisfied. The yield
predicate in {\tt YieldColorsOnlyGetDarker()} expresses the fact that
other threads in the environment of the thread running {\tt
  SetColGrayIfWht} can only modify {\tt Color[addr]} to a higher
value. \civl verifies that this is the case. Given the correct
modeling of the environment interference by {\tt yield} statements,
\civl then verifies that, for every control path through the
procedure, exactly one {\tt yield}-to-{\tt yield} execution
fragment implements the atomic action spec while others do not modify
global state. 

The verification of atomicity for \exC{SetColGrayIfWht} highlights a
novel verification feature in \civl -- that of combining
Owicki-Gries-style reasoning and reduction to verify refinement.

{\bf Yield Elimination} Observe that in 
\exC{LockedSetColGryIfWht} there are no {\tt yield}s between
statements. Since threds explicitly yield control, this means that the
entire body of \exC{LockedSetColGrayIfWht} is executed atomically. In
a real execution, control can switch between threads at any point in
the code. The absence of {\tt yield}s, and treating the entire body of
\exC{LockedSetColGrayIfWht} as atomic is justified by reasoning about
mover types and reduction. The procedures called in
\exC{LockedSetColGrayIfWht} have the mover types claimed in their
declarations and verified by \civl. Given the mover types of all
statements, including accesses to local variables, calls to procedures
with and without atomic action specifications, a ``yield sufficiency
checker'' in the \civl verifier (explained in Section~\ref{}) checks
whether the absence of yields is justified using reduction.  \civl
then verifies that the body of \exC{LockedSetColGrayIfWht} satisfies
its atomic specification.

{\bf Variable Hiding} Observe that the atomic action specification of
\exC{LockedSetColGryIfWht} makes no reference to the lock variable,
although its implementation involves a lock. In the refinement step in
which \exC{LockedSetColGryIfWht} becomes atomic, the lock variable has
been hidden. Hiding variables at refinement steps and providing
different {\tt yield} predicates at different phases of a proof are
important novel capabilities in \civl that facilitate proofs that span
large abstraction gaps, such as the proof of the garbage collector in
Section~\ref{}. 

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
