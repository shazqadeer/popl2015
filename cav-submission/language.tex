\section{A concurrent programming language}
\label{sec:language}

\begin{wrapfigure}{l}{0.6\textwidth}
\setlength{\tabcolsep}{3pt}
\scriptsize{
\begin{tabular}{rclcl}
$\stmt \in \Stmt$ &::= & $\skipstmt \mid \yield{e,\lins} \mid \call{A} \mid$ \\
                  & & $\call{P} \mid \async{P} \mid$ \\
                  & & $\ablock{e,\lins}{\stmt} \mid \stmt;\;\stmt \mid$\\
                  & & $\ite{\locExpr}{\stmt}{\stmt} \mid$ \\
                  & & $\while{e,\alpha}{\locExpr}{\stmt}$ \\
$\Frame \in \mathit{Frame}$ &::= & $(P, \varsL, \stmt)$ \\
$T \in \mathit{Thread}$ &::= &$(\varsTL, \Frames)$ \\
$\StmtCtxt \in \mathit{StmtCtxt}$ &::= &$[]_{\Stmt} \mid \StmtCtxt;\stmt$ \\
$\FrameCtxt \in \mathit{FrameCtxt}$ &::= & $(P, []_{\StoreLocal}, \StmtCtxt)$ \\
$\ThreadCtxt \in \mathit{ThreadCtxt}$ &::= &$([]_{\StoreThreadLocal}, \FrameCtxt\cdot\Frames)$ \\
$\ProgCtxt \in \mathit{ProgCtxt}$ &::= & $(\procs, \actions, \ProcLins, []_{\StoreGlobal}, \TS \cdot \ThreadCtxt \cdot \TS)$ \\
$\Prog \in \Program$ &::= & $\ProgCtxt[\varsG][\varsTL][\varsL][\stmt]$ \\
$\YieldingThread \in \mathit{YieldingThread}$ &::= &$\ThreadCtxt[\varsTL][\varsL][\yield{e,\lins}]$ \\
$\YProgram$ &::= & $(\procs, \actions, \ProcLins, \varsG, \YieldingThreads \cdot T \cdot \YieldingThreads)$ \\
$\CProgram$ &::= & $(\procs, \actions, \ProcLins, \varsG, \YieldingThreads)$
\end{tabular}
}
\caption{Syntax}
\label{fig:syntax}
\end{wrapfigure}

We present our verification method on a core concurrent programming language, \civl.
In this section, we present the syntax (Figure~\ref{fig:syntax}) and operational semantics of our language informally.
A \civl program is comprised of threads each of which has a stack, global variables shared across threads, 
thread-local variables that are shared across procedures, and local variables inside a procedure.
The mutually disjoint sets $\Global$, $\ThreadLocal$, and $\Local$ are the names of global, thread-local, and procedure-local variables 
respectively, and $\Var$ denotes their union.
There is an uninterpreted set $\Value$ of values that may be stored in these variables.
$\Store$, $\StoreGlobal$, $\StoreThreadLocal$, and $\StoreLocal$ are all sets of maps into $\Value$
from $\Var$, $\Global$, $\ThreadLocal$, and $\Local$ respectively.
We denote elements of $\Store$, $\StoreGlobal$, $\StoreThreadLocal$, and $\StoreLocal$
by $\sigma$, $\varsG$, $\varsTL$, and $\varsL$ respectively.
Formally, a \civl program is a tuple $(\procs, \actions, \ProcLins, G, \TS)$ with the following components.

\noindent
{\bf Procedures.}
$\procs$ maps a procedure name $P \in \ProcName$ to a tuple $(\phi, \mods, \psi, \stmt)$, 
where $\phi$ is the precondition of $P$, $\mods$ is the set of thread-local variables potentially modified by $P$, 
$\psi$ is the postcondition of $P$, and $\stmt$ is the body of $P$.
The predicates $\phi$ and $\psi$ cannot refer to procedure-local variables.
Procedures do not have parameters, but parameters may be modeled using thread-local variables.

\noindent
{\bf Actions.}
$\actions$ maps an action name $A \in \ActionName$ to a tuple $(\rho,\alpha,m)$.
Actions are used inside procedure bodies to access global and thread-local variables.
The predicate $\rho$ over $\Store$ is the gate and the predicate $\alpha$ over $\Store \times \Store$ 
is the transition relation of $A$.
If the gate $\rho$ does not hold on the current state, the program fails;
otherwise, the program makes progress by executing the action $A$ based on the transition relation $\alpha$.
Finally, $m$ is one of four values in $\{B,R,L,N\}$;
it denotes the commutativity type of the action, $B$ for both mover, $R$ for right mover, $L$ for left mover, 
and $N$ for non mover~\cite{FlanaganFLQ08}. 

\noindent
{\bf Linear interfaces.}
$\ProcLins$ maps each procedure and action name in $\ProcName \cup \ActionName$ to a linear interface 
$(\lins,\lins')$, where each of $\lins$ and $\lins'$ is a set comprising global and thread-local variables.
The procedure (or action) requires that the set $\lins$ be available at the beginning of its invocation 
and makes available the set $\lins'$ at the end of its invocation; 
we refer to $\lins$ and $\lins'$ as the input and output linear permissions respectively.
The programmer provides a function $\Perm$ from $\Value$ to $2^\Value$
and the linear type checker enforces the invariant that 
different available variables contain distinct values and 
the sets $\Perm(v)$ for values $v$ contained in available variables are always pairwise disjoint.

\noindent
{\bf Global store.}
$\varsG$ is the global store of the program.

\noindent
{\bf Threads.}
$\TS$ is a sequence of threads.
Each thread $T$ in $\TS$ is a pair $(\varsTL, \Frames)$ where
$\varsTL$ is the thread-local store and $\Frames$ is a stack of frames comprising the continuation of $T$.  
Each frame $(P, \varsL, \stmt)$ in $\Frames$ comprises a procedure $P$, its procedure-local store $\varsL$, 
and a statement $\stmt$.

We formalize the operational semantics of \civl as a relation $\trans$ between a pair of programs.
The rules for the relation extend the syntax of statements with an embedded context~\cite{WrightF94}.
A statement context $\StmtCtxt$ is either a context $[]_{\Stmt}$ or the sequential composition of a 
statement context and a statement.
Thus, each statement context has a unique context $[]_{\Stmt}$ inside it;
this context encodes the current position of the execution of a thread.
The result of substituting a statement $\stmt$ inside the statement context $\StmtCtxt$ 
is another statement and is denoted by $\StmtCtxt[\stmt]$.
Similarly, we define a frame context $\FrameCtxt$ with two contexts embedded inside it, 
$[]_{\StoreLocal}$ for substituting a procedure-local store
and $[]_{\Stmt}$ for substituting a statement.
The result of substituting a procedure-local store $\varsL$ and a statement $\stmt$ inside 
$\FrameCtxt$ is a frame and is denoted by $\FrameCtxt[\varsL][\stmt]$;
here, $\varsL$ is the procedure-local store for the procedure containing the currently executed statement $\stmt$.
A thread context $\ThreadCtxt$ has three contexts embedded inside it, $[]_{\StoreThreadLocal}$ for substituting a thread-local store, 
$[]_{\StoreLocal}$ for substituting a procedure-local store, and $[]_{\Stmt}$ for substituting a statement.
The result of substituting a thread-local store $\varsTL$, a procedure-local store $\varsL$, and a statement $\stmt$ inside $\ThreadCtxt$ 
is a thread and is denoted by $\ThreadCtxt[\varsTL][\varsL][\stmt]$.
Finally, the result of substituting a global store $\varsG$, a thread-local store $\varsTL$, 
a procedure-local store $\varsL$, and a statement $\stmt$ inside $\ProgCtxt$ is a program and is denoted by $\ProgCtxt[\varsG][\varsTL][\varsL][\stmt]$.

A finite $\trans$-execution from $\Prog$ is a sequence of programs $\Prog_0,\Prog_1,\ldots,\Prog_n$ such that $\Prog_0 = \Prog$ 
and $\Prog_i \trans \Prog_{i+1}$ for all $0 \leq i < n$.
An infinite $\trans$-execution from $\Prog$ is defined similarly.
We write $\Safe(\Prog)$ if $\Prog$ cannot fail in one step.
We write $\Safe^*(\Prog)$ if $\Safe(\Prog')$ for all $\Prog'$ such that $\Prog \trans^* \Prog'$.

Figure~\ref{fig:syntax} defines the subset $\mathit{YieldingThread}$ of threads and subsets 
$\YProgram$ and $\CProgram$ of $\Program$.
A yielding thread in $\mathit{YieldingThread}$ is one that is waiting to execute at a yield statement.
A program in $\YProgram$ is one in which all threads except at most one thread are yielding threads.
A program in $\CProgram$ is one in which all threads are yielding threads.
Let $\ytrans$ be the relation $\trans$ whose domain and codomain are restricted to $\YProgram$.
A $\ytrans$-execution from a program $\Prog \in \YProgram$ is defined similarly to a $\trans$-execution.
In such an execution, the one (possibly) non-yielding thread is the only one allowed to execute until it reaches 
a yield statement and becomes a yielding thread.
At that point, all threads are yielding and any one can be picked for execution.

We define the relation $\ctrans$ with domain $\CProgram$ and codomain $\CProgram \cup \{\error\}$ as follows:
\begin{enumerate}
\item 
$\Prog \ctrans \Prog'$ if there is a $\ytrans$-execution from $\Prog$ to $\Prog'$ such that every program on the execution 
except for $\Prog$ and $\Prog'$ is not in $\CProgram$.
\item
$\Prog \ctrans \error$ if there is a $\ytrans$-execution from $\Prog$ to $\error$ such that every program on the execution 
except for $\Prog$ is not in $\CProgram$.
\end{enumerate}

Consider a program $\Prog \in \CProgram$.
We write $\CSafe(\Prog)$ if it is not the case that $\Prog \ctrans \error$.
We write $\CSafe^*(\Prog)$ if $\CSafe(\Prog')$ for all $\Prog'$ such that $\Prog \ctrans^* \Prog'$.
We write $\Cooperative(\Prog)$ if for each infinite $\ytrans$-execution $\Prog \ytrans \Prog_0 \ytrans \Prog_1 \ytrans \cdots$ 
starting from $\Prog$, there is some $i \geq 0$ such that $\Prog_i \in \CProgram$.
We write $\Cooperative^*(\Prog)$ if $\Cooperative(\Prog')$ for all $\Prog' \in \CProgram$ such that $\Prog \ctrans^* \Prog'$.
