\section{Verification}
\label{sec:verification}

Suppose a program $\Prog'$ has been proved to be safe.
However, it is implemented using atomic actions that are too coarse to be directly implementable.  
To carry over the safety of $\Prog'$ to a realizable implementation $\Prog$, 
these coarse atomic actions must be refined down to lower-level actions.
During this refinement, an invocation $\call{A}$ of a high-level atomic action $A$ is transformed into an 
invocation $\call{P}$ of a procedure that is implemented using low-level actions.
The main contribution of this paper is a verification method that allows us to safely refine
program $\Prog'$ to another program $\Prog$ (or abstract $\Prog$ to $\Prog'$) so that 
safety properties proved on $\Prog'$ continue to hold on $\Prog$ as well.

The safety of the program $\Prog$, as defined in Section~\ref{sec:language}, depends on 
the preemptive semantics of $\Prog$.
Our overall goal is to conclude the safety of preemptive semantics of $\Prog$
from the safety of the preemptive semantics of $\Prog'$.
We achieve this goal in two steps.
First, we establish a simulation relation from the cooperative semantics of $\Prog$ 
to the preemptive semantics of $\Prog'$,
allowing us to conclude the safety of the former from the safety of the latter.
This step involves three verification judgments---$\Refines;\HiddenProcs;\HiddenVars;\HiddenActions;\bs{b} \vdash \Prog \leadsto \Prog'$,
$\Refines;\HiddenProcs \jr \Prog$, and $\InterferenceSafe(\Prog)$.
Next, we establish that the safety of the cooperative semantics of $\Prog$ is 
sufficient for the safety of the preemptive semantics of $\Prog$.
This step involves three verification judgments---$\Refines \jy \Prog$ and $\CommutativitySafe(\Prog)$.
Together, these judgments allow us to conclude the safety of preemptive semantics of $\Prog$
from the safety of the preemptive semantics of $\Prog'$.

The verification strategy described above depends on the auxiliary judgment $\jl \Prog$ that
checks that $\Prog$ uses linear variables appropriately.
This check is important because appropriate use of linear variables gives our verifier access to free disjointness
assumptions that increase precision at low annotatation overhead.

\begin{theorem}
\label{thm:correctness}
Let $\Prog \in \CProgram$ be such that $\Cooperative^*(\Prog)$.
Let $\Prog' \in \CProgram$, $\Refines \in \ProcName \pf \ActionName$, $\HiddenProcs \in 2^{\ProcName}$, 
$\HiddenVars \in 2^{\Global}$, $\HiddenActions \in 2^{\ActionName}$,
and $\bs{b} \in \overrightarrow{\Boolean}$ be such that the following hold:
\begin{enumerate}
\item
$\jl \Prog$.
\item
$\Refines;\HiddenProcs;\HiddenVars;\HiddenActions;\bs{b} \vdash \Prog \leadsto \Prog'$,
$\Refines;\HiddenProcs;\HiddenVars;\bs{b} \jr \Prog$ \\ and $\InterferenceSafe(\Prog)$.
\item
$\jy \Prog$ and $\CommutativitySafe(\Prog)$.
\end{enumerate}
If $\Safe^*(\Prog')$, then $\Safe^*(\Prog)$.
\end{theorem}

Theorem~\ref{thm:correctness} is our main soundness theorem;
it concludes the safety of $\Prog$ from the safety of $\Prog'$.
In general, the correctness proof of a large program is obtained by chaining together
multiple instances of this theorem connecting a sequence of programs.  

In the rest of this section, we look at the individual verification judgments discussed above in more detail.
We begin with the judgments $\Refines;\HiddenProcs;\HiddenVars;\HiddenActions;\bs{b} \vdash \Prog \leadsto \Prog'$,
$\Refines;\HiddenProcs \jr \Prog$, and $\InterferenceSafe(\Prog)$ for establishing a simulation relation from 
the cooperative semantics of $\Prog$ to the preemptive semantics of $\Prog'$.

