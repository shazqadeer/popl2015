
\section{Related work}
\label{sec:related}

The key design goal for \civl is automated refinement of a concurrent software system,
via intermediate descriptions, down to a detailed implementation in terms of primitive atomic operations.
\civl verifies that each description correctly refines the description
at the level above, which requires a collection of correlated
whole-program refinement proofs. 
By contrast, existing work on atomicity refinement for concurrent software is
targeted at a single refinement proof between procedure implementations and
specifications, and not between two whole programs.
The \civl theory and verification tool are the first to
enable multiple layered whole-program refinement proofs
within a single unifying theory and automate this process with
interactive tool support.
While many of the verification techniques available in \civl appear in
the literature, \civl is the first to make sound, joint use of them to
support multiple layers of refinement. 

\subsection{Refinement-oriented verification}
Atomic action specifications have been explored by the
\calvin~\cite{FlanaganFQS05,FreundQ04} verifier previously. 
\civl makes a distinction between preemptive and cooperative
semantics, and carries out refinement verification on a procedure body
with cooperative semantics as enabled by movers types and reduction.
\calvin attempts to verify refinement directly on the preemptive
semantics, making only limited use of movers at the lowest-level
representation. 
\calvin, unlike \civl, does not support location invariants and linear
variables. 
It instead requires that a two-state rely predicate modeling all possible
interference on the shared state by other threads be supplied. 
Location invariants can encode rely-guarantee reasoning vice versa. 
However, in practice, carrying out non-interference reasoning only
using rely-guarantee reasoning can be significantly harder from a
human interactive proof standpoint. We discuss this point further on
the garbage collector below. 

\QED~\cite{ElmasQT09} is a simplifier for concurrent programs and is close in spirit to the 
refinement-oriented approach of \civl.
A key distinction between \civl and \QED is the fact that a proof step in \QED is a small rewrite in the concurrent program
that must be justified by potentially expensive reduction and invariant reasoning.
In \QED, abstract versions of a program are obtained by transforming the initial
version by applying a proof script. 
This makes it difficult to organize a proof in \QED by providing a
description of a program at several different levels of abstraction. 
Further, the number of small proof steps directly affect both programmer
and computer effort. 
By contrast, \civl supports large proof steps, in each of which the bodies of several procedures
are automatically replaced by atomic actions, thereby lowering the cost of both interaction and automation.
The non-interference reasoning in \QED is even more limited than \calvin.
\QED supports only global invariants and does not support rely-guarantee reasoning or linear variables.

Liang et al.~\cite{LiangRGSim} present a method for verifying that procedure
bodies refine atomic specifications. 
The key verification approach is
rely-guarantee reasoning and the refinement (simulation) relation between
a procedure and its specification is constrained so it is preserved under
parallel composition. 
This work also lists a concurrent garbage collector as one of the case
studies. 
Their proof corresponds to a few layers of our proof, in particular,
does not refine the implementation to the level of hardware
instructions. 
Since this work uses different languages to describe the high-level
and low-level programs, it is not immediately possible to carry out a
multi-level stepwise refinement proof. 
This work does not provide any tool support for verifying refinement. 

Turon and Wand~\cite{TuronM11} use ownership disciplines and
separation logic to verify refinement of atomic specifications by 
concurrent data structure implementations. 
Rely-guarantee reasoning is
supported to provide compositionality and non-interference
arguments. 
This work targets a single refinement step between atomic
specifications for methods and their implementations. 
No tool support for this verification method is provided. 

Verifying linearizability of concurrent data structures (see, e.g.,
\cite{tacasLin,aliLin}) can be viewed as an instance of one-level of
refinement in our setting. 
\civl can be used for mechanical
verification of linearizability, as we did for the Treiber stack, for
instance. 
Tools and techniques specific to verifying linearizability
cannot, however, be easily generalized for stepwise refinement proofs
through multiple levels. 

Refinement proofs
between implementations and specifications of protocols have been
investigated using the TLA+~\cite{Lamport2004} specification
language. 
Compositional proofs between specifications and
implementations consisting of modules~\cite{AbadiAssumeGuarantee} have
been investigated in this context. 
Modular refinement proofs for hardware systems have been investigated extensively
(e.g.,~\cite{Henzinger1999,Eiriksson2000}) using the SMV~\cite{McMillan00} and Mocha~\cite{AlurHMQRT98} 
model checking tools.
For concurrent, shared-memory
software, there is a significant cognitive gap between the imperative
multithreaded program text as written in, e.g., \civl, and the TLA+,
SMV or Mocha descriptions for the program. 
The latter encode the
semantics of an imperative concurrent program as a
state-transition relation. 
Proofs in TLA+, SMV and Mocha, whether modular or not, are
distinguished from proofs in \civl and other techniques that operate
off of the imperative program text in this key regard. 
Reasoning on a
semantic model of a program rather than the program text itself, for
shared-memory concurrent programs, adds a significant amount of
cognitive load to the user. 
It also makes it difficult to structure a
proof along the syntactic structure of the imperative program. 

\subsection{Reasoning about concurrency}
In this section, we briefly discuss foundational techniques
for combating the complexity of concurrent program verification. 
\civl as well as atomicity refinement verification discussed in the previous
section have common ideas with tools and formalisms
discussed in this section. But the primary purpose of the techniques
discussed here is the verification of safety properties of a {\em single} concurrent program rather than refinement. 
Refinement in \civl is orthogonal to these techniques and can potentially be combined with them.
Conversely, these techniques can be aided by \civl's 
ability to connect a complex concurrent program to a simpler abstraction.

VCC~\cite{VCC} is a tool for verifying concurrent C programs.  
Chalice~\cite{LM09} is a language and modular verification tool for concurrent programs. 
VCC does not support refinement and Chalice does so only for sequential programs.  
VCC and Chalice base their invariant reasoning on objects, object ownership, and type invariants. 
Invariant reasoning in \civl is more primitive and based on predicates in yield statements. 
Although the approach in VCC and Chalice is more convenient when applicable, \civl's approach is more flexible. 
VCC and Chalice can reason sequentially about objects exclusively owned by a thread;
\civl accomplishes the same using linear variables.
Neither VCC nor Chalice support movers and reduction reasoning.

Concurrent separation logic~\cite{OHearn07} reasons about concurrency without 
explicitly checking for non-interference between threads. 
Recently, tools based on this logic that blend in explicit non-interference reasoning have been developed~\cite{SAGL,RGSep}. 
\civl's combination of interference checking and linear variables is
an extreme example of this trend, is very general and technique-agnostic. 
We supply very primitive abstractions and let programmers mix and
match these abstractions freely to encode the non-interference reasoning style of their choice. 



