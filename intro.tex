Although significant progress has been made in developing verifiers for sequential programs, practical verifiers for concurrent programs remain elusive.
A reason for this gap is that verification of concurrent programs is fundamentally harder.
Concurrent systems software,  in particular, is complex and difficult to verify both computationally and humanswise.
Verifying existing concurrent software is difficult -- even when partial specifcations are available, one must extract the design intent. 
When the goal is verified software, a top-down methodology, where a simple high-level description is refined, possibly through several levels, down to an optimized and more highly-concurrent implementation is conceptually recommended. 
However, currently there is no such tool-supported top-down methodology that can go from a very high, user-level spec down to the level of individual memory accesses, which is ultimately what is needed for systems software correctness.  
Needed because going the other way is hard. VCC is the only one on which something big has been done, but it is flat, top-down refinement reasoning not possible. 
Much work advocates it, but no tool supports it. 
Components of a correct-by-verified-refinement approach include a methodology and language for writing systems code and modular specifications at different levels of abstraction, support for various concurrent program verification methods integrated soundly into a verification tool, 
In this paper, we present such a proof methodology, an intermediate language and a verification tool and demonstrate it on a realistic concurrent garbage collector refined all the way down from atomic actions describing memory allocation and field accesses and the garbage collector summarized by ``skip'' to individual memory accesses performed on the hardware. 

In our proof method, a program is described at different levels of abstraction. All of these descriptions as well as the refinement relationships connecting them are reside in the same \civl file, the input to our tool. 
When going from a lower-level description to a higher-level one, some variables are hidden, and some procedures are proven atomic and replaced by their atomic action specifications. Alternatively, atomic actions in a high-level description are refined to more highly-granular, optimized implementations which may include more implementation-level variables. Modular specifications and proof annotations such as program and location invariants and procedure pre- and post-conditions, can be specified separately at each level in terms of the set of variables visible at that level. 
As a result, for instance in the GC, the top-level annotations express the client's view, e.g., in terms of an infinite heap and field relationships between objects, 
 whereas lower levels express different views of the implementation, referring to, e.g., atomic updates of objects' colors or lock operations in lower levels. 
Concurrent refinement tools and techniques in the literature have typically been applied to small examples to relate representations that are relatively close in terms of level of abstraction, such as the abstract specification of a concurrent stack vs. a lock-based implementation. Provably correct systems software requires correct refinement from a very high-level description (such as ``skip'' for the GC) down to individual memory updates. To the best of our knowledge, there are no existing tools demonstrated capable of supporting refinement proof of a realistic system that bridges a large abstraction gap as in our GC proof. 

The verification method, language, and tool design have all been carried out with an eye toward carrying out a modular hierarchical refinement proof in a way that feels natural to a user and is computationally efficient. Our method integrates as a sound proof system and verification tool the concurrent program verification techniques described below. 
Yield predicates and non-preemptive concurrency. 
The first verification technique available in \civl is a generalization of the Owicki-Gries method~\cite{OwickiG76} for non-preemptive concurrency, 
allowing arbitrary code to appear inside an atomic action.
This simple but surprisingly powerful generalization allows us, among other things, to compactly encode rely-guarantee reasoning~\cite{Jones83}
and to reuse non-interference specifications from one program location to another.
The second verification technique in \civl is an implementation of linear type checking.
Linear types~\cite{Wadler90lineartypes} and separation logic~\cite{Reynolds02} enable substructural reasoning about data types
(e.g. using separating conjunction or linear maps~\cite{LahiriQW11}).
Perhaps surprisingly, linear types can also be used to encode the notion of unique thread identifiers useful for reasoning about non-interference.
The third verification technique in \civl is the use of Lipton-style reduction, abstraction, and variable hiding to support atomicity refinement.  
Movers allow yield elimination, which simplifies verification by saving the user from writing yield predicates and the verification tool from verifying them for the yields removed. 
 Techniques have sweet spots, no one of them enough by itself. 
\civl is more than a toolbox that provides these techniques. The sound combination of the techniques in a proof system enables us to use them in a symbiotic manner for verifying refinement. 
For instance, stable location invariants verified using Owicki-Gries-style reasoning can facilitate verification of atomicity refinement which, combined with variable hiding, allows the use of simpler location invariants and rely-guarantee annotations for a higher-level version of the program. When going bottom-up, a program with fewer procedures, larger atomic blocks, fewer variables constitutes a new starting point for further abstraction.
The power of this symbiosis became clear during our garbage collector verification effort, for different aspects of which we used each of the techniques listed above. 

We have demonstrated our methodology and tool on a concurrent garbage collector that we have designed for this purpose. Design choices in this new collector, an extension of the collector of Dijkstra et. al. \cite{dijk78}  with handshakes \cite{doli93,doli94} and repeated scans for safe termination, were made with verified refinement and high performance in mind. Our garbage collector is not as complex as some popular collectors such as those that use a snapshot-based approach \cite{doli93,doli94,doma00,azat03} or that contain complex phases and write-barrier properties \cite{boeh91,prin00a,bara05} in order to allow a ``no-black-to-white'' invariant to hold continuously throughout the execution. Yet, it supports a garbage collector thread running concurrently with multiple mutator threads and its performance is competitive with well-known modern collectors. To the best of our knowledge this is a new collector that has not been previously proposed in the literature or in practice. 

The verification of the collector started from atomic action specifications for object allocation and field acccesses by mutator threads, and a specification of ``skip'' for the collector -- that it have no effects visible to the mutator threads. To the best of our knowledge, this is the first such automated verification of a practical, executable garbage collector implementation as contrasted with verification of garbage collection algorithms. In refinement proofs among lower phases, atomicity of lock implementations, lock-protected field accesses and data structure (mark stack) operations were verified. Later phases built larger atomic procedures from these primitives and verified garbage collector invariants involving garbage collector phases, colors used in the garbage-collection algorithm and field relationships among objects, and handshakes between mutator threads and the garbage collector. Using these invariants and variable hiding, we were able to verify the top-level specification of  ``skip'' for methods of the garbage collector and atomic action specifications for methods called by mutators. Atomicity reasoning and variable hiding were extremely important. Reasoning about lower-level lower-level issues, e.g., lock implementations, atomicity of lock-protected code blocks, and correctness of blocks containing racy reads critical for performance was cleanly separated from reasoning about complex invariants and annotations involving the garbage collection algorithm assuming the atomicity of actions in an algorithm-level description of the GC.


Key contributions of this paper are 
\begin{itemize}
\item The design and verified refinement of a realistic concurrent garbage collector from a very high-level description (``skip'') down to individual memory accesses
\item A modular refinement proof system, tool, and intermediate verification language to support this effort
\item A sound proof system that combines reduction, abstraction, Owicki-Gries- and rely-guarantee-style reasoning for powerful refinement verification
\end{itemize}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 

