Building a practical verifier for concurrent programs remains a challenge. 
Concurrent systems software, in particular, is complex and difficult to verify. 
The verification of existing existing software starting from source code requires inferring the design intent and is even more difficult. 
Researchers have instead advocated a refinement approach in which a simple high-level description is refined, through several phases, down to an optimized, highly-concurrent implementation.
However, there is as yet no tool-supported method for refinement of realistic systems software down to an executable implementation.
In this paper, we present such a refinement method, and an intermediate language  and a verification tool (\civl) that support it.
We demonstrate our approach on a realistic concurrent garbage collection (GC) algorithm.
The high level specification for the GC consists of atomic action specifications for memory allocation and field accesses, and the garbage collector has a specification of ``skip.'' This description is refined down to a highly-concurrent implementation described in terms of individual memory accesses.

In our proof method, a program is described at several different levels of abstraction. 
All of these descriptions as well as the refinement relationships connecting them reside in the same \civl file, the input to our tool. 
Atomic actions in a high-level description are refined to more fine-grain, optimized lower-level implementations. An implementation of an atomic action may make use of additional variables which are hidden in the action's specification. 
Modular specifications and proof annotations such as program and location invariants and procedure pre- and post-conditions, are specified separately, independently at each level in terms of the variables visible at that level. For instance, in the GC, the top-level specifications and annotations reflect the client's view in terms of an idealized infinite heap and field relationships between objects, 
 whereas lower levels represent different views of the implementation, referring to, e.g., atomic updates of objects' colors or lock operations.
In addition to making it possible to verify specifications at the most abstract level possible, we find that such an approach is a natural way to design a program to be verified.  


The verification method, language, and tool design have all been carried out with the goal of supporting  modular refinement verification in a natural and computationally efficient manner. 
\civl integrates in a sound proof system three concurrent program verification techniques that collectively enable refinement verification. 
The first of these is a generalization of the Owicki-Gries method~\cite{OwickiG76} for non-preemptive concurrency, 
allowing arbitrary code to appear inside an atomic action. 
This simple but surprisingly powerful generalization allows us to compactly encode rely-guarantee reasoning~\cite{Jones83}
and to reuse non-interference specifications from one program location to another.
The second verification technique in \civl is an implementation of linear type checking.
Linear types~\cite{Wadler90lineartypes} and separation logic~\cite{Reynolds02} enable substructural reasoning about data types
(e.g. using separating conjunction or linear maps~\cite{LahiriQW11}).
Linear types can also be used to encode the notion of unique thread identifiers useful for reasoning about non-interference. 
The third technique in \civl is atomicity refinement through mover actions, reduction, abstraction, and variable hiding. 
Atomicity refinement allows reasoning coarser-grain atomic actions at higher levels of abstraction, and reduces the annotation burden and the computational cost of verification. 
The three techniques listed above have been investigated individually previously and are each best suited for proof tasks of a particular nature. 
The sound, symbiotic combination of the techniques in a proof system results in a powerful refinement tool. 

As a design driver for our proof system and tool, we developed a new concurrent GC. 
Design choices in our GC, an extension of the collector by Dijkstra et. al. \cite{dijk78}  with handshakes \cite{doli93,doli94} and repeated scans, were made with verified refinement and high performance in mind. 
Our GC supports a garbage collection thread running concurrently with multiple program threads (mutators) and its performance is competitive with well-known modern collectors. 
Popular collectors use a snapshot-based approach \cite{doli93,doli94,doma00,azat03} or contain phases and cards \cite{boeh91,prin00a,bara05}. These make the verification invariants more complex. In contrast, 
our collector satisfies the simple ``no-black-to-white'' invariant continuously throughout the execution. We intend to use our GC as part of a verified operating system. 

The verification of the collector spanned a large abstraction gap. For verifying refinement, symbiotic use of the verification techniques in \civl was crucial. Stable location invariants verified using rely-guarantee-style reasoning facilitated the verification of atomicity refinement. Replacing procedure bodies with atomic action specifications, combined with variable hiding, allowed the use of simpler location invariants and rely-guarantee annotations for higher-level versions of the program.
Using our refinement approach, lower-level implementation issues in the GC were cleanly separated from higher-level invariants and annotations involving the garbage collection algorithm. Lower-level representations were useful for reasoning about the atomicity of lock implementations, lock-protected field accesses and data structure operations. Higher-level versions focused on algorithmic issues such as verifying invariants involving phases, colors and object field relationships. This is the first automated verification of a practical, executable garbage collector from ``skip'' to an algorithmic description, and from there down to the implementation level.

Key contributions of this paper are 
\begin{itemize}
\item a modular and automated proof system to support refinement reasoning for concurrent program, and 
\item the design and verified refinement of a realistic concurrent GC algorithm, mechanically checked with our proof system, from a very high-level description (``skip'') down to individual memory accesses.
\end{itemize}

%To force commit

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 

