Building a practical verifier for concurrent programs remains a challenge. 
Concurrent systems software, in particular, is complex and difficult to verify. 
The verification of existing existing software starting from source code requires inferring the design intent and is even more difficult. 
Researchers have instead advocated a refinement approach in which a simple high-level description is refined, through several phases, down to an optimized, highly-concurrent implementation.
However, there is as yet no tool-supported method for refinement of realistic systems software down to an executable implementation.
In this paper, we present such a refinement method, and an intermediate language  and a verification tool (\civl) that support it.
We demonstrate our approach on a realistic concurrent garbage collection (GC) algorithm.
The high level specification for the GC consists of atomic action specifications for memory allocation and field accesses, and the garbage collector has a specification of ``skip.'' This description is refined down to a highly-concurrent implementation described in terms of individual memory accesses.

In our proof method, a program is described at several different levels of abstraction. 
All of these descriptions as well as the refinement relationships connecting them reside in the same \civl file, the input to our tool. 
Atomic actions in a high-level description are refined to more fine-grain, optimized lower-level implementations. An implementation of an atomic action may make use of additional variables which are hidden in the action's specification. 
Modular specifications and proof annotations such as program and location invariants and procedure pre- and post-conditions, are specified separately, independently at each level in terms of the variables visible at that level. For instance, in the GC, the top-level specifications and annotations reflect the client's view in terms of an idealized infinite heap and field relationships between objects, 
 whereas lower levels represent different views of the implementation, referring to, e.g., atomic updates of objects' colors or lock operations.
In addition to making it possible to verify specifications at the most abstract level possible, we find that such an approach is a natural way to design a program to be verified.  


The verification method, language, and tool design have all been carried out with the goal of supporting  modular refinement verification in a natural and computationally efficient manner. 
\civl integrates in a sound proof system three concurrent program verification techniques that collectively enable refinement verification. 
The first of these is a generalization of the Owicki-Gries method~\cite{OwickiG76} for non-preemptive concurrency, 
allowing arbitrary code to appear inside an atomic action. 
This simple but surprisingly powerful generalization allows us to compactly encode rely-guarantee reasoning~\cite{Jones83}
and to reuse non-interference specifications from one program location to another.
The second verification technique in \civl is an implementation of linear type checking.
Linear types~\cite{Wadler90lineartypes} and separation logic~\cite{Reynolds02} enable substructural reasoning about data types
(e.g. using separating conjunction or linear maps~\cite{LahiriQW11}).
Linear types can also be used to encode the notion of unique thread identifiers useful for reasoning about non-interference. 
The third technique in \civl is atomicity refinement through mover actions, reduction, abstraction, and variable hiding. 
Atomicity refinement allows reasoning coarser-grain atomic actions at higher levels of abstraction, and reduces the annotation burden and the computational cost of verification. 
The three techniques listed above have been investigated individually previously and are each best suited for proof tasks of a particular nature. 
The sound, symbiotic combination of the techniques in a proof system results in a powerful refinement tool. 

Key contributions of this paper are 
\begin{itemize}
\item a modular and automated proof system to support refinement reasoning for concurrent program, and 
\item the design and verified refinement of a realistic concurrent GC algorithm, mechanically checked with our proof system, from a very high-level description (``skip'') down to individual memory accesses.
\end{itemize}

%To force commit

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 

