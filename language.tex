
% no parantheses
% A, no parentheses
% par

\begin{figure}
\setlength{\tabcolsep}{3pt}
{\bf Program Syntax} \\
\begin{tabular}{rclcl}
$z$ & $\in$ & $\Globals$ & $\subseteq$ &$\Var$ \\
$w$ & $\in$ & $\Locals$ & $\subseteq$ & $\Var$ \\
$t$ & $\in$ & $\Type$ \\
$x,y$ & $\in$ & $\Var$ \\
$v$ &  $\in$ & $\Value$ \\
%$\joinLabel$ & $\in$ & $\JoinLabels$ \\
$e, \tau, \phi, \rho$ & $\in$ & $\StateExpr$ \\
$\alpha, \beta$ & $\in$ & $\TransExpr$ \\
$\locExpr$ & $\in$ & $\LExpr$ \\
$P$ & $\in$ & $\ProcName$ \\
$P_{A}$ & $\in$ & $\AtomicProcName$ & $\subseteq$ & $\ProcName$ \\
$A$ & $\in$ & $\AtomName$ \\
\end{tabular}\\
\begin{tabular}{rclcl}
$\specs \in \Spec$ & = & $\AtomName \rightarrow \TransExpr$ \\
$\bodies \in \Body$ & = & $\ProcName \rightarrow \Stmt$ \\
$\procSpecs \in \ProcSpec$ & = & $\ProcName \rightarrow (\Locals,\StateExpr,\StateExpr)$\\
$\procRefSpecs \in \ProcRefSpec$ & = & $\AtomicProcName \rightarrow (\moverType,\StateExpr,\TransExpr)$
%$\atomicAction$ & $\in$ & $\AtomicAction$ & ::= & $(\tau, \alpha)\ $ \\
%$\alpha$ & $\in$ & $\GatedAction$ & ::= & $\phi\ \rhd\ \tau$ \\ % Goes away
% $\proc \in \Proc$&::= & $P\ \mathit{modifies}\ \vec{w}\ 
%                                                         \mathit{requires}\ \phi\
%                                                         \mathit{ensures}\ \beta\ \mid $\\
%                      & ::= & $P_{A}\ \mathit{modifies}\ \vec{w}\ 
%                      \mathit{requires}\ \phi\ $\\
% & &                     $\hspace*{0.8cm} \mathit{ensures}\ \beta\
%                      \mathit{refines}\ (m, \tau, \alpha)$\\
\end{tabular}
\begin{tabular}{rclcl}
$\Prog \in \Program$ & ::= & $\varsG, \specs, \bodies, \TS$ \\
$T \in \Thread$ & ::=  & $\varsL, \stmt$ \\
$\Vinfo$ & ::= & $x:t=v$ \\
$\varsG,\varsL,\vars$ & $\in$ & $\Vstore$ & ::= & $\Vinfos$ \\
\end{tabular}
\begin{tabular}{rclcl}
$m \in \moverType$ &::= &$\mathit{non} \mid \mathit{left} \mid \mathit{right} \mid \mathit{both}$ \\
$r \in \refType$ &::= &$\mathit{pre} \mid \mathit{act} \mid \mathit{post} $ \\
$\stmt \in \Stmt$ &::= & $\skipstmt \mid w := \locExpr \mid
\assert{le} \mid $ \\
                  & & $\call{A} \mid \call{r}{P} \mid \async{P} \mid $\\
                  & & $s;\;s \mid \yield{e} \mid \ablock{e}{s}{r} \mid$\\
                 & & $\ite{\locExpr}{s}{s} \mid$ \\
                  & & $\while{e}{\locExpr}{s} \mid \termwhile{e}{\locExpr}{s}$
                  \\ 
\end{tabular}\\
\begin{tabular}{rclcl}
$\YieldingStmt \in \mathit{YieldingStmt}$ &::= &$\yield{e} \mid \YieldingStmt;s$ \\
$\YieldingThread \in \mathit{YieldingThread}$ &::= &$\varsL, \YieldingStmt$ \\
$\StmtCtxt \in \mathit{StmtCtxt}$ &::= &$[]_{Stmt} \mid \StmtCtxt;s$ \\
$\ThreadCtxt \in \mathit{ThreadCtxt}$ &::= &$[]_{Locals}, \StmtCtxt$ \\
$\ProgCtxt \in \mathit{ProgCtxt}$ &::= &$\YieldingThreads \cdot \ThreadCtxt \cdot \YieldingThreads$ \\
\end{tabular}\\
\setlength{\tabcolsep}{6pt}
\caption{Syntax}
\label{fig:syntax}
\end{figure}

For procedures, we informally write $P\ \mathit{modifies}\
\vec{w}\ \mathit{requires}\ \rho\ \mathit{ensures}\ \phi\ $
if $\procSpecs(P) = (\vec{w}, \phi, \tau)$. Similarly, for
abstract-atomic procedures, we write $P_{A}\ \mathit{modifies}\
\vec{w}\ \mathit{requires}\ \rho\ \mathit{ensures}\ \phi\
\mathit{refines}\ (m, \tau, \alpha)$ if $\procSpecs(P) =
(\vec{w}, \rho, \phi)$ and $\procRefSpecs(P) = (m, \tau,
\alpha)$. 

\begin{figure}
\scriptsize{
$
\hspace{5cm}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\bodies;\specs \vdash (\varsG \cdot \varsL, s) \trans (\varsG' \cdot \varsL', s')
}
{\bodies;\specs \vdash (\varsG, \ProgCtxt[\varsL][s]) \trans (\varsG', \ProgCtxt[\varsL'][s'])}
\;(\textsc{Program-Step})
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\bodies;\specs \vdash (\varsG \cdot \varsL, s) \fails
}
{\bodies;\specs \vdash (\varsG, \ProgCtxt[\varsL][s]) \fails}
\;(\textsc{Program-Fail})
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
T' = (\varsL, \bodies(P))
}
{\bodies;\specs \vdash (\varsG, \ProgCtxt[\varsL][\async{P}]) \trans (\varsG, \ProgCtxt[\varsL][\skipstmt] \cdot T')}
\;(\textsc{Async})
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\\
}
{\bodies;\specs \vdash (\varsG, \YieldingThreads \cdot (\varsL, \skipstmt) \cdot \YieldingThreads') \trans (\varsG, \YieldingThreads \cdot \YieldingThreads')}
\;(\textsc{Thread-End})
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\\
}
{\bodies;\specs \vdash (\vars, \skipstmt;\stmt) \trans (\vars, \stmt)}
\;{(\textsc{Skip})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
w:t=v \in \varsL \\
\varsG \cdot \varsL \vdash \locExpr \rightarrow v'
}
{\bodies;\specs \vdash (\varsG \cdot \varsL, w := \locExpr) \trans (\varsG \cdot \varsL[w := v'], \skipstmt)}
\;{(\textsc{Assignment})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\vars \vdash \locExpr \rightarrow \mathit{true}
}
{\bodies;\specs \vdash (\vars, \assert{\locExpr}) \trans (\vars, \skipstmt)}
\;{(\textsc{Assert-True})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\vars \vdash \locExpr \rightarrow \mathit{false}
}
{\bodies;\specs \vdash (\vars, \assert{\locExpr}) \fails}
\;{(\textsc{Assert-False})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\specs(A) = \alpha\ \\
(\varsG \cdot \varsL, \varsG' \cdot \varsL') \vdash \alpha \\
}
{
\bodies;\specs \vdash (\varsG \cdot \varsL, \call{A}) \trans (\varsG' \cdot \varsL',\skipstmt)
}
\;{(\textsc{Atomic})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
}
{\bodies;\specs \vdash (\vars, \call{r}{P}) \trans (\vars, \bodies(P))}
\;{(\textsc{Call})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\\
}
{\bodies;\specs \vdash (\vars, \yield{e}) \trans (\vars, \skipstmt)}
\;{(\textsc{Yield})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\\
}
{\bodies;\specs \vdash (\vars, \ablock{e}{\stmt}{r}) \trans (\vars, \stmt)}
\;{(\textsc{AtomicBlock})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\vars \vdash \locExpr \rightarrow \mathit{true}
}
{\bodies;\specs \vdash (\vars, \ite{\locExpr}{s_1}{s_2}) \trans (\vars, s_1)}
\;{(\textsc{If-True})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\vars \vdash \locExpr \rightarrow \mathit{false}
}
{\bodies;\specs \vdash (\vars, \ite{\locExpr}{s_1}{s_2}) \trans (\vars, s_2)}
\;{(\textsc{If-False})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\vars \vdash \locExpr \rightarrow \mathit{false}
}
{\bodies;\specs \vdash (\vars, \while{e}{\locExpr}{s}) \trans (\vars, \skipstmt)}
\;{(\textsc{While-False})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\vars \vdash \locExpr \rightarrow \mathit{true}
}
{\bodies;\specs \vdash (\vars, \while{e}{\locExpr}{s}) \trans (\vars, s;\while{e}{\locExpr}{s})}
\;{(\textsc{While-True})}
$
%%%%%%%%%%%%%%%%%%%%
}
{{\bf \\ twhile rules here??}}
\caption{Operational semantics}
\label{fig:operational-semantics}
\end{figure}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 


