\begin{figure}
\setlength{\tabcolsep}{3pt}
\begin{tabular}{rclcl}
$g$ & $\in$ & $\Global \subseteq \VarName$ \\
$\tl$ & $\in$ & $\ThreadLocal \subseteq \VarName$ \\
$l$ & $\in$ & $\Local \subseteq \VarName$ \\
$x,y$ & $\in$ & $\Var = \Global \cup \ThreadLocal \cup \Local$ \\
$v$ &  $\in$ & $\Value$ \\
$\sigma$ & $\in$ & $\Store = \Var \rightarrow \Value$ \\
$\varsG$ & $\in$ & $\StoreGlobal = \Global \rightarrow \Value$ \\
$\varsTL$ & $\in$ & $\StoreThreadLocal = \ThreadLocal  \rightarrow \Value$ \\
$\varsL$ & $\in$ & $\StoreLocal = \Local \rightarrow \Value$ \\
$e, \phi, \psi, \rho$ & $\in$ & $\StateExpr = 2^{\Store}$ \\
$\alpha, \beta$ & $\in$ & $\TransExpr = 2^{(\Store,\Store)}$ \\
$\locExpr$ & $\in$ & $\LocalStateExpr = 2^{\StoreLocal}$ \\
$P$ & $\in$ & $\ProcName$ \\
$A$ & $\in$ & $\ActionName$ \\
$m$ & $\in$ & $\Mover = \{B,R,L,N\}$\\
$\actions$ & $\in$ & $\ActionName \rightarrow (\StateExpr, \TransExpr, \Mover)$ \\
$\procs$ & $\in$ & $\ProcName \rightarrow (\StateExpr, 2^\ThreadLocal, \StateExpr, \Stmt)$ \\
$\lins$ & $\in$ & $\LinearVar = 2^{\Global \cup \ThreadLocal}$ \\
$\ProcLins$ & $\in$ & $(\ActionName \cup \ProcName) \rightarrow (\LinearVar, \LinearVar)$ \\
$\ABlockAny$ & $\in$ & $\mathit{InsideABlock} ::= \ABlockInside \mid \ABlockOutside$ \\
$\RefinementAny$ & $\in$ & $\mathit{InsideRefinement} ::= \RefinementInside \mid \RefinementOutside$ \\
$\Refines$ & $\in$ & $\ProcName \pf \ActionName$ \\
$\RemovedActions$ & $\in$ & $2^\ActionName$ 
\end{tabular}
\caption{Definitions}
\label{fig:definitions}
\end{figure}

\begin{figure}
\setlength{\tabcolsep}{3pt}
\begin{tabular}{rclcl}
$\stmt \in \Stmt$ &::= & $\skipstmt \mid \assert{\locExpr} \mid \yield{e,\lins} \mid$ \\
                  & & $\call{A} \mid \call{P} \mid \async{P} \mid $\\
                  & & $\ablock{e,\lins}{s} \mid s;\;s \mid$\\
                  & & $\ite{\locExpr}{s}{s} \mid$ \\
                  & & $\while{e,\alpha}{\locExpr}{s}$ \\ 
$\StmtStack \in \mathit{StmtStack}$ &::= & $\stmt \mid (\varsL,\StmtStack) \mid \StmtStack;\stmt$ \\
$T \in \mathit{Thread}$ &::= &$(\varsTL, (\varsL, \StmtStack))$ \\
$\Prog \in \Program$ &::= & $\ProgCtxt[\varsG][\varsTL][\varsL][\stmt]$ \\
~\\
$\StmtCtxt \in \mathit{StmtCtxt}$ &::= &$[]_{Stmt} \mid \StmtCtxt;\stmt$ \\
$\StmtStackCtxt \in \mathit{StmtStackCtxt}$ &::= & $([]_{\Local}, \StmtCtxt) \mid (L,\StmtStackCtxt) \mid \StmtStackCtxt;\stmt$ \\
$\ThreadCtxt \in \mathit{ThreadCtxt}$ &::= &$([]_{\ThreadLocal}, ([]_{\Local}, \StmtCtxt)) \mid$ \\
 & &$([]_{\ThreadLocal}, (\varsL, \StmtStackCtxt))$ \\
$\YieldingThread \in \mathit{YieldingThread}$ &::= &$\ThreadCtxt[\varsTL][\varsL][\yield{e,\lins}]$ \\
$\ProgCtxt \in \mathit{ProgCtxt}$ &::= & $(\procs, \actions, \ProcLins, []_{\Global}, \YieldingThreads \cdot \ThreadCtxt \cdot \YieldingThreads)$
\end{tabular}
\caption{Syntax}
\label{fig:syntax}
\end{figure}

\begin{figure}
\scriptsize{
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\ProgCtxt[\varsG][\varsTL][\varsL][s] = (\_, \actions, \_, \_, \_) \\
\actions \vdash (\MakeStore{\varsG}{\varsTL}{\varsL}, s) \trans (\MakeStore{\varsG'}{\varsTL'}{\varsL'}, s')
}
{\ProgCtxt[\varsG][\varsTL][\varsL][s] \trans \ProgCtxt[\varsG'][\varsTL'][\varsL'][s']}
\;(\textsc{Step})
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\ProgCtxt[\varsG][\varsTL][\varsL][s] = (\_, \actions, \_, \_, \_) \\
\actions \vdash (\MakeStore{\varsG}{\varsTL}{\varsL}, s) \fails
}
{\ProgCtxt[\varsG][\varsTL][\varsL][s]) \fails}
\;(\textsc{Fail})
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\procs(P) = (\phi, \mods, \psi,\stmt) \\
\ProcLins(P) = (\lins, \lins') \\
T' = (\varsTL, (\varsL, \yield{\phi,\lins};\stmt)) \\
\TS = \ThreadCtxt[\varsTL][\varsL][\async{P}] \\
\TS' = \ThreadCtxt[\varsTL][\varsL][\skipstmt]
}
{
(\procs, \actions, \ProcLins, \varsG, \TS)
\trans
(\procs, \actions, \ProcLins, \varsG, \TS' \cdot T')
}
\;(\textsc{Async})
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
T = (\varsTL, (\varsL,\skipstmt)) 
}
{(\procs, \actions, \ProcLins, \varsG, \YieldingThreads \cdot T \cdot \YieldingThreads') \trans (\procs, \actions, \ProcLins, \varsG, \YieldingThreads \cdot \YieldingThreads')}
\;(\textsc{End})
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\procs(P) = (\phi, \mods, \psi,\stmt) \\
\ProcLins(P) = (\lins, \lins') \\
\StmtStack = \yield{\phi,\lins};\stmt;\yield{\psi,\lins'}
}
{\ProgCtxt[\varsG][\varsTL][\varsL][\call{P}] \trans \ProgCtxt[\varsG][\varsTL][\varsL][\Frame{L}{\StmtStack}]}
\;{(\textsc{Call})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\\
}
{\ProgCtxt[\varsG][\varsTL][\varsL][\Frame{\varsL'}{\skipstmt}] \trans \ProgCtxt[\varsG][\varsTL][\varsL][\skipstmt]}
\;{(\textsc{Return})}
$
%%%%%%%%%%%%%%%%%%%%
}
\caption{Operational semantics for program}
\label{fig:operational-semantics1}
\end{figure}


\begin{figure}
\scriptsize{
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\vars = \MakeStore{\varsG}{\varsTL}{\varsL} \\
\varsL \in \locExpr
}
{\actions \vdash (\vars, \assert{\locExpr}) \trans (\vars, \skipstmt)}
\;{(\textsc{Assert-True})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\vars = \MakeStore{\varsG}{\varsTL}{\varsL} \\
\varsL \not \in \locExpr
}
{\actions \vdash (\vars, \assert{\locExpr}) \fails}
\;{(\textsc{Assert-False})}
$
\medskip
~\\
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\actions(A) = (\rho, \alpha, m) \\
(\vars, \vars') \in \alpha \\
}
{
\actions \vdash (\vars, \call{A}) \trans (\vars',\skipstmt)
}
\;{(\textsc{Atomic})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\\
}
{\actions \vdash (\vars, \yield{e,\lins}) \trans (\vars, \skipstmt)}
\;{(\textsc{Yield})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
}
{\actions \vdash (\vars, \ablock{e,\lins}{\stmt}) \trans (\vars, \stmt)}
\;{(\textsc{AtomicBlock})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\\
}
{\actions \vdash (\vars, \skipstmt;\stmt) \trans (\vars, \stmt)}
\;{\;\;\;\;\;\;\;\;\;\;\;\;(\textsc{Seq})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\vars = \MakeStore{\varsG}{\varsTL}{\varsL} \\
\varsL \not\in \locExpr
}
{\actions \vdash (\vars, \ite{\locExpr}{s_1}{s_2}) \trans (\vars, s_2)}
\;{(\textsc{If-False})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\vars = \MakeStore{\varsG}{\varsTL}{\varsL} \\
\varsL \in \locExpr
}
{\actions \vdash (\vars, \ite{\locExpr}{s_1}{s_2}) \trans (\vars, s_1)}
\;{(\textsc{If-True})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\vars = \MakeStore{\varsG}{\varsTL}{\varsL} \\
\varsL \not\in \locExpr \\
}
{\actions \vdash (\vars, \while{e,\alpha}{\locExpr}{s}) \trans (\vars, \skipstmt)}
\;{(\textsc{While-False})}
$
\medskip
%%%%%%%%%%%%%%%%%%%%
$
\inferrule
{
\vars = \MakeStore{\varsG}{\varsTL}{\varsL} \\
\varsL \in \locExpr \\
\stmt' = \while{e,\alpha}{\locExpr}{\stmt}
}
{\actions \vdash (\vars, \stmt') \trans (\vars, \stmt;\stmt')}
\;{(\textsc{While-True})}
$
%%%%%%%%%%%%%%%%%%%%
}
\caption{Operational semantics for statement}
\label{fig:operational-semantics2}
\end{figure}

In this paper, we will formalize our verification method on a core concurrent programming language \civl.
In this section, we present the syntax and operational semantics of our language.
Figure~\ref{fig:definitions} contains basic definitions; 
Figure~\ref{fig:syntax} uses these definitions to define the syntax of a (dynamically executing) \civl program;
Figures~\ref{fig:operational-semantics1} and~\ref{fig:operational-semantics2} provide the formal rules according 
to which a \civl program evolves.

Informally, a \civl program is comprised of threads each of which has a stack, global variables shared across threads, 
thread-local variables that are shared across procedures, and local variables inside a procedure.
The sets $\Global$, $\ThreadLocal$, and $\Local$ are the names of global, thread-local, and procedure-local variables 
respectively.
These sets are mutually disjoint and $\Var$ denotes their union.
There is an uninterpreted set $\Value$ of values that may be stored in these variables.
$\Store$, $\StoreGlobal$, $\StoreThreadLocal$, and $\StoreLocal$ are the set of all maps into $\Value$
from $\Var$, $\Global$, $\ThreadLocal$, and $\Local$ respectively.
We denote elements of $\Store$, $\StoreGlobal$, $\StoreThreadLocal$, and $\StoreLocal$
by $\sigma$, $\varsG$, $\varsTL$, and $\varsL$ respectively.

Formally, a \civl program is a tuple $(\procs, \actions, \ProcLins, G, \TS)$ with the following components:
\begin{itemize}
\item 
$\procs$ maps a procedure name $P \in \ProcName$ to a tuple $(\phi, \mods, \psi, \stmt)$, 
where $\phi$ is the precondition of $P$, $\mods$ is the set of thread-local variables potentially modified by $P$, 
$\psi$ is the postcondition of $P$, and $\stmt$ is the body of $P$.
The predicates $\phi$ and $\psi$ should not refer to procedure-local variables.
Procedures do not have parameters; however, parameters may be modeled using thread-local variables.
\item
$\actions$ maps an action name $A \in \ActionName$ to a tuple $(\rho,\alpha,m)$.
Actions are used inside procedure bodies to access variables.
The predicate $\rho$ is the precondition and the predicate $\alpha$ is the transition relation of $A$;
$\rho$ is a predicate over $\Store$ and $\alpha$ is a predicate over $\Store \times \Store$.
The final component $m$ is one of four values in $\{B,R,L,N\}$;
it denotes the commutativity type of the action, $B$ for both mover, $R$ for right mover, $L$ for left mover, 
and $N$ for non mover. 
\item
$\ProcLins$ maps each procdure and action name in $\ProcName \cup \ActionName$ to a linear interface 
$(\lins,\lins')$, where each of $\lins$ and $\lins'$ is a set comprising global and thread-local variables.
The procedure (or action) requires that the set $\lins$ be available at the beginning of its invocation 
and makes available the set $\lins'$ at the end of its invocation.
\item
$\TS$ is a sequence of threads.
Each thread $T$ in $\TS$ is a pair $(\varsTL, (\varsL, \StmtStack))$, where $\varsTL$ and $(\varsL, \StmtStack)$ 
are the thread-local variables and stack of $T$.
\end{itemize}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 


