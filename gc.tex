We have chosen to demonstrate the proposed verification methodology and tool on a realistic modern concurrent garbage collector. To this end, we designed a garbage collector that extends the concurrent collector of Dijkstra et. al. \cite{dijk78}. The goal in this design is to build a collector that is on one hand easy to verify and on the other hand highly performant in practice. Most modern concurrent collectors are snapshot-oriented  \cite{doli93,doli94,doma00,azat03}, and as such may require complex claims on snapshot times and reachability. Other popular concurrent collectors and in particular the {\em mostly concurrent} garbage collector \cite{boeh91,prin00a,bara05} consist of different complex phases and complex interaction between objects that reside on specific {\em cards}. We preferred a collector whose invariants are simple and hold continuously as much as possible throughout the execution. This means that a program execution can move from one thread to another and then to the garbage collector while all relevant invariants continue to hold at all times. 

Dijkstra's collector seems to be a good candidate, but it cannot be considered a modern or performant collector. On the positive side, its write-barrier maintains simple invariants continuously. However, this collector becomes incorrect in the presence of more than one program thread (mutator), which is unacceptable for use with modern multicore platforms. Furthermore, it requires that the write-barrier will run with both heap pointers and root pointers, i.e., on any modification of the runtime stacks and the registers. This requirement implies bad performance, and modern concurrent garbage collectors avoid such a requirement so that they may obtain good performance. 

We therefore extended and modified Dijkstra's collector to make it work with parallel programs and also not require applying any write-barrier on root modifications. As far as we know, the obtained garbage collector algorithm has not been previously proposes or implemented. Let us shortly recall Dijkstra's collector, and then explain how we modified it to eliminate its shortcomings.  

The analysis of Dijkstra's collector employs a tri-color abstraction to describe the trace of the objects reachable from the roots. Objects are said to be {\em white} if the collector has not seen them yet during the trace. This means that unreachable objects (that are never encountered during the trace) remain white throughout the trace. Objects that the collector encounters become gray and remain gray until the collector scans their children. Once all the children of an object are noted (meaning that none of them are white), the object becomes black. The collector works by choosing a gray node, {\em shading} all it's children, and making it black. The shading operation grays a node if it is white, and does noting otherwise. The trace initiates by making all objects white and then shading all objects reachable from the roots. The trace terminates when there are no more gray objects in the heap. Termination is guaranteed because objects can only get darker. Correctness is guaranteed using the invariant that there cannot be a black to white pointer during the trace. At the end of the trace, objects pointed by the roots must be black and since black objects can only point to black objects (there are no gray objects at the end and no black to white pointers), then the entire set of objects reachable from the roots must be black.

In the presence of concurrent program operations, the no-black-to-white invariant does not hold, because the program may simply redirect a pointer of a black object to point to a white object. Therefore, a coordination between the program and the concurrent collector is required and this coordination takes place in the form of a {\em write-barrier}. A write-barrier is a piece of code that executes with each pointer update, and Dijkstra's write-barrier lets the program shades the new target of a pointer modification.  When a pointer field $p$ is set to reference an object $B$, the write barrier starts by assigning the address of $B$ to $p$ and then it shades $B$. A major complication comes from the fact that the pointer change and the shading operations do not occur as a single atomic unit, but there is a point in between the two in which the no black-to-white pointers invariant is not preserved. Dijkstra et. al. show that the algorithm is still correct, but only a single program thread. If there are two concurrent program threads, the proof not only fails, but the algorithm actually becomes incorrect. 

We start with achieving multithreading and later we will also explain how to get rid of the need to use a write-barrier when modifying the root pointers. We modify Dijkstra's write-barrier by reversing the order of the two actions. First, shade the target object $B$ and only then execute the assignment of $B$'s address to the pointer $p$. As noted by Doligez et. al. \cite{doli93,doli94} this requires a {\em handshake} between all program threads and the collector before a new collection initiates. A handshake is initiated by the collector by raising a collector flag that the program threads check occasionally. When a program thread discovers that a handshake is required to start a collection, it raises its own thread flag to indicate that it has noted the handshake flag and that it is not in the middle of a write operation. When the collector finds that all program threads have responded the handshake is done and a collection may start. We use the same handshaking mechanism, but unlike \cite{doli93,doli94}, we shade the target of the pointer $B$. (Most previous  concurrent collectors shaded the object that lost a pointer in the operation in order to obtain a snapshot-like tracing behavior). The shading of the target pointer does not make a difference for
correctness if we use the write-barrier when modifying root pointers, but next we would like to explain how we avoid the need of using the write-barrier on pointer modifications of the roots. 

If we do not use a write-barrier with the roots, it is possible that the roots point to objects that have not been traced, i.e., white objects. This foils the correctness, because it is no longer the case that all objects referenced by the roots are black (and all their descendants are black as well). However, we still know that there are no gray objects at the end of the trace and that there are never black-to-white pointers throughout the trace. So if we could get all roots to reference black objects we would obtain a correct tracing of the heap. To this end, we modify the algorithm to test the roots at the end of the concurrent trace. If all roots point to black objects, then we are done. Otherwise, we continue the collection by shading all objects reachable by the roots and tracing from them again. 
In a worst-case theoretical scenario we may need to run many root scans and discover more and more white descendants to trace each time. 
But in practice we usually finish after the first or second traversal, and we seldom need more than that. So we obtain correctness and termination in all scenarios and we obtain good performance in real-world scenarios. 







