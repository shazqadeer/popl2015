%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                              %
%              %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                 %
%              %                                             %                 %
%              %        GARBAGE COLLECTION BIBLIOGRAPHY      %                 %
%              %                                             %                 %
%              %        (c) 1996-2014, Richard E. Jones      %                 %
%              %                                             %                 %
%              %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                 %
%                                                                              %
%                                                                              %
% This bibliography may be freely used for non-commercial purposes.            %
% It may also be freely distributed provided that this notice is included.     %
% The bibliography is available in BibTeX, PDF and HTML forms from             %
%       http://www.cs.ukc.ac.uk/people/staff/rej/gcbib/gcbib.html              %
% I would be most grateful to receive additions, corrections and URLs of       %
% electronically available papers.                                             %
%                                                                              %
% Richard Jones                                                                %
%                                                                              %
% Computing Laboratory                                                         %
% University of Kent at Canterbury          Telephone: 01227 764000 ext.7943   %
% Canterbury,                                          01227 827943 (direct)   %
% CT2 7NF, U.K.                                   FAX: 01227 762811            %
%                                                                              %
% http://www.cs.kent.ac.uk/~rej                                                %
%                                                                              %
% Copyright Richard Jones 1996-2014                                            %
%                                                                              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




% JOURNAL ABBREVIATIONS

@string{ActInf = "Acta Informatica"}
@string{CACM = "Communications of the {ACM}"}
@string{CompJ = "Computer Journal"}
@string{CPE = "Concurrency and Computation: Practice and Experience"},
@string{Dobbs = "Dr. Dobb's Journal"}
@string{IPL = "Information Processing Letters"}
@string{IEEETransComp = "IEEE Transactions on Computers"}
@string{IEEETransSWE = "IEEE Transactions on Software Engineering"}
@string{ISJ = "{IBM} Systems Journal"}
@string{JACM = "Journal of the ACM"}
@string{JFP = "Journal of Functional Programming"}
@string{JSS = "Journal of Systems and Software"}
@string{LNCS = "Lecture Notes in Computer Science"}
@string{LSC = "Lisp and Symbolic Computation"}
@string{SPE = "Software: Practice and Experience"}
@string{SIGPLAN = "ACM SIGPLAN Notices"}
@string{SIGARCH = "ACM SIGARCH Computer Architecture News"}
@string{SIGOPS = "ACM SIGOPS Operating Systems Review"}
@string{TACO = "ACM Transactions on Architecture and Code Optimization"}
@string{TECS = "ACM Transactions on Embedded Computer Systems"}
@string{TOPLAS = "ACM Transactions on Programming Languages and Systems"}
@string{TPDS = "IEEE Transactions on Parallel and Distributed Systems"}
@string{TransCompSys = "ACM Transactions on Computer Systems"}
@string{TransSWE = "ACM Transactions on Software Engineering"}

% PUBLISHER + ADDRESS ABBREVIATIONS

@string{ACM = "ACM Press"}
@string{AP = "Academic Press"}
@string{AW = "Addison-Wesley"}
@string{BCS = "British Computer Society"}
@string{CUP = "Cambridge University Press"}
@string{ENH = "Elsevier-North Holland"}
@string{ES = "Elsevier Science Publishers"}
@string{IBM = "IBM Corp."}
@string{IEEE = "IEEE Press"}
@string{IEEEcomp = "IEEE Computer Society Press"}
@string{Kluwer = "Kluwer"}
@string{PH = "Prentice-Hall"}
@string{MGH = "McGraw-Hill"}
@string{MK = "Morgan Kaufman"}
@string{NH = "North Holland"}
@string{MIT = "MIT Press"}
@string{SV = "Springer-Verlag"}
@string{UA = "USENIX Association"}
@string{Wiley = "Wiley"}
@string{WSP = "World Scientific Publishing"}


% INSTITUTION ABBREVIATIONS

@string{CMU = "Carnegie Mellon University"}
@string{Cornell = "Cornell University"}
@string{DECSRC = "DEC Systems Research Center, Palo Alto, CA"}
@string{DECWRL = "DEC Western Research Laboratory, Palo Alto, CA"}
@string{DIKU = "Department of Computer Science (DIKU), University of Copenhagen"}
@string{INRIA = "Institut National de la Recherche en Informatique et Automatique (INRIA)"}
@string{Lund = "Lund University, Sweden"}
@string{MITAI = "MIT AI Laboratory"}
@string{MITLCS = "MIT Laboratory for Computer Science"}
@string{PARC = "Xerox PARC, Palo Alto, CA"}
@string{Princeton = "Department of Computer Science, Princeton University"}
@string{Purdue = "Purdue University"}
@string{Rice = "Rice University"}
@string{UCB = "University of California, Berkeley"}
@string{UKC = "Computing Laboratory, The University of Kent at Canterbury"}
@string{UoK = "Computing Laboratory, University of Kent"}
@string{UCSC = "University of California, Santa Cruz"}
@string{UMass = "University of Massachusetts"}

% CONFERENCE ABBREVIATIONS
@string{ASPLOS = "International Conference on Architectural Support for Programming Languages and Operating Systems"}
@string{CC = "International Conference on Compiler Construction"}
@String{CGO = {International Symposium on Code Generation and Optimization (CGO)}}
@string{ECOOP = "European Conference on Object-Oriented Programming"}
@string{FPCA = "Conference on Functional Programming and Computer Architecture"}
@String{ESOP = {European Symposium on Programming}}
@string{GWFP = "Glasgow Workshop on Functional Programming"}
@string{ICFP = "ACM SIGPLAN International Conference on Functional Programming"}
@string{ICLP = "International Conference on Logic Programming"}
@string{ISCA = "International Symposium on Computer Architecture"}
@string{ISMM = "International Symposium on Memory Management"}
@string{ISORC = "International Symposium on Object-Oriented Real-Time Distributed Computing"}
@string{IWMM = "International Workshop on Memory Management"}
@string{IWOOS = "International Workshop on Object Orientation in Operating Systems"}
@string{JTRES = "International Workshop on Java Technologies for Real-time and Embedded Systems"}
@string{JVM = "Java Virtual Machine Research and Technology Symposium"}
@string{LCPC = "Workshop on Languages and Compilers for Parallel Computing"}
@string{LCTES = "ACM SIGPLAN/SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems"}
@string{LFP = "ACM Conference on LISP and Functional Programming"}
@String{MSP = {Workshop on Memory System Performance}}
@String{MSPC = {Workshop on Memory System Performance and Correctness}}
@string{OOPSLA = "ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications"}
@string{PARLE = "Parallel Architectures and Languages Europe (PARLE)"}
@String{PASTE = {ACM SIGPLAN-SIGSOFT Workshop on Program Analysis for Software Tools and Engineering (PASTE)}}
@string{PLDI = "ACM SIGPLAN Conference on Programming Language Design and Implementation"}
@string{POPL = "ACM Symposium on Principles of Programming Languages"}
@string{POS = "International Workshop on Persistent Object Systems"}
@string{PPoPP = "ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming"}
@string{PPPJ = "ACM International Symposium on Principles and Practice of Programming in Java"}
@string{RTCSA = "International Conference on Embedded and Real-Time Computing Systems and Applications (RTCSA)"}
@string{RTCSAW = "International Workshop on Real-Time Computing Systems and Applications (RTCSA)"}
@string{SPACE = "Workshop on Semantics, Program Analysis, and Computing Environments for Memory Management (SPACE)"}
@string{SIGMETRICS = "ACM SIGMETRICS International Conference on Measurement and Modeling of Computer Systems"}
@string{SIGMOD = "ACM SIGMOD International Conference on Management of Data"}
@string{SOSP = "ACM Symposium on Operating Systems Principles"}
@string{TLDI = "ACM SIGPLAN International Workshop on Types in Language Design and Implementation"}
@string{VEE = "ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments"}
@string{WGCOOS = "Workshop on Garbage Collection in Object-Oriented Systems"}

% REFERENCES

@inproceedings{abdu92,
title = {Distributed Garbage Collection},
author = "Saleh E. Abdullahi and Eliot E. Miranda and Graem A. Ringwood",
crossref = "IWMM92",
pages = {43--81},
doi = {10.1007/BFb0017181},
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/dgcsurvey.ps",
}

@inproceedings{abdu92a,
author = "Saleh E. Abdullah",
title = {Managing Computer Memory: Dynamic Allocation and Deallocation Strategies},
booktitle = {2nd Conference on Information Technology and its Applications},
address = {Leicester},
month = dec,
pages = {25--40},
year = 1992
}

@article{abdu93,
author = "Saleh E. Abdullah and E.J.A. Edemenang",
title = {A Comparative Study of Dynamic Memory Management Techniques},
journal = {Advances in Modelling and Analysis},
volume = 15,
number = 2,
publisher = {ASME Press},
pages = {17-31},
year = 1993
}

@inproceedings{abdu94,
author = "Saleh E. Abdullah",
title = {Recycling Garbage},
booktitle = {3rd Conference on Information Technology and its Applications},
address = {Leicester},
month = apr,
pages = {192--197},
year = 1994
}

@phdthesis{abdu95,
author = {Saleh E. Abdullahi},
title = {Empirical Studies of Distributed Garbage Collection},
school = {Queen Mary and Westfield College},
URL = {http://www.dcs.qmw.ac.uk/~gar/yakubu.thesis.ps.gz},
month = dec,
year = 1995
}

@techreport{abdu96,
author = {Saleh E. Abdullahi and Graem A. Ringwood},
title = {Empirical Studies of Distributed Garbage Collection: Parts I, II and III},
institution = {Queen Mary and Westfield College, University of London},
year = 1996
}

@techreport{abdu96a,
title = {Garbage collecting the {I}nternet},
author = {Saleh E. Abdullahi and Graem A. Ringwood},
institution = {Queen Mary and Westfield College, University of London},
year = {1996?},
note = {Draft version of \cite{abdu98}}
}

@article{abdu98,
  title =	 {Garbage Collecting the {I}nternet: a Survey of Distributed
                  Garbage Collection},
  author =	 {Saleh E. Abdullahi and Graem A. Ringwood},
  journal =	 {ACM Computing Surveys},
  volume =	 30,
  number =	 3,
  month =	 sep,
  pages =	 {330--373},
  year =	 1998,
  doi =		 {10.1145/292469.292471},
  abstract =	 {Internet programming languages such as Java present new
                  challenges to garbage-collection design. The spectrum of
                  garbage-collection schema for linked structures distributed
                  over a network are reviewed here. Distributed garbage
                  collectors are classified first because they evolved from
                  single-address-space collectors. This taxonomy is used as a
                  framework to explore distribution issues: locality of
                  action, communication overhead and indeterministic
                  communication latency.}
}

@book{abel96,
  title =	 {Structure and Interpretation of Computer Programs},
  booktitle =	 {Structure and Interpretation of Computer Programs},
  author =	 {Harold Abelson and Gerald Jay Sussman and Julie Sussman},
  year =	 1996,
  publisher =	 MIT,
  edition =	 {Second}
}

@inproceedings{abra87,
author = "Santosh Abraham and J. Patel",
title = "Parallel Garbage Collection on a Virtual Memory System",
booktitle = "International Conference on Parallel Processing",
year = 1987,
month = aug,
address = "University Park, PA",
publisher = "Pennsylvania State University Press",
pages = {243--246},
note = "Also technical report CSRD 620,
University of Illinois at Urbana-Champaign,
Center for Supercomputing Research and Development",
comment = "snapshot-at-the-beginning write barrier"
}

@article{abra67,
title = "Storage Allocation in a Certain Iterative Process",
author = "John Abramowich",
journal = CACM,
publisher = ACM,
volume = 10,
number = 6,
month = jun,
year = 1967,
pages = "368--370"
}

@inproceedings{abua04,
  author =	 {Diab Abuaiadh and Yoav Ossia and Erez Petrank and Uri
                  Silbershtein},
  title =	 {An Efficient Parallel Heap Compaction Algorithm},
  pages = {224--236},
  crossref =	 {OOPSLA04},
  doi =		 {10.1145/1028976.1028995},
  comment = 	 {http://www.cs.technion.ac.il/~erez/Papers/parallel-compaction.ps},
  abstract =	 {We propose a heap compaction algorithm appropriate for
                  modern computing environments. Our algorithm is targeted at
                  SMP platforms. It demonstrates high scalability when running
                  in parallel but is also extremely efficient when running
                  single-threaded on a uniprocessor. Instead of using the
                  standard forwarding pointer mechanism for updating pointers
                  to moved objects, the algorithm saves information for a pack
                  of objects. It then does a small computation to process this
                  information and determine each object's new location.  In
                  addition, using a smart parallel moving strategy, the
                  algorithm achieves (almost) perfect compaction in the lower
                  addresses of the heap, whereas previous algorithms achieved
                  parallelism by compacting within several predetermined
                  segments.  Next, we investigate a method that trades
                  compaction quality for a further reduction in time and space
                  overhead.  Finally, we propose a modern version of the
                  two-finger compaction algorithm. This algorithm fails, thus,
                  re-validating traditional wisdom asserting that retaining
                  the order of live objects significantly improves the quality
                  of the compaction.  The parallel compaction algorithm was
                  implemented on the IBM production Java Virtual Machine. We
                  provide measurements demonstrating high efficiency and
                  scalability. Subsequently, this algorithm has been
                  incorporated into the IBM production JVM.}
}

@inproceedings{acar06,
  author =	 {Umut A. Acar and Guy E. Blelloch and M. Blume and
                  K. Tangwongsan},
  title =	 {An Experimental Analysis of Self-Adjusting Computation},
  crossref =	 {PLDI06},
  pages =	 {96-107},
  doi =		 {10.1145/1133981.1133993},
  comment =	 {GC is a significant cost for self-adjusting computations}
}

@inproceedings{acce86,
author = "M. Accetta and R. Baron and W. Bolosky and D. Golub and R. Rashid
and A. Tevanian and M. Young",
title = "Mach: A New Kernel Foundation for {U}nix Development",
booktitle = "Usenix Summer Conference",
publisher = UA,
year = 1986,
month = jul
}


@inproceedings{adit94,
  author =	 "Shail Aditya and Christine Flood and James Hicks",
  title =	 "Garbage Collection for Strongly-Typed Languages Using
                  Run-time Type Reconstruction",
  pages =	 "12--23",
  crossref =	 "LFP94",
  doi =		 {10.1145/182409.182414},
  comment = 	 "http://csg-www.lcs.mit.edu:8001/mcrctr/gc-lfp/gc-lfp.ps.Z",
  abstract =	 "Garbage collectors perform two functions: live-object
                  detection and dead-object reclamation. In this paper, we
                  present a new technique for live-object detection based on
                  run-time type reconstruction for a strongly-typed,
                  polymorphic language. This scheme uses compile-time type
                  information together with the run-time tree of activation
                  frames to determine the exact type of every object
                  participating in the computation.  These reconstructed types
                  are then used to identify and traverse the live heap objects
                  during garbage collection.  We describe an implementation of
                  our scheme for the Id parallel programming language compiled
                  for the *T multiprocessor architecture. We present
                  simulation studies that compare the performance of
                  type-reconstructing garbage collection with conservative
                  garbage collection and compiler-directed storage
                  reclamation."
}

@mastersthesis{adji96,
title = {Mesure et caract\'{e}risation d'applications r\'{e}parties},
author = {C\'{e}dric Adjih},
school = {Universit\'{e} Paris Sud},
URL = "http://www-sor.inria.fr/publi/summaries/1996/MCAR_dea96.html",
year = 1996,
abstract = "This article studies the memory behaviour of a number of
benchmark applications, with respect to the main difficulties of a
garbage collector for a distributed shared memory system. The main
variables measured are:  amount of garbage; locality of pointers; size
and locality of cycles (both reachable and garbage); in-degrees and
out-degrees."
}

@inproceedings{adl98,
  title =	 {Fast Effective Code Generation in a {J}ust-{I}n-{T}ime
                  {J}ava Compiler},
  author =	 {Ali-Reza Adl-Tabatai and Michal Cierniak and Guei-Yuan Leuh
                  and Vihesh M. Parikh and James M. Stichnoth},
  crossref =	 {PLDI98},
  pages =	 {280-290},
  doi =		 {10.1145/277650.277740}
}

@inproceedings{adl04,
  author    = {Ali-Reza Adl-Tabatabai and
               Richard L. Hudson and
               Mauricio J. Serrano and
               Sreenivas Subramoney},
  title     = {Prefetch Injection Based on Hardware Monitoring and Object Metadata},
  pages     = {267-276},
  doi       = {10.1145/996841.996873},
  crossref  = {PLDI04}
}

@techreport{adve95,
  author =	 {Sarita V. Adve and Kourosh Gharachorloo},
  title =	 {Shared Memory Consistency Models: A Tutorial},
  institution =	 {Digital Western Research Laboratory},
  year =	 1995,
  type =	 {WRL Research Report},
  number =	 {95/7},
  month =	 sep,
  url =		 {http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf}
}

@article{adve96,
  author =	 {Sarita V. Adve and Kourosh Gharachorloo},
  title =	 {Shared Memory Consistency Models: A Tutorial},
  journal =	 {IEEE Computer},
  year =	 1996,
  volume =	 29,
  number =	 12,
  pages =	 {66-76},
  month =	 dec,
  doi =		 {10.1109/2.546611}
}

@techreport{aert81,
author = "J. P. H. Aerts",
title = "Implementing {SASL} Without Garbage Collection",
institution = "Eindhoven University of Technology",
type = "EUT Report",
number = "81--WSK--05",
year = "1981"
}

@inproceedings{afta08,
title = {{GC} Assertions: Using the Garbage Collector to Check Heap Properties},
author = {Edward Aftandilian and Samuel Guyer},
crossref={MSPC08},
pages = {36--40},
doi = {10.1145/1353522.1353533},
URL = {http://www.eecs.tufts.edu/~eaftan/gcassertions-mspc-2008.pdf}
}

@inproceedings{afta09,
  title =	 {{GC} Assertions: Using the Garbage Collector to Check Heap
                  Properties},
  author =	 {Edward Aftandilian and Samuel Guyer},
  pages = {235--244},
  doi = {10.1145/1542476.1542504},
  crossref =	 {PLDI09}
}

@phdthesis{agar87,
author = "Anant Agarwal",
title = "Analysis of Cache Performance for Operating Systems and Multiprogramming",
school = "Stanford University",
address = "Palo Alto, CA",
note = "Available as Technical Report CSL-TR-87-332",
month = may,
year = 1987
}

@article{agar88,
author = "Agarwal, Anant and Mark Horowitz and John Hennessy",
title = "Cache Performance of Operating Systems and Multiprogramming Workloads",
journal = TransCompSys,
publisher = ACM,
volume = 6,
number = 4,
pages = "393--431",
month = Nov,
year = 1988
}

@inproceedings{agar06,
title = {Decomposing Memory Performance: Data Structures and Phases},
author = {Kartik Agaram and Steve Keckler and Calvin Lin and Kathryn McKinley},
pages = {95--103},
crossref = {ISMM06},
}

@inproceedings{agga02,
title = {Software Caching \emph{vs.} Prefetching},
author = {Aneesh Aggarwal},
crossref = {ISMM02},
pages = {157--162}
}

@inproceedings{ages97,
author = {Ole Agesen and David Detlefs},
title = {Finding References in {J}ava Stacks},
crossref = "OOPSLA97-gc",
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/detlefs.ps}
}

@inproceedings{ages98,
  author =	 {Ole Agesen and David Detlefs and J. Eliot B. Moss},
  title =	 {Garbage Collection and Local Variable Type-Precision and
                  Liveness in {Java} Virtual Machines},
  crossref =	 {PLDI98},
  pages =	 {269--279},
  doi =		 {10.1145/277650.277738}
}


@techreport{ages98a,
author = {Ole Agesen},
title = {{GC} Points in a Threaded Environment},
institution = {Sun Microsystems Laboratories},
address = {Palo Alto, CA},
number = {SMLI TR-98-70},
year = 1998,
URL = {http://research.sun.com/research/techrep/1998/smli_tr-98-70.pdf},
abstract = {Many garbage-collected systems, including most that involve
a stop-the-world phase, restrict GC to so-called GC points. In
single-threaded environments, GC points carry no overhead: when a GC
must be done, the single thread is already at a GC point. In
multi-threaded environments, however, only the thread that triggers the
GC by failing an allocation will be at a GC point. Other threads must
be rolled forward to their next GC point before the GC can take place.
We compare, in the context of a high-performance Java" virtual machine,
two approaches to advancing threads to a GC point, polling and code
patching, while keeping all other factors constant. Code patching
outperforms polling by an average of 4.7\% and sometimes by as much as
11.2\%, while costing only slightly more compiled code space. Put
differently, since most programs spend less than 1/5 of the time in GC,
a 4.7\% bottom-line speedup amounts to more than a 20\% reduction in
the GC-related costs. Patching is, however, more difficult to implement.}
}

@article{ages99,
author = {Ole Agesen},
title = {Space and Time-Efficient Hashing of Garbage-Collected Objects},
journal = {Theory and Practice of Object Systems},
volume = 5,
number = 2,
pages = {119--124},
year = 1999,
doi={31087.310867},
URL = {http://www.sunlabs.com/research/java-topics/pubs/99-tapos.ps}
}

@inproceedings{ages00,
author = {Ole Agesen and Alex Garthwaite},
title = {Efficient Object Sampling Via Weak References},
pages = {121--136},
crossref = {ISMM2000},
abstract = {
The performance of automatic memory management may be improved if he
policies used in allocating and collecting objects had knowledge of the
lifetimes of objects. To date, approaches to the pretenuring of objects in
older generations have relied on profile-driven feedback gathered from
trace runs. This feedback has been used to specialize allocation sites in a
program. These approaches suffer from a number of limitations. We
propose an alternative that through efficient sampling of objects allows for
on-line adaption of allocation sites to improve the efficiency of the memory
system. In doing so, we make use of a facility already present in many
collectors such as those found in Java(TM) virtual machines: weak
references. By judiciously tracking a subset of allocated objects with weak
references, we are able to gather the necessary statistics to make better
object-placement decisions.
}
}

@inproceedings{aggo90,
author = "A. Aggoun and N. Beldiceanu",
title = "Time Stamps Techniques for the Trailed Data in Constraint Logic
Programming Systems",
booktitle = {S\'{e}minaire de Programmation Logique de Tr\'{e}gastel, CNET,
France},
pages = "487--509",
year = 1990,
}


@book{agha86,
author = "G. Agha",
title = "Actors: A Model of Concurrent Computation in Distributed Systems",
publisher = MIT,
year = 1986
}

@book{aho86,
author = "Alfred V. Aho and Ravi Sethi and Jeffrey D. Ullman",
title = "Compilers: Principles, Techniques and Tools",
publisher = AW,
year = 1986
}

@book{aho88,
author = "Alfred V. Aho and Brian W. Kernighan and Peter J. Weinberger",
title = "The {AWK} Programming Language",
publisher = AW,
year = 1988
}

@techreport{aign10,
title = {Short-Term Memory for Self-Collecting Mutators},
author = {Martin Aigner and Andreas Haas and Christoph Kirsch and Hannes Payer
and Andreas Sch\"{o}negger and Ana Sokolova},
institution = {University of Salzburg},
number = {2010--03},
month = apr,
year = 2010,
URL = {http://cs.uni-salzburg.at/~ck/publications/reports/SBG10-ShortTermMemory.pdf},
abstract = {We propose a new memory model, short-term memory, and an algorithm
that employs it, called self-collecting mutators. In short- term memory objects
expire after a certain amount of time, which makes deallocation unnecessary.
Self-collecting mutators require programmer support to control the time and
thereby enable reusing the memory of expired objects. We identify a class of
programs for which programmer support is easy and correctness is guaranteed. We
also provide support for multi-threaded applications. Self-collecting mutators
perform competitively with garbage-collected systems, as shown by our
experimental results on several benchmarks. Unlike garbage-collected systems,
our system has no pause times, provides constant execution time of all memory
operations, independent of number of live objects, and constant memory
consumption after a steady state has been reached.}
}

@inproceedings{aign11,
title = {Short-Term Memory for Self-Collecting Mutators},
author = {Martin Aigner and Andreas Haas and Christoph M. Kirsch and Michael
Lippautz and Ana Sokolova and Stephanie Stroka and Andreas Unterweger},
crossref = {ISMM11},
pages = {99--108},
doi = {1993478.1993493},
abstract = {We propose a new memory model called short-term memory for managing
objects on the heap. In contrast to the traditional persistent memory model for
heap management, objects in short-term memory expire after a finite amount of
time, which makes deallocation unnecessary. Instead, expiration of objects may
be extended, if necessary, by refreshing. We have developed a concurrent,
incremental, and non-moving implementation of short-term memory for explicit
refreshing called self-collecting mutators that is based on
programmer-controlled time and integrated into state-of-the-art runtimes of
three programming languages: C, Java, and Go. All memory management operations
run in constant time without acquiring any locks modulo the underlying
allocators. Our implementation does not require any additional heap management
threads, hence the name. Expired objects may be collected anywhere between one
at a time for maximal incrementality and all at once for maximal throughput and
minimal memory consumption. The integrated systems are heap management hybrids
with persistent memory as default and short-term memory as option. Our approach
is fully backwards compatible. Legacy code runs without any modifications with
negligible runtime overhead and constant per-object space overhead. Legacy code
can be modified to take advantage of short-term memory by having some but not
all objects allocated in short-term memory and managed by explicit refreshing.
We study single- and multi-threaded use cases in all three languages
macro-benchmarking C and Java and micro-benchmarking Go. Our results show that
using short-term memory (1) simplifies heap management in a state-of-the-art
H.264 encoder written in C without additional time and minor space overhead, and
(2) improves, at the expense of safety, memory management throughput, latency,
and space consumption by reducing the number of garbage collection runs, often
even to zero, for a number of Java and Go programs.}
}

@inproceedings{aign13,
author = {Aigner, Martin and Kirsch, Christoph M.},
title = {{ACDC}: Towards a Universal Mutator for Benchmarking Heap Management Systems},
crossref = {ISMM13},
 doi = {10.1145/2464157.2464161},
abstract = {We present ACDC, an open-source benchmark that may be configured to
emulate explicit single- and multi-threaded memory allocation, sharing, access,
and deallocation behavior to expose virtually any relevant allocator performance
differences. ACDC mimics periodic memory allocation and deallocation (AC) as
well as persistent memory (DC). Memory may be allocated thread-locally and
shared among multiple threads to study multicore scalability and even false
sharing. Memory may be deallocated by threads other than the allocating threads
to study blowup memory fragmentation. Memory may be accessed and deallocated
sequentially in allocation order or in tree-like traversals to expose allocator
deficiencies in exploiting spatial locality. We demonstrate ACDC's capabilities
with seven state-of-the-art allocators for C/C++ in an empirical study which
also reveals interesting performance differences between the allocators.},
} 

@techreport{aike95,
title = {Better Static Memory Management: Improving Region-Based Analysis of Higher-Order Languages},
author = {Alex Aiken and Manuel F\"{a}hndrich and Raph Levien},
institution = UCB,
URL = {http://www.cs.berkeley.edu/~aiken/ftp/region.ps},
year = 1995
}

@inproceedings{aike95a,
  title =	 {Better Static Memory Management: Improving Region-Based
                  Analysis of Higher-Order Languages},
  author =	 {Alex Aiken and Manuel F\"{a}hndrich and Raph Levien},
  crossref =	 {PLDI95},
  pages =	 {174--185},
  doi =		 {10.1145/207110.207137}
}

@inproceedings{aino14,
title = {A Study of Connected Object Locality in {NUMA} Heaps},
author = {Khaled Alnowaiser},
crossref = {MSPC14},
doi = {10.1145/2618128.2618132},
abstract = {Reference locality is vital to the performance of parallel Garbage
Collection (GC) running on Non-Uniform Memory Access (NUMA) machines. A GC
thread may trace remotely placed objects that descend from the root set or, for
load balance, a GC thread may steal non-local objects from other threads' work
lists. Processing distant live objects could introduce contention in the
interconnect links between memory nodes and it could increase memory access
latency. Researchers have proposed various techniques to improve GC tracing
locality. However, few studies attempt to optimize the locality of connected
objects in NUMA object graph. In this paper, we study the locality of a rooted
subgraph, a unit of object connectivity in the object graph. A rooted subgraph
is a set of references containing one root reference, and every reference is
reachable from the root. We empirically study the locality of rooted subgraphs
of DaCapo and SPECjbb2005 benchmark suites. The results show that more than 80\%
of objects in a rooted subgraph are located in the same memory node as the root
object. We then propose a GC locality optimization that uses the root memory
node as a heuristic to guide GC threads processing local objects.}
}

@incollection{ait91,
author = {Hassan A\"{i}t-Kaci},
title = "The {WAM}: A (Real) Tutorial",
booktitle = "Warren's {A}bstract {M}achine: A Tutorial Reconstruction",
publisher = MIT,
note = "Also Technical report 5, DEC Paris Research Laboratory, 1990",
year = 1991,
comment = "environment protection",
}

@manual{AIX,
title = "Subroutines Overview",
key = "AIX",
edition = "{G}eneral {P}rogramming {C}oncepts, {AIX} version 3.2",
organisation = IBM,
year = "version 3.2"
}



@article{akyu95,
author = {Sedat Aky\"{u}rek and Kenneth Salem},
title = "Adaptive Block Rearrangement",
journal = TransCompSys,
publisher = ACM,
volume = 13,
number = 2,
month = may,
year = 1995,
pages = "95--121"
}

@inproceedings{albe07,
title = {Heap Space Analysis for {J}ava Bytecode},
author = {Elvira Albert and Samir Genaim and Miguel G\'{o}mez-Zamalloa},
pages = {105--116},
crossref = {ISMM07}
}

@inproceedings{albe09,
title = {Live Heap Space Analysis for Languages with Garbage Collection},
author = {Elvira Albert and Samir Genaim and G\'{o}mez-Zamalloa Gil, Miguel },
pages = {129--138},
doi = {10.1145/1542431.1542450},
crossref = {ISMM09}
}

@inproceedings{albe10,
author = {Albert, Elvira and Genaim, Samir and G\'{o}mez-Zamalloa, Miguel},
title = {Parametric Inference of Memory Requirements for Garbage Collected Languages},
crossref = {ISMM10},
pages = {121--130},
doi = {10.1145/1806651.1806671},
abstract = {The accurate prediction of program's memory requirements is a
critical component in software development. Existing heap space analyses either
do not take deallocation into account or adopt specific models of garbage
collectors which do not necessarily correspond to the actual memory usage. We
present a novel approach to inferring upper bounds on memory requirements of
Java-like programs which is parametric on the notion of object lifetime, i.e.,
on when objects become collectible. If objects lifetimes are inferred by a
reachability analysis, then our analysis infers accurate upper bounds on the
memory consumption for a reachability-based garbage collector. Interestingly, if
objects lifetimes are inferred by a heap liveness analysis, then we approximate
the program minimal memory requirement, i.e., the peak memory usage when using
an optimal garbage collector which frees objects as soon as they become dead.
The key idea is to integrate information on objects lifetimes into the process
of generating the recurrence equations which capture the memory usage at the
different program states. If the heap size limit is set to the memory
requirement inferred by our analysis, it is ensured that execution will not
exceed the memory limit with the only assumption that garbage collection works
when the limit is reached. Experiments on Java bytecode programs provide
evidence of the feasibility and accuracy of our analysis.},
}

@article{ali98,
author = {K.A.M. Ali},
title = {A Simple Generational Real-Time Garbage Collection Scheme},
journal = {Computing Paradigms and Computational Intelligence
(New Generation Computing)},
volume = 16,
number = 2,
year = 1998
}

@article{alla91,
title = "Real-Time Programming in {C}ommon {L}isp",
author = "J. R. Allard and L. B. Hawkinson",
address = "Gensym Corp., 125 Cambridge Park Drive, Cambridge, Ma., 02140",
journal = CACM,
publisher = ACM,
year = 1991,
volume = 34,
number = 9,
pages = "64--69"
}

@article{alle02,
title = {System Description for a Scalable, Fault-Tolerant, Distributed Garbage Collector},  
author = {N. Allen and Timothy B. Terriberry},
journal = {Computing Research Repository (CORR)},
volume = {cs.DC/0207},
year = 2002,
abstract = {We describe an efficient and fault-tolerant algorithm for
distributed cyclic garbage collection. The algorithm imposes few requirements on
the local machines and allows for flexibility in the choice of local collector
and distributed acyclic garbage collector to use with it. We have emphasized
reducing the number and size of network messages without sacrificing the
promptness of collection throughout the algorithm. Our proposed collector is a
variant of back tracing to avoid extensive synchronization between machines. We
have added an explicit forward tracing stage to the standard back tracing stage
and designed a tuned heuristic to reduce the total amount of work done by the
collector. Of particular note is the development of fault-tolerant cooperation
between traces and a heuristic that aggressively reduces the set of suspect
objects.}
}

@article{alli89,
title = "Circular Programs and Self-Referential Structures",
author = "L. Allison",
institution = "Monash University, Department of Computer Science, Clayton, Vic 3168, Australia",
journal = SPE,
publisher = Wiley,
year = 1989,
volume = 19,
number = 2,
pages = "99--109"
}

@phdthesis{alme80,
author = "Almes, Guy T.",
title = "Garbage collection in an Object-Oriented System",
school = CMU,
year = 1980,
}

@incollection{alme83,
author = "Guy Almes and A. Borning and E. Messinger",
title = "Implementing a {S}malltalk-80 System on the {I}ntel 432",
crossref = "Smalltalk-BHWA",
pages = "175--187",
}

@inproceedings{alon87,
author = {Noga Alon and Amnon Barak and Udi Mander},
title = {On disseminating information reliably without broadcasting},
booktitle = {7th International Conference on Distributed Computing Systems ICDCS97},
address = {Berlin},
editors = {R. Popescu-Zeletin and G. Lehann and K.H. Kim},
month = sep,
year = 1987,
publisher = IEEE,
ISBN = {0-8186-0801-3}
}


@inproceedings{alon90,
title = "An Advisor for Flexible Working Sets",
author = "Rafael Alonso and Andrew W. Appel",
booktitle = SIGMETRICS,
address = {Boulder, CO},
publisher = ACM,
month = may,
pages = "153--162",
year = 1990,
doi = {10.1145/98457.98753},
abstract = {The traditional model of virtual memory working sets does not
account for programs that can adjust their working sets on demand.
Examples of such programs are garbage-collected systems and databases
with block cache buffers.  We present a memory-use model of such systems,
and propose a method that may be used by virtual memory managers to advise
programs on how to adjust their working sets.  Our method tries to minimize
memory contention and ensure better overall system response time.  We have
implemented a memory 'advice server' that runs as a non-privileged process
under Berkeley Unix.  User processes may ask this server for advice about
working set sizes, so as to take maximum advantage of memory resources.
Our implementation is quite simple, and has negligible overhead, and
experimental results show that it results in sizable performance improvements.}
}

@inproceedings{alpe99,
  title =	 {Implementing {J}alape\~{n}o in {J}ava},
  author =	 {Bowen Alpern and C. R. Attanasio and Anthony Cocchi and
                  Derek Lieber and Stephen Smith and Ton Ngo and John
                  J. Barton and Susan Flynn Hummel and Janice C. Sheperd and
                  Mark Mergen},
  crossref =	 {OOPSLA99},
  pages =	 {314--324},
  doi =		 {10.1145/320385.320418}
}

@article{alpe00,
Author = {Bowen Alpern and Dick Attanasio and John J. Barton and M.  G.
Burke and Perry Cheng and J.-D. Choi and Anthony Cocchi
and Stephen J. Fink and David Grove and Michael Hind and Susan Flynn Hummel and
D. Lieber and V. Litvinov and Mark Mergen and Ton Ngo and
J. R. Russell and Vivek Sarkar and Manuel J. Serrano and Janice Shepherd
and S. Smith and V. C. Sreedhar and H.  Srinivasan and J. Whaley },
title =   {The {J}alape\~{n}o Virtual Machine},
journal =   ISJ,
year =   2000,
volume =  39,
number =  1,
month =  feb,
URL = {http://www.research.ibm.com/journal/sj/391/alpern.pdf}
}

@inproceedings{alpe02,
title = {Experiences Porting the {J}ikes {RVM} to {L}inux/{IA}32},
author = {Bowen Alpern and Maria Butrico and Anthony Cocchi and Julian Dolby and Stephen Fink and David Grove and Ton Ngo},
crossref = {JVM02},
URL = {http://www.research.ibm.com/people/d/dgrove/papers/jvm01.pdf},
abstract = {This paper describes our experiences in porting the Jikes
Research Virtual Machine from its first platform, AIX/PowerPC, to its
second, Linux/IA32. We discuss the main issues in realizing both an
initial functional port, and then tuning efforts to achieve competitive
performance. The paper presents software engineering issues in building
a portable runtime system and compilers, as well as specific
optimizations to improve performance on IA32. }
}

@inproceedings{amad04,
author = {Roberto Amadio and Solange Coupet-Grimal and Silvano Dal Zilio and Line Jakubiec},
title = {A Functional Scenerio for Bytecode Verification of Space Bounds},
crossref = {SPACE04},
}

@inproceedings{amam83,
title = "List Processing with a Data Flow Machine",
author = "M. Amamiya and R. Hasegawa and H. Mikami",
booktitle = "RIMS Symposia on Software Science and Engineering",
year = 1983,
address = "Kyoto, Japan",
series = LNCS,
volume = 147,
publisher = SV,
pages = "165--190",
doi={10.1007/3-540-11980-9_22},
abstract = {This paper discussed some issues in list processing within the
context of a data flow control environment, and from the viewpoint of
parallelism.  The basic philosophy behind the data flow machine architecture
presented in this paper is that highly parallel execution can be achieved by
data flow control concept, both at the primitive operation level and at the
function activation level.  The mechanism of partial execution for each
function was shown through some examples including an Lisp interpreter
implementation, to be effective for exploitation of the parallelism in list
processing.  The lenient cons mechanism was shown through analysis of two
programs, to be effective for maximally exploiting parallelism.  A garbage
collection mechanism based on the referenced count method was also
described.}
}

@techreport{amsa94,
author = "Laurent Amsaleg and Michael Franklin and Olivier Gruber",
title = "Efficient Incremental Garbage Collection for Workstation/Server
Database Systems",
institution = "University of Maryland",
number = "CS--TR--3370",
month = nov,
year = 1994,
URL = "ftp://ftp.cs.umd.edu/pub/papers/papers/ncstrl.umcp/CS-TR-3370",
abstract = " We describe an efficient server-based algorithm for garbage
collecting object-oriented databases in a workstation/server environment.
The algorithm is incremental and runs concurrently with client
transactions, however, it does not hold any locks on data and does not
require callbacks to clients. It is fault tolerant, but performs very
little logging. The algorithm has been designed to be integrated into
existing OODB systems, and therefore it works with standard
implementation techniques such as two-phase locking and
write-ahead-logging. In addition, it supports client-server performance
optimizations such as client caching and flexible management of client
buffers. We describe an implementation of the algorithm in the EXODUS
storage manager and present results from an initial performance study of
the implementation. These results demonstrate that the introduction of
the garbage collector adds minimal overhead to client operations.",
note = "Also University of Maryland Institute for Advanced Computer Studies
report UMIACS-TR-94-121"
}

@inproceedings{amsa95,
author = "Laurent Amsaleg and Michael Franklin and Olivier Gruber",
title = "Efficient Incremental Garbage Collection for Client--Server Object Database Systems",
booktitle = "Twenty-first International Conference on Very Large Databases (VLDB95)",
address = "Zurich, Switzerland",
month = sep,
year = 1995,
URL = {http://www.cs.umd.edu/users/franklin/papers/vldbgc.ps.gz}
}

@inproceedings{amsa95a,
author = "Laurent Amsaleg and Paulo Ferreira and Michael Franklin and Marc Shapiro",
title = "Evaluating Garbage Collectors for Large Persistent Stores",
booktitle = "OOPSLA'95 Workshop on Object Database Behavior, Benchmarks, and Performance",
address = "Austin, TX",
month = oct,
year = 1995,
URL = "http://www-sor.inria.fr/SOR/docs/EGCLPS_oopsla95ws.html"
}

@article{amsa99,
author = "Laurent Amsaleg and Michael Franklin and Olivier Gruber",
title = {Garbage Collection for a Client-Server Persistent Object Store},
journal = TransCompSys,
volume = 17,
number = 3,
pages = {153--201},
year = 1999
}

@article{amst00,
author = {Jonathan Amsterdam},
title = {Use Object Pools to Sidestep Garbage Collection},
journal = {Java Report},
month = sep,
year = 2000,
pages = {120-119 (really)},
comment = {Articles like this are a good indication of how much work there
is to be done educating developers and `Java training and consulting firms'.}
}

@inproceedings{ande87,
author = "Wayne Anderson and William Galway and Robert Kessler and Herbert
Melenk and Winfried Neun",
title = "The Implementation and Optimisation of {P}ortable {S}tandard
{L}isp for the {C}ray",
booktitle = "20th Annual Hawaii International Conference on Science Systems",
year = 1987,
month = jan
}

@inproceedings{ande04,
author = {Anderson, T. and Eng, M. and Glew, N. and Lewis, B. and Menon, V. and
Stichnoth, J},
title = {Experience integrating a new compiler and garbage collector into
{R}otor},
booktitle = {{.NET} {T}echnologies'2004},
year = 2004,
URL = {http://dotnet.zcu.cz/NET_2004/Papers/C37.pdf}
}

@inproceedings{ande10,
author = {Anderson, Todd A.},
title = {Optimizations in a Private Nursery-Based Garbage Collector},
crossref = {ISMM10},
pages = {21--30},
doi = {10.1145/1806651.1806655},
abstract = {This paper describes a garbage collector designed around the use of
permanent, private, thread-local nurseries and is principally oriented towards
functional languages. We try to maximize the cache hit rate by having threads
continually reuse their individual private nurseries. These private nurseries
operate in such a way that they can be garbage collected independently of other
threads, which creates low collection pause times. Objects which survive
thread-local collections are moved to a mature generation that can be collected
either concurrently or in a stop-the-world fashion. We describe several
optimizations (including two dynamic control parameter adaptation schemes)
related to garbage collecting the private nurseries and to our concurrent
collector, some of which are made possible when the language provides mutability
information. We tested our collector against six benchmarks and saw
single-threaded performance improvements in the range of 5-74\/%. We also saw a
10x increase (for 24 processors) in scalability for one parallel benchmark that
had previously been memory-bound.}
}

@manual{ANSI-C,
title = "{A}merican {N}ational {S}tandard for {I}nformation {S}ystems:
{P}rogramming Language {C}",
key = "ANSI-C",
organization = "American National Standards Institute",
number = "X3.159--1989",
month = dec,
year = 1989
}

@manual{ANSI-C++,
title = "{D}raft {P}roposed {I}nternational {S}tandard for {I}nformation
{S}Systems:
{P}rogramming Language {C++}",
key = "ANSI-C++",
organization = "ANSI document X3J16/95--0087, ISO document WG21/N0618",
month = apr,
year = 1995
}
% key = "ANSI-C++, 1993",
% organization = "ANSI document X3J16/93--0010, ISO document WG21/N0218",
% month = jan,
% year = 1993

@inproceedings{ande91,
  author =	 "Thomas E. Anderson and Henry M. Levy and Brian N. Bershad
                  and Edward D. Lazowska",
  title =	 "The Interaction of Architecture and Operating Systems
                  Design",
  crossref =	 "ASPLOS91",
  pages =	 "108--120",
}


@mastersthesis{andr86,
author = "Andre, David L.",
title = "Paging in {L}isp Programs",
school = "University of Maryland",
address = "College Park, MD",
year = 1986
}

@inproceedings{andr02,
title = {To Collect or Not to Collect? Machine Learning for Memory Management},
author = {Eva Andreasson and Frank Hoffmann and Olof Lindholm},
crossref = {JVM02},
URL = {http://www.usenix.org/events/jvm02/andreasson.html}
}

@misc{aonix,
key = {Aonix},
title = {The {PERC} Virtual Machine},
URL = {http://www.aonix.com},
}

@article{appe87,
title = "Garbage Collection can be Faster than Stack Allocation",
author = "Andrew W. Appel",
journal = IPL,
publisher = NH,
year = 1987,
volume = 25,
number = 4,
pages = "275--279",
doi = {10.1016/0020-0190(87)90175-X},
URL = "http://www.cs.princeton.edu/fac/~appel/papers/45.ps",
abstract = {An old and simple algorithm for garbage collection gives very good
results when the physical memory is much larger than the number of
reachable cells.
In fact, the overhead associated with allocating and collecting cells
from the heap can be reduced to less than one instruction per cell by
increasing the size of physical memory.  Special hardware, intricate
garbage-collection algorithms, and fancy compiler analysis become unnecessary.},
comment = {A rebuttal of this argument can be found in \cite{mill94}.}
}


@inproceedings{appe88,
title = "Real-Time Concurrent Collection on Stock Multiprocessors",
author = "Andrew W. Appel and John R. Ellis and Kai Li",
crossref = {PLDI88},
pages = {11--20},
doi = {10.1145/53990.53992},
comment = "Not ``real'' real-time, but a very cool algorithm. (Paul Wilson)
Augustsson recommends this one.
Uses VM access protection as a coarse approximation of Baker's write barrier.
Mutator is not allowed to see any page that might contain a pointer to
fromspace.
Pointers in scanned area of tospace are guaranteed to point into tospace.
Ant pointers from fromspace to tospace must be in the unscanned area (gray).
When mutator accesses a protected page, a trap handler scans the whole
page,fixing up pointers.
Fails to provide meaningful real-time guarantees in the general case,
but is concurrent and greatly reduces the cost of the read barrier."
}


@techreport{appe88a,
author = "Andrew W. Appel and Aage Bendiksen",
title = "Vectorized Garbage Collection",
institution = princeton,
number = "CS-TR-169-88",
year = 1988,
month = jul,
url = {http://www.cs.princeton.edu/research/techreps/TR-169-88},
comment = "Can get useful speedup by vectorising GC operations"
}


@techreport{appe88b,
author = "Andrew W. Appel",
title = "Allocation without Locking",
institution = princeton,
number = "CS-TR-182-88",
year = 1988,
month = sep
}

@techreport{appe88c,
author = "Appel, Andrew W. and Duba, Bruce F. and MacQueen, David B.",
title = "Profiling in the Presence of Optimization and Garbage Collection",
year = 1988,
institution = princeton,
number = "CS-TR-197-88",
month = Nov
}


@techreport{appe88d,
author = "Appel, Andrew W. and Hanson, David R.",
title = "Copying Garbage Collection in the Presence of Ambiguous References",
institution = princeton,
year = 1988,
number = "CS-TR-162-88"
}

@article{appe89,
title = "Simple Generational Garbage Collection and Fast Allocation",
author = "Andrew W. Appel",
institution = princeton,
journal = SPE,
publisher = Wiley,
year = 1989,
volume = 19,
number = 2,
pages = "171--183",
doi = "10.1002/spe.4380190206",
URL = "http://www.cs.princeton.edu/fac/~appel/papers/143.ps",
abstract = {Generational garbage collection algorithms achieve efficiency
because newer records point to older records; the only way an older record
can point to a newer record is by a store operation to a previously created
record, and such operations are rare in many languages.  A garbage collector
that concentrates just on recently allocated records can take advantage of this
fact.  Such a garbage collector can be so efficient that the allocation of
records costs more than their disposal.  A scheme for quick record allocation
attacks this bottleneck.  Many garbage-collected environments do not know when
to ask the operating system for more memory.  A robust heuristic solves this
problem.  This paper presents a simple, efficient, low-overhead version of
generational garbage collection with fast allocation, suitable for
implementation in a Unix environment.}
}


@article{appe89a,
title = "Allocation Without Locking",
author = "Andrew W. Appel",
institution = princeton,
journal = SPE,
publisher = Wiley,
year = 1989,
volume = 19,
number = 7,
note = "Short Communication",
abstract = "...This paper shows how allocation can run extremely quickly
even in a multi-thread environment: open-coded, without locking",
}


@article{appe89b,
title = "Runtime Tags Aren't Necessary",
author = "Andrew W. Appel",
address = princeton,
journal = LSC,
year = 1989,
volume = 2,
pages = "153--162",
doi={10.1007/BF01811537},
comment = "For a purely statically-typed language, no per-object runtime type
information is necessary, except the types of the root set variables."
}

@article{appe89c,
author = "Appel, Andrew W.  and Bendiksen, Aage",
title = "Vectorized Garbage Collection",
journal = "The Journal of Supercomputing",
volume = 3,
pages = "151--160",
doi = {10.1007/BF00127826},
URL = "http://www.cs.princeton.edu/fac/~appel/papers/169.ps",
year = 1989,
}

@article{appe90,
author = "Andrew W. Appel",
title = "A Runtime System",
journal = LSC,
volume = 3,
year = 1990,
pages = "343--380"
}



@article{appe91,
  title =	 "Virtual Memory Primitives for User Programs",
  author =	 "Andrew W. Appel and Kai Li",
  crossref =	 {ASPLOS91},
  pages =	 {96-107},
  doi =		 {10.1145/106972.106984},
  URL =		 {http://ncstrl.cs.Princeton.EDU/expand.php?id=TR-276-90}
}


@incollection{appe91a,
author = "Andrew W. Appel",
title = "Garbage Collection",
booktitle = "Topics in Advanced Language Implementation",
editor = "Peter Lee",
pages = "89--100",
publisher = MIT,
year = 1991
}


@inproceedings{appe92,
  title =	 "Tutorial: Compilers and Runtime Systems for Languages with
                  Garbage Collection",
  author =	 "Andrew W. Appel",
  crossref =	 "PLDI92",
  comment =	 "TUTORIAL: Appel spent most of the time talking about Garbage
                  Collection and Data Representation issues covered by his
                  papers and book.  He had McCarthy's 1960 description of Mark
                  and Sweep on a single slide, pointing out that publications
                  were much more terse 30 years ago.  He claims that Garbage
                  Collectors are already ``down in the noise'' today, but that
                  they now should start improving mutator performance to earn
                  their keep.  On Compiler Issues, he suggests that language
                  specifications should stipulate what is live data, and have
                  the collector guarantee a limit near that.  His case study
                  was SML/NJ but he had run out of time."
}

@inbook{appe92a,
  author =	 "Andrew W. Appel",
  title =	 "The runtime system",
  booktitle =	 "Compiling with Continuations",
  chapter =	 16,
  publisher =	 CUP,
  pages =	 "205--214",
  year =	 1992
}

@techreport{appe93,
author = "Andrew W. Appel and Marcelo J. R. Gon\c{c}alves",
title = "Hash-consing Garbage Collection",
institution = princeton,
number = "CS-TR-412-93",
month = feb,
year = 1993,
URL = {http://www.cs.princeton.edu/research/techreps/TR-412-93}
}

@techreport{appe94,
author = "Andrew W. Appel and Zhong Shao",
title = "An Empirical and Analytic Study of Stack vs. Heap Cost for Languages with Closures",
institution = princeton,
number = "CS--TR--450--94",
month = mar,
year = 1994,
URL = {http://www.cs.princeton.edu/research/techreps/TR-450-94}
}

@techreport{appe94a,
title = {Emulating Write-Allocate on a No-Write-Allocate Cache},
author = {Andrew W. Appel},
institution = princeton,
number = {TR-459-94},
month = jun,
year = 1994,
URL = {http://www.cs.princeton.edu/research/techreps/TR-459-94},
abstract = {A cache write-miss policy of write-allocate leads to better
performance for many programs than a policy of no-write-allocate. I show
a compiling technique to emulate a write-allocate policy even on a
no-write-allocate machine, if that machine has non-blocking cache read
misses (e.g. DEC Alpha 21064). The trick is to pre-fetch garbage before
the write, so that the cache line will be allocated and the write will
hit the cache.  Measurements show a factor-of-1.2 improvement in execution
time.
}
}

@article{appe96,
title = "Empirical and analytic study of stack versus heap cost for languages with closures",
author = "Andrew W. Appel and Zhong Shao",
pages = "47--74",
journal = JFP,
month = jan,
year = 1996,
volume = 6,
number = 1,
doi={10.1017/S095679680000157X},
URL = "ftp://daffy.cs.yale.edu/pub/papers/shao/stack.ps"
}

@book{appe97,
author = "Andrew W. Appel",
title = "Modern Compiler Implementation in {ML}: Basic Techniques",
publisher = CUP,
ISBN = "0-521-58775-1",
URL = "http://www.cup.org/Titles/58/052158275X.html",
year = 1997
}

@book{appe97a,
author = "Andrew W. Appel",
title = "Modern Compiler Implementation in {C}: Basic Techniques",
publisher = CUP,
ISBN = "0-521-58653-4",
URL = "http://www.cup.org/Titles/58/0521583896.html",
year = 1997
}

@book{appe97b,
author = "Andrew W. Appel",
title = "Modern Compiler Implementation in {J}ava: Basic Techniques",
publisher = CUP,
ISBN = "0-521-58654-2",
URL = "http://www.cup.org/Titles/58/0521583896.html",
year = 1997
}

@misc{appe97c,
author = {Andrew W. Appel},
title = {A Better Analytical Model for the Strong Generational
Hypothesis},
month = nov,
year = 1997,
note = {Cited by \cite{stef99}.}
}

@book{appe98,
author = "Andrew W. Appel",
title = "Modern Compiler Implementation in {ML}",
publisher = CUP,
ISBN = "0-521-52745-1",
year = 1998
}

@book{appe98a,
author = "Andrew W. Appel",
title = "Modern Compiler Implementation in {C}",
publisher = CUP,
ISBN = "0-521-58390-X",
year = 1998
}

@book{appe98b,
author = "Andrew W. Appel",
title = "Modern Compiler Implementation in {J}ava",
publisher = CUP,
ISBN = "0-521-58388-8",
year = 1998
}

@article{appl88,
title = "Garbage Collection for {P}rolog based on {WAM}",
author = "Karen Appleby and Mats Carlsson and Seif Haridi and Dan Sahlin",
address = "IBM Corp, Thomas J Watson Res Ctr, Yorktown Hts, Ny, 10598
Swedish Inst Comp Sci, S--16428 Kista, Sweden",
journal = CACM,
publisher = ACM,
year = 1988,
volume = 31,
number = 6,
pages = "719--741",
abstract = {The Warren abstract machine (WAM) has become a generally accepted
standard Prolog implementation technique.  Garbage collection is an important
aspect in the implementation of any Prolog system.  A synopsis of the WAM is
presented and then marking and compaction algorithms are shown that take
advantage of WAM's unique use of the data areas.  Marking and compaction are
performed on both the heap and the trail; both use pointer reversal techniques,
which obviate the need for extra stack space.  However, two bits for every
pointer on the heap are reserved for the garbage collection algorithm.  The
algorithm can work on segments of the heap, which may lead to a significant
reduction of the total garbage collection time.  The time of the algorithms
are linear in the size of the areas.}
}


@article{armb07,
title = {A Real-Time {J}ava Virtual Machine with Applications in Avionics},
author = {Austin Armbruster and Jason Baker and Antonio Cunei and Chapman Flack
and David Holmes and Filip Pizlo and Edward Pla and Marek Prochazka and Jan
Vitek},
journal = TECS,
volume = 7,
number = 1,
year = 2007,
pages =	{5:1--5:49},
articleno = 5,
numpages = 49,
doi = {10.1145/1324969.1324974},
URL = {http://www.cs.purdue.edu/homes/jv/pubs/tecs06.pdf},
note = {Supersedes \cite{bake06}.}
}

@article{arnb72,
author = "Stefan Arnborg",
title = "Storage Administration in a Virtual Memory Simulation System",
journal = "BIT",
volume = 12,
number = 2,
year = 1972,
pages = "125--141",
}


@article{arnb74,
author = "Stefan Arnborg",
title = "Optimal Memory Management in a System with Garbage Collection",
journal = "BIT",
volume = 14,
number = 4,
year = 1974,
pages = "375--381",
}

@book{arms93,
author = "Joe Armstrong and Robert Virding and Mike Williams",
title = {Concurrent Programming in {ERLANG}},
publisher = PH,
year = 1993
}

@inproceedings{arms95,
title = "One-Pass Real-Time Generational Mark-Sweep Garbage Collection",
author = "Joe Armstrong and Robert Virding",
crossref = "IWMM95",
pages = {313--322},
doi = {10.1007/3-540-60368-9_31},
URL = {http://citeseer.nj.nec.com/armstrong95one.html}
}

@inproceedings{arno00,
  author =	 {Matthew Arnold and Stephen J. Fink and David Grove and
                  Michael Hind and Peter F. Sweeney},
  title =	 {Adaptive Optimization in the {J}alape\~{n}o {JVM}},
  crossref =	 {OOPSLA00},
  pages =	 {47--65},
  doi =		 {10.1145/353171.353175}
}

@inproceedings{arno01,
  author =	 {Matthew Arnold and Barbara G. Ryder},
  title =	 {A framework for reducing the cost of instrumented code},
  crossref =	 {PLDI01},
  pages =	 {168--179},
  doi =		 {10.1145/378795.378832}
}

@InProceedings{arno02,
  author =	 {Matthew Arnold and Michael Hind and Barbara G. Ryder},
  title =	 {Online Feedback-Directed Optimization of {J}ava},
  crossref =	 {OOPSLA02},
  pages =	 {111--129},
  doi =		 {10.1145/582419.582432}
}

@InProceedings{arno05,
  author =	 {Matthew Arnold and David Grove},
  title =	 {Collecting and Exploiting High-Accuracy Call Graph Profiles
                  in Virtual Machines},
  crossref =	 {CGO05},
  pages =	 {51--62},
  doi =		 {10.1109/CGO.2005.9}
}

@article{assc06,
  author =	 {van Assche, Maxime and Jo\"{e}l Goossens and Raymond
                  R. Devillers},
title = {Joint Garbage Collection and Hard Real-Time Scheduling},
journal = {Journal of Embedded Computing},
volume = 2,
number = {3--4},
year = 2006,
pages={313--326},
publisher = {IOS Press},
note = {Also published in RTS'05 International Conference on Real-Time Systems,
2005}
}

@inproceedings{asse93,
author = {Holger Assenmacher and Thomas Breitbach and Peter Buhler and Volker H\"{u}bsch and Reinhard Schwarz},
title = "{PANDA} --- Supporting Distributed Programming in {C++}",
crossref = "ECOOP93",
pages = "361--383",
abstract = "PANDA is a run-time package based
on a very small operating system kernel which supports distributed
applications written in C++. It provides powerful abstractions such
as very efficient user-level threads, a uniform global address
space, object and thread mobility, garbage collection, and
persistent objects. The paper discusses the design rationales
underlying the PANDA system. The fundamental features of PANDA are
surveyed, and their implementation in the current prototype
environment is outlined."
}

@inproceedings{atke04,
author = {Robert Atkey},
title = {A Calculus for Resource Relationships},
crossref = {SPACE04},
}

@article{atki88,
title = "The Active Deallocation of Objects in Object-Oriented Systems",
author = "Martin C. Atkins and Lee R. Nackman",
institution = "{IBM} Corp., Thomas J Watson Research Center, Dept Mfg Res, Yorktown Heights, NY",
journal = SPE,
publisher = Wiley,
year = 1988,
volume = 18,
number = 11,
pages = "1073--1089"
}

@phdthesis{atki89,
title = "Implementation Techniques for Object-Oriented Systems",
author = "Martin Atkins",
school = "University of York",
month = jun,
year = 1989
}

@article{atki83,
author = {Malcolm P. Atkinson and P.J. Bailey and K.J. Chisholm and W.P. Cockshott and Ron Morrison},
title = {An Approach to Persistent Programming},
journal = CompJ,
publisher = BCS,
volume = 26,
number = 4,
pages = {360--365},
month = dec,
year = 1983
}

@article{atki85,
title = "Procedures as Persistent Data Objects",
author = "Malcolm P. Atkinson and Ronald Morrison",
pages = "539--559",
journal = TOPLAS,
publisher = ACM,
year = 1985,
month = oct,
volume = 7,
number = 4
}

@inproceedings{atki89a,
  author =	 "Russ Atkinson and Alan Demers and Carl Hauser and Christian
                  Jacobi and Peter Kessler and Mark Weiser",
  title =	 "Experiences Creating a Portable {Cedar}",
  crossref =	 "PLDI89",
  pages =	 "322--329",
  doi =		 {10.1145/73141.74847}
}

@inproceedings{atta01,
title = {A Comparative Evaluation of Parallel Garbage Collectors},
author = {Clement R. Attanasio and David F. Bacon and Anthony Cocchi and Stephen Smith},
crossref = {LCPC01},
URL = {http://www.research.ibm.com/people/d/dfb/papers/Attanasio01Comparative.ps},
abstract = {Describes a suite of garbage collectors we implemented in
the IBM Jalapeo Java Virtual Machine, and quantitatively evaluates the
relative performance of the different collectors. With large amounts of
available memory, a generational semi-space copying collector performs
best. But a hybrid collector that uses a copying semi-space for the
young generation and a mark-and-sweep collector for the old generation
can run at close to the same speed in half the memory of other
collectors, thereby doubling the potential transaction throughput.
}
}

@techreport{atta94,
author = "Giuseppe Attardi and Tito Flagella",
title = "A Customisable Memory Management Framework",
institution = " International Computer Science Institute, Berkeley",
year = 1994,
number = "TR-94-010",
URL = "ftp://ftp.icsi.berkeley.edu:/pub/techreports/1994/tr-94-010.ps.Z",
note = "Also {USENIX} {C++} Conference, Cambridge, MA, 1994"
}

@inproceedings{atta94a,
author = "Giuseppe Attardi and Tito Flagella",
title = "A Customisable Memory Management Framework",
crossref = "ECOOP84",
pages = "320--343"
}

@inproceedings{atta95,
title = "Performance Tuning in a Customizable Collector",
author = "Giuseppe Attardi and Tito Flagella and Pietro Iglio",
crossref = "IWMM95",
pages = {179--196},
doi = {10.1007/3-540-60368-9_24}
}

@article{atta96,
title = {Memory Management in the {PoSSo} Solver},
author = {Giuseppe Attardi and Tito Flagella},
journal = {Journal of Symbolic Computation},
volume = 21,
number = 3,
pages = {293--311},
year = 1996
}

@article{atta98,
title = {A Customisable Memory Management Framework for {C++}},
author = "Giuseppe Attardi and Tito Flagella and Pietro Iglio",
journal = SPE,
month = nov,
year = 1998,
volume = 28,
number = 11,
pages = {1143--1183},
URL = {ftp://ftp.di.unipi.it/pub/Papers/attardi/SPE.ps.gz},
abstract = {Automatic garbage collection relieves programmers from the burden of
managing memory themselves and several techniques have been developed
that make garbage collection feasible in many situations, including
real time applications or within traditional programming
languages. However optimal performance cannot always be achieved by a
uniform general purpose solution.  Sometimes an algorithm exhibits a
predictable pattern of memory usage that could be better handled
specifically, delaying as much as possible the intervention of the
general purpose collector.  This leads to the requirement for
algorithm specific customisation of the collector strategies.  We
present a dynamic memory management framework which can be customised
to the needs of an algorithm, while preserving the convenience of
automatic collection in the normal case.  The Customisable Memory
Manager (CMM) organises memory in multiple heaps.  Each heap is an
instance of a C++ class which abstracts and encapsulates a particular
storage discipline.  The default heap for collectable objects uses the
technique of mostly copying garbage collection, providing good
performance and memory compaction.  Customisation of the collector is
achieved exploiting object orientation by defining specialised
versions of the collector methods for each heap class.  The object
oriented interface to the collector enables coexistence and
coordination among the various collectors as well as integration withtraditional code unaware of garbage collection.  The CMM is
implemented in C++ without any special support in the language or the
compiler.  The techniques used in the CMM are general enough to be
applicable also to other languages.  The performance of the CMM is
analysed and compared to other conservative collectors for C/C++ in
various configurations.}
}

@inproceedings{auer07,
  author =	 {Auerbach, Joshua and Bacon, David F. and B\"{o}mers, Florian
                  and Cheng, Perry},
  title =	 {Real-Time Music Synthesis in {J}ava using the {M}etronome
                  Garbage Collector},
  booktitle =	 {International Computer Music Conference},
  address =	 {Copenhagen, Denmark},
  year =	 2007,
  pages =	 {103--110},
  publisher =	 {University of Michigan Library},
  doi =		 {2027/spo.bbp2372.2007.132},
}

@inproceedings{auer07a,
author = {Auerbach, Joshua and Bacon, David F. and Iercan, Daniel T. and Kirsch,
Christopher M. and Rajan, V.T. and R\"{o}ck, Harald and Trummer, Rainer},
title = {Java Takes Flight: Time-portable Real-time Programming with {E}xotasks},
booktitle = {ACM SIGPLAN Conference on Languages, Compilers, and Tools
for Embedded Systems},
year = 2007,
pages = {31--62},
publisher = ACM
}

@inproceedings{auer07b,
title  = {Design and Implementation of a Comprehensive Real-time {J}ava Virtual
Machine},
author = {Joshua Auerbach and David F. Bacon and Bob Blainey and Perry Cheng and
Michael Dawson and Mike Fulton and David Grove and Darren Hart and Mark
Stoodley},
booktitle = {7th ACM \& IEEE International Conference on Embedded Software},
address = {Salzburg, Austria},
publisher = ACM,
pages = {249--258},
year = 2007,
month = sep,
doi = {10.1145/1289927.1289967},
abstract = {The emergence of standards for programming real-time
systems in Java has encouraged many developers to consider its use
for systems previously only built using C, Ada, or assembly language.
However, the RTSJ standard in isolation leaves many important
problems unaddressed, and suffers from some serious problems in
usability and safety.  As a result, the use of Java for real-time
programming has continued to be viewed as risky and adoption has
been slow.
In this paper we provide a description of IBM's new real-time Java
virtual machine product, which combines Metronome real-time garbage
collection, ahead-of-time compilation, and a complete implementation
of the RTSJ standard, running on top of a custom real-time
multiprocessor Linux kernel.
We will describe the implementation of each of these components, including how
they interacted both positively and negatively, and the extensions to previous
work required to move it from research prototype to a system implementing the
complete semantics of the Java language. The system has been adopted for hard
real-time development of naval weapons systems and soft real-time
telecommunications servers. We present measurements showing that the system is
able to provide sub-millisecond worst-case garbage collection latencies, 50
microsecond Linux scheduling accuracy, and eliminate non-determinism due to JIT
compilation.}
}

@inproceedings{auer08,
title = {Tax-and-Spend: Democratic Scheduling for Real-Time Garbage Collection},
author = {Joshua Auerbach and David F. Bacon and Perry Cheng and David Grove and
Ben Biron and Charlie Gracie and Bill McCloskey	 and Aleksandar Micic and Ryan
Sciampacone},
booktitle = {8th ACM International Conference on Embedded Software},
address = {Atlanta, GA},
publisher = ACM,
pages = {245--254},
year = 2008,
doi = {10.1145/1450058.1450092},
abstract = {Real-time Garbage Collection (RTGC) has recently advanced to the
point where it is being used in production for financial trading, military
command-and-control, and telecommunications. However, among potential users of
RTGC, there is enormous diversity in both application requirements and
deployment environments.
Previously described RTGCs tend to work well in a narrow band of possible environments, leading to fragile systems and limiting adoption of real-time garbage collection technology.
This paper introduces a collector scheduling methodology called tax-and-spend
and the collector design revisions needed to support it. Tax-and-spend provides
a general mechanism which works well across a variety of application, machine,
and operating system configurations. Tax-and-spend subsumes the predominant
pre-existing RTGC scheduling techniques. It allows different policies to be
applied in different contexts depending on the needs of the application. Virtual
machines can co-exist compositionally on a single machine.
We describe the implementation of our system, Metronome-TS, as an extension of
the Metronome collector in IBM's Real-time J9 virtual machine product, and we
evaluate it running on an 8-way SMP blade with a real-time Linux kernel.
Compared to the state-of-the-art Metronome system on which it is based,
implemented in the identical infrastructure, it achieves almost 3x shorter
latencies, comparable utilization at a 2.5x shorter time window, and mean
throughput improvements of 10-20\%}
}


@book{auge79,
author = "Moshe J. Augenstein and Aaron M. Tenenbaum",
title = "Data Structures using Pascal",
edition = "Second",
publisher = "Prentice-Hall",
address = "Englewood Cliffs, N. J.",
year = 1986,
comment = {book with sections on garbage collection},
}


@inproceedings{augu87,
title = "Garbage Collection in a Distributed Environment",
author = "Lex Augusteijn",
institution = "Philips Res Labs, Eindhoven, Netherlands",
crossref = "PARLE87",
volume = 259,
pages = "75--93",
doi = {10.1007/3-540-17945-3_4},
comment = "on-the-fly garbage collection, mark-sweep, termination
detection."
}


@inproceedings{augu84,
author = "Lennart Augustsson",
title = "A Compiler for Lazy {ML}",
pages = "218--227",
crossref = "LFP84",
}

@InProceedings{auha11,
  author =	 {Sven Auhagen and Lars Bergstrom and Matthew Fluet and John
                  Reppy},
  title =	 {Garbage Collection for Multicore {NUMA} Machines},
  crossref =	 {MSPC11},
  pages =	 {51--57},
  doi =          {10.1145/1988915.1988929}
}

@inproceedings{aust94,
  author =	 "Todd M. Austin and Scott E. Breachand and Gurindar S. Sohi",
  title =	 "Efficient Detection of All Pointer and Array Access Errors",
  crossref =	 "PLDI94",
  pages =	 "290--301",
  doi =		 {10.1145/182409.156783},
}

@article{axfo90,
title = "Reference Counting of Cyclic Graphs for Functional Programs",
author = "Thomas H. Axford",
address = "University Birmingham, Birmingham B15 2tt, W Midlands, England",
journal = CompJ,
publisher = BCS,
year = 1990,
volume = 33,
number = 5,
pages = "466--470",
doi={10.1093/comjnl/33.5.466}
}

@inproceedings{azag98,
author = {Alain Azagury and Elliot K. Kolodner and Erez Petrank and Zvi Yehudai},
title = {Combining Card Marking with Remembered Sets: How to Save Scanning Time},
pages = {10--19},
crossref = {ISMM98},
doi = {10.1145/286860.286862},
URL = {http://www.cs.technion.ac.il/~erez/papers.html},
abstract = {We consider the combination of card marking with remembered
sets for generational garbage collection as suggested by Hosking and
Moss. When more than two generations are used, a naive implementation
may cause excessive and wasteful scanning of the cards and thus
increase the collection time. We offer a simple data structure and a
corresponding algorithm to keep track of which cards need be scanned
for which generation. We then extend these ideas for the Train
Algorithm of Hudson and Moss. Here, the solution is more involved, and
allows tracking of which card should be scanned for which
car-collection in the train. }
}

@article{azag99,
author = {Alain Azagury and Elliot K. Kolodner and Erez Petrank},
title =	 {A Note on the Implementation of Replication-Based Garbage
          Collection for Multithreaded Applications and Multiprocessor
          Environments},
journal = {Parallel Processing Letters},
volume = 9,
number = 3,
year =	 1999,
doi =	 {10.1142/S0129626499000360},
URL =	 {http://www.cs.technion.ac.il/~erez/papers.html},
pages =	 {391--399},
publisher = WSP
}

@inproceedings{azat03,
author = {Hezi Azatchi and Yossi Levanoni and Harel Paz and Erez Petrank},
title = {An On-The-Fly Mark and Sweep Garbage Collector Based on Sliding Views},
doi = {10.1145/949305.949329},
pages = {269--281},
crossref = {OOPSLA03}
}

@inproceedings{azat03a,
  title =	 "Integrating Generations with Advanced Reference Counting
                  Garbage Collectors",
  author =	 "Hezi Azatchi and Erez Petrank",
  pages =	 "185--199",
  address =	 "Warsaw, Poland",
  booktitle =	 "12th International Conference on Compiler Construction",
  year =	 2003,
  month =	 may,
  publisher =	 SV,
  series =	 LNCS,
  volume =	 2622,
  doi = {10.1007/3-540-36579-6_14}
}

@article{azat03b,
  title =	 "Integrating Generations with Advanced Reference Counting
                  Garbage Collectors",
  author =	 "Hezi Azatchi and Erez Petrank",
  journal =	 CPE,
  volume =	 18,
  number =	 9,
  pages =	 {959--995},
  year =	 2006,
  publisher =	 "Wiley",
  doi =		 {10.1002/cpe.1005}
}

@inproceedings{azim07,
title = {{PATH}: Page Access Tracking to Improve Memory Management},
author = {Reza Azimi and Livio Soares and Michael Stumm and Thomas Walsh and
Angela Demke Brown},
pages = {31-42},
crossref = {ISMM07},
}

@techreport{azul08,
title = {Pauseless Garbage Collection},
institution = {Azul Systems Inc.},
author = {Azul},
month = jul,
year = 2008,
number = {AWP--005--020},
type = {White paper},
URL = {http://www.azulsystems.com/products/whitepaper/wp_pgc.pdf},
comment = {Adds generations to the Pauseless GC}
}

@techreport{azul10,
  title = 	 {Comparison of Virtual Memory Manipulation Metrics},
  institution = {Azul Systems Inc.},
  author = {Azul},
  year = 	 2010,
  type = 	 {White paper},
  URL = {http://www.managedruntime.org/files/downloads/AzulVmemMetricsMRI.pdf}
}

@article{baba83,
author = "Babaoglu, Ozalp and Domenico Ferrari",
title = "Two-Level Replacement Decisions in Paging Stores",
journal = IEEETransComp,
publisher = IEEE,
volume = "C-32",
number = 12,
month = dec,
year = 1983,
pages = {1151--1159}
}

@incollection{baba93,
author = {Babaoglu, Ozalp and Keith Marzullo},
title = {Consistent Global States of Distributed Systems: Fundamental Concepts and Mechanisms},
booktitle = {Distributed Systems},
editor = {S. Mullender},
publisher = AW,
pages = {55--96},
year = 1993
}


@inproceedings{back83,
title = "Derivation of Efficient {DAG} Marking Algorithms",
author = {R. J. R. Back and Heikki Mannila and Kari-Jouko R\"{a}ih\"{a}},
pages = "20--27",
crossref = "POPL83"
}

@inproceedings{baco96,
author = {David F. Bacon and Peter F. Sweeney},
title = {Fast Static Analysis of {C++} Virtual Function Calls},
pages = {324--34},
crossref = {OOPSLA96}
}

@inproceedings{baco01,
  title =	 {Java Without the Coffee Breaks: A Nonintrusive
                  Multiprocessor Garbage Collector},
  author =	 {David F. Bacon and Clement R. Attanasio and Han Bok Lee and
                  V. T. Rajan and Stephen E. Smith},
  crossref =	 {PLDI01},
  pages =	 {92-103},
  doi =		 {10.1145/378795.378819}
}

@inproceedings{baco01a,
title = {Concurrent Cycle Collection in Reference Counted Systems},
author = {David F. Bacon and V.T. Rajan},
doi = {10.1007/3-540-45337-7_12},
pages = {207--235},
crossref = {ECOOP01}
}

@inproceedings{baco02,
title = {Space- and Time-Efficient Implementation of the {J}ava Object Model},
author = {David F. Bacon and Stephen Fink and David Grove},
crossref = {ECOOP02},
doi = {10.1007/3-540-47993-7_5},
pages = {111-132}
}


@inproceedings{baco03,
  title =	 {A Real-Time Garbage Collector with Low Overhead and
                  Consistent Utilization},
  author =	 {David F. Bacon and Perry Cheng and V.T. Rajan},
  crossref =	 {POPL03},
  pages =	 {285-298},
  doi =		 {10.1145/604131.604155}
}

@inproceedings{baco03a,
  title =	 {Controlling Fragmentation and Space Consumption in the
                  {Metronome}, a Real-time Garbage Collector for {Java}},
  author =	 {David F. Bacon and Perry Cheng and V.T. Rajan},
  crossref =	 {LCTES03},
  pages =	 {81-92},
  doi =		 {10.1145/780732.780744}
}

@inproceedings{baco03b,
  title =	 {The {M}etronome: A Simpler Approach to Garbage Collection in
                  Real-Time Systems},
  author =	 {David F. Bacon and Perry Cheng and V.T. Rajan},
  pages =	 {466--478},
  doi =		 {10.1007/978-3-540-39962-9_52},
  address =	 {Catania, Sicily, Italy},
  month =	 nov,
  booktitle =	 {On The Move to Meaningful Internet Systems 2003: OTM 2003
                  Workshops},
  year =	 2003,
  series =	 LNCS,
  publisher =	 SV,
  volume =	 2889
}

@inproceedings{baco04,
  title =	 {A Unified Theory of Garbage Collection},
  author =	 {David F. Bacon and Perry Cheng and V. T. Rajan},
  crossref =	 {OOPSLA04},
  pages =	 {50--68},
  doi =		 {10.1145/1035292.1028982},
  abstract =	 {Tracing and reference counting are uniformly viewed as being
                  fundamentally different approaches to garbage collection
                  that posess very distinct performance properties. We have
                  implemented high-performance collectors of both types, and
                  in the process observed that the more we optimized them, the
                  more similarly they behavedthat they seem to share some deep
                  structure.  We present a formulation of the two algorithms
                  that shows that they are in fact duals of each
                  other. Intuitively, the difference is that tracing operates
                  on live objects, or "matter," while reference counting
                  operates on dead objects, or "anti-matter." For every
                  operation performed by the tracing collector, there is a
                  precisely corresponding anti-operation performed by the
                  reference counting collector.  Using this framework, we show
                  that all high-performance collectors (for example, deferred
                  reference counting and generational collection) are in fact
                  hybrids of tracing and reference counting. We develop a
                  uniform cost-model for the collectors to quantify the
                  tradeoffs that result from choosing different hybridizations
                  of tracing and reference counting. This allows the correct
                  scheme to be selected based on system performance
                  requirements and the expected properties of the target
                  application.}
}

@inproceedings{baco04a,
author = {David F. Bacon and Perry Cheng and David Grove},
title = {Garbage Collection for Embedded Systems},
booktitle = {International Conference on Embedded Software (EMSOFT'04)},
pages = {125-136},
year = 2004,
publisher = ACM
}

@inproceedings{baco05,
  title =	 {Syncopation: Generational Real-time Garbage Collection in
                  the {M}etronome},
  author =	 {David F. Bacon and Perry Cheng and David Grove and Martin T.
                  Vechev},
  crossref =	 {LCTES05},
  pages =	 {183-192},
  doi =		 {10.1145/1065910.1065937a},
  publisher =    ACM
}

@inproceedings{baco06,
  author =	 {David F. Bacon and Perry Cheng and Daniel Frampton and David
                  Grove and Matthias Hauswirth and V.T. Rajan},
  title =	 {On-line Visualization and Analysis of Real-time Systems with
                  {T}uning{F}ork},
  crossref =      {CC06},
  pages =	 {96--100},
  doi = {10.1007/11688839_8}
}

@article{baco07,
author = {David F. Bacon},
title = {Real-Time Garbage Collection},
journal = {{ACM} Queue},
volume = 5,
number = 1,
month = feb,
year = 2005,
pages = {40--49},
}

@inproceedings{baco12,
 author = {Bacon, David F. and Cheng, Perry and Shukla, Sunil},
 title = {And Then There Were None: a Stall-free Real-time Garbage Collector for Reconfigurable Hardware},
 crossref = {PLDI12},
 pages = {23--34},
 doi = {10.1145/2254064.2254068},
 abstract = {Programmers are turning to radical architectures such as
 reconfigurable hardware (FPGAs) to achieve performance. But such systems,
 programmed at a very low level in languages with impoverished abstractions, are
 orders of magnitude more complex to use than conventional CPUs. The continued
 exponential increase in transistors, combined with the desire to implement ever
 more sophisticated algorithms, makes it imperative that such systems be
 programmed at much higher levels of abstraction. One of the fundamental
 high-level language features is automatic memory management in the form of
 garbage collection.
We present the first implementation of a complete garbage collector in hardware
(as opposed to previous "hardware-assist" techniques), using an FPGA and its
on-chip memory. Using a completely concurrent snapshot algorithm, it provides
single-cycle access to the heap, and never stalls the mutator for even a single
cycle, achieving a deterministic mutator utilization (MMU) of 100\%.
We have synthesized the collector to hardware and show that it never consumes
more than 1\% of the logic resources of a high-end FPGA. For comparison we also
implemented explicit (malloc/free) memory management, and show that real-time
collection is about 4\% to 17\% slower than malloc, with comparable energy
consumption. Surprisingly, in hardware real-time collection is superior to
stop-the-world collection on every performance axis, and even for stressful
micro-benchmarks can achieve 100\% MMU with heaps as small as 1.01 to 1.4 times
the absolute minimum.}
} 

@inproceedings{baco12a,
 author = {Bacon, David F. and Cheng, Perry and Shukla, Sunil},
 title = {A Stall-free Real-time Garbage Collector for {FPGA}s},
 booktitle = {The Second Workshop on the Intersections of Computer Architecture
 and Reconfigurable Logic}, 
 year = 2012,
 URL = {http://researcher.ibm.com/files/us-bacon/Bacon12StallFree.pdf},
 abstract = {Programmers are turning to diverse architectures such as
 reconfigurable hardware (FPGAs) to achieve performance. But such systems are
 far more complex to use than conventional CPUs. The continued exponential
 increase in transistors, combined with the desire to implement ever more
 sophisticated algorithms, makes it imperative that such systems be programmed
 at much higher levels of abstraction. One fundamental high-level language
 features is automatic memory management in the form of garbage collection. We
 present the first implementation of a complete garbage collector in hardware
 (as opposed to previous ``hardware-assist'' techniques), using an FPGA and its
 on-chip memory. Using a completely concurrent snapshot algorithm, it provides
 single-cycle access to the heap, and never stalls the mutator for even a single
 cycle. We have synthesized the collector to hardware and show that it never
 consumes more than 1\% of the logic resources of a high-end FPGA. For
 comparison we also implemented explicit (malloc/free) memory management, and
 show that our collector is between 4\% to 17\% slower than malloc, with
 comparable energy consumption. Surprisingly, in hardware real-time collection
 is superior to stop-the-world collection on every performance axis, and even
 for stressful micro-benchmarks can achieve 100\% MMU with heaps as small as
 1.01 to 1.4 times the absolute minimum. This reprises work previously published
 in PLDI~\cite{baco12}.}
}

@inproceedings{baco14,
title = {Parallel Real-Time Garbage Collection of Multiple Heaps in Reconfigurable Hardware},
author = {David F. Bacon and Perry Cheng and Sunil Shukla},
pages = {117--127},
crossref = {ISMM14},
doi = {10.1145/2602988.2602996},
abstract = {Despite rapid increases in memory capacity, reconfigurable hardware
is still programmed in a very low-level manner, generally without any dynamic
allocation at all. This limits productivity especially as the larger chips
encourage more and more complex designs to be attempted.
Prior work has shown that it is possible to implement a real-time collector in
hardware and achieve stall-free operation --- but at the price of severe
restrictions on object layouts. We present the first hardware garbage collector
capable of collecting multiple inter-connected heaps, thereby allowing a rich
set of object types.
We show that for a modest additional cost in logic and memory, we can support
multiple heaps at a clock frequency competitive with monolithic, fixed-layout
heaps. We evaluate the hardware design by synthesizing it for a Xilinx FPGA and
using co-simulation to measure the run-time behavior over a set of four
benchmarks. Even at high allocation and mutation rates the collector is able to
sustain stall-free (100\% minimum mutator utilization) operation with up to 4
inter-connected heaps, while only requiring between 1.1 and 1.7 times the
maximum live memory of the application.}
}

@mastersthesis{bade82,
author = "Scott B. Baden",
title = "High Performance Reclamation in an Object-Based Memory System",
school = "Computer Science Division, Department of EECS, " # UCB,
year = 1982,
month = jun
}

@incollection{bade83,
author = "Scott B. Baden",
title = "Low-Overhead Storage Reclamation in the {S}malltalk-80 Virtual Machine",
crossref = "Smalltalk-BHWA",
pages = "331--342",
comment = "Reference counting: don't count references from roots -- reduces
manipulations by 90 percent and RC time by half"
}

@techreport{bade84,
author = "Baden, Scott B.",
title = "High Performance Storage Reclamation in an Object-Based Memory System",
institution = UCB,
type = "CSD",
year = 1984,
number = "84-167",
}

@article{baec70,
author = "H. D. Baecker",
title = "Implementing  the {A}lgol--68 Heap",
journal = "BIT",
volume = 10,
number = 4,
year = 1970,
pages = "405--414",
comment = "Proposes adding areas or regions to Algol-68. Each region maintains
a table of objects that reside in the region."
}

@article{baec72,
author = "H. D. Baecker",
title = "Garbage Collection for Virtual Memory Computer Systems",
journal = CACM,
publisher = ACM,
volume = 15,
number = 11,
month = Nov,
year = 1972,
pages = "981--986",
}

@article{baec73,
title = "Aspects of Reference Locality in List Structures in Virtual Memory",
author = "H. D. Baecker",
journal = SPE,
publisher = Wiley,
volume = 3,
number = 3,
year = 1973,
pages = "245--254"
}

@article{baec75,
author = "H. D. Baecker",
title = "Areas and Record Classes",
journal = CompJ,
publisher = BCS,
volume = 18,
number = 3 ,
month = Aug,
year = 1975,
pages = "223--226",
}

@article{baer76,
author = "Baer, Jean-Loup and Sager, Gary R.",
title = "Dynamic Improvement of Locality in Virtual Memory Systems",
journal = IEEETransSWE,
publisher = IEEE,
volume = "SE-2",
number = 1,
month = mar,
pages = {54-62},
year = 1976
}


@inproceedings{baer77,
author = "Jean-Loup Baer and M. Fries",
title = "On the Efficiency of some List Marking Algorithms",
pages = "751--6",
booktitle = "Information Processing 77, Toronto",
month = aug,
editor = "B. Gilchrist",
publisher = "North-Holland",
year = 1977
}

@phdthesis{bagh87,
author = "Bagherzadeh, Nader",
title = "Distributed Resource Management: Garbage Collection",
year = 1987,
school = "University of Texas at Austin"
}

@article{bagh91,
author = "Bagherzadeh, Nader and Heng, S-l. and Wu, C-l.",
title = "A Parallel Asynchronous Garbage Collection Algorithm for Distributed Systems",
journal = "IEEE Transactions on Knowledge and Data Engineering",
publisher = IEEE,
volume = 3,
number = 1,
month = mar,
pages = "100--107",
year = 1991
}

@book{bail75,
author = {Norman T.J.Bailey},
title = {The Mathematical Theory of Infectious Diseases and its Applications},
publisher = {Griffin},
edition = {2nd},
year = 1975,
ISBN = {0-8564264-231-8}
}

@article{bake85,
author = "Baker, Brenda and E. G. Coffman and D. E. Willard",
title = "Algorithms for Resolving Conflicts in Dynamic Storage Allocation",
journal = JACM,
publisher = ACM,
volume = 32,
number = 2,
pages = "327--343",
year = 1985,
doi = {10.1145/3149.335126},
month = apr
}

@techreport{bake77,
author = "Baker, Henry G. and Hewitt, Carl E.",
title = "The Incremental Garbage Collection of Processes",
institution = MIT,
year = 1977,
month = dec,
type = "AI memo",
number = "454"
}

@article{bake77a,
author = "Baker, Henry G. and Hewitt, Carl E.",
title = "The Incremental Garbage Collection of Processes",
journal = SIGPLAN,
publisher = ACM,
volume = 12,
number = 8,
pages = "55--59",
month = aug,
year = 1977,
URL = "http://home.pipeline.com/~hbaker1/Futures.ps.gz",
abstract = "An early discussion of the concept of 'futures' in a parallel functional programming language.
Naively uses 'reachability' for eliminating garbage processes, which is now known to be insufficient in the
presence of shared cells with assignment."
}

@article{bake78,
author = "Henry G. Baker",
title = "List Processing in Real-Time on a Serial Computer",
journal = CACM,
publisher = ACM,
volume = 21,
number = 4,
pages = "280--294",
year = "1978",
comment = "The best known real-time incremental copying gc.  Uses a read barrier.",
note = "Also AI Laboratory Working Paper 139, 1977",
doi = {10.1145/359460.359470},
URL = "http://home.pipeline.com/~hbaker1/RealTimeGC.ps.gz"
}

@techreport{bake78a,
author = "Henry G. Baker",
title = "Actor Systems for Real-Time Computation",
institution = "Laboratory for Computer Science",
number = "MIT Rep. TR--197",
month = Mar,
year = 1978,
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TR-197.html",
}

@incollection{bake79,
author = "Henry G. Baker",
title = "Optimizing Allocation and Garbage Collection of Spaces in {M}acL{L}isp",
booktitle = "Artificial Intelligence: An MIT Perspective",
editor = "Winston and Brown",
publisher = MIT,
year = 1979,
URL = "http://home.pipeline.com/~hbaker1/OptAlloc.ps.gz",
abstract = "How to allocate the sizes of the various spaces in 'big bag of pages' (BIBOP) garbage collection
systems"
}

@techreport{bake80,
author = "Baker, Henry G.",
title = "The Paging Behavior of the {C}heney List Copying Algorithm",
institution = "University of Rochester Computer Science Department",
year = 1980
}

@techreport{bake89,
author = "Henry G. Baker",
title = "Garbage Collection in {A}da",
institution = "Ada Joint Program Office",
type = "Ada-9X Revision Request",
number = 643,
year = 1989,
month = oct
}

@inproceedings{bake90,
author = "Henry G. Baker",
title = "Unify and Conquer (Garbage, Updating, Aliasing, \ldots) in Functional Languages",
crossref = "LFP90",
pages = "218--226",
}

@inproceedings{bake91,
author = "Baker, Henry G.",
title = "Cache-Conscious Copying Collection",
crossref = "OOPSLA91-gc",
URL = "http://home.pipeline.com/~hbaker1/CacheCGC.ps.gz",
}

@article{bake92,
author = "Baker, Henry G.",
title = "The Buried Binding and Dead Binding Problems of {Lisp} 1.5:
Sources of Incomparability in Garbage Collector Measurements",
journal = "Lisp Pointers",
publisher = ACM,
volume = 4,
number = 2,
pages = "11--19",
month = apr,
year = 1992
}

@article{bake92a,
title = "The {T}readmill, Real-time Garbage Collection without Motion Sickness",
author = "Henry G. Baker",
journal = SIGPLAN,
publisher = ACM,
volume = 27,
number = 3,
pages = "66--70",
month = Mar,
year = 1992,
doi = {10.1145/130854.130862},
URL = "http://home.pipeline.com/~hbaker1/NoMotionGC.ps.gz",
comment = {
Incremental non-copying GC with some of the advantages of a copying scheme.
Objects are held in a doubly-linked list and each has a "colour"
to indicate which (logical) space it is a member of.
Clever.
Doesn't deal with fragmentation.}
}

@article{bake92b,
author = "Henry  G. Baker",
title = "Lively Linear {L}isp --- `Look {M}a, No Garbage!'",
journal = SIGPLAN,
publisher = ACM,
volume = 27,
number = 9,
pages = "89--98",
month = aug,
year = 1992
}

@inproceedings{bake92c,
title = "{NREVERSAL} of Fortune --- Thermodynamics of Garbage Collection",
author = "Henry  G. Baker",
crossref = "IWMM92",
pages = {507--524},
doi = {10.1007/BFb0017210},
URL = "http://home.pipeline.com/~hbaker1/ThermoGC.ps.gz",
}

@article{bake92d,
title = "{CONS} should not {CONS} its Arguments, or a Lazy Alloc is a Smart Alloc",
author = "Henry G. Baker",
journal = SIGPLAN,
publisher = ACM,
volume = 27,
number = 3,
doi = {10.1145/130854.130858},
URL = "http://home.pipeline.com/~hbaker1/LazyAlloc.ps.gz",
month = Mar,
year = 1992
}

@article{bake93,
author = "Baker, Henry G.",
title = "`{I}nfant Mortality' and Generational Garbage Collection",
journal = SIGPLAN,
publisher = ACM,
volume = 28,
number = 4,
month = apr,
doi = {10.1145/152739.152747},
URL = "http://home.pipeline.com/~hbaker1/YoungGen.ps.gz",
pages = {55--57},
year = 1993,
comment = "A counterexample to the `most objects die young' notion showing
generational gc as ineffective in improving the average mark/cons ratio.
Other benefits --- better locality, smaller number of large delays ---
may still make generational gc attractive."
}

@article{bake93b,
author = "Baker, Henry G.",
title = "Safe and Leak-Proof Resource Management using {Ada83} Limited Types",
journal = "ACM Ada Leters",
publisher = ACM,
volume = 13,
number = 5,
pages = "32--42",
month = sep,
year = 1993
}

@article{bake93c,
author = "Baker, Henry G.",
title = "The Boyer Benchmark Meets Linear Logic",
journal = "Lisp Pointers",
publisher = ACM,
volume = 6,
number = 4,
month = oct,
year = 1993,
pages = "3--10"
}

@article{bake94,
author = "Baker, Henry G.",
title = "Minimising Reference Count Updating with Deferred and Anchored Pointers for Functional Data Structures",
URL = "http://home.pipeline.com/~hbaker1/LRefCounts.ps.gz",
journal = SIGPLAN,
publisher = ACM,
volume = 29,
number = 9,
month = sep,
year = 1994,
comment = {Baker claims that RC can be made more efficient. But he also strongly
supports Linear Logic. See
'A Linear Logic Quicksort' SIGPLAN 29(2), Feb, 1994, 13-18 and
'Linear Logic and Permutation stacks' ACM Comp. Arch. news 22(1), March, 1994, 34-43}
}

@article{bake95,
author = "Baker, Henry G.",
title = "Use-Once Variables and Linear Objects --- Storage Management, Reflection and Multi-threading",
journal = SIGPLAN,
publisher = ACM,
volume = 30,
number = 1,
year = 1995
}

@article{bake95a,
  author =	 "Henry G. Baker",
  title =	 {{CONS} Should Not {CONS} Its Arguments, Part II: {C}heney On
                  the M.T.A.},
  journal =	 SIGPLAN,
  publisher =	 ACM,
  volume =	 30,
  number =	 9,
  month =	 sep,
  year =	 1995,
  doi =		 {10.1145/214448.214454}
}

@inproceedings{bake06,
  title =	 {A Real-Time {J}ava Virtual Machine for Avionics --- An
                  Experience Report},
  author =	 {Jason Baker and Antonio Cunei and Chapman Flack and Filip
                  Pizlo and Marek Prochazka and Jan Vitek and Austin
                  Armbruster and Edward Pla and David Holmes},
  booktitle =	 {12th IEEE Real-Time and Embedded Technology and Applications
                  Symposium (RTAS)},
  pages =	 {384--396},
  year =	 2006,
  month =	 apr,
  address =	 {San Jose, CA},
  doi =		 {10.1109/RTAS.2006.7},
  URL =		 {http://www.cs.purdue.edu/homes/jv/pubs/rtas06.pdf}
}

@inproceedings{bake07,
title = {Accurate Garbage Collection in Uncooperative Environments with Lazy Pointer Stacks},
author = {Jason Baker and Antonio Cunei and Filip Pizlo and Jan Vitek},
booktitle = "International Conference on Compiler Construction",
address = {Braga, Portugal},
series = LNCS,
publisher =    SV,
volume = 4420,
month = mar,
year = 2007,
doi = {10.1007/978-3-540-71229-9_5},
URL ={http://www.cs.purdue.edu/homes/jv/pubs/cc07.pdf}
}

@article{bake09,
title = {Accurate Garbage Collection in Uncooperative Environments Revisited},
author = {Jason Baker and Antonio Cunei and Tomas Kalibera and Filip Pizlo and Jan Vitek},
journal = CPE,
year = 2009,
pages = {1572--1606},
volume = 21,
number = 12,
doi = {10.1002/cpe.1391},
note = {Supersedes \cite{bake07}}
}

@misc{bake92e,
author = "C. A. Baker-Finch",
title = "Relevance and Contraction: A  Logical Basis for Strictness and Sharing Analysis",
year = 1992,
note = "Submitted to " # JFP
}

@inproceedings{bake00,
author = {Adam Bakewell and Colin Runciman},
title = {A Model for Comparing the Space Usage of Lazy Evaluators},
booktitle = {2nd International Conference on Principles and Practice of Declarative Programming},
address = {Montreal},
month = sep,
year = 2000
}

@inproceedings{bake01,
author = {Adam Bakewell},
title = {Looking for leaks},
crossref = {SPACE01},
}

@article{bal91,
author = "Henri E. Bal and Andrew S. Tanenbaum",
title = "Distributed Programming with Shared Data",
journal = "Computer Languages",
volume = 16,
number = 2,
pages = "129--146",
year = 1991
}

@article{bal92,
author = "Henri E. Bal and M. Frans Kaashoek and Andrew S. Tanenbaum",
title = "Orca: A Language for Parallel Programming of Distributed Systems",
journal = TransSWE,
publisher = ACM,
volume = 18,
number = 3,
pages = "190--205",
year = 1992
}

@inproceedings{ball92,
author = "Thomas Ball and James Larus",
title = "Optimal Profiling and Tracing of Programs",
crossref = "POPL92",
pages = "59--70"
}

@incollection{ball83,
author = "Stoney Ballard and Stephen Shirron",
title = "The Design and Implementation of {VAX}/{S}malltalk-80",
crossref = "Smalltalk-BHWA",
pages = "127--150",
comment = "Variation of Lieberman-Hewitt collector; use indirection table;
don't like reference counting"
}

@inproceedings{bala05,
  title =	 {The Impact of Performance Asymmetry in Emerging Multicore
                  Architectures},
  author =	 {Saisanthosh Balakrishnan and Ravi Rajwar and Mike Upton and
                  Konrad Lai},
  booktitle =	 {32nd Annual} # ISCA,
  pages =	 {506--517},
  year =	 2005,
  doi =		 {10.1109/ISCA.2005.51},
  comment = 	 {http://www.stanford.edu/group/comparch/papers/balakrishnan05.pdf}
}

@article{bana94,
title = "Term Graph Rewriting and Garbage Collection using Opfibrations",
author = "R Banach",
journal = "Theoretical Computer Science",
volume = 131,
number = 1,
month = aug,
year =1994,
pages = "29--94"
}

@inproceedings{bane99,
author = {A. Banerjee and N. Heintze and J.G. Riecke},
title = {Region Analysis and the Polymorphic Lambda Calculus},
booktitle = {14th IEEE Symposium on Logic in Computer Science},
address = {Trento, Italy},
month = jul,
year = 1999,
publisher = IEEE,
pages = {88--97},
doi={10.1109/LICS.1999.782594}
}

@inproceedings{bara01,
author = {Katherine Barabash and N. Buchbinder and Tamar Domani and Elliot Kolodner and Yoav Ossia and S.S. Pinter and J. Shepherd and R.Sivan and V. Umansky},
title = {Mostly Accurate Stack Scanning},
crossref = {JVM01},
URL = {http://www.usenix.org/events/jvm01/barabash.html},
pages = {153--170}
}

@inproceedings{bara03,
title = {Mostly Concurrent Garbage Collection Revisited},
author = {Katherine Barabash and Yoav Ossia and Erez Petrank},
crossref = {OOPSLA03},
pages = {255--268},
doi = {10.1145/949305.949328},
URL = {http://www.cs.technion.ac.il/~erez/papers.html},
}

@article{bara05,
title = {A Parallel, Incremental, Mostly Concurrent Garbage Collector for Servers},
author = {Katherine Barabash and Ori Ben-Yitzhak and Irit Goft and Elliot K.
Kolodner and Victor Leikehman and Yoav Ossia and Avi Owshanko and Erez Petrank},
pages = {1097--1146},
journal = TOPLAS,
volume = 27,
number = 6,
month = nov,
year = 2005,
doi = {10.1145/1108970.1108972}
}

@inproceedings{bara10,
author = {Barabash, Katherine and Petrank, Erez},
title = {Tracing Garbage Collection on Highly Parallel Platforms},
crossref = {ISMM10},
pages = {1--10},
doi = {10.1145/1806651.1806653},
abstract = {The pervasiveness of multiprocessor and multicore hardware and the
rising level of available parallelism are radically changing the computing
landscape. Can software deal with tomorrow's potential higher parallelism? In
this paper we study this issue from the garbage collection perspective. In
particular, we investigate the scalability of parallel heap tracing, which
stands at the core of the garbage collection activity. Heap shapes can be
sequential in nature, and prevent the collector from scaling the trace. We start
by proposing the idealized trace utilization as a scalability measure for
evaluating the scalability of a given heap shape. We then examine standard Java
benchmarks and evaluate the existence of non-scalable object-graph shapes in
their execution. Next, we propose and implement a prototype of garbage
collection techniques that attempt to ameliorate the object-graph shape problem.
Finally, we measure and report their efficacy.}
}

@article{bara82,
author = "David R. Barach and David H. Taenzer and Robert E. Wells",
title = "A Technique for Finding Storage Allocation Errors in {C}-language Programs",
journal = SIGPLAN,
publisher = ACM,
volume = 17,
number = 5,
pages = "16--23",
month = may,
year = 1982
}

@techreport{barb71,
author = "M. Barbacci",
title = "A {LISP} Processor for {C}.ai",
institution = CMU,
type = "Memo",
number = "CMU-CS-71-103",
year = 1971
}

@inproceedings{bark86,
title = "Garbage Cut for Garbage Collection of Iterative {P}rolog Programs.",
author = "Jonas Barklund and H\o{a}kan Millroth",
booktitle = "Symposium on Logic Programming",
address={Salt Lake City, UT},
month=sep,
publisher = IEEEcomp,
pages = "276--283",
year = 1986,
URL = "ftp://ftp.csd.uu.se/pub/papers/reports/0038.ps.gz",
abstract = {
A strategy is presented for garbage collection in Prolog machines.
Its application to iterative programs and implications on programming style is
described.  An implementation of the garbage collection together with an
implementation of cut in an abstract machine for Prolog is suggested.  Some
benchmark figures are presented, indicating a two-fold speedup of garbage
collection for large programs.}
}

@techreport{bark86a,
title = {Garbage Cut},
author = {Jonas Barklund and H\o{a}kan Millroth},
institution = {Uppsala University},
number = 38,
URL = {ftp://ftp.csd.uu.se/pub/papers/reports/0038.ps.gz},
year = 1986
}

@techreport{bark87,
author = "Jonas Barklund",
title = "A Garbage Collection Algorithm for {T}ricia",
number = "37B",
institution = "Uppsala University",
year = 1987,
URL = {ftp://ftp.csd.uu.se/pub/papers/reports/0037.ps.gz}
}

@inproceedings{barn97,
author = {Nick Barnes and Richard Brooksby and David Jones and Gavin Matthews
and Pekka P. Pirinen and Nick Dalton and P. Tucker Withington},
title = {A Proposal for a Standard Memory Management Interface},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/harlequin.ps},
crossref = {OOPSLA97-gc}
}

@article{barn79,
author = {Jeff A. Barnett},
title = {Garbage collection versus swapping},
journal = SIGOPS,
volume = 13,
number = 3,
year = 1979
}

@inproceedings{barr93,
  title =	 "Using Lifetime Predictors to Improve Memory Allocation
                  Performance",
  author =	 "David A. Barrett and Benjamin G. Zorn",
  crossref =	 "PLDI93",
  pages =	 "187--196",
  doi =		 {10.1145/155090.155108},
  URL =          {ftp://ftp.cs.colorado.edu/pub/cs/techreports/zorn/PLDI-93-predictors.ps.Z},
  abstract =	 {Dynamic storage allocation is used heavily in many
                  application areas including interpreters, simulators,
                  optimizers, and translators.  We describe research that can
                  improve all aspects of the performance of dynamic storage
                  allocation by predicting the lifetimes of short-lived
                  objects when they are allocated.  Using five significant,
                  allocation-intensive C programs, we show that a great
                  fraction of all bytes allocated are short-lived (> 90\% in
                  all cases).  Furthermore, we describe an algorithm for
                  lifetime prediction that accurately predicts the lifetimes
                  of 42-99\% of all objects allocated.  We describe and
                  simulate a storage allocator that takes advantage of
                  lifetime prediction of short-lived objects and show that it
                  can significantly improve a program's memory overhead and
                  reference locality, and even, at times, improve CPU
                  performance as well.}
}

@techreport{barr93a,
author = "David A. Barrett and Benjamin Zorn",
title = "Garbage Collection using a Dynamic Threatening Boundary",
institution = "University of Colorado",
type = "Computer Science Technical Report",
number = "CU-CS-659-93",
month = jul,
year = 1993,
URL = "ftp://ftp.cs.colorado.edu/pub/cs/techreports/zorn/CU-CS-659-93.ps.Z",
abstract = {Generational techniques have been very successful in reducing the
impact of garbage collection algorithms upon the performance of programs.
However, it is impossible for designers of collection algorithms to anticipate
the memory allocation behavior of all applications in advance.  Existing
generational collectors rely upon the applications programmer to tune the
behavior of the collector to achieve  maximum performance for each application.
Unfortunately, because the many tuning parameters require detailed knowledge
of both the collection algorithm and the program allocation behavior in order
to be used effectively, such tuning is difficult and error-prone.  We propose
a new garbage collection algorithm that uses just two easily-understood
tuning parameters that directly reflect the maximum memory and pause time
constraints familiar to application programmers and users.
Like generational collectors, ours divides memory into two spaces,
one for short-lived, and another for long-lived objects.  Unlike previous
work, our collector dynamically adjusts the boundary between these
two spaces in order to directly meet the resource constraints specified by the
user.  We describe two methods for adjusting this boundary, compare them with
several existing algorithms, and show how effectively ours meets
the specified constraints.  Our pause-time collector saved memory by holding
median pause times closer to the constraint than the other pause-time
constrained algorithm and, when not over-constrained, our memory-constrained
collector exhibited the lowest CPU overhead of the algorithms we measured
yet was capable of maintaining a maximum memory constraint.}
}

@inproceedings{barr95,
  author =	 "David A. Barrett and Benjamin Zorn",
  title =	 "Garbage Collection using a Dynamic Threatening Boundary",
  crossref =	 "PLDI95",
  pages =	 {301-314},
  doi =		 {10.1145/207110.207164}
}

@inproceedings{barr98,
author = {L.A. Barroso and K. Gharachorloo and E. Bugnion},
title = {Memory System Characterization of Commercial Workloads},
booktitle = "25th Annual " # ISCA,
pages = {3--14},
year = 1998,
doi = {10.1145/279358.279363}
}

@article{bart77,
author = "Jeffrey M. Barth",
title = "Shifting Garbage Collection Overhead to Compile Time",
journal = CACM,
publisher = ACM,
volume = 20,
number = 7 ,
month = jul,
year = 1977,
pages = "513--518",
}


@techreport{bart88,
author = "Bartlett, Joel F.",
title = "Compacting Garbage Collection with Ambiguous Roots",
type = "WRL Research Report",
number = "88/2",
URL = "http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-88-2.pdf",
institution = DECWRL,
month = feb,
comment = "Excellent trick here---make newness a page property, not an
  address-range property",
note = "Also appears as \cite{bart88a}.",
year = 1988
}

@article{bart88a,
  author =	 {Joel F. Bartlett},
  title =	 {Compacting Garbage Collection with Ambiguous Roots},
  journal =	 {Lisp Pointers},
  publisher =	 ACM,
  year =	 1988,
  volume =	 1,
  number =	 6,
  pages =	 {3--12},
  month =	 apr,
  doi =		 {10.1145/1317224.1317225}
}

@techreport{bart89,
author = "Joel F. Bartlett",
title = "Mostly-{C}opying Garbage Collection picks up Generations and {C++}",
institution = DECWRL,
type = "Technical Note",
number = "TN--12",
month = oct,
year = "1989",
URL = "http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-TN-12.pdf",
comment = "Sources available in ftp://ftp.digital.com/pub/DEC/CCgc",
}

@techreport{bart89a,
author = "Joel F. Bartlett",
title = "{SCHEME}-$>${C}: a Portable {S}cheme-to-{C} Compiler",
institution = DECWRL,
type = "WRL Research Report",
number = "89/1",
month = jan,
URL = "http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-89-1.pdf",
year = 1989
}

@inproceedings{bart90,
author = "Joel F. Bartlett",
title = "A Generational, Compacting Collector for {C++}",
crossref = "OOPSLA90-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC90/Bartlett.ps.Z",
}

@inproceedings{basa05,
title = {Towards Distributed Garbage Collection in Distributed Real-Time {J}ava},
author = {Basanta-Val, Pablo and Garcia-Valls, Marisol and Estévez-Ayres, I.},
crossref = {ISORC05},
pages = {382--389},
doi = {10.1109/ISORC.2005.61},
abstract = {This paper presents a memory management solution for distributed
real-time Java. The proposed model is targeted at distributed applications that
require to keep their internal state and that consume a bounded memory size in
their operation. The aim is to provide an alternative to the garbage collector
for distributed real-time systems and to avoid the penalties it introduces. The
approach is based on the usage of scoped memory defined in the real-time
specification for Java (RTSJ). Our solution introduces constraints in the
programming model and in the current distributed Java architecture. However,
these are compensated by eliminating the dependency of the garbage collector in
the end-to-end invocation and by achieving self-cleaning with respect to the
memory consumed by remote invocations.}
}

@misc{basa14§,
title = {A Simple Distributed Garbage Collector for Distributed Real-Time {J}ava
(DRAFT)},
author = {Basanta-Val, Pablo and Garcia-Valls, Marisol},
howpublished = {Draft for The Journal of Supercomputing},
year = 2014,
url =
{https://www.researchgate.net/publication/263302917_A_simple_distributed_garbage_collector_for_distributed_real-time_Java_%28DRAFT%29?pli=1&loginT=5e00XVGtyZl7YJQgkzD8JMW1WONr97LiSY6prTKfLAs*&uid=dadf0630-9a6f-459d-a2bc-1922114830f8&cp=re290_up_p11&ch=reg},
abstract = {The use of real-time distribution middleware programmed with
high-level languages like Java is becoming of increasing interest in next generation
applications. Technology like Java’s RMI (Remote Method Invocation) paves
the way towards these new distributed horizons. RMI offers many high-level
abstractions useful for distributed application programmers to reduce their
development times. One of these abstractions is a distributed garbage collector
(DGC) that removes unreachable remote objects from the distributed ecosystem.
However, in real-time Java, distributed garbage collection is under-specified
and it introduces unbounded indeterminism on end-to-end real-time Java
communications. This article analyses this problem proposing a simple
characterization for a predictable real-time distributed garbage collector (RT-DGC).
The approach requires support from the middleware infrastructure that
implements the abstraction but it also introduces bounded overhead. The 
article provides insight on the performance that RT-DGC offers to a distributed
real-time Java application and the extra overheads due to the intrinsic cost of
this abstraction.}
}

@article{bast88,
title = "Concurrent Maintenance of Data-Structures in a Distributed
Environment",
author = "F. B. Bastani and S. S. Iyengar and I. L. Yen",
address = "University of  Houston, Department of Computer Science",
journal = CompJ,
publisher = BCS,
year = 1988,
volume = 31,
number = 2,
pages = "165--174"
}


@inproceedings{bate82,
author = "Raymond L. Bates and David Dyer and Johannes A. G. M. Koomen",
title = "Implementation of {I}nterlisp on {VAX}",
crossref = "LFP82",
pages = "81--87"
}

@article{bats76,
author = "Alan Batson",
title = "Program Behavior at the Symbolic Level",
journal = "{IEEE} Computer",
publisher = IEEE,
month = nov,
year = 1976,
pages = "21--26"
}

@article{bats77,
author = "Alan P. Batson and R. E. Brundage",
title = "Segment Sizes and Lifetimes in {ALGOL} 60 Programs",
journal = CACM,
publisher = ACM,
volume = 20,
number = 1,
year = 1977,
month = jan,
pages = {36--44}
}

@book{baue82,
title = "Algorithmic Language and Program Development",
author = {F. L. Bauer and H. W\"{o}ssner},
publisher = SV,
year = 1982,
comment = "Contains useful chapters on recursion removal and transformation
of recursion into iteration."
}

@article{baum91,
title = "Computer Scheduling Algorithms --- Past,  Present,  and Future",
author = "K. M. Baumgartner and B. W. Wah",
address = "Digital Equipment Corp, Maynard, Ma, 01754 Univ Illinois,
Coordinated Science Laboratory, Urbana, Il, 61801",
journal = "Information Sciences",
month = Sep,
year = 1991,
pages = "319--345"
}

@techreport{bawd77,
author = "A. Bawden and Richard Greenblatt and J. Holloway and T. Knight and David A. Moon and D. Weinreb",
title = "{L}isp Machine Progress Report",
number = "Memo 444",
institution = "A.I. Lab",
address = "MIT, Cambridge, MA",
month = Aug,
year = 1977,
}

@article{bayl00,
author = {Baylor, S.J. and Devarakonda, M. and Fink, S. and Gluzberg, E. and
Kalantar, M. and  Muttineni, P. and Barsness, E. and Munroe, S. and Arora, R.
and Dimpsey, R.},
title = "{J}ava Server Benchmarks",
journal = ISJ,
volume = 39,
number = 1,
year = 2000
}

@article{bays77,
author = "C. Bays",
title = "A Comparison of Next-Fit, First-Fit and Best-Fit",
journal = CACM,
publisher = ACM,
volume = 20,
number = 3,
pages = "191--192",
month = mar,
year = 1977
}

@phdthesis{beau91,
author = "Barbara Beaudoing",
title = {Recycler-en-Marquant: Un Algorithme de Gestion de M\'{e}moire en Temps
R\'{e}el, \'{E}tude et Implantation},
school = {Universit\'{e} de Paris VI},
year = 1991
}

@inproceedings{beeb01,
author = {{Beebee, Jr.}, William S. and Martin Rinard},
title = {An Implementation of Scoped Memory for Real-Time {J}ava},
crossref = {EMSOFT01},
pages = {289--305},
}

@inproceedings{bece03,
author = {Yolanda Becerra and Toni Cortes and Jordi Garcia and Nacho Navarro},
title = {Evaluating the Importance of Virtual Memory for {J}ava},
booktitle = {IEEE International Symposium on Performance Analysis of Systems and Software},
year = 2003,
month = mar,
pages = {101--110},
publisher = IEEE,
doi = {10.1109/ISPASS.2003.1190237},
address = {Austin, TX},
}

@article{beck82,
author = "Leland L. Beck",
title = "A Dynamic Storage Allocation Technique based on Memory Residence Time",
journal = CACM,
publisher = ACM,
volume = 25,
number = 10,
month = oct,
year = 1982,
pages = "714--724"
}

@techreport{beck86,
author = "Michael J. Beckerle and Kattamuri Ekanadham",
title = "Distributed Garbage Collection with no Global Synchronisation",
institution = IBM,
type = "Research Report",
number = "RC 11667 (\#52377)",
month = jan,
year = 1986,
comment = "Handles cycles"
}

@inproceedings{beem90,
author = "Marcel Beemster",
title = "Back-end Aspects of a Portable {POOL--X} Implementation",
booktitle = "Parallel Database Systems PRISMA Workshop",
doi = {10.1007/3-540-54132-2_58},
editor = "Pierre America",
series = LNCS,
volume = 503,
publisher = SV,
pages = "193--228",
year = 1990,
month = sep,
address={Noordwijk, The Netherlands}
}

@inproceedings{beg10,
author = {Beg, Mirza and van Beek, Peter},
title = {A Graph Theoretic Approach to Cache-Conscious Placement of Data for Direct Mapped Caches},
crossref = {ISMM10},
pages = {113--120},
doi = {10.1145/1806651.1806670},
abstract = {Caches were designed to amortize the cost of memory accesses by
moving copies of frequently accessed data closer to the processor. Over the
years the increasing gap between processor speed and memory access latency has
made the cache a bottleneck for program performance. Enhancing cache performance
has been instrumental in speeding up programs. For this reason several hardware
and software techniques have been proposed by researchers to optimize the cache
for minimizing the number of misses. Among these are compile-time data placement
techniques in memory which improve cache performance. For the purpose of this
work, we concern ourselves with the problem of laying out data in memory given
the sequence of accesses on a finite set of data objects such that cache-misses
are minimized. The problem has been shown to be hard to solve optimally even if
the sequence of data accesses is known at compile time. In this paper we show
that given a direct-mapped cache, its size, and the data access sequence, it is
possible to identify the instances where there are no conflict misses. We
describe an algorithm that can assign the data to cache for minimal number of
misses if there exists a way in which conflict misses can be avoided altogether.
We also describe the implementation of a heuristic for assigning data to cache
for instances where the size of the cache forces conflict misses. Experiments
show that our technique results in a 30\% reduction in the number of cache misses
compared to the original assignment.},
}

@article{bekk83,
author = "Yves Bekkers and B. Canet and Olivier Ridoux and L. Ungaro",
title = "A Short Note on Garbage Collection in {P}rolog Interpreters",
journal = "Logic Programming Newsletter",
volume = 5,
year = 1983,
comment = "Some binding values may become useless.",
}

@inproceedings{bekk84,
author = "Yves Bekkers and B. Canet and Olivier Ridoux and L. Ungaro",
title = "A Memory Management Machine for {P}rolog Interpreters",
crossref = "ICLP84",
pages = "343--351",
comment = "Traverse goal-statements in the backtrack stack but consider binding status.",
}

@inproceedings{bekk86,
author = "Yves Bekkers and B. Canet and Olivier Ridoux and L. Ungaro",
title = "{MALI}: A Memory with a Real-Time Garbage Collector for
Implementing Logic Programming Languages",
booktitle = "3rd Symposium on Logic Programming",
publisher = IEEE,
year = 1986,
comment = "Traverse goal-statements in the backtrack stack but consider binding status.",
}

@article{bekk85,
author = "Yves Bekkers and B. Canet and Olivier Ridoux and L. Ungaro",
title = "A Memory Management Machine for {P}rolog",
journal = {Informatique--85, Symposium Sovi\'{e}to-Fran\c{c}ais, Tallin},
pages = "111--117",
year = 1985,
}

@inproceedings{bekk91,
author = "Yves Bekkers and L. Ungaro",
title = "Implementing Parallel Garbage Collection for {P}rolog",
booktitle = "Russian Conference on Logic Programming",
series = LNCS,
publisher =    SV,
volume = 592,
editor = "A. Voronkov",
year = 1991,
}

@inproceedings{bekk92a,
title = "Dynamic Memory Management for Sequential Logic Programming Languages",
author = "Yves Bekkers and Olivier Ridoux and L. Ungaro",
crossref = "IWMM92",
pages = {82--102},
doi = {10.1007/BFb0017184}
}

@inproceedings{bena82,
title = "On-The-Fly Garbage Collection: New Algorithms Inspired by Program Proofs",
author = "Mordechai Ben-Ari",
pages = "14--22",
booktitle = "Automata, languages and programming. Ninth colloquium",
address = "Aarhus, Denmark",
month = "July 12--16",
year = 1982,
editor = "M.  Nielsen and E. M. Schmidt",
publisher = SV,
doi = {10.1145/579.587}
}

@article{bena84,
author = "Mordechai Ben-Ari",
title = "Algorithms for On-The-Fly Garbage Collection",
journal = TOPLAS,
publisher = ACM,
volume = 6,
number = 3,
pages = "333--344",
month = jul,
year = 1984,
doi = {10.1145/579.587},
comment = {This paper presents alternative methods of on-the-fly garbage
collection \cite{Dijk78} with simpler proofs.}
}

@techreport{bend10,
  author =	 {Anna Bendersky and Erez Petrank},
  title =	 {Space Overhead Bounds for Dynamic Memory Management with
                  Partial Compaction},
  institution =	 {Technion, Israel},
  URL = {http://www.cs.technion.ac.il/~erez/Papers/MemoryBounds-fullver.pdf},
  note =	 {Full version of \cite{bend11}.},
  month =	 jul,
  year =	 2010
}

@inproceedings{bend11,
  author =	 {Anna Bendersky and Erez Petrank},
  title =	 {Space Overhead Bounds for Dynamic Memory Management with
                  Partial Compaction},
  crossref =	 {POPL11},
  pages =	 {475--486},
  doi =		 {10.1145/1926385.1926441}
}

@article{bend12,
  title={Space Overhead Bounds for Dynamic Memory Management with Partial Compaction},
  author={Bendersky, Anna and Petrank, Erez},
  journal=TOPLAS,
  volume=34,
  number=3,
  pages=13,
  year=2012,
  publisher=ACM
}

@inproceedings{bene81,
author = "V. E. Benes",
title = "Models and Problems of Dynamic Storage Allocation",
booktitle = "Applied Probability and Computer Science --- the Interface",
publisher = "Institute of Management Science and Operations Research Society of America",
month = jan,
year = 1981
}

@inproceedings{beng90,
author = "Mats Bengtsson and Boris Magnusson",
title = "Real-time Compacting Garbage Collection",
crossref = "OOPSLA90-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC90/Bengtsson.ps.Z",
}

@mastersthesis{beng90a,
author = "Mats Bengtsson",
title = "Real-time Compacting Garbage Collection Algorithms",
school = "Department of Computer Science, Lund University",
year = 1990,
type = "Licentiate thesis",
URL = "http://www.dna.lth.se/Research/ProgEnv/Abstracts/Thesis.MB.abs.html"
}

@inproceedings{benn87,
author = "J. K. Bennett",
title = "The Design and Implementation of Distributed {S}malltalk",
crossref = "OOPSLA87",
pages = "318--330",
}

@inproceedings{benn90,
  author =	 "J. Bennet and J. Carter and W. Zwaenepoel",
  title =	 "Munin: Distributed Shared Memory based on Type-Specific
                  Memory Coherence",
  crossref =	 "PPoPP90",
  pages =	 "168--176",
}

@inproceedings{bens97,
title = {The Memory Manager for the {A}urora {J}ava {V}irtual {M}achine Testbed},
author = {Peter Benson},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/pbenson.ps},
crossref = {OOPSLA97-gc}
}

@inproceedings{bent06,
title = {Abstracting Allocation: The {N}ew New Thing},
author = {Nick Benton and Noah Torp-Smith},
pages = {108--110},
crossref = {SPACE06}
}

@inproceedings{beny02,
title = {An Algorithm for Parallel Incremental Compaction},
author = {Ori Ben-Yitzhak and Irit Goft and Elliot Kolodner and Kean Kuiper and Victor Leikehman},
crossref = {ISMM02},
pages = {100--105},
doi= {10.1145/512429.512442}
}

@techreport{berg88,
author = "Bergstein, Steven H.",
title = "Best-Case Caching in a Symbolic Multiprocessor",
institution = "Massachusetts Institute of Technology EECS Department",
month = feb,
year = 1988,
address = "Cambridge, MA",
type = "Bachelor's thesis"
}

@techreport{berg99,
author = "Emery D. Berger and Robert D. Blumofe",
title = "{H}oard: A Fast, Scalable, and Memory-Efficient Allocator for
Shared-Memory Multiprocessors",
institution = "University of Texas at Austin",
number = "UTCS TR99-22",
year = 1999,
month = nov,
URL = "http://www.cs.utexas.edu/users/emery/hoard/download2.cgi?location=UTCS-TR99-22.ps.gz",
}

@inproceedings{berg00,
  title =	 {Hoard: A Scalable Memory Allocator for Multithreaded
                  Applications},
  author =	 {Emery Berger and Kathryn McKinley and Robert Blumofe and
                  Paul Wilson},
  crossref =	 {ASPLOS00},
  pages =	 {117--128},
  doi =		 {10.1145/356989.357000},
  URL =		 {ftp://ftp.cs.umass.edu/pub/osl/papers/asplos2000.ps.gz}
}

@inproceedings{berg01,
  title =	 {Composing High-Performance Memory Allocators},
  author =	 {Emery D. Berger and Benjamin G. Zorn and Kathryn
                  S. McKinley},
  crossref =	 {PLDI01},
  pages =	 {114-124},
  doi =		 {10.1145/378795.378821},
  URL =		 {ftp://ftp.cs.umass.edu/pub/osl/papers/pldi2001.ps.gz}
}

@inproceedings{berg02,
author = "Emery D. Berger and Benjamin G. Zorn and Kathryn S. McKinley",
title = "Reconsidering Custom Memory Allocation",
crossref = {OOPSLA02},
URL = "http://citeseer.nj.nec.com/berger01reconsidering.html",
abstract = {
Programmers hoping to achieve performance improvements often use
custom memory allocators. This in-depth study examines eight
applications that use custom allocators. Surprisingly, for six of
these applications, a state-of-the-art general-purpose allocator (the
Lea allocator) performs as well as or better than the custom
allocators. The two exceptions use regions, which deliver higher
performance (improvements of up to 44\%). Regions also reduce
programmer burden and eliminate a source of memory leaks. However, we
show that the inability of programmers to free individual objects
within regions can lead to a substantial increase in memory
consumption. Worse, this limitation precludes the use of regions in
common programming idioms, reducing their usefulness.

We present a generalization of general-purpose and region-based
allocators that we call {\em reaps}. Reaps are a combination of
regions and heaps, providing a full range of region semantics with the
addition of individual object deletion. We show that our
implementation of reaps provides high performance, outperforming other
allocators with region-like semantics. Our results indicate that
programmers needing fast regions should use reaps, and that most
programmers considering custom allocators should instead use the Lea
allocator.  }
}

@article{berr78,
author = "Berry, D. M. and Chirica, L. M. and Johnston, J. B. and Martin, D. F. and Sorkin A.",
title = "Time Required for Garbage Collection in Retention Block-Structured Languages",
journal = "Journal of Computer Information Science",
volume = 7,
number = 1 ,
year = 1978,
pages = "361--404",
}

@misc{berr02,
author = {Robert F. Berry},
title = {The Business Importance of {J}ava Garbage Collection},
crossref = {ISMM02},
note = {Invited talk.}
}

@article{berz65,
author = "A. T. Bertziss",
title = "A Note on the Storage of Strings",
journal = CACM,
publisher = ACM,
volume = 8,
number = 8,
month = aug,
year = 1965,
pages = "512--513"
}

@book{berz75,
author = "A. T. Berztiss",
title = "Data Structures Theory and Practice",
edition = "Second",
publisher = AP,
year = 1975,
comment = {book with sections on garbage collection},
}

@techreport{bess07,
title = {Computing Stack Maps with Interfaces},
author = {Fr\'{e}d\'{e}ric Besson and Thomas Jensen and Tiphaine Turpin},
institution = {INRIA, Universit\'{e} Rennes I, Institut National des Sciences Appliqu\'{e}es de Rennes},
type = {Research report},
number = {PI 1879},
year = 2007,
URL = {http://hal.inria.fr/action/open_file.php?url=http://hal.inria.fr/docs/00/20/07/24/PDF/PI-1879.pdf&docid=200724},
abstract = {Lightweigth byte code verification uses stack maps to annotate Java
byte code programs with type information so that the byte code verifier (BCV)
only has to check this typing, without having to do any data flow analysis. This
report describes an improved analysis technique together with algorithms for
optimizing the stack maps generated by the analyser. The improved BCV is based
on a modified version of the abstract domain. This domain is simplified in its
treatment of base values, keeping only the necessary information to ensure the
memory safety property. It is richer in its representation of interface types,
using the known Dedekind-MacNeille completion technique to construct abstract
domain elements representing sets of interfaces. Tracking interface information
allows to remove the dynamic checks at interface method invocations. We prove
the memory safety property guaranteed by BCV using an operational semantics
whose distinguishing feature is a low-level memory model operating on untagged
32-bit values, as opposed to the standard, higher-level memory models using
tagged memory objects. For bytecode that is typable without sets of types (this
includes any code compiled from Java) we show how to prune the fix-point to
obtain a stack map that can be validated without the interface set computations
arising from this extension. In the context of lightweight verification, this is
an advantage as it does not make the verification more complex or costly. The
size of the certificates is not significantly modified. Experiments show that
the pruning can be done by reasonably efficient (though in theory exponential)
algorithms that uses heuristics to explore the space of valid program typings
from the least fixpoint generated by the analyser. Stack maps for three
substantial test suites were correctly handled by the optimized (but incomplete)
pruning algorithm.}
}

@inproceedings{bess08,
title = {Computing Stack Maps with Interfaces},
author = {Fr\'{e}d\'{e}ric Besson and Thomas Jensen and Tiphaine Turpin},
crossref = {ECOOP08}
}

@article{bett73,
title = "An Analytical Storage Allocation Model",
author = "Terry Betteridge",
journal = ActInf,
publisher = SV,
volume = 3,
year = 1973,
pages = "101--122"
}

@book{bett82,
author = "Terry Betteridge",
title = "An Algebraic Analysis of Storage Fragmentation",
publisher = "UMI Research Press",
address = "Ann Arbor, Michigan",
year = 1982
}

@inproceedings{beva87,
author = "David I. Bevan",
title = "Distributed Garbage Collection using Reference Counting",
crossref = {PARLE87},
volume = 259,
pages = "176--187",
doi = {10.1007/3-540-17945-3_10},
comment = "Weighted reference count algorithm (see also \cite{wats87})
reduces communication overheads."
}

@article{beva88,
title = "An Efficient Reference Counting Solution to the Distributed Garbage
Collection Problem",
author = "David I. Bevan",
journal = {Parallel Computing},
volume = 9,
number = 2,
month = jan,
year = 1989,
pages = {179--192},
doi = {10.1016/0167-8191(89)90127-0},
abstract = {
A good programming language permits the programmer to concentrate
on his application rather than on low-level implementation details.  In
particular, he does not have to concern himself with storage allocation
because memory management is dealt with efficiently by the implementation of
the language.  To reclaim disused storage for reuse the implementation
incorporates a garbage collection algorithm.  When the language is implemented
on a distributed multiprocessor architecture, this algorithm ideally collects
garbage as soon as it is created and has minimal overheads in terms of space
requirements and interprocess communications.  We describe here an elegant
algorithm with these properties which makes use of reference counting.}
}

@inproceedings{beve94,
author = {Johan Bevemyr and Thomas Lindgren},
title = {A Simple and Efficient Copying Garbage Collector for {P}rolog},
booktitle = {PLILP94 International Symposium on Programming Language Implementation and Logic Programming},
pages = {88--101},
year = 1994,
URL = {ftp://ftp.csd.uu.se/pub/papers/reports/0087.ps.gz}
}

@techreport{beve95,
author = {Johan Bevemyr},
title = {A Generational Parallel Copying Garbage Collector for Shared Memory {P}rolog},
institution = {Uppsala University},
number = 117,
month = oct,
year = 1995,
URL = {ftp://ftp.csd.uu.se/pub/papers/reports/0117.ps.gz}
}

@article{beye79,
title = "A Space Efficient Dynamic Allocation Algorithm for Queuing Messages",
author = "Eric Beyer and Peter Buneman",
journal = TOPLAS,
publisher = ACM,
year = 1979,
month = oct,
volume = 1,
number = 2,
pages = "287--294"
}

@inproceedings{bhat06,
title = {Memory-Manager/Scheduler Co-Design: Optimizing Event-Driven Servers to Improve Cache Behavior},
author = {Sapan Bhatia and Charles Consel and Julia Lawall},
pages = {104--114},
crossref = {ISMM06},
}

@inproceedings{biag94,
  author =	 "Edoardo Biagioni and Robert Harper and Peter Lee and Brian
                  Milnes",
  title =	 "Signatures for a Network Protocol Stack: A Systems
                  Application of {S}tandard {ML}",
  crossref =	 "LFP94",
  doi =		 {10.1145/182409.182431}
}

@inproceedings{biel99,
title = {Implementing a Distributed Garbage Collector for {OO} Databases},
author = {Richard Bielak and Jean-Pierre Sarkis},
organisation = {CAL FP Bank, USA},
booktitle = {TOOLS USA '99 Technology of Object-Oriented Languages and Systems},
address = {Santa Barbara, CA},
month = aug,
year = 1999
}

@inproceedings{bigl85,
author = "B. M. Bigler and S. J. Allan and Rod R. Oldehoeft",
title = "Parallel Dynamic Storage Allocation",
booktitle = "1985 International Conference on Parallel Processing",
year = 1985,
pages = "272--275"
}

@inproceedings{bili92,
author = "Biliris, Alexandros",
title = "An Efficient Database Storage Structure for Large Dynamic
Objects",
booktitle = "8th International Conference on Data Engineering",
publisher = IEEE,
address = "Tempe, AZ",
month = feb,
year = 1992,
pages = "301--308",
doi = {10.1109/ICDE.1992.213180}
}

@inproceedings{bing93,
title = "Experiences Developing and Using an Object-Oriented Library for Program Manipulation",
author = "Tim Bingham and Nancy Hobbs and Dave Husson",
crossref = "OOPSLA93",
comment = "Boehm GC greatly improved dynamically allocated memory usage, but GC
is not a substitute for well-designed classes."
}

@inproceedings{birk96,
author = {Lars Birkedal and Mads Tofte and Magnus Vejlstrup},
title = {From Region Inference to von {N}eumann Machines via Region Representation Inference},
crossref = {POPL96},
URL = {http://www.diku.dk/users/tofte/publ/popl96.ps}
}

@inproceedings{birk04,
author = {Lars Birkedal and Noah Torp-Smith and John C. Reynolds},
title = {Local Reasoning about a Copying Garbage Collector},
crossref = {POPL04},
pages = {220--231}
}

@article{birm87,
title = "Exploiting Virtual Synchrony in Distributed Systems",
author = "K. Birman",
journal = SIGOPS,
publisher = ACM,
volume = 21,
number = 5,
pages = "123--138",
month = nov,
year = 1987,
comment = "Symmetric atomic multicast protocol."
}

@article{birr78,
author = "Andrew D. Birrell and Roger M. Needham",
title = "An Asynchronous Garbage Collector for the {CAP} Filing System",
journal = SIGOPS,
publisher = ACM,
volume = 12,
number = 2,
pages = "31--33",
month = apr,
year = 1978
}

@techreport{birr93,
author = "Andrew Birrell and David Evers and Greg Nelson and Susan Owicki and Edward Wobber",
title = "Distributed Garbage Collection for Network Objects",
institution = "DEC Systems Research Center",
address = "130 Lytton Avenue, Palo Alto, CA 94301",
number = 116,
month = dec,
year = 1993,
URL = {ftp://ftp.digital.com/pub/DEC/SRC/research-reports/SRC-116.ps.Z},
comment = "based on reference counting, pair-wise communication, no global
synchronization"
}

@techreport{birr94,
author = "Andrew Birrell and Greg Nelson and Susan Owicki and Edward Wobber",
title = "Network Objects",
institution = DECSRC,
number = 115,
month = feb,
year = 1994,
URL = {http://birrell.org/andrew/papers/115-NetworkObjects.pdf},
comment = "based on reference counting, pair-wise communication, no global
synchronization"
}

@inproceedings{birr94a,
author = "Andrew Birrell and Greg Nelson and Susan Owicki and Edward Wobber",
title = "Network Objects",
booktitle = "14th " # SOSP,
address = {Asheville, NC},
month = dec,
publisher = ACM,
pages = {217--230},
year = 1994,
doi = {10.1145/168619.168637}
}

@article{birr95,
author = "Andrew Birrell and Greg Nelson and Susan Owicki and Edward Wobber",
title = "Network Objects",
doi = {10.1002/spe.4380251305},
journal = SPE,
volume = 25,
number = 4,
pages = {87--130},
publisher = {Wiley},
month = dec,
year = 1995,
URL = {http://birrell.org/andrew/papers/115-NetworkObjects.pdf},
note = {Also appeared as SRC Research Report 115.}
}

@techreport{bish75,
author = "Peter B. Bishop",
title = "Garbage collection in a Very Large Address Space",
type = "Working paper",
number = 111,
institution = "AI Laboratory",
address = "MIT, Cambridge, MA",
month = sep,
year = 1975
}

@phdthesis{bish77,
author = "Peter B. Bishop",
title = "Computer Systems with a Very Large Address Space and Garbage Collection",
note = "Technical report MIT/LCS/TR--178",
school = "MIT Laboratory for Computer Science",
month = May,
year = 1977,
doi="1721.1/16428",
comment = {Variant of Kurukawa's algorithm \cite{kuro75}:
marking algorithm which uses
a fixed-length stack. Cohen says that they haven't
been compared and neither of them has been proved correct},
abstract = "The concept of objects is beginning to gain acceptance
throughout the field of computer science.  A new computer system is
proposed that provides hardware support for objects and object
references that can be used in all applications of objects.  The new
system provides small object references that can be copied freely,
makes very small objects efficient, and retrieves the storage for
inaccessible objects automatically.  This system is compared with
some widely used existing systems, and while its speed seems to be
competitive, it is much easier to use.
Object references provide protection in the new system as do
capabilities in capability systems.  The object reference in the new
system contains an address from a linear, paged virtual address space
rather than a unique ID.  Use of small objects is made feasible by
efficiently grouping objects into areas.  Objects in the same area
may be placed on the same page.  The system automatically and
efficiently maintains lists of inter-area links that allow single
areas to be garbage collected independently of the rest of the
system.  The garbage collector can determine whether objects have
been inappropriately placed in an area and can move these objects to
more appropriate areas automatically."
}

@incollection{bjor89,
author = {Anders Bj\"{o}rnerstedt},
title = "Secondary Storage Garbage Collection for Decentralized Object-Based Systems",
booktitle = "Object Oriented Development",
type = "Technical Report",
editor = "D. Tsichritzis",
publisher = "Centre Universitaire d'Informatique, University of Geneva",
month = jul,
year = 1989,
pages = "277--319",
comment = "This paper describes a mechanism for secondary storage
garbage collection that may be used to reclaim inaccessible resources
in decentralized persistent object based systems. Schemes for object
addressing and object identification are discussed and a proposal
is made which handles volatile objects separately from persistent
objects.  The garbage collection of the space of volatile objects
is decoupled from the garbage collection of the space of persistent
objects. The first kind of garbage collection can avoid the
complexity and overhead of a distributed algorithm by classifying
exported objects as persistent. The problem of detecting and
collecting ``distributed garbage'' is then deferred to garbage
collection of persistent objects."
}

@phdthesis{bjor90,
author = {Anders Bj\"{o}rnerstedt},
title = "Secondary Storage Garbage Collection for Decentralized Object-Based Systems",
school = {Royal Institute of Technology and Stockholm University, Sweden},
month = jun,
year = 1990,
note = {Technical Report 77}
}

@inproceedings{bjor02,
title = {{Bu}ddy{C}ache: High Performance Object Storage for Collaborative Strong-Consistency Applications in a {WAN}},
author = {Magnus Bjornsson and Liuba Shrira},
crossref = {OOPSLA02},
abstract = {Collaborative applications provide a shared work
environment for groups of networked clients collaborating on a common
task. They require strong consistency for shared persistent data and
efficient access to fine-grained objects. These properties are
difficult to provide in wide-area networks because of high network
latency.  BuddyCache is a new transactional caching approach that
improves the latency of access to shared persistent objects for
collaborative strong-consistency applications in high-latency network
environments. The challenge is to improve performance while providing
the correctness and availability properties of a transactional caching
protocol in the presence of node failures and slow peers. We have
implemented a BuddyCache prototype and evaluated its performance.
Analytical results, confirmed by measurements of the BuddyCache
prototype using the multi-user 007 benchmark indicate that for typical
Internet latencies, e.g. ranging from 40 to 80 milliseconds round trip
time to the storage server, peers using BuddyCache can reduce by up to
50\% the latency of access to shared objects compared to accessing the
remote servers directly.}
}

@inproceedings{blac86,
author = "Andrew Black and Norman Hutchinson and Eric Jul and Henry Levy",
title = "Object Structure in the {E}merald System",
crossref = "OOPSLA86",
pages = "78--86",
}

@article{blac87,
author = "Andrew Black and Norman Hutchinson and Eric Jul and Henry Levy
and Larry Carter",
title = "Distribution and Abstract Types in {E}merald",
journal = TransSWE,
publisher = ACM,
volume = 13,
number = 1,
pages = "65--76",
year = 1987,
month = jan,
}

@inproceedings{blac01,
author = {Stephen M. Blackburn and Sharad Singhai and Matthew Hertz and
Kathryn S. McKinley and J. Eliot B. Moss},
title = {Pretenuring for {J}ava},
crossref = {OOPSLA01},
pages = {342--352},
doi = {10.1145/504282.504307},
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/oopsla2001.ps.gz}
}

@inproceedings{blac02,
  author =	 {Stephen M. Blackburn and Richard E. Jones and Kathryn
                  S. McKinley and J. Eliot B. Moss},
  title =	 {Beltway: Getting Around Garbage Collection Gridlock},
  crossref =	 {PLDI02},
  pages =	 {153--164},
  doi =		 {10.1145/512529.512548},
  URL =		 {http://www.cs.ukc.ac.uk/pubs/2002/1363},
  abstract =	 {We present the design and implementation of a new garbage
                  collection framework that significantly generalizes existing
                  copying collectors. The \emph{Beltway} framework exploits
                  and separates object age and incrementality. It groups
                  objects in one or more increments on queues called
                  \emph{belts}, collects belts independently, and collects
                  increments on a belt in first-in-first-out order. We show
                  that Beltway configurations, selected by command line
                  options, act and perform the same as semi-space,
                  generational, and older-first collectors, and encompass all
                  previous copying collectors of which we are aware.  The
                  increasing reliance on garbage collected languages such as
                  Java requires that the collector perform well. We show that
                  the generality of Beltway enables us to design and implement
                  new collectors that are robust to variations in heap size
                  and improve total execution time over the best generational
                  copying collectors of which we are aware by up to 40\%, and
                  on average by 5 to 10\%, for small to moderate heap sizes.
                  New garbage collection algorithms are rare, and yet we
                  define not just one, but a new family of collectors that
                  subsumes previous work.  This generality enables us to
                  explore a larger design space and build better collectors.},
}

@inproceedings{blac02a,
title = {In or Out? Putting Write Barriers in Their Place},
author = {Stephen M. Blackburn and Kathryn S. McKinley},
crossref = {ISMM02},
pages = {175--184},
doi = {10.1145/512429.512452}
}

@inproceedings{blac03,
title = {Ulterior Reference Counting: Fast Garbage Collection without a Long Wait},
author = {Stephen M. Blackburn and Kathryn S. McKinley},
crossref = {OOPSLA03},
pages = {344--458},
doi = {10.1145/949305.949336}
}

@techreport{blac03a,
author = {Stephen M. Blackburn and Perry Cheng and Kathryn S. McKinley},
title = {A Garbage Collection Design and Bakeoff in {JMTk}:
An Extensible {J}ava Memory Management Toolkit},
institution = {Australian National University},
number = {TR--CS--03--02},
month = feb,
year = 2003,
URL = {http://eprints.anu.edu.au/archive/00001986}
}

@inproceedings{blac04,
  author =	 {Stephen M. Blackburn and Perry Cheng and Kathryn
                  S. McKinley},
  title =	 {Myths and Realities: The Performance Impact of Garbage
                  Collection},
  booktitle =	 SIGMETRICS,
  publisher =	 ACM,
  month =	 jun,
  year =	 2004,
  pages =	 "25--36",
  series =	 {ACM SIGMETRICS Performance Evaluation Review 32(1)},
  doi =		 "10.1145/1005686.1005693",
  abstract =	 {This paper explores and quantifies garbage collection (GC)
                  behavior for three whole heap collectors and generational
                  counterparts: copying semi-space, mark-sweep, and reference
                  counting, the canonical algorithms from which essentially
                  all other GC algorithms are derived.  Efficient
                  implementations in the memory management toolkit (MMTk) in
                  Jikes RVM share all common mechanisms to provide a clean
                  experimental platform. Performance counters and
                  instrumentation measure timing and memory performance,
                  separating GC and program behavior.  Experiments on SPEC JVM
                  Benchmarks reveal key algorithmic features and how they
                  match program characteristics to explain the direct cost of
                  GC as a function of heap size, and the indirect impact of GC
                  on application performance. Results include the finding that
                  the choice of GC algorithms can improve mutator locality,
                  disputing the myth that "no GC is good GC." We show how the
                  trade-offs in space utilization versus allocation and
                  tracing costs in copying and mark-sweep collectors motivates
                  a copying nursery for newly allocated objects, even without
                  high nursery mortality. We find that object locality and
                  pointer mutations demographics in the mature space are much
                  less sensitive to GC algorithm, but that copying and
                  mark-sweep for the mature space occasionally excel in
                  different programs. This study is unique in its breadth of
                  GC algorithms and its depth of analysis.}
}

@inproceedings{blac04a,
author = {Stephen M. Blackburn and Perry Cheng and Kathryn S. McKinley},
title = {Oil and Water? {H}igh Performance Garbage Collection in {J}ava with {MMTk}},
crossref = {ICSE04},
pages = "137--146",
doi = {10.1109/ICSE.2004.1317436},
abstract = {Increasingly popular languages such as Java and C\# require
efficient garbage collection. This paper presents the design,
implementation, and evaluation of MMTk, a Memory Management Toolkit for
and in Java. MMTk is an efficient, composable, extensible, and portable
framework for building garbage collectors. MMTk uses design patterns
and compiler cooperation to combine modularity and efficiency. The
resulting system is more robust, easier to maintain, and has fewer
defects than monolithic collectors. Experimental comparisons with
monolithic Java and C implementations reveal MMTk has significant
performance advantages as well. Performance critical system software
typically uses monolithic C at the expense of flexibility. Our results
refute common wisdom that only this approach attains efficiency, and
suggest that performance critical software can embrace modular design
and high-level languages.}
}

@inproceedings{blac04b,
  author =	 {Stephen M. Blackburn and Antony L. Hosking},
  title =	 {Barriers: Friend or Foe?},
  crossref =	 {ISMM04},
  pages =	 {143--151},
  doi =		 {10.1145/1029873.1029891}
}

@inproceedings{blac06,
  title =	 {The {D}a{C}apo Benchmarks: {J}ava Benchmarking Development
                  and Analysis},
  author =       {Blackburn, Stephen M. and Garner, Robin and Hoffman, Chriss and Khan,
                  Asjad M.  and McKinley, Kathryn S. and Bentzur, Rotem and
                  Diwan, Amer and Feinberg, Daniel  and Frampton, Daniel and Guyer, Samuel Z. and Hirzel,
                  Martin and Hosking, Antony  and Jump, Maria and Lee, Han and Moss,
                  J. Eliot B. and Phansalkar, Aashish and Stefanovi\'{c}, Darko and
                  {VanDrunen}, Thomas and von Dincklage, Daniel and Wiedermann, Ben},
  crossref =	 {OOPSLA06},
  pages =	 {169--190},
  doi =		 {10.1145/1167473.1167488}
}

@techreport{blac06a,
title = {The {D}a{C}apo Benchmarks: {J}ava Benchmarking Development and Analysis
(Extended Version)},
author = {Stephen Blackburn and Robin Garner and Chris Hoffman and Asjad M. Khan
and Kathryn S. McKinley and Rotem Bentzur and Amer Diwan and Daniel Feinberg
and Samuel Z. Guyer and Martin Hirzel and Antony Hosking and Maria Jump and Han
Lee and J. Eliot B. Moss and Aashish Phansalkar and Darko Stefanovi\'{c} and
Thomas VanDrunen and von Dincklage, Daniel and Ben Wiederman},
institution = {The DaCapo Group},
URL = {http://dacapobench.org/dacapo-TR-CS-06-01.pdf},
year = 2006
}

@article{blac07,
  author =	 {Stephen M. Blackburn and Matthew Hertz and Kathryn
                  S. Mckinley and J. Eliot B. Moss and Ting Yang},
  title =	 {Profile-Based Pretenuring},
  journal =	 TOPLAS,
  volume =	 29,
  number =	 1,
  year =	 2007,
  issn =	 {0164-0925},
  pages =	 {1--57},
  doi =		 {10.1145/1180475.1180477},
  publisher =	 ACM
}

@inproceedings{blac08,
  title =	 {Immix: a mark-region garbage collector with space
                  efficiency, fast collection, and mutator performance},
  author =	 {Stephen Blackburn and Kathryn S. McKinley},
  crossref =	 {PLDI08},
  pages =	 {22-32},
  doi =		 {10.1145/1375581.1375586},
  abstract =	 {Programmers are increasingly choosing managed languages for
                  modern applications, which tend to allocate many
                  short-to-medium lived small objects.  The garbage collector
                  therefore directly determines program performance by making
                  a classic space-time tradeoff that seeks to provide space
                  efficiency, fast reclamation, and mutator performance. The
                  three canonical tracing garbage collectors: semi-space,
                  mark-sweep, and mark-compact each sacrifice one
                  objective. This paper describes a collector family, called
                  mark-region, and introduces opportunistic defragmentation,
                  which mixes copying and marking in a single pass. Combining
                  both, we implement immix, a novel high performance garbage
                  collector that achieves all three performance
                  objectives. The key insight is to allocate and reclaim
                  memory in contiguous regions, at a coarse block grain when
                  possible and otherwise in groups of finer grain lines.  We
                  show that immix outperforms existing canonical algorithms,
                  improving total application performance by 7 to 25\% on
                  average across 20 benchmarks. As the mature space in a
                  generational collector, immix matches or beats a highly
                  tuned generational collector, e.g.  it improves jbb2000 by
                  5\%. These innovations and the identification of a new
                  family of collectors open new opportunities for garbage
                  collector design.}
}

@article{blac08a,
title = {Wake Up and Smell the Coffee: Evaluation Methodology for the 21st Century},
author = {S. M. Blackburn and K. S. McKinley and R. Garner and C. Hoffmann and
A. M. Khan and R. Bentzur and A. Diwan and D. Feinberg and D. Frampton and S. Z.
Guyer and M. Hirzel and A. Hosking and M. Jump and H. Lee and J. E. B. Moss and
A. Phansalkar and D. Stefanovi\'{c} and T. VanDrunen and D. von Dincklage and B.
Wiedermann},
journal = CACM,
volume = 51,
number = 8,
year = 2008,
pages = {83--89},
doi = {10.1145/1378704.1378723}}
}

@techreport{blan96,
title = {Garbage Collection statique},
author = {Bruno Blanchet},
type = {DEA report},
institution = {INRIA, Rocquencourt},
month = sep,
year = 1996
}

@inproceedings{blan98,
  title =	 {Escape Analysis: Correctness Proof, Implementation and
                  Experimental Results},
  author =	 {Bruno Blanchet},
  crossref =	 {POPL98},
  pages =	 {25--37},
  doi =		 {10.1145/268946.268949},
  comment =	 {By analysing which objects escape methods/threads, we can
                  allocate on the stack / avoid synchronisations.}
}

@inproceedings{blan99,
  title =	 {Escape Analysis for Object Oriented Languages: Application
                  to {J}ava},
  author =	 {Bruno Blanchet},
  pages =	 {20--34},
  crossref =	 {OOPSLA99},
  doi =		 {10.1145/320384.320387},
  comment =	 {By analysing which objects escape methods/threads, we can
                  allocate on the stack / avoid synchronisations.}
}

@article{blan03,
title =	 {Escape Analysis for  {J}ava: Theory and Practice},
author = {Bruno Blanchet},
journal = TOPLAS,
pages =	 {712--775},
volume = 25,
number = 6,
month = nov,
year = 2003,
doi = {10.1145/945885.945886},
}

@inproceedings{blau83,
author = "Ricki Blau",
title = "Paging on an Object-Oriented Personal Computer for {S}malltalk",
booktitle = SIGMETRICS,
pages = {44--54},
address = {Minneapolis, MN},
month = aug,
year = 1983,
publisher = ACM,
doi = {10.1145/800040.801394},
note = "Also appears as Technical Report UCB/CSD 83/125, " # UCB # ", Computer Science Division (EECS)"
}

@inproceedings{blel99,
  author =	 {Guy E. Blelloch and Perry Cheng},
  title =	 {On Bounding Time and Space for Multiprocessor Garbage
                  Collection},
  crossref =	 {PLDI99},
  pages =	 {104--117},
  doi =		 {10.1145/301618.301648}
}

@inproceedings{blel01,
  author =	 {Guy E. Blelloch and Perry Cheng and Phillip B. Gibbons},
  title =	 {Room Synchronizations},
  booktitle =	 {13th ACM Symposium on Parallel Algorithms and Architectures},
  pages =	 {122--133},
  year =	 2001,
  address =	 {Heraklion, Crete, Greece},
  month =	 jul,
  publisher =    ACM,
  doi =		 {10.1145/378580.378605}
}

@article{blel03,
  author =	 {Guy E. Blelloch and Perry Cheng and Phillip B. Gibbons},
  title =	 {Scalable Room Synchronizations},
  journal =	 {Theory of Computing Systems},
  year =	 2003,
  volume =	 36,
  number =	 5,
  pages =	 {397--430},
  month =	 sep,
  doi =		 {10.1007/s00224-003-1081-y}
}

@inproceedings{blon97,
title = {{PerDIS} {PPF} Case Study: Fitting a Distributed Garbage Collection Algorithm to a Persistent Distributed Store Architecture},
author = {Xavier Blondel and Paulo Ferreira and Marc Shapiro},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/perdis_gc.ps},
crossref = {OOPSLA97-gc}
}

@unpublished{blon98,
title = {Implementing Garbage Collection in the {PerDiS} System},
author = {Xavier Blondel and Paulo Ferreira and Marc Shapiro},
note = {Submitted for publication},
year = 1998,
URL = {http://cretina.inesc.pt/people/pjpf-home/submitted.ps}
}

@techreport{blon99,
title = {Report on the Scalability of Garbage Collection},
author = {Xavier Blondel},
institution = {Esprit},
note = {Deliverable {TC}.1.3-B, {P}er{D}i{S} project},
year = 1999,
URL = {http://www.perdis.esprit.ec.org/deliverables/docs/wpC/tc13b}
}

@phdthesis{blon00,
title = {Gestion de M\'{e}ta-donne\'{e}s de la M\'{e}moire dans un
Environment R\'{e}parti Persistant Transactionnel \`{a} Grande
\'{E}chelle: l'Exemple de {P}er{D}i{S}},
author = {Xavier Blondel},
school = {Conservatoire National des Arts et M\'{e}tiers},
month = sep,
year = 2000
}

@article{bobr64,
title = "A Comparison of List-Processing Computer Languages",
author = "Daniel G. Bobrow and Bertram Raphael",
journal = CACM,
publisher = ACM,
volume = 7,
number = 4,
month = apr,
year = 1964,
pages = "231--240"
}

@article{bobr67,
author = "Daniel G. Bobrow and Daniel L. Murphy",
title = "Structure of a {LISP} System Using Two-Level Storage",
journal = CACM,
publisher = ACM,
volume = 10,
number = 3,
month = mar,
year = 1967,
pages = "155--159",
}

@article{bobr68a,
author = "Daniel G. Bobrow",
title = "Storage Management in {L}isp",
journal = "Symbol manipulation languages and techniques",
editor = "Daniel G. Bobrow",
publisher = "North-Holland",
address = "Amsterdam",
year = 1968,
}

@article{bobr68b,
author = "Daniel G. Bobrow and Daniel L. Murphy",
title = "A Note on the Efficiency of a {LISP} Computation in a Paged Machine",
journal = CACM,
publisher = ACM,
volume = 11,
number = 8,
month = Aug,
year = 1968,
pages = "558--560",
}

@article{bobr75,
author = "Daniel G. Bobrow",
title = "A Note on Hash Linking",
journal = CACM,
publisher = ACM,
volume = 18,
number = 7 ,
month = jul,
year = 1975,
pages = "413--15",
comment = { Hash link cells with RC != 1.  }
}

@article{bobr79,
title = "Compact Encodings of List Structure",
author = "Daniel G. Bobrow and Douglas W. Clark",
journal = TOPLAS,
publisher = ACM,
year = 1979,
month = oct,
volume = 1,
number = 2,
pages = "266--286",
comment = "Good words on {CDR}-coding"
}

@article{bobr80,
title = "Managing Re-entrant Structures using Reference Counts",
author = "Daniel G. Bobrow",
journal = TOPLAS,
publisher = ACM,
year = 1980,
month = jul,
volume = 2,
number = 3,
pages = "269--273",
doi = {10.1145/357103.357104},
comment = "can handle some special cases of reference counting, but
restricts the programmer to certain stereotyped patterns."
}

@techreport{boeh85,
author = "Hans-Juergen Boehm and Alan Demers",
title = "Implementing {R}ussell",
institution = Rice,
number = "COMP TR85-25",
year = 1985
}

@article{boeh88,
title = "Garbage Collection in an Uncooperative Environment",
author = "Hans-Juergen Boehm and Mark Weiser",
journal = SPE,
publisher = Wiley,
year = 1988,
volume = 18,
number = 9,
pages = "807--820",
doi = {10.1002/spe.4380180902},
URL = "http://www.hpl.hp.com/personal/Hans_Boehm/gc/index.html",
abstract = {We describe a technique for storage allocation and garbage
collection in the absence of significant co-operation from the code using the
allocator.  This limits garbage collection overhead to the time actually
required for garbage collection.  In particular, application programs that
rarely or never make use of the collector no longer encounter a substantial
performance penalty.  This approach greatly simplifies the implementation of
languages supporting garbage collection.  It further allows conventional
compilers to be used with a garbage collector, either as the primary means
of storage reclamation, or as a debugging tool.}
}

@unpublished{boeh88a,
author = "Hans-Juergen Boehm and Lucy Hederman",
title = "Storage Allocation Optimization in a Compiler for {R}ussell",
note = "Submitted for publication",
year = 1988,
month = jul
}

@inproceedings{boeh91,
title = "Mostly Parallel Garbage Collection",
author = "Hans-Juergen Boehm and Alan J. Demers and Scott  Shenker",
crossref = {PLDI91},
pages = "157--164",
doi = {10.1145/113445.113459},
comment = "Incremental update, uses VM dirty bits as a coarse pagewise write barrier."
}

@inproceedings{boeh91a,
author = "Hans-Juergen Boehm",
title = "Simple {GC}-Safe Compilation",
crossref = "OOPSLA91-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/boehm.ps"
}

@inproceedings{boeh91b,
author = "Hans-Juergen Boehm and Eliot Moss and Joel Bartlett and David R.
Chase",
title = "Panel Discussion: Conservative vs. Accurate Garbage Collection",
note = "Summary appears in Wilson and Hayes' OOPSLA'91 GC workshop report",
crossref = "OOPSLA91-gc",
}

@inproceedings{boeh91c,
title = "Hardware and Operating System Support for Conservative Garbage Collection",
author = "Hans-Juergen Boehm",
crossref = "IWOOOS91",
pages = {61--67},
}

@article{boeh92,
author = "Hans-Juergen Boehm and David R. Chase",
title = "A Proposal for Garbage-Collector-Safe {C} Compilation",
journal = "Journal of C Language Translation",
mon = dec,
year = 1992,
pages = "126--141",
URL = {http://reality.sgi.com/employees/boehm_mti/papers/boecha.ps.gz},
comment = "on GC in the presence of compiler optimizations?"
}

@inproceedings{boeh93,
  title =	 "Space Efficient Conservative Garbage Collection",
  author =	 "Hans-Juergen Boehm",
  crossref =	 "PLDI93",
  pages =	 "197--206",
  doi =		 {10.1145/155090.155109},
  URL =		 "http://www.hpl.hp.com/personal/Hans_Boehm/gc/index.html",
}

@inproceedings{boeh93a,
author = "Hans-Juergen Boehm and Zhong Shao",
title = "Inferring Type Maps during Garbage collection",
crossref = "OOPSLA93-gc",
URL = "ftp://daffy.cs.yale.edu/pub/papers/shao/gc.ps"
}

@article{boeh95,
author = "Hans-Juergen Boehm",
title = "Dynamic Memory Allocation and Garbage Collection",
journal = "Computers in Physics",
volume = 9,
number = 3,
month = "May/June",
year = 1995,
pages = "297--303"
}

@inproceedings{boeh96,
  author =	 "Hans-Juergen Boehm",
  title =	 "Simple Garbage-Collector Safety",
  crossref =	 "PLDI96",
  pages =	 "89--98",
  doi =		 {10.1145/231379.231394},
  URL =		 "http://www.hpl.hp.com/personal/Hans_Boehm/gc/index.html",
}

@inproceedings{boeh00,
author = {Hans-Juergen Boehm},
title = {Reducing Garbage Collector Cache Misses},
pages = {59--64},
crossref = {ISMM2000},
doi = {10.1145/362422.362438},
abstract = {
Cache misses are currently a major factor in the cost of garbage
collection, and we expect them to dominate in the future.  Traditional
garbage collection algorithms exhibit relatively little temporal
locality; each live object in the heap is likely to be touched exactly
once during each garbage collection. We measure two techniques for
dealing with this issue:  prefetch-on-grey, and lazy sweeping. The
first of these is new in this context. Lazy sweeping has been in common
use for a decade. It was introduced as a mechanism for reducing paging
and pause times; we argue that it is also crucial for eliminating cache
misses during the sweep phase. Our measurements are obtained in the
context of a non-moving garbage collector. Fully copying garbage
collection inherently requires more traffic through the cache, and thus
probably also stands to benefit substantially from something like the
prefetch-on-grey technique. Generational garbage collection may reduce
the benefit of these techniques for some applications, but experiments
with a non-moving generational collector suggest that they remain quite
useful.}
}

@techreport{boeh00tr,
  author =	 {Hans-Juergen Boehm},
  title =	 {Fast Multiprocessor Memory Allocation and Garbage
                  Collection},
  institution =	 {HP Laboratories},
  year =	 2000,
  number =	 {HPL-2000-165},
  address =	 {Palo Alto},
  URL =		 {http://www.hpl.hp.com/techreports/2000/HPL-2000-165.html},
  month =	 dec
}

@inproceedings{boeh02,
author = {Hans-Juergen Boehm},
title = {Bounding Space Usage of Conservative Garbage Collectors},
crossref = {POPL02},
URL = {http://www.hpl.hp.com/techreports/2001/HPL-2001-251.html}
}

@inproceedings{boeh03,
author = {Hans-Juergen Boehm},
title = {Destructors, Finalizers, and Synchronization},
crossref = {POPL03},
doi = {10.1145/604131.604153},
pages = {262--272}
}

@inproceedings{boeh04,
author = {Hans-Juergen Boehm},
title = {The Space Cost of Lazy Reference Counting},
crossref = {POPL04},
pages = {210--219},
doi = {10.1145/604131.604153},
URL = {http://www.hpl.hp.com/techreports/2003/HPL-2003-215.html}
}

@inproceedings{boeh08,
  author =	 {Hans-Juergen Boehm and Sarita V. Adve},
  title =	 {Foundations of the {C++} Concurrency Memory Model},
  crossref =	 {PLDI08},
  pages =	 {68-78},
  doi =		 {10.1145/1375581.1375591}
}

@inproceedings{boeh09,
title = {Garbage Collection in the Next {C++} Standard},
author = {Hans-Juergen Boehm and Mike Spertus},
pages = {30--38},
doi = {10.1145/1542431.1542437},
crossref = {ISMM09}
}

@techreport{boer92,
author = "de Boer, F. S. and Klop, J. W.",
title = "Asynchronous Communication in Process Algebra: Extended Abstract",
institution = "Stichting Mathematisch Centrum",
year = 1992,
number = "CS-R9206",
month = Jan,
abstract = "We study the paradigm of asynchronous process
communication, as contrasted with the synchronous communication
mechanism which is present in process algebra frameworks such as
CCS, CSP and ACP. We investigate semantics and axiomatizations
with respect to various observability criteria: bisimulation,
traces and abstract traces.  Our aim is to develop a process
theory which can be regarded as a kernel for languages based on
asynchronous communication, like data flow, concurrent logic
languages and concurrent constraint programming."
}

@inproceedings{bogd99,
  title =	 {Removing Unnecessary Synchronization in {J}ava},
  author =	 {Jeff Bogda and Urs H\"{o}lzle},
  pages =	 {35--46},
  crossref =	 {OOPSLA99},
  doi =		 {10.1145/320384.320388},
  comment =	 {By analysing which objects escape threads, we can avoid
                  synchronisations.}
}

@inproceedings{bogd01,
  title =	 {Removing Unnecessary Synchronization in {J}ava},
  author =	 {Jeff Bogda and Ambuj Singh},
  crossref =	 {JVM01},
}

@inproceedings{boiz86,
author = "P. Boizumault",
title = "A General Model to Implement {\it dif} and {\it freeze}",
crossref = "ICLP86"
}

@inproceedings{bond06,
  title =	 {Bell: Bit-Encoding Online Memory Leak Detection},
  author =	 {Michael Bond and Kathryn McKinley},
  crossref =	 {ASPLOS06},
  pages =	 {61-72},
  doi =		 {10.1145/1168857.1168866},
}

@inproceedings{bond08,
title = {Tolerating Memory Leaks},
author = {Michael Bond and Kathryn McKinley},
crossref = {OOPSLA08},
pages = {109--126},
doi = {10.1145/1449764.1449774},
abstract = {Type safety and garbage collection in managed languages eliminate
memory errors such as dangling pointers, double frees, and leaks of unreachable
objects. Unfortunately, a program still leaks memory if it maintains references
to objects it will never use again. Leaked objects decrease program locality and
increase garbage collection frequency and workload, and a growing leak will
eventually exhaust memory and crash the program. This paper introduces leak
tolerance, which safely eliminates performance degradations and crashes due to
leaks of stale objects in managed languages given sufficient disk space. Leak
tolerance (1) identifies stale objects that the program is not accessing; (2)
segregates in-use and stale objects, and stores stale objects to disk; and (3)
activates stale objects if the program subsequently accesses them. Activation
makes leak tolerance completely safe. We design and implement a prototype leak
tolerance tool called Melt in a Java VM and show it adds overhead low enough for
production systems. Our results show that existing VMs grind to a halt and then
crash on programs with leaks, whereas Melt keeps many of these programs running
much longer without significantly degrading performance. Leak tolerance provides
users the illusion of no bug and developers more time to fix leaky programs.}
}

@inproceedings{borg03,
author = {Andrew Borg and Andy J. Wellings},
title = {Reference Objects for {RTSJ} Memory Areas},
booktitle = {OTM Workshops 2003},
series = LNCS,
number = 2889,
pages = {397--410},
year = 2003,
abstract = {The RTSJ introduces a memory model that includes immortal and
scoped memory areas that are not subject to garbage collection. Associated with
scoped memory areas are rules that restrict reference assignments to guarantee
dangling pointers can not occur. Java includes special references which have
different semantics than regular references. Encapsulated by reference objects,
these references are treated uniquely way by the garbage collector. In
particular, they do not stop their referents from being marked for
finalization, finalized and reclaimed.
This paper makes four contributions. We first propose semantics for reference
objects used in the RTSJ. We then propose a new scoped reference object that
allows access to objects where this would be disallowed by the RTSJ scoping
rules. Next, we show how reference object reachability changes can be processed
using RTSJ asynchronous events. Finally, we show how thread groups, unavailable
to RTSJ RealtimeThreads can be implemented safely using scoped reference
objects.}
}

@inproceedings{borg06,
author = {Andrew Borg and Andy J. Wellings and Christopher Gill and Ron K. Cytron},
title = {Real-Time Memory Management: Life and Times},
booktitle = {18th Euromicro Conference on Real-Time Systems (ECRTS'06)},
year = 2006,
pages = {237--250},
address = {Dresden, Germany},
month = jul,
abstract = {As real-time and embedded systems become increasingly large and
complex, the traditional strictly static approach to memory management begins to
prove untenable. The challenge is to provide a dynamic memory model that
guarantees tight and bounded time and space requirements without overburdening
the developer with memory concerns. This paper provides an analysis of memory
management approaches in order to characterise the tradeoffs across three
semantic domains: space, time and a characterisation of memory usage information
such as the lifetime of objects. A unified approach to distinguishing the merits
of each memory model highlights the relationship across these three domains,
thereby identifying the class of applications that benefit from targeting a
particular model. Crucially, an initial investigation of this relationship
identifies the direction future research must take in order to address the
requirements of the next generation of complex embedded systems. Some initial
suggestions are made in this regard and the memory model proposed in the
Real-Time Specification for Java is evaluated in this context.},
URL = {http://www.cs.york.ac.uk/rts/cgi-bin/bibtex/bibtex.pl?key=R:Borg:2006}
}

@article{borm02a,
title = {Sensible Sanitation --- Understanding the {IBM} {J}ava Garbage Collector, Part 1: Object allocation},
author = {Sam Borman},
journal = {IBM developerWorks},
month = aug,
year = 2002,
URL = {http://www-106.ibm.com/developerworks/ibm/library/i-garbage1/},
abstract = {This article is the first of three in a series on the IBM
Java Garbage Collector (GC), a storage manager for the IBM Java
development kits and runtime environments. The series will cover:
storage areas used by GC; object allocation; garbage collection; how
external interfaces work; and verbosegc and other command line
parameters.
This article discusses how objects are allocated in the Java heap for
garbage collection. It describes the layout of an object and examines
some of the data areas, such as the heap and the free list. The author
also discusses direct allocation from the heap and thread local
allocation, and gives some recommendations for controlling the heap
size. Information in this article reflects the Java 1.2.2 through 1.3.1
versions.}
}

@article{borm02b,
title = {Sensible Sanitation --- Understanding the {IBM} {J}ava Garbage Collector, Part 2: Garbage Collection},
author = {Sam Borman},
journal = {IBM developerWorks},
month = aug,
year = 2002,
URL = {http://www-106.ibm.com/developerworks/ibm/library/i-garbage2/},
abstract = {This is the second of three articles in a series on the IBM
Java Garbage Collector (GC), which is a storage manager for the IBM
Java development kits and runtime environments. Part 1 in this series
covered object allocation, and the next article will discuss verbosegc
and other command line parameters. In this article Sam Borman reviews
how garbage collection works, and describes the three main phases of
GC: mark, sweep, and compact. He also discusses concurrent mark and
parallel bitwise sweep. The article includes a brief discussion of
reference objects, heap expansion, and heap shrinkage. Information in
this article reflects the Java 1.2.2 through 1.3.1 release levels.}
}

@article{borm02c,
title = {Sensible Sanitation --- Understanding the {IBM} {J}ava Garbage Collector, Part 3: \texttt{verbosegc} and command-line},
author = {Sam Borman},
journal = {IBM developerWorks},
month = sep,
year = 2002,
URL = {http://www-106.ibm.com/developerworks/ibm/library/i-garbage3/},
abstract = {This is the last article in our series on the IBM Java
Garbage Collector (GC), which is a storage manager for the IBM Java
product. Part 1 in this series covered object allocation, and part 2
discussed phases of GC.

In this article Sam Borman explains how to interpret verbosegc, and how
some of the command-line parameters work. He uses examples to
illustrate verbosegc output, and describes the command line parameters
that influence GC and when to use them. Information in this article
reflects the Java 1.2.2 through 1.3.1 release levels.}
}

@inproceedings{born04,
author = {Richard Bornat and Cristiano Calcagno and Peter O'Hearn},
title = {Local Reasoning, Separation, and Aliasing},
crossref = {SPACE04},
}

@phdthesis{boqu99,
author = {U. Boquist},
title = {Code Optimisation Techniques for Lazy Functional Languages},
school = {Chalmers University of Technology},
address = {Gothenburg, Sweden},
month = apr,
year = 1999
}

@inproceedings{bowm93,
author = "Howard Bowman and John Derrick and Richard E. Jones",
title = "Modelling Garbage Collection Algorithms",
booktitle = "International Workshop on Concurrency in Computational Logic,
City University, London, 13 December 1993",
month = dec,
year = 1993,
comment = "Initial report of attempts to model CRC algorithms using
CCS and temporal logic."
}

@inproceedings{boya03,
  author =	 {Chandrasekhar Boyapati and Alexandru Salcianu and {Beebee,
                  Jr.}, William and Martin Rinard},
  title =	 {Ownership Types for Safe Region-Based Memory Management in
                  {R}eal-{T}ime {J}ava},
  crossref =	 {PLDI03},
  pages =	 {324-337},
  doi =		 {10.1145/781131.781168}
}

@incollection{boye72,
author = "R. S. Boyer and J. S. Moore",
title = "The Sharing of Structure in Theorem-Proving Programs",
booktitle = "Machine Intelligence",
editor = "B. Meltzer and Donald Michie",
publisher = "Edinburgh University Press",
pages = "101--116",
year = 1972,
comment = "The first implementations of logic programming used Boyer-Moore's
`structure sharing' which represents a term with a pair of pointers, one
to a static model and the other to an `environment'.",
}

@article{boys93,
title = "Reducing Object Storage Requirements in a Multi-User Environment",
author = "P. Boysen and P. Shah",
journal = SPE,
volume = 23,
number = 2,
month = mar,
year = 1993,
pages = "243--253"
}

@article{bozm84,
author = "G. Bozman and W. Buco and T. P. Daly and W. H. Tetzlaff",
title = "Analysis of Free Storage Algorithms --- Revisited",
journal = ISJ,
volume = 23,
number = 1,
pages = "44-64",
year = 1984
}

@article{bozm84a,
title = "The Software Lookaside Buffer Reduces Search Overhead with Linked Lists
",
author = "Gerald Bozman",
journal = CACM,
publisher = ACM,
volume = 27,
number = 3,
month = mar,
year = 1984,
pages = "222--227"
}

@inproceedings{brab08,
title = {Parametric Prediction of Heap Memory Requirements},
author = {V\'{i}ctor Braberman and Federico Fern\'{a}ndez and Diego Garbervetsky and
Sergio Yovine},
crossref = {ISMM08},
pages = {141--150},
doi = {10.1145/1375634.1375655},
abstract = {This work presents a technique to compute symbolic
polynomial approximations of the amount of dynamic memory required
to safely execute a method without running out of memory, for
Java-like imperative programs.  We consider object allocations and
deallocations made by the method and the methods it transitively
calls. More precisely, given an initial configuration of the stack
and the heap, the peak memory consumption is the maximum space
occupied by newly created objects in all states along a run from
it.  We over-approximate the peak memory consumption using a
scoped-memory management where objects are organized in regions
associated with the lifetime of methods.  We model the problem of
computing the maximum memory occupied by any region configuration
as a parametric polynomial optimization problem over a polyhedral
domain and resort to Bernstein basis to solve it. We apply the
developed tool to several benchmarks.}
}

@inproceedings{bran14,
title = {Concurrent, Parallel Garbage Collection in Linear Time},
author = {Steven R. Brandt and Hari Krishnan and Gokarna Sharma and Costas Busch},
pages = {47--58},
crossref = {ISMM14},
doi= {10.1145/2602988.2602990},
anstract = {This paper presents a new concurrent garbage collection algorithm
based on two types of reference, strong and weak, to link the graph of objects.
Strong references connect the roots to all the nodes in the graph but do not
contain cycles. Weak references may, however, contain cycles.
Advantages of this system include: (1) reduced processing, non-trivial garbage
collection work is only required when the last strong reference is lost; (2)
fewer memory traces to delete objects, a garbage cycle only needs to be
traversed twice to be deleted; (3) fewer memory traces to retain objects, since
the collector can often prove objects are reachable without fully tracing
support cycles to which the objects belong; (4) concurrency, it can run in
parallel with a live system without ``stopping the world''; (5) parallel, because
collection operations in different parts of the memory can proceed at the same
time.
Previous variants of this technique required exponential cleanup time, but our
algorithm is linear in total time, i.e. any changes in the graph take only O(N)
time steps, where N is the number of edges in the affected subgraph (e.g. the
subgraph whose strong support is affected by the operations).}
}

@incollection{bran71,
author = "P. Branquart and J. Lewi",
title = "A Scheme of Storage Allocation and Garbage Collection for {A}lgol--68",
crossref = "Algol68",
pages = "198--238",
}

@inproceedings{brec01,
title = {Controlling Garbage Collection and Heap Growth to Reduce the Execution Time of {J}ava Applications},
author = {Tim Brecht and Eshrat Arjomandi and Chang Li and Hang Pham},
crossref = {OOPSLA01},
pages = {353--366},
doi = {10.1145/504282.504308}
}

@article{brec06,
title = {Controlling Garbage Collection and Heap Growth to Reduce the Execution Time of {J}ava Applications},
author = {Tim Brecht and Eshrat Arjomandi and Chang Li and Hang Pham},
journal = TOPLAS,
volume = 28,
number = 5,
month = sep,
year = 2006,
pages = {908--941},
doi = {10.1145/1152649.1152652}
}

@inproceedings{breg00,
author = {Roberto Brega and Gabrio Rivera},
title = {Dynamic Memory Management with Garbage Collection for Embedded
Applications},
booktitle = {Proc. of the {USENIX} Workshop on Industrial Experiences with
Systems Software ({WIESS} 2000)},
address = {San Diego, CA},
month = oct,
year = 2000,
URL = {http://xo2.org/Docs/wiess2000.pdf}
}

@article{bren89,
title = "Efficient Implementation of the First-Fit Strategy for Dynamic Storage Allocation",
author = "R. P. Brent",
pages = "388--403",
journal = TOPLAS,
publisher = ACM,
year = 1989,
month = jul,
volume = 11,
number = 3,
doi={10.1145/65979.65981}
}

@phdthesis{bris92,
author = "P. Brisset",
title = "Compilation de $\lambda${P}rolog",
school = {Universit\'{e} de Rennes},
year = 1992,
comment = "MALI uses copying for lists of goals.",
}

@mastersthesis{brit75,
author = {Dianne Ellen Britton},
title = {Heap Storage Management for the Programming Language {P}ascal},
school = {University of Arizona},
year = 1975,
URL = {http://druseikis.com/dbritton/msthesis/}
}

@article{brob03,
author = {Magnus Broberg and Daniel H\"{a}ggander and Per Lid\'{e}n and Lars Lundberg},
title = {Improving the Performance of Multiprocessor Memory Management in {J}ava},
journal = {Java Report},
note = {To appear},
URL = {http://www.artes.uu.se/publications/Daniel_Haggander.pdf}
}

@inproceedings{brod04,
author = {William Brodie-Tyrrell and Henry Detmold and Katrina E. Falkner and David S. Munro},
title = {Garbage Collection for Storage-Oriented Clusters},
booktitle = {Australian Computer Science Conference},
editor = {Vladimir Estivill-Castro},
address={Dunedin, New Zealand},
month = jan,
volume = {26 of {CRPIT}},
pages = {99--108},
publisher = {Australian Computer Society},
year = 2004,
url={http://www.acs.org.au/documents/public/crpit/CRPITV26BrodieTyrrell.pdf}
}

@article{brom80,
author = "A. G. Bromley",
title = "Memory Fragmentation in Buddy Methods for Dynamic Storage Allocation",
journal = ActInf,
publisher = SV,
volume = 14,
number = 2,
month = aug,
year = 1980,
pages = "107--117"
}

@inproceedings{broo82,
author = "Rodney A. Brooks and Richard P. Gabriel and Guy L. Steele",
title = "S--1 {C}ommon {L}isp Implementation",
crossref = "LFP82",
pages = "108--113",
}

@inproceedings{broo83,
author = "Rodney A. Brooks and Richard P. Gabriel and Guy L. Steele",
title = "{LISP}-in-{LISP}: High Performance and Portability",
booktitle = "International Joint Conference on Artifical Intelligence",
year = 1983,
volume = 2,
pages = {845--849},
organization = "IJCAI"
}

@inproceedings{broo84,
title = "Trading Data Space for Reduced Time and Code Space in Real-Time
Garbage Collection on Stock Hardware",
author = "Rodney A. Brooks",
pages = "256--262",
crossref = "LFP84",
doi={10.1145/800055.802042},
comment = "Variation on Baker where objects are {\em always} referred to
via an indirection field embedded in the object itself. If an object is
valid, the indirection points to itself. If it is an obsolete version in
tospace, it points to the new version. Unconditional indirection is cheaper
than checking.
Write-barrier scheme. Expensive."
}

@techreport{broo02,
title = {The {M}emory {P}ool {S}ystem: Thirty Person-Years of Memory Management Development goes Open Source},
author = {Richard Brooksby},
institution = {Ravenbrook Limited},
month = jan,
year = 2002,
URL = {http://www.ravenbrook.com/project/mps/doc/2002-01-30/ismm2002-paper/ismm2002.html},
abstract = {The Memory Pool System (MPS) is a very general, adaptable,
flexible, reliable, and efficient memory management system. It permits
the flexible combination of memory management techniques, supporting
manual and automatic memory management, in-line allocation, finalization,
weakness, and multiple simultaneous co-operating incremental generational
garbage collections. It also includes a library of memory pool classes
implementing specialized memory management policies.}
}


@phdthesis{brow84,
title = "Recursive Structures in Computer Systems",
author = "David R. Brownbridge",
school = "University of Newcastle upon Tyne",
year = 1984,
month = sep
}

@inproceedings{brow85,
author = "David R. Brownbridge",
title = "Cyclic Reference Counting for Combinator Machines",
crossref = "FPCA85",
pages={273--288},
doi={10.1007/3-540-15975-4_42},
comment = {
Presents an interesting, but incorrect algorithm
(see \cite{salk87}), for cyclic reference counting
based on the notion of strong and weak (cycle-closing) pointers.}
}

@article{broy82,
title = "Combining Algebraic and Algorithmic Reasoning: An Approach to the {S}chorr--{W}aite Algorithm",
author = "Manfred Broy and Peter Pepper",
pages = "362--381",
journal = TOPLAS,
publisher = ACM,
year = 1982,
month = jul,
volume = 4,
number = 3
}

@techreport{bruh87,
author = "Bruha, Ivan",
title = "Representation of Structures and Garbage Collection in
{McMaster} {POPLOG}",
institution = "McMaster University, Department of Computer Science and
Systems,Canada",
year = 1987,
number = "88-01"
}

@inproceedings{brus87,
author = "T. Brus and van Eekelen, M. J. C. D. and M. J. Plasmeijer and H. P. Barendregt",
title = "Clean: A Language for Functional Graph Rewriting",
crossref = "FPCA87",
pages = "364--384"
}

@inproceedings{bruy82,
author = "Maurice Bruynooghe",
title = "A Note on Garbage Collection in {P}rolog Interpreters",
crossref = "ICLP82",
pages = {52--55}
}

@article{bruy82a,
author = "Maurice Bruynooghe",
title = "Garbage Collection in {P}rolog Implementations",
journal = "Logic Programming",
editor = {S.-A. T\"{a}rnlund and K. L. Clark},
pages = "83--98",
note = "Also in Workshop on Logic Programming, Debrecen, Hungary, 1980",
year = 1980,
comment = "Structure copying:simplifies gc algorithms (mell80).",
}

@incollection{bruy84,
author = "Maurice Bruynooghe",
title = "Garbage Collection in {P}rolog Implementations",
booktitle = "Implementations of {P}rolog",
editor = "J. A. Campbell",
year = 1984,
pages = "259--267",
publisher = "Ellis-Horwood",
comment = "Traverse goal-statements in the backtrack stack but consider binding status.",
}

@incollection{bruy86,
title = "Compile-Time Garbage Collection or {H}ow to Transform Programs in an
Assignment-Free Language into Code with Assignments",
author = "Maurice Bruynooghe",
pages = "113--129",
booktitle = "Program specification and transformation. The {IFIP} {TC2/WG} 2.1
Working Conference, {B}ad {T}olz, {G}ermany",
month = "April 15--17, 1986",
editor = "L. G. L. T. Meertens",
publisher = "North-Holland",
address = "Amsterdam",
year = "1987"
}

@techreport{bruy86a,
author = "Maurice Bruynooghe",
title = "Compile-Time Garbage Collection",
institution = "Katholieke Universiteit of Leuven",
type = "Report",
number = "CW43",
year = 1986
}

@inproceedings{bruy88,
author = "Maurice Bruynooghe and G. Janssens",
title = "An Instance of Abstract Interpretation Integrating Type and Mode Inferencing",
booktitle = "5th International Conference and Symposium on Logic Programming",
pages = "669--683",
publisher = MIT,
year = 1988
}

@inproceedings{bu13,
author = {Bu, Yingyi and Borkar, Vinayak and Xu, Guoqing and Carey, Michael J.},
title = {A Bloat-Aware Design for Big Data Applications},
crossref = {ISMM13},
doi = {10.1145/2464157.2466485},
abstract = {Over the past decade, the increasing demands on data-driven business
intelligence have led to the proliferation of large-scale, data-intensive
applications that often have huge amounts of data (often at terabyte or petabyte
scale) to process. An object-oriented programming language such as Java is often
the developer's choice for implementing such applications, primarily due to its
quick development cycle and rich community resource. While the use of such
languages makes programming easier, significant performance problems can often
be seen --- the combination of the inefficiencies inherent in a managed run-time
system and the impact of the huge amount of data to be processed in the limited
memory space often leads to memory bloat and performance degradation at a
surprisingly early stage.
This paper proposes a bloat-aware design paradigm towards the development of
efficient and scalable Big Data applications in object-oriented GC enabled
languages. To motivate this work, we first perform a study on the impact of
several typical memory bloat patterns. These patterns are summarized from the
user complaints on the mailing lists of two widely-used open-source Big Data
applications. Next, we discuss our design paradigm to eliminate bloat. Using
examples and real-world experience, we demonstrate that programming under this
paradigm does not incur significant programming burden. We have implemented a
few common data processing tasks both using this design and using the
conventional object-oriented design. Our experimental results show that this new
design paradigm is extremely effective in improving performance --- even for the
moderate-size data sets processed, we have observed 2.5x+ performance gains, and
the improvement grows substantially with the size of the data set.},
} 

@inproceedings{budi09,
author = {Budimlic, Zoran and Chandramowlishwaran, Aparna M. and Knobe, Kathleen and Lowney, Geoff N. and Sarkar, Vivek and Treggiari, Leo},
title = {Declarative Aspects of Memory Management in the {C}oncurrent {C}ollections Parallel Programming Model},
booktitle = {DAMP 2009: Workshop on Declarative Aspects of Multicore Programming},
address = {Savannah, GA},
month = jan,
year = 2009,
doi = {10.1145/1481839.1481846}
}

@article{bull00,
author = {J. M. Bull and L. A. Smith and M. D. Westhead and D. S. Henty and R. A. Davey},
title = {A Benchmark Suite for High Performance {J}ava},
journal = CPE,
volume = 12,
number = 6,
pages = {375-–388},
year = 2000,
doi = {10.1002/1096-9128}
}

@inproceedings{burd01,
author = {Lilian Burdy},
title = {{B} vs. {C}oq to Prove a Garbage Collector},
booktitle = {14th International Conference on Theorem Proving in
Higher Order Logics: Supplemental Proceedings},
editor = {R. J. Boulton and P. B. Jackson},
month = sep,
year = 2001,
pages = {85--97},
note = {Report EDI--INF--RR--0046, Division of Informatics, University of Edinburgh}
}

@techreport{burg99,
title = {The Concurrent {M}assey {H}ope+{C} Functional Language System},
author = {Peter Burgess and Nigel Perry and Robert Pointon},
type = "Report",
institution = {Massey University},
year = 1999,
note = {Available on request from Nigel Perry.},
comment = {Technique similar to that of \cite{hend02} for finding pointers.}
}

@inproceedings{burn87,
title = "Parallel Reduction Architecture",
author = "T. D. Burnett",
booktitle = "IFIP WG 10.3 Working Conference for Numerical and Signal Processing Applications on Highly Parallel Computers",
address = {Sophia Antipolis, France},
month = mar,
publisher = "North-Holland",
pages = "41--57",
year = "1987",
isbn = "0--444--70131--1",
abstract = {
A parallel machine architecture is presented aimed at digital
signal processing applications.  The ability of the reduction language F. P. to
express parallelism within algorithm is used as the basis for this parallel
processor.  Efficiency of operation of each individual processing element is
stressed and a novel garbage collection techniques which imposes negligible time
penalty makes a major contribution to this efficiency.  This paper reports
simulation results which indicate that the architecture is well suited to
high performance signal processing.}
}

@article{burt00,
author = {Joshua W. Burton},
title = {Garbage Collection on the Run},
journal = Dobbs,
volume = 311,
pages = {46--53},
month = apr,
year = 2000
}

@article{burt76,
author = "F. Warren Burton",
title = "A Buddy System Variation for Disk Storage Allocation",
journal = CACM,
publisher = ACM,
volume = 19,
number = 7,
month = jul,
year = 1976,
pages = "416--417",
doi={10.1145/360248.360259}
}

@article{burt00a,
author = {F. Warren Burton and David J. Simpson},
title = {Memory Requirements for Parallel Programs},
journal = {Parallel Computing},
volume = 26,
number = {13---14},
year = 2000,
pages = {1739---1763},
URL = {http://www.elsevier.nl/PII/S0167819100000533}
}

@inproceedings{butl86,
title = "Storage Reclamation for Object Oriented Database Systems: a Summary
of the Expected Costs",
author = "Margaret H. Butler",
booktitle = "International Workshop on Object-Oriented Database Systems",
address={Pacific Grove, CA},
month=sep,
publisher = IEEE,
pages = "210--211",
year = 1986,
abstract = {A brief description is given of the model used for evaluating
garbage collection algorithms.  A summary is then provided of the results of a
study analyzing the input/output behavior of existing automatic storage
reclamation schemes when operating on data stored in a database management
system.  The tradeoffs that must be kept in mind when choosing a storage
reclamation scheme for a database system are examined.},
comment = {Generational hypothesis does not apply to large distributed DBs?}
}

@inproceedings{butl87,
author = "Margaret H. Butler",
title = "Storage Reclamation in Object Oriented Database Systems",
booktitle = SIGMOD,
pages = "410--425",
month = may,
year = 1987,
address = {San Francisco, CA},
doi={10.1145/38713.38757}
}

@techreport{butt07,
title = {Total Cost of Ownership: A Comparison of {C}/{C++} and {J}ava},
author = {Albin M. Butters},
institution = {Evans Data Corporation},
month = jun,
year = 2007,
comment = { Surveyed 350 developers from around the world.
Harder to find skilled C/C++ developers than skilled Java developers.
One average, developers have more years of experience with C/C++ than with Java.
Clear majority (at least 60\%) believe Java allows applications to be rolled out
quicker, and that C/C++ is more difficult to maintain.
Applications written with Java entail easier post-production maintenance than those written with C/C++
C/C++ applications take 52\% longer to develop and 44\% longer to maintain.
C/C++ is more expensive than Java is based on actual experience paying for licenses, support, training, updates, and so forth. }
}

@inproceedings{buyt04,
author = {Dries Buytaert and Kris Venstermans and Lieven Eeckhout and De Bosschere, Koen},
title = {Garbage Collection Scheduling},
booktitle = {Program Acceleration through Application and Architecture Driven
Code Transformations: Symposium Proceedings},
year = 2004,
pages = {47--49},
}

@inproceedings{buyt05,
author = {Dries Buytaert and Kris Venstermans and Lieven Eeckhout and De Bosschere, Koen},
title = {Garbage Collection Hints},
booktitle = {HiPEAC 2005 International Conference on High Performance Embedded
Architectures and Compilers},
address = {Barcelona},
month = nov,
year = 2005,
URL = {http://buytaert.net/files/hipeac05-paper.pdf}
}

@inproceedings{cahi93,
title = "The {A}madeus {GRT} --- Generic Runtime Support for Distributed Persistent Programming",
author = {Vinny Cahill and Se\'{a}n Baker and Chris Horn and Gradimir Stavovic},
crossref = "OOPSLA93",
note = {Technical report TCD--CS--93--37}
}

@inproceedings{cai03,
author = {H. Cai and A. J. Wellings},
title = {Towards a High-Integrity Real-Time {J}ava Virtual Machine},
booktitle = {On the Move to Meaningfull Internet Systems 2003: Workshop on Java Technologies for Real-Time and Embedded Systems},
series = LNCS,
volume = 2889,
pages = {319--334},
publisher =    SV,
year = 2003,
abstract = {This paper defines a run-time architecture for a Java Virtual
Machine (JVM) that supports the Ravenscar-Java profile (RJVM). This architecture
introduces an early class loading and verifying model that can facilitate the
predictable efficient execution of Java applications, detect program errors at
the initialization phase and prevent errors occurring during the mission phase.
A pre-emptive fixed priority scheduler is provided which supports the immediate
ceiling priority protocol to facilitate efficient resource usage. An economical
predictable memory management model based on heap, immortal and linear time
scoped memory (LTM) is presented. The integration of our proposed runtime
architecture and the KVM is discussed.},
URL = {http://www.cs.york.ac.uk/rts/cgi-bin/bibtex/bibtex.pl?key=R:Cai:2003}
}
@inproceedings{calc01,
author = {Cristiano Calcagno},
title = {Program Logics in the Presence of Garbage Collection},
crossref = {SPACE01},
}

@article{calc03,
title = {Program Logic and Equivalence in the Presence of Garbage Collection},
author = {Cristiano Calcagno and Peter O'Hearn and Richard Bornat},
journal = {Theoretical Computer Science},
volume = 298,
number = 3,
year = 2003,
URL = {http://www.dcs.qmw.ac.uk/~ohearn/papers/GI-tcs.ps},
}

@article{cald94,
title = {Quantifying Behavioral Differences Between {C} and {C++} Programs},
author = {Brad Calder and Dirk Grunwald and Benjamin Zorn},
journal = {Journal of Programming Languages},
year = 1994,
volume = 2,
number = 4,
pages = {313--351},
URL = {ftp://ftp.cs.colorado.edu/pub/techreports/zorn/CU-CS-698-94.ps.Z},
abstract = {Improving the performance of C programs has been a topic of great
interest for many years.  Both hardware technology and compiler
optimization research has been applied in an effort to make C programs
execute faster.  In many application domains, the C++ language is
replacing C as the programming language of choice.  In this paper, we
measure the empirical behavior of a group of significant C and C++
programs and attempt to identify and quantify behavioral differences
between them.  Our goal is to determine whether optimization
technology that has been successful for C programs will also be
successful in C++ programs.  We furthermore identify behavioral
characteristics of C++ programs that suggest optimizations that should
be applied in those programs.  Our results show that C++ programs
exhibit behavior that is significantly different than C programs.
These results should be of interest to compiler writers and
architecture designers who are designing systems to execute
object-oriented programs.}
}

@inproceedings{cald98,
  title =	 {Cache-Conscious Data Placement},
  author =	 {Brad Calder and Chandra Krintz and S. John and T. Austin},
  crossref =	 {ASPLOS98},
  pages =	 {139-149},
  doi =		 {10.1145/291069.291036}
}

@article{camp71,
author = "John A. Campbell",
title = "A Note on an Optimal-Fit Method for Dynamic Allocation of Storage",
journal = CompJ,
publisher = BCS,
volume = 14,
number = 1,
year = 1971,
month = feb,
pages = "7--9"
}

@article{camp74,
author = "John A. Campbell",
title = "Optimal Use of Storage in a Simple Model of Garbage Collection",
journal = IPL,
publisher = NH,
volume = 3,
number = 2 ,
month = Nov,
year = 1974,
pages = "374",
}

@techreport{camp86,
title = {A Persistent Store Garbage Collector with Statistical Facilities},
author = {J. Campin and Malcolm Atkinson},
institution = {Universities of Glasgow and St Andrews},
year = 1986
}

@phdthesis{camp93,
author = "Alvaro E. Campos",
title = "Distributed, Garbage-Collected, Persistent, Virtual Address Spaces",
school = "Princeton University",
type = "{PhD} Dissertation",
address = "Department of Computer Science",
month = jun,
year = 1993,
URL = "http://ncstrl.cs.Princeton.EDU/expand.php?id=TR-419-93"
}

@inproceedings{camp93a,
author = "Alvaro E. Campos and David R. Hanson",
title = "Garbage Collection in {EZ}",
booktitle = "13th International Conference on Computer Science",
address = "La Serena, Chile",
mont = oct,
year = 1993,
publisher = "Plenum Press",
editor = "R. Baeza-Yates"
}

@techreport{cann88,
author = "D. C. Cann and Rod R. Oldehoeft",
title = "Reference Count and Copy Elimination for Parallel Applicative Computing",
institution = "Department of Computer Science, Colorado State University",
address = "Fort Collins, CO",
number = "CS--88--129",
year = 1988
}

@manual{cann92,
author = "D. C. Cann and J. T. Feo and A. D. W. Bohoem and Rod R. Oldehoeft",
title = "{SISAL} Reference Manual: Language Version 2.0",
year = 1992,
URL = "ftp://sisal.llnl.gov/pub/sisal/publications.dir/s2.manual.ps.Z"
}

@inproceedings{cann00,
  title =	 {Contaminated Garbage Collection},
  author =	 {Dante Cannarozzi and Michael P. Plezbert and Ron Cytron},
  crossref =	 {PLDI00},
  pages =	 {264-273},
  doi =		 {10.1145/349299.349334}
}

@inproceedings{cao11,
author = {Ting Cao and Stephen M. Blackburn and Tiejun Gao and Kathryn S. McKinley},
title = "Virtual Machine Services: An Opportunity for Hardware Customization",
booktitle = {Workshop on Energy-efficient Computing for a Sustainable World (EESC)}, 
address = {Porto Alegre, Brazil},
month = dec,
year = 2011,
note = {Held in conjunction with MICRO-44},
URL = {http://users.cecs.anu.edu.au/~tingc/EESC-Ting%20Cao.pdf}
}

@inproceedings{cao12,
author = {Ting Cao and Stephen M. Blackburn and Tiejun Gao and Kathryn S. McKinley},
title = "The Yin and Yang of Power and Performance for Asymmetric Hardware and
Managed Software",
crossref = "ISCA12",
url = {http://users.cecs.anu.edu.au/~tingc/yinyang-isca-2012.pdf},
note = {Data at
http://users.cecs.anu.edu.au/~steveb/downloads/results/yinyang-isca-2012.zip}
}

@techreport{cao12a,
author = {Ting Cao and Stephen M. Blackburn and Kathryn S. McKinley},
title = "System Design for Heterogeneity: The Virtual Machine Services Test Case",
institution = {Australian National University}, 
number = {TR--CS--12--01},
year = 2012,
URL = {http://users.cecs.anu.edu.au/~tingc/techReport-TingCao.pdf}
}

Proceedings of the 39th International Symposium on Computer Architecture (ISCA), Portland, OR, USA, June 2012. 
@inproceedings{capl88,
author = "Michael Caplinger",
title = "A Memory Allocator with Garbage Collection for {C}",
booktitle = "{USENIX} Winter Conference",
publisher = UA,
pages = "323--323",
year = 1988
}

@inproceedings{card84,
author = "Luca Cardelli",
title = "Compiling a Functional Language",
pages = "208--217",
crossref = "LFP84",
}

@techreport{card88,
author = "Luca Cardelli and James Donahue and Lucille Glassman and Mick Jordan
and Bill Kalsow and Greg Nelson",
title = "Modula-3 Report (revised)",
institution = "DEC Systems Research Center and Olivetti Research Center",
type = "Research Report",
number = "PRC--131",
year = 1988
}

@incollection{card91,
author = {Luca Cardelli},
title = {Typeful Programming},
booktitle = {Formal Description of Programming Concepts},
editor = {E.J. Neuhold and M. Paul},
publisher = SV,
year = 1991,
URL = {http://research.microsoft.com/research/cambridge/luca/Papers/TypefulProg.ps},
note = {Revised 1 January, 1993}
}

@article{card92,
  author =	 "Luca Cardelli and James Donahue and Lucille Glassman and
                  Mick Jordan and Bill Kalsow and Greg Nelson",
  title =	 "{Modula-3} Language Definition",
  journal =	 SIGPLAN,
  publisher =	 ACM,
  volume =	 27,
  number =	 8,
  pages =	 "15--42",
  month =	 aug,
  year =	 1992,
  doi =		 {10.1145/142137.142141}
}

@article{carl92,
author = "Carlini, Giuliano and Rendina, Susan",
title = "Garbage Collection for {C} Programs",
journal = Dobbs,
volume = 17,
number = 11,
month = nov,
year = 1992
}

@inproceedings{carl87,
author = "M. Carlsson",
title = "Freeze, Indexing and Other Implementation Issues in the {WAM}",
crossref = "ICLP87",
pages = "40--58",
}

@inproceedings{carl90,
author = "Svante Carlsson and Christer Mattsson and Mats Bengtsson",
title = "A Fast Expected-Time Compacting Garbage Collection Algorithm",
crossref = "OOPSLA90-gc",
}

@inproceedings{carl91,
author = "Svante Carlsson and Christer Mattsson and Mats Bengtsson and
Patricio Poblete",
title = "A New Compacting Garbage Collection Algorithm with a Good
Average-Case Performance",
booktitle = "STACS-91",
year = 1991
}

@inproceedings{cart89,
title = "Cascade: Hardware for High/Variable Precision Arithmetic",
author = "A. M. Carter",
booktitle = "9th Symposium on Computer Arithmetic",
address = {Santa Monica, CA},
month = sep,
publisher = IEEE,
pages = "184--191",
year = 1989,
doi = {10.1109/ARITH.1989.72825},
abstract = {The Cascade hardware architecture for high/variable precision
arithmetic is described.  It uses a radix-16 redundant signed-digit number
representation and directly supports single or multiple precision addition,
subtraction, multiplication, division, extraction of the square root, and
computation of the greatest divisor.  It is object-oriented and implements an
abstract class of objects, variable precision integers.  It provides a complete
suite of memory management functions implemented in hardware, including a
garbage collector.  The Cascade hardware permits free tradeoffs of space
versus time.}
}

@article{case91,
author = "Brian Case",
title = "{PA--RISC} Provides Rich Instruction Set within {RISC} Framework",
journal = "Microprocessor Report",
volume = 5,
number = 6,
month = apr,
year = 1991
}

@inproceedings{caud86,
author = "Caudill, Patrick J. and Allen Wirfs-Brock",
title = "A Third-Generation {S}malltalk-80 Implementation",
crossref = "OOPSLA86",
pages = "119--130",
doi={10.1145/28697.28709},
comment = {
In order to resolve the problem of too much tenured garbage,
objects have to pass through multiple generations (each of which is subject to
periodic reclamation) before obtaining tenure.
Copying collector but uses a separate large object area.
Tektronix 4406 Smalltalk, using semispaces for each of 8 generations. }
}

@manual{cent92,
title = "Code{C}enter, The Programming Environment",
key = "CenterLine",
organization = "CenterLine Software",
address = "Cambridge, MA",
year = 1992
}

@inproceedings{chai84,
author = {J\'{e}rome Chailloux and Matthieu Devin and Jean-Marie Hullot},
title = "Le\_{L}isp: A Portable and Efficient {L}isp System",
crossref = "LFP84",
pages = "113-122",
comment = "The heap is divided into separate areas, which are collected
simultaneously but by distinct, although co-operating, strategies."
}

@article{chai90,
author = "Chaiken, David and Craig Fields and Kiyoshi Kurihara and Anant
Agarwal",
title = "Directory-Based Cache Coherence in Large-Scale Multiprocessors",
journal = "IEEE Computer",
publisher = IEEE,
volume = 23,
number = 6,
month = jun,
year = 1990,
pages = "49--58"
}

@phdthesis{chai91,
author = "Emmanuel Chailloux",
title = "Compilation des Langages Fonctionnels: {CeML} un Traducteur {ML}
vers {C}",
school = {Universit\'{e} de Paris VII},
year = 1991,
month = nov
}

@inproceedings{chai92,
title = "A Conservative Garbage Collector with Ambiguous Roots for Static Typechecking Languages",
author = "Emmanuel Chailloux",
crossref = "IWMM92",
pages = {218--229},
doi = {10.1007/BFb0017192}
}

@inproceedings{chai92a,
author = "Emmanuel Chailloux",
title = "An Efficient Way of Compiling {ML} to {C}",
booktitle = "{ACM} {SIGPLAN} {W}orkshop on {ML} and its Applications, San
Francisco",
publisher = ACM,
editor = "David MacQueen",
year = 1992,
month = jun
}

@inproceedings{cham89,
title = "An Efficient Implementation of {SELF}, a Dynamically-Typed
Object-Oriented Language Based on Prototypes",
author = "Craig Chambers and David M. Ungar and Elgin Lee",
crossref = "OOPSLA89",
pages = "48--70",
doi = {10.1145/74877.74884}
}

@inproceedings{cham89a,
author = "Craig Chambers and David M. Ungar",
title = "Customization:  Optimizing Compiler Technology for {S}elf, a
Dynamically-Typed Object-Oriented Language",
crossref = {PLDI89},
pages = "146--160",
doi = {10.1145/73141.74831}
}

@article{cham91,
title = "An Efficient Implementation of {SELF}, a Dynamically-Typed
Object-Oriented Language Based on Prototypes",
author = "Craig Chambers and David M. Ungar and Elgin Lee",
journal = LSC,
volume = 4,
number = 3,
year = 1991,
pages = "243--281",
doi = {10.1007/BF01806108}
}

@inproceedings{cham91a,
author = "Craig Chambers",
title = "Cost of Garbage Collection in the {SELF} System",
crossref = "OOPSLA93-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/chambers.ps"
}

@phdthesis{cham92,
author = "Craig Chambers",
title = "The Design and Implementation of the {SELF} Compiler, an Optimizing
Compiler for an Objected-Oriented Programming Language",
school = "Stanford University",
month = mar,
year = 1992,
comment = "Improvement of (wils89b) card-marking scheme."
}

@inproceedings{chan89,
author = "Ellis E. Chang and Randy H. Katz",
title = "Exploiting Inheritance and Structure Semantics for
Effective Clustering and Buffering in an Object-Oriented {DBMS}",
crossref = "SIGMOD89",
pages = "348--357"
}

@article{chan84,
title = "Reliable Broadcast Protocols",
author = "J. Chang and N. F. Maxemchuk",
journal = TransCompSys,
publisher = ACM,
volume = 2,
nunber = 3,
pages = "251--273",
month = aug,
year = 1984,
comment = "Atomic multicast protocol."
}

@inproceedings{chan93,
author = "J. Morris Chang and Edward F. Gehringer",
title = "Evaluation of an Object-Caching Coprocessor Design for Object-Oriented Systems",
booktitle = "International Conference on Computer Design",
publisher = IEEE,
month = oct,
year = 1993,
address = {Cambridge, MA},
doi = {10.1109/ICCD.1993.393393},
pages = {132--139},
comment = "Coprocessor manages objects in the cache by reference
counting"
}

@inproceedings{chan93a,
author = "J. Morris Chang and Edward F. Gehringer",
title = "Performance of Object Caching for Object-Oriented Systems",
booktitle = "IFIP TC10/WG10.5 International Conference on Very Large Scale
Integration",
address = {Grenoble, France},
pages = {83--91},
month = sep,
year = 1993,
comment = "Coprocessor manages objects in the cache by reference
counting"
}

@article{chan96,
author = {J. Morris Chang and Edward F. Gehringer},
title = {A High-Performance Memory Allocator for Object-Oriented Systems},
journal = IEEETransComp,
month = mar,
year = 1996,
pages = {357--366}
}

@article{chan97,
author = {J. Morris Chang},
title = {An Optimized Two-Dimensional Buddy System for Dynamic Resource Allocation},
journal = {Journal of High Performance Computing},
volume = 4,
number = 1,
month = dec,
year = 1997,
pages = {47--55}
}

@inproceedings{chan98,
author = {J. Morris Chang and Woo Hyong Lee},
title = {A Study on Memory Allocations in {C++}},
booktitle = {14th International Conference on Advanced Science and Technology},
address = {Naperville, IL},
month = apr,
year = 1998,
pages = {53--62}
}

@inproceedings{chan99,
author = {J. Morris Chang and Witiwas Srisa-an and Chia-Tien Dan Lo},
title = {{DMMX} (Dynamic Memory Management Extensions): An Introduction},
booktitle = {Workshop notes of ICCD workshop on Hardware Support for Objects and Microarchitectures for Java},
address = {Austin, TX},
month = oct,
year = 1999,
pages = {11-14}
}

@inproceedings{chan99a,
author = {J. Morris Chang and Woo Hyong Lee and Yusuf Hasan},
title = {Measuring Dynamic Memory Invocations in Object-Oriented Programs},
booktitle = {18th IEEE International Performance Conference on Computers and Communications},
address = {Phoenix, AZ},
month = feb,
year = 1999,
pages = {268--274}
}

@inproceedings{chan99b,
author = {J. Morris Chang and Witiwas Srisa-an and Chia-Tien Dan Lo},
title = {{OMeX}: Object Management Extensions for Embedded Systems},
booktitle = {2nd International Workshop on Compiler and Architecture Support for Embedded Systems},
address = {Washington, DC},
month = oct,
year = 1999
}

@article{chan00,
author = {J. Morris Chang and Charles H. Daugherty},
title = {An Efficient Data Structure for Dynamic Memory Management},
journal = JSS,
year = 2000,
volume = 54,
number = 3,
pages = {219-226},
month = nov,
doi={10.1016/S0164-1212(00)00039-X}
}

@inproceedings{chan00b,
author = {J. Morris Chang and Witiwas Srisa-an and Chia-Tien Dan Lo},
title = {Architectural Support for Dynamic Memory Management},
booktitle = {IEEE International Conference on Computer Design},
address = {Austin, TX},
month = sep,
year = 2000,
pages = {99--104},
doi = {10.1109/ICCD.2000.878274}
}

@inproceedings{chan00c,
author = {J. Morris Chang and Chia-Tien Dan Lo and Edward F. Gehringer},
title = {Hardware Support for Dynamic Memory Management},
booktitle = {Workshop notes of} # ISCA # {workshop on Solving the Memory Wall Problem},
address = {Vancouver},
month = jun,
year = 2000
}

@inproceedings{chan00d,
author = {J. Morris Chang and Yusuf Hasan and Woo Hyong Lee},
title = {High-performance Memory Allocator for Memory Intensive Applications},
booktitle = {4th IEEE International Conference on High Performance Computing in Asia-Pacific Region},
address = {Beijing, China},
month = may,
year = 2000,
pages = {6--12}
}

@inproceedings{chan00e,
author = {J. Morris Chang and Witiwas Srisa-an and C.D. Lo},
title = {Hardware Support for Concurrent Garbage Collection in {SMP} Systems},
booktitle = {4th  IEEE International Conference on High Performance Computing in Asia-Pacific Region},
address = {Beijing, China},
month = may,
year = 2000,
pages = {513--517}
}

@article{chan01,
author = {J. Morris Chang and W.H. Lee and Witiwas Srisa-an},
title = {A Study of the Allocation Behavior of {C++} Programs},
journal = JSS,
year = 2001,
note = {accepted for publication, Fall 2001}
}

@article{chan02,
author = {J. Morris Chang and Witawas Srisa-an and Chia-Tien Dan Lo and Edward F. Gehringer},
title = {{DMMX}: Dynamic Memory Management Extensions},
journal = JSS,
volume = 63,
number = 3,
abstract = {Dynamic memory management allows programmers to be more
productive and increases system reliability and functionality. However,
software algorithms for memory management are slow and
non-deterministic. It is well known that object-oriented applications
tend to be dynamic memory intensive. This has led programmers to eschew
dynamic memory allocation for many real-time and embedded systems.
Instead, programmers using Java or C++ as a development language
frequently decide to allocate memory statically instead of dynamically.
In this paper, we present the design of a bitmap-based memory allocator
implemented primarily in combinational logic to allocate memory in a
small, predictable amount of time. It works in conjunction with an
application-specific instruction-set extension called the dynamic
memory management extension (DMMX). Allocation is done through a
complete binary tree of combinational logic, which allows constant-time
object creation. The garbage collection algorithm is mark sweep, where
the sweeping phase can be accomplished in constant time. This hardware
scheme can greatly improve the speed and predictability of dynamic
memory management. The proposed DMMX is an add-on approach, which
allows easy integration into any CPU, hardware-implemented Java virtual
machine, or processor in memory.},
month = sep,
year = 2002,
URL = {http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6V0N-45BHK2S-2&_user=125871&_coverDate=09%2F15%2F2002&_alid=58536322&_rdoc=2&_fmt=full&_orig=search&_qd=1&_cdi=5651&_sort=d&_acct=C000010239&_version=1&_urlVersion=0&_userid=125871&md5=bb2d052b708f1ed95f4dc253dea98b0f}
}

@inproceedings{chan02a,
title = {A Real-Time Garbage Collection Mechanism for Flash-Memory Storage
Systems in Embedded Systems},
author = {Li-Pin Chang and Tei-Wei Kuo},
crossref = {RTCSA02},
URL = {http://www.csie.ntu.edu.tw/~d6526009/papers/RTCSA-rdy.pdf}
}

@article{chan04,
author = {Chang, Li-Pin and Kuo, Tei-Wei and Lo, Shi-Wu},
title = {Real-Time Garbage Collection for Flash-Memory Storage Systems of Real-Time Embedded Systems},
journal = TECS,
volume = 3,
number = 4,
month = nov,
year = 2004,
issn = {1539-9087},
pages = {837--863},
doi = {10.1145/1027794.1027801},
publisher = ACM,
abstract = {flash-memory technology is becoming critical in building embedded
systems applications because of its shock-resistant, power economic, and
nonvolatile nature. With the recent technology breakthroughs in both capacity
and reliability, flash-memory storage systems are now very popular in many types
of embedded systems. However, because flash memory is a write-once and
bulk-erase medium, we need a translation layer and a garbage-collection
mechanism to provide applications a transparent storage service. In the past
work, various techniques were introduced to improve the garbage-collection
mechanism. These techniques aimed at both performance and endurance issues, but
they all failed in providing applications a guaranteed performance. In this
paper, we propose a real-time garbage-collection mechanism, which provides a
guaranteed performance, for hard real-time systems. On the other hand, the
proposed mechanism supports non-real-time tasks so that the potential bandwidth
of the storage system can be fully utilized. A wear-leveling method, which is
executed as a non-real-time service, is presented to resolve the endurance
problem of flash memory. The capability of the proposed mechanism is
demonstrated by a series of experiments over our system prototype.}
} 

@inproceedings{chan05,
author = {Yang Chang and Andy Wellings},
title = {Integrating Hybrid Garbage Collection with Dual Priority Scheduling},
crossref = {RTCSA05},
pages = {185--188},
doi={10.1109/RTCSA.2005.56},
abstract = {In this paper, we propose an approach to integrate a hybrid garbage
collection algorithm (a combination of reference counting and mark-and-sweep
techniques) into the current response time analysis framework for real-time
systems. Instead of collecting garbage incrementally, we put most GC work into a
periodic real-time thread, namely the GC thread, which is scheduled according to
the dual priority scheduling method. More importantly, we can perform
schedulability analysis (response time analysis) for all the real-time threads
including the GC thread.},
URL = {http://www.cs.york.ac.uk/rts/cgi-bin/bibtex/bibtex.pl?key=R:Chang:2005}
}

@techreport{chan05a,
author = {Yang Chang},
title = {Integrating Hybrid Garbage Collection with Dual Priority Scheduling},
institution = {University of York},
year = 2005,
number = {YCS388(2005)},
abstract = {In this report, we propose an approach to integrate a hybrid garbage
collection algorithm into the current response time analysis framework for
real-time systems. In our approach, the collection algorithm is a combination of
reference counting and mark-and-sweep techniques so we can keep the advantages
of reference counting while eliminating cyclic garbage by invoking
mark-and-sweep occasionally. Instead of collecting garbage incrementally, we put
most GC work into a periodic real-time thread, namely the GC thread, which is
scheduled according to the dual priority scheduling method. By performing static
analysis, we can get the GC thread's parameters such as period, deadline,
priority and worst case execution time. With these parameters, we can perform
schedulability analysis (response time analysis) for all the real-time threads
including the GC thread.},
URL = {http://www.cs.york.ac.uk/rts/cgi-bin/bibtex/bibtex.pl?key=R:Chang:2005a}
}


@inproceedings{chan06,
author = {Yang Chang and Andy Wellings},
title = {Low Memory Overhead Real-Time Garbage Collection for {J}ava},
booktitle = {4th International Workshop on Java Technologies for Real-time and Embedded Systems},
year = 2006,
month = oct,
address = {Paris, France},
abstract = {Current real-time garbage collection algorithms are usually
criticised for their high memory requirements. Even when consuming nearly 50\%
of cpu time, some garbage collectors ask for at least twice the memory as really
needed. This paper explores the fundamental reason for this problem and proposes
a new performance indicator for better design of real-time garbage collection
algorithms. Use of this indicator motivates an algorithm that combines both
reference counting and mark-and-sweep techniques. The implementation of this
algorithm for jRate is described and its performance reviewed. The use of dual
priority scheduling of the garbage collection tasks allows spare capacity in the
system to be reclaimed whilst guaranteeing deadlines.},
URL = {http://www.cs.york.ac.uk/rts/cgi-bin/bibtex/bibtex.pl?key=R:Chang:2006},
doi = {10.1145/1167999.1168014}
}

@inproceedings{chan06a,
author = {Yang Chang and Andy J. Wellings},
title = {Hard Real-time Hybrid Garbage Collection with Low Memory Requirements},
booktitle = {27th IEEE Real-Time Systems Symposium},
year = 2006,
pages = {77--86},
month = dec,
doi={10.1109/RTSS.2006.25},
abstract = {Current real-time garbage collection algorithms are usually
criticised for their high memory requirements. Even when consuming nearly 50\%
of CPU time, some garbage collectors ask for at least twice the memory as really
needed. This paper explores the fundamental reason for this problem and proposes
a new performance indicator for the evaluation of real-time garbage collection
algorithms. Use of this performance indicator motivates an algorithm that
combines both reference counting and mark-and-sweep techniques. In the presence
of our collector, a garbage collected hard real-time system can achieve the
correct balance of time-space tradeoff with less effort. In order to provide
both temporal and spatial guarantees needed by a hard real-time application, an
offline analysis is developed and integrated into the current response time
analysis framework. Moreover, the use of dual priority scheduling of the garbage
collection tasks allows spare capacity in the system to be reclaimed whilst
guaranteeing deadlines.},
URL = {http://www.cs.york.ac.uk/rts/cgi-bin/bibtex/bibtex.pl?key=R:Chang:2006a}
}

@techreport{chan06b,
author = {Yang Chang},
title = {Hard Real-time Hybrid Garbage Collection with Low Memory Requirement},
institution = {University of York},
year = 2006,
abstract = {Current real-time garbage collection algorithms are usually
criticised for their high memory requirements. Even when consuming nearly 50\%
of cpu time, some garbage collectors ask for at least twice the memory as really
needed. This report explores the fundamental reason of this problem and proposes
new metrics for real-time garbage collection algorithm designs. Use of these
metrics motivate an algorithm that combines both reference counting and
mark-and-sweep techniques. The use of dual priority scheduling of the garbage
collection task allows spare capacity in the system to be reclaimed whilst
guaranteeing deadlines.},
URL = {http://www.cs.york.ac.uk/rts/cgi-bin/bibtex/bibtex.pl?key=R:Chang:2006b}
}

@phdthesis{chan07,
author = {Yang Chang},
title = {Garbage Collection for Flexible Hard Real-time Systems},
school = {University of York},
year = 2007
}

@book{chan86,
title = "Efficient Use of Systems with Many Processors",
author = "R. J. Chansler",
publisher = "University of Michigan Press, Ann Arbor, MI",
series = "Computer science:  computer architecture and design",
number = 6,
year = "1986",
pages = "130",
isbn = "0--8357--1749--6",
abstract = {In the Introduction, the author says that his primary thesis is that ``the
performances of a system can be improved by relaxing the coupling among its
component parts,'' and that ``the interest [of the book] lies in the
performance domain.'' The book contains a case study of some aspects of the
garbage collector of the Cm*/STAROS system (Chapters 2, 3, and 4) and a
synthesis based on this case (Chapters 5, 6, and 7).
Chapter 2 begins by arguing about the necessity of a garbage collector for
STAROS. The author then points out that the analysis of the garbage
collector is an important topic in the performance study of a system with
many processors. Chapter 3 deals with the problem and performances of
local garbage collection, while Chapter 4 tackles the question of ``when'' the
garbage collection must be made. From Chapter 5, the author analyzes four
types of coupling induced by contention for processors, contention for
resources, communication between processors, and synchronization. Chapter 5,
after some considerations about the case, gives programmers some
practical advice to reduce the coupling caused by the contention for
processors. Two examples of this advice are:  ``Exploit features of the
machine architecture that allow effective use of otherwise idle processors'';
and ``Allocate work to processes that need not compete for processors.''
Chapter 6 also emphasizes hardware structure; the author is ``cognizant of
the peculiarities of the hardware architecture.'' In the same chapter the
author, after an analysis of the STAROS garbage collector, ironically
observes that ``bad programs exploit multiprocessors more effectively than
good programs.'' Chapters 7 and 8 deal with two problems that are often
merged in the literature: communication and synchronization between
processors. The author says that it is often better to compute than to
communicate, and that it is necessary ``to design algorithms to be tolerant
to imprecise data.'' On the subject of synchronization, the author starts
with an introduction where ``the synchronization . . . as the task of
preventing concurrent execution of processes'' is opposed to the
``synchronization as a way to direct the attention of a process or to
assign work.'' An example from STAROS and, as usual, some advice on how
to reduce coupling are presented.
The book is a research book and it fulfills its purpose, especially for
readers interested in the Cm*/STAROS system. The length is just right.
However, I think that two articles in a research journal would have been a
better choice for the author. The best feature of the book is the case
study. The worst is the synthesis because it is sometimes too commonplace.
The book is interesting, and the ideal reader is a graduate student or a
researcher working on multiprocessors. The title is a little misleading. A
better title would emphasize garbage collection and STAROS, which
occupies at least two-thirds of the book.}
}

@phdthesis{chas87,
author = "David R. Chase",
title = "Garbage Collection and Other Optimizations",
school = Rice,
month = Aug,
year = 1987,
doi = {1911/16127},
URL = {http://world.std.com/~chase/dissertation.pdf},
comment = "see also http://www.centerline.com/people/chase/papers/thesis/*.ps"
}

@inproceedings{chas88,
title = "Safety Considerations for Storage Allocation Optimizations",
author = "David R. Chase",
crossref={PLDI88},
pages = "1--10",
doi={10.1145/53990.53991}
}

@article{chas90,
author = "David R. Chase and Wegman and Zadeck",
title = "Analysis of Pointers and Structures",
journal = SIGPLAN,
publisher = ACM,
volume = 25,
number = 6,
year = 1990,
comment = "Incremental Static Single Assignment form, plus heuristics
           for detecting trees, and careful treatment of evaluation
           order to preserve monotonic behavior.",
abstract = {suggested reference on compile-time garbage collection.
            Imperative programs.}
}

@inproceedings{chas92,
author = "Jeffrey S. Chase and Henry M. Levy and Edward D. Lazowska and Miche
Baker-Harvey",
title = "Lightweight Shared Objects in a 64-bit Operating System",
crossref = "OOPSLA92",
}

@article{chaw03,
title = {Fine-tuning {J}ava Garbage Collection Performance:
How to Detect and Troubleshoot Garbage Collection Issues with the {IBM} {J}ava Virtual Machine},
author = {Sumit Chawla},
journal = {IBM developerWorks},
month = jan,
year = 2003,
URL = {http://www-106.ibm.com/developerworks/ibm/library/i-gctroub/},
}

@techreport{chas92a,
author = "Jeffrey S. Chase and Henry M. Levy and Miche Baker-Harvey
and Edward D. Lazowska",
title = "How To Use a 64-bit Virtual Address Space",
institution = "University of Washington",
address = "Seattle, WA",
number = "92-03-02",
year = 1992,
month = feb
}

@inproceedings{chea00,
author = {Cheadle, Andrew M. and Field, Anthony J. and Marlow, Simon and Peyton Jones, Simon L. and While, R.L},
title = {Non-stop {H}askell},
crossref = {ICFP00},
pages = {257--267},
doi = {10.1145/351240.351265},
comment = {A prototype in Haskell GHC4.01 RTS of Baker as described in \cite{whil92}.}
}

@inproceedings{chea04,
author = {Cheadle, Andrew M. and Field, Anthony J. and Marlow, Simon and
Peyton Jones, Simon L. and While, Lyndon},
title = {Exploring the Barrier to Entry --- Incremental Generational Garbage
Collection for {H}askell},
pages = {163--174},
crossref = {ISMM04},
doi={10.1145/1029873.1029893}
}

@inproceedings{chea06,
title = {Visualising Dynamic Memory Allocators},
author = {Andrew Cheadle and Tony Field and John Ayres and Neil Dunn and Richard Hayden and Johan Nystrom-Persson},
pages = {115--125},
crossref = {ISMM06},
}

@inproceedings{chea08,
author = "A. M. Cheadle and A. J. Field and J. Nystr{\"{o}}m-Persson",
title = "A Method Specialisation and Virtualised Execution Environment for {Java}",
crossref = {VEE08},
pages = {51--60},
comment = {Uses virtual dispatch for each object access plus ability to flip
           between different specialised method tables so as to provide
           what amounts to a self-erasing read barrier that copies an object
           to to-space},
doi = {10.1145/1346256.1346264}
}

@inproceedings{chen03b,
author = {D. Chen and A. Messer and D. Milojicic and S. Dwarkadas},
title = {Garbage Collector Assisted Memory Offloading for Memory Constrained Devices},
booktitle = {5th IEEE Workshop on Mobile Computing Systems and Applications},
publisher = IEEE,
year = 2003
}

@inproceedings{chen02,
title = {Adaptive Garbage Collection for Battery-Operated Environments},
author = {Gungyu Chen and Mahmut T. Kandemir and Narayanan Vijaykrishnan and Mary Jane Irwin and Mario Wolczko},
crossref = {JVM02},
pages = {1--12},
URL = {http://static.usenix.org/event/jvm02/full_papers/chen_g/chen_g.ps}
}

@inproceedings{chen02a,
title = {Tuning Garbage Collection in an Embedded {J}ava Environment},
author = {Gungyu Chen and R. Shetty and Mahmut T. Kandemir and Narayanan Vijaykrishnan and Mary Jane Irwin and Mario Wolczko},
booktitle = "8th Annual Symposium on High-Performance Computer Architecture",
publisher = IEEEcomp,
address = {Boston, MA},
pages = {92--103},
month = feb,
year = 2002,
doi = {10.1109/HPCA.2002.995701},
}

@article{chen02b,
title = {Tuning Garbage Collection for Reducing Memory System Energy in an Embedded {J}ava Environment},
author = {Gungyu Chen and R. Shetty and Mahmut T. Kandemir and Narayanan Vijaykrishnan and Mary Jane Irwin and Mario Wolczko},
journal = TECS,
publisher = ACM,
pages = {6--26},
volume = 1,
number = 1,
month = nov,
year = 2002,
doi = {10.1145/581888.581892},
abstract = {Java has been widely adopted as one of the software
platforms for the seamless integration of diverse computing devices.
Over the last year, there has been great momentum in adopting Java
technology in devices such as cellphones, PDAs, and pagers where
optimizing energy consumption is critical. Since, traditionally, the
Java virtual machine (JVM), the cornerstone of Java technology, is
tuned for performance, taking into account energy consumption requires
reevaluation, and possibly redesign of the virtual machine. This
motivates us to tune specific components of the virtual machine for a
battery-operated architecture. As embedded JVMs are designed to run for
long periods of time on limited-memory embedded systems, creating and
managing Java objects is of critical importance. The garbage collector
(GC) is an important part of the JVM responsible for the automatic
reclamation of unused memory. This article shows that the GC is not
only important for limited-memory systems but also for
energy-constrenergy-constrained architectures. This article focuses on
tuning the GC to reduce energy consumption in a multibanked memory
architecture. Tuning the GC is important not because it consumes
a sizeable portion of overall energy during execution, but because
it influences the energy consumed in the memory during application
execution. In particular, we present a GC-controlled leakage energy
optimization technique that shuts off memory banks that do not hold live
data. Using two different commercial GCs and a suite of thirteen mobile
applications, we evaluate the effectiveness of the GC-controlled energy
optimization technique and study its sensitivity to different parameters
such as bank size, the garbage collection frequency, object allocation
style, compaction style, and compaction frequency. We observe that the
energy consumption of an embedded Java application can be significantly
more if the GC parameters are not tuned appropriately. Further, we
notice that the object allocation pattern and the number of memory
banks available in the underlying architecture are limiting factors on
how effectively GC parameters can be used to optimize the memory energy
consumption.}
}

@article{chen02c,
title = {Influence of Garbage Collection on Memory System Energy},
author = {Guangyu Chen and R. Shetty and Mahmut T. Kandemir and Narayanan Vijaykrishnan and Mary Jane Irwin and Mario Wolczko},
journal = TECS,
publisher = ACM,
month = nov,
volume = 1,
number = 1,
year = 2002
}

@inproceedings{chen03a,
  title =	 {Heap Compression for Memory-Constrained {J}ava Environments},
  author =	 {Guangyu Chen and Mahmut Kandemir and Naraya Vijaykrishnan
                  and Irwin, Mary Jane and Bernd Mathiske and Mario Wolczko},
  crossref =	 {OOPSLA03},
  pages =	 {282--301},
  doi =		 {10.1145/949305.949330}
}

@inproceedings{chen04,
title = {Field Level Analysis for Heap Space Optimization in Embedded {J}ava
Environments},
author = {Guangyu Chen and Mahmut Kandemir and Narayanan Vijaykrishnan and Mary
Jane Irwin},
pages = {131--142},
crossref = {ISMM04}
}

@inproceedings{chen05,
  title =	 {Exploiting Frequent Field Values in {Java} Objects for
                  Reducing Heap Memory Requirements},
  author =	 {Guangyu Chen and Mahmut Kandemir and Mary J. Irwin},
  crossref =	 {VEE05},
  pages =	 {68--78},
  doi =		 {10.1145/1064979.1064990}
}

@article{chen11,
author = {Kuo-Yi Chen and J. Morris Chang and Ting-Wei Hou},
title = {Multithreading in {J}ava: Performance and Scalability on Multicore Systems}, 
journal = IEEETransComp,
volume = 60,
number = 11,
[ages = {1521--},
year = 2011,
URL = {http://home.engineering.iastate.edu/~morris/papers/11/ieeetc11.pdf},
abstract = {The performance and scalability issues of multithreaded Java
programs on multicore systems are studied in this paper. First, we examine the
performance scaling of benchmarks with various numbers of processor cores and
application threads. Second, by correlating low-level hardware performance data
to JVM threads and system components, the detail analyses of performance and
scalability are presented, such as the hardware stall events and memory system
latencies. Third, the usages of memory resource are detailed to observe the
potential bottlenecks. Finally, the JVM tuning techniques are proposed to
alleviate the bottlenecks, and improve the performance and scalability. Several
key findings are revealed through this study. First, the lock contentions
usually lead to a strong limitation of scalability. Second, in terms of memory
access latencies, the most of memory stalls are produced by L2 cache misses and
cache-to-cache transfers. Finally, the overhead of minor garbage collections
could be an important factor of throughput reductions. Based on these findings,
the appropriate Java Virtual Machine (JVM) tuning techniques are examined in
this study. We observe that the use of a parallel garbage collector and an
appropriate ratio of young to old generation can alleviate the overhead of minor
collection and improve the efficiency of garbage collections. Moreover, the
cache utilizations could be enhanced with the use of thread-local allocation
buffer, and then leads to the performance improvements significantly.}
}

@inproceedings{chen06,
  title =	 {Profile-Guided Proactive Garbage Collection for Locality
                  Optimization},
  author =	 {Wen-Ke Chen and Sanjay Bhansali and Trishul M. Chilimbi and
                  Xiaofeng Gao and Weihaw Chuang},
  crossref =	 {PLDI06},
  pages =	 {332--340},
  doi =		 {10.1145/1133981.1134021}
}

@article{chen70,
author = " C. J. Cheney",
title = "A Non-Recursive List Compacting Algorithm",
journal = CACM,
publisher = ACM,
volume = 13,
number = 11,
pages = "677--8",
month = nov,
year = 1970,
doi={10.1145/362790.362798},
profiel = "CESV",
abstract = {Breadth-first non-recursive Copying GC.
Avoids use of mark bits by examining pointers to see
which semi-space they refer to.}
}

@inproceedings{chen98,
  title =	 {Generational Stack Collection and Profile-Driven
                  Pretenuring},
  author =	 {Perry Cheng and Robert Harper and Peter Lee},
  crossref =	 {PLDI98},
  pages =	 {162-173},
  doi =		 {10.1145/277650.277718},
  URL =		 {http://foxnet.cs.cmu.edu/papers/pscheng-pldi98.ps}
}

@inproceedings{chen01,
  title =	 {A Parallel, Real-Time Garbage Collector},
  author =	 {Perry Cheng and Guy Blelloch},
  crossref =	 {PLDI01},
  pages =	 {125--136},
  doi =		 {10.1145/378795.378823}
}

@phdthesis{chen01a,
author = {Perry Sze-Din Cheng},
title = {Scalable Real-Time Parallel Garbage Collection for Symmetric Multiprocessors},
school = CMU,
year = 2001,
month = sep,
note = {SCS Technical Report CMU-CS-01-174},
URL = {http://reports-archive.adm.cs.cmu.edu/anon/2001/CMU-CS-01-174.pdf}
}

@techreport{cheo92,
author = "Cheong, Fah-Chun",
title = "Almost Tag-Free Garbage Collection for Strongly-Typed Object-Oriented Languages",
institution = "University of Michigan",
year = 1992,
number = "CSE-TR-126-92",
abstract = "Given the heavy use of dynamic storage under the
object-oriented paradigm, efficient storage reclamation
techniques have become especially important.  Previously, Appel
and Goldberg have discussed compiler-supported tag-free
collection schemes for strongly typed  languages.  This paper
presents a more efficient, almost tag-free garbage collection
scheme that takes into consideration the special requirements of
object-oriented languages that are strongly typed.  Our method
requires only a single pass over the run-time procedure-call
stack during garbage collection, as opposed to two passes for
Goldberg's scheme and a linear number of passes in the worst case
for Appel's.
Furthermore, in the case of distributed languages where it is
practically impossible to unwind the stack all the way to its
origin while trying to identify generic variables, the methods of
Appel and Goldberg are  not applicable.  Our scheme uses a
generic tag vector to help identify generic variables and does
not require any stack searches beyond the current frame.  We have
incorporated our proposed scheme into a newly designed
distributed object-oriented language Oasis.  This paper includes
a  discussion of our practical implementation experience in the
Oasis context."
}

@inproceedings{cher04a,
  title =	 {Software Prefetching for Mark-Sweep Garbage Collection:
                  Hardware Analysis and Software Redesign},
  author =	 {Chen-Yong Cher and Antony L. Hosking and T.N. Vijaykumar},
  crossref =	 {ASPLOS04},
  pages =	 {199--210},
  doi =		 {10.1145/1024393.1024417}
}

@inproceedings{cher08,
author = {C.-Y. Cher and M. Gschwind},
title = {Cell {GC}: Using the {C}ell Synergistic Processor as a Garbage Collection Coprocessor},
crossref = {VEE08}
}

@inproceedings{cher04,
title = {Region Analysis and Transformation for {J}ava Programs},
author = {Sigmund Cherem and Radu Rugina},
pages = {85--96},
crossref = {ISMM04}
}

@inproceedings{cher06,
title = {Compile-Time Deallocation of Individual Objects},
author = {Sigmund Cherem and Radu Rugina},
pages = {138--149},
crossref = {ISMM06},
}

@inproceedings{cher07,
  title =	 {Practical Memory Leak Detection using Guarded Value-Flow
                  Analysis},
  author =	 {Sigmund Cherem and Lonnie Princehouse and Radu Rugina},
  crossref =	 {PLDI07},
  pages =	 {480-491},
  doi =		 {10.1145/1250734.1250789}
}

@inproceedings{cher07a,
title = {Uniqueness Inference for Compile-Time Object Deallocation},
author = {Sigmund Cherem and Radu Rugina},
pages = {117--128},
crossref = {ISMM07},
}

@techreport{chev02,
author = {K. Chevalier and J. Kodumal and X. Jiang},
title = {Memory Subsystem Optimization for Functional Languages: A Case Study},
institution = {Computer Science Division, } # UCB,
month = may,
year = 2002,
URL = {http://www.cs.berkeley.edu/~zdjiang/cs252}
}

@phdthesis{chic02,
author = {Yannis Chicha},
title = {Practical Aspects of Interacting Garbage Collectors},
school = {University of Western Ontario},
year = 2002
}

@inproceedings{chic06,
title = {A Localized Tracing Scheme Applied to Garbage Collection},
author = {Yannis Chicha and Stephen M. Watt},
booktitle = {4th Asian Symposium on Programming Languages and Systems},
editor = {Naoki Kobayashi},
address = {Sydney, Australia},
pages = {323--349},
month = nov,
year = 2006,
series = LNCS,
publisher = SV,
volume = 4279,
doi = {10.1007/11924661_20},
abstract = {We present a method to visit all nodes in a forest of data
structures while taking into account object placement. We call the technique a
Localized Tracing Scheme as it improves locality of reference during object
tracing activity. The method organizes the heap into regions and uses trace
queues to defer and group tracing of remote objects. The principle of localized
tracing reduces memory traffic and can be used as an optimization to improve
performance at several levels of the memory hierarchy. The method is applicable
to a wide range of uniprocessor garbage collection algorithms as well as to
shared memory multiprocessor collectors. Experiments with a mark-and-sweep
collector show performance improvements up to 75\% at the virtual memory level.}
}

@inproceedings{chih04,
author = {Irina Chihaia and Thomas Gross},
title = {An Analytical Model for Software-Only Main Memory Compression},
booktitle = {3rd Workshop on Memory Issues},
address = {Munich, Germany},
month = jun,
pages = {107--113},
publisher = ACM,
year = 2004,
doi = {10.1145/1054943.1054958}
}

@inproceedings{chik87,
author = "T. Chikayama and Y. Kimura",
title = "Multiple Reference Management in {F}lat {GHC}",
booktitle = "4th International Conference on Logic Programming",
pages = "276--293",
year = 1987
}

@inproceedings{chil98,
author = {Trishul M. Chilimbi and James R. Larus },
title = {Using Generational Garbage Collection To Implement Cache-Conscious Data Placement},
pages = {37--48},
crossref = {ISMM98},
doi={10.1145/301589.286865},
abstract = {Processor and memory technology trends show a continual increase in
the cost of accessing main memory. Machine designers have tried to
mitigate the effect of this trend through a variety of techniques that
attempt to reduce or tolerate memory latency. These techniques,
unfortunately, have only been partially successful for pointer-
manipulating programs. Recent research has demonstrated that these
programs can benefit greatly from the complementary approach of
reorganizing pointer data structures to improve cache locality. This
paper describes how a generational garbage collector can be used to
achieve a cache-conscious data layout, in which objects with high
temporal affinity are placed next to each other, so they are likely to
reside in the same cache block. The paper demonstrates the feasibility
of collecting low overhead, real-time profiling information about data
access patterns for object-oriented languages, and describes a new
copying algorithm that utilizes this information to produce a
cache-conscious object layout. Preliminary results indicate that this
technique reduces cache miss rates by 21-42\%, and improves
program performance by 14-37\%. }
}

@inproceedings{chil99,
  author =	 {Trishul M. Chilimbi and Mark D. Hill and James R. Larus},
  title =	 {Cache-Conscious Structure Layout},
  crossref =	 {PLDI99},
  pages =	 {1--12},
  doi =		 {10.1145/301618.301633}
}

@inproceedings{chil99a,
  author =	 {Trishul M. Chilimbi and Bob Davidson and James R. Larus},
  title =	 {Cache-Conscious Structure Definition},
  crossref =	 {PLDI99},
  pages =	 {13--24},
  doi =		 {10.1145/301618.301635}
}

@inproceedings{chil00,
author = {Trishul Chilimbi and Richard E. Jones and Benjamin Zorn},
title = {Designing a Trace Format for Heap Allocation Events},
pages = {35--49},
doi = {10.1145/362422.362435},
crossref = {ISMM2000},
abstract = {
Dynamic storage allocation continues to play an important role in the
performance and correctness of systems ranging from user productivity
software to high-performance servers. While algorithms for dynamic
storage allocation have been studied for decades, much of the literature is
based on measuring the performance of benchmark programs
unrepresentative of many important allocation-intensive workloads.
Furthermore, to date no standard has emerged or been proposed for
publishing and exchanging representative allocation workloads. In this
paper, we describe a preliminary design of a trace format for such
workloads and investigate its effectiveness at representing large allocation
traces. Our proposal allows for a flexible encoding of information in the trace
to achieve greater compression. We evaluate our preliminary design in two
dimensions. First, we measure how effective these encodings are at
reducing trace size. Second we consider how a meta-level specification
language could be used to describe such formats and to generate trace
readers and writers automatically. }
}

@inproceedings{chil01,
  author =	 {Trishul M. Chilimbi},
  title =	 {Efficient Representations and Abstractions for Quantifying
                  and Exploiting Data Reference Locality},
  crossref =	 {PLDI01},
  pages =	 {191-202},
  doi =		 {10.1145/378795.378840}
}

@inproceedings{chil04,
  author =	 {Mattias Hauswirth and Trishul M. Chilimbi},
  title =	 {Low-Overhead Memory Leak Detection Using Adaptive
                  Statistical Profiling},
  crossref =	 {ASPLOS04},
  pages =	 {156-164},
  doi =		 {10.1145/1024393.1024412}
}

@techreport{chin03,
title = {Region Inference for an Object-Oriented Language},
author = {Wei-Ngan Chin and Florin Craciun and Shengchao Qin and Martin Rinard},
institution = {National University of Singapore},
month = nov,
year = 2003,
URL = {http://www.comp.nus.edu.sg/.qinsc/papers/reginf.ps.gz}
}

@inproceedings{chin04,
  title =	 {Region Inference for an Object-Oriented Language},
  author =	 {Wei-Ngan Chin and Florin Craciun and Shengchao Qin and
                  Martin C. Rinard},
  crossref =	 {PLDI04},
  pages =	 {243--254},
  doi =		 {10.1145/996841.996871}
}

@inproceedings{chin08,
title = {Analysing Memory Resource Bounds for Bytecode Programs},
author = {Wei-Ngan Chin and Huu Hai Nguyen and Corneliu Popeea and Shengchao
Qin},
crossref = {ISMM08},
pages = {151--160},
doi = {10.1145/1375634.1375656},
abstract = {Embedded systems are becoming more widely used but these
systems are often resource constrained. Programming models for these
systems should take into formal consideration resources such as
stack and heap. In this paper, we show how memory resource bounds
can be inferred for assembly-level programs. Our inference process
captures the memory needs of each method in terms of the symbolic
values of its parameters. For better precision, we infer path-sensitive
information through a novel guarded expression format. Our current
proposal relies on a Presburger solver to capture memory requirements
symbolically, and to perform fixpoint analysis for loops and
recursion. Apart from safety in memory adequacy, our proposal can
provide estimate on memory costs for embedded devices and improve
performance via fewer runtime checks against memory bound.}
}

@techreport{chin92,
author = "Ramakrishna Chinta",
title = "Hardware-Assisted Garbage Collection for the {I}con Programming Language",
institution ="Iowa State University",
number = "92--39",
month = dec,
year = 1992,
URL = "http://www.cs.iastate.edu/tech-reports/TR92-39.ps"
}

@article{chir96,
title = "Reference Counting as a Computational Interpretation of Linear Logic",
author = "Jawahar Chirimar and Carl A. Gunter and Jon G. Riecke",
pages = "195--244",
journal = JFP,
month = mar,
year = 1996,
volume = 6,
number = 2
}

@inproceedings{chir92,
title = {Proving Memory Managemeont Invariants for a Language Based on Linear
Logic},
author = {Jawahar Chirimar and Carl A. Gunter and Jon G. Riecke},
crossref = {LFP92},
pages = {129--150}
}

@InProceedings{chis11,
  author =	 {Adriana E. Chis and Nick Mitchell and Edith Schonberg and
                  Gary Sevitsky and Patrick O'Sullivan and Trevor Parsons and
                  John Murphy},
  title =	 {Patterns of Memory Inefficiency},
  crossref =	 {ECOOP11},
  pages =	 {383--407},
  doi =		 {10.1007/978-3-642-22655-7_18}
}

@inproceedings{chiu91,
author = "Chiueh, Tzi-cker",
title = "An Architectural Technique for Cache-level Garbage Collection",
crossref = "FPCA91",
pages = "520--537",
}

@article{cho07,
author = {Cho, Hyeonjoong and Na, Chewoo and Ravindran, Binoy and Jensen, E. Douglas},
title = {On Scheduling Garbage Collector in Dynamic Real-Time Systems with Statistical Timing Assurances},
journal = {Real-Time Systems},
volume = 36,
number = {1--2},
year = 2007,
pages = {23--46},
doi = {10.1007/s11241-006-9011-0},
publisher = {Kluwer Academic Publishers},
abstract = {We consider garbage collection (GC) in dynamic real-time systems. We
consider the time-based GC approach of running the collector as a separate,
concurrent thread, and focus on real-time scheduling to obtain assurances on
mutator timing behavior, while ensuring that memory is never exhausted. We
present a scheduling algorithm called GCUA. The algorithm considers mutator
activities that are subject to time/utility function time constraints, variable
execution time demands, the unimodal arbitrary arrival model that allows a
strong adversary, and resource overloads. We establish several properties of
GCUA including probabilistically-satisfied utility lower bounds for each mutator
activity, a lower bound on the system-wide total accrued utility, bounded
sensitivity for the assurances to variations in mutator execution time demand
estimates, and no memory exhaustion at all times. Our simulation experiments
validate our analytical results and confirm the algorithm's effectiveness and
superiority.}
}

@article{cho07a,
author = {Cho, Hyeonjoong and Ravindran, Binoy and Na, Chewoo},
title = {Garbage Collector Scheduling in Dynamic, Multiprocessor Real-Time Systems},
journal = TPDS,
volume = 20,
number = 6,
month = jun,
pages = {845--856},
doi = {10.1109/TPDS.2009.20},
year = 2009,
abstract = {We consider garbage collection (GC) in dynamic, multiprocessor
real-time systems. We consider the time-based, concurrent GC approach and focus
on real-time scheduling to obtain mutator timing assurances, despite memory
allocation and garbage collection. We present a scheduling algorithm called
GCMUA. The algorithm considers mutator activities that are subject to
time/utility function time constraints, stochastic execution-time and memory
demands, and overloads. We establish that GCMUA probabilistically lower bounds
each mutator activity's accrued utility, lower bounds the system-wide total
accrued utility, and upper bounds the timing assurances' sensitivity to
variations in mutator execution-time and memory demand estimates. Our simulation
experiments validate our analytical results and confirm GCMUA's effectiveness.}
}

@inproceedings{choi99,
  title =	 {Escape Analysis for {J}ava},
  author =	 {Jong-Deok Choi and Manish Gupta and Mauricio Serrano and
  Vugranam C. Sreedhar and Samuel Midkiff},
  pages =	 {1--19},
  crossref =	 {OOPSLA99},
  doi =		 {10.1145/320384.320386},
  comment =	 {By analysing which objects escape methods/threads, we can
                  allocate on the stack / avoid synchronisations.}
}

@article{choi03,
title =	 {Stack Allocation and Synchronization Options for {J}ava Using Escape Analysis},
author =	 {Jong-Deok Choi and Manish Gupta and Mauricio Serrano and
Vugranam C. Sreedhar and Samuel Midkiff},
journal = TOPLAS,
pages =	 {876--910},
volume = 25,
number = 6,
month = nov,
year = 2003,
doi = {10.1145/945885.945892}
}

@article{choi05,
title = {Java Memory Allocation with Lazy Worst Fit for Small Objects},
author = {Hyung-Kyu Choi and Yoo C. Chung and Soo-Mook Moon},
journal = CompJ,
volume = 48,
pages = {437--442},
URL = {http://comjnl.oxfordjournals.org/cgi/content/abstract/48/4/437?etoc},
year = 2005
}


@mastersthesis{chri98,
author = {M. V. Christiansen and P. Velschrow},
title = {Region-based Memory Management in {J}ava},
school = DIKU,
month = may,
year = 1998
}

@article{chri84,
author = "T. W. Christopher",
title = "Reference Count Garbage Collection",
journal = SPE,
publisher = Wiley,
volume = 14,
number = 6,
pages = "503--507",
month = jun,
year = "1984",
comment = {A heap management scheme fo languages (such as Fortran) which do not have
this facility buit in.
Does not rely on the existance of {\it roots} in the graph.
His complex and inefficient algorithm actually contains
a cyclic reference count algorithm.  },
}

@inproceedings{chri10,
author = {Dave Christie and Jae-Woong Chung and Stephan Diestelhorst and
          Michael Hohmuth and Martin Pohlack and Christof Fetzer and Martin Nowack and
          Torvald Riegel and Pascal Felber and Patrick Marlier and Etienne Riviere},
title = {Evaluation of {AMD}'s {A}dvanced {S}ynchronization {F}acility within
         a Complete Transactional Memory Stack},
booktitle = {European Conference on Computer Systems (EuroSys)},
publisher = ACM,
year = 2010,
pages = {27-40},
doi = {10.1145/1755913.1755918}
}

@inproceedings{chun00,
author = {Yoo C. Chung and Soo-Mook Moon and Kemal Ebcioglu and Dan Sahlin},
title = {Reducing Sweep Time for a Nearly Empty Heap},
booktitle = {27th Annual ACM SIGPLAN-SIGACT} # POPL # {(POPL '00)},
address = {Boston, MA},
publisher = ACM,
year = 2000,
month = jan
}

@inproceedings{chun00a,
author = {Yoo C. Chung and Soo-Mook Moon},
title = {Memory Allocation with Lazy Fits},
pages = {65--70},
crossref = {ISMM2000},
abstract = { Dynamic memory allocation is an important part of modern programming
languages. It is important that it be done fast without wasting too much
memory. Memory allocation using lazy fits is introduced, where pointer
increments, which is very fast, is used as the primary allocation method and
where conventional fits such as best fit or first fit are used as backup. Some
experimental results showing how lazy segregated first fit might perform are
shown, and shows that the approach has the potential to be useful in actual
systems. }
}

@article{chun05,
title = {Selective sweeping},
author = {Yoo C. Chung and Soo-Mook Moon and Kemal Ebciolu and Dan Sahlin},
journal = SPE,
volume = 35,
number = 1,
pages = {15--26},
year = 2005,
doi = {10.1002/spe.624},
abstract = {Traditional mark and sweep garbage collectors use time proportional
to the heap size when sweeping memory, since all objects in the heap, dead or
alive, must be traversed. Here we introduce a sweeping algorithm which traverses
only the live objects. Since this sweeping algorithm is slower when the heap
occupancy is high, we also discuss how to avoid this slowdown by using an
adaptive algorithm.}
}

@inproceedings{chun10,
author  = {Jae-Woong Chung and Luke Yen and Stephan Diestelhorst and Martin
Pohlack and Michael Hohmuth and David Christie and Dan Grossman},
title  = {{ASF}: {AMD64} Extension for Lock-free Data Structures and Transactional Memory},
booktitle = {43rd IEEE/ACM International Symposium on Microarchitecture},
year = 2010,
pages = {39--50},
month = dec,
address = {Atlanta, GA},
doi={10.1109/MICRO.2010.40},
}

@techreport{ciep83,
author = "A. Ciepielewski and Seif Haridi",
title = "Storage Models for {O}r-Parallel Execution of Logic Programs",
institution = "Royal Institute of Technology",
address = "Stockholm, Sweden",
number = "TRITA--CS--8301",
year = 1983
}

@article{cier03,
title = {The {O}pen {R}untime {P}latform: A Flexible High-Performance Managed
Runtime Environment},
author = {Michal Cierniak and Marsha Eng and Neal Glew and Brian Lewis and James
Stichnoth},
journal = {Intel Technology Journal},
volume = 7,
number = 1,
year = 2003,
pages = {5--18},
publisher = {Intel Corporation},
URL =
{http://download.intel.com/technology/itj/2003/volume07issue01/vol7iss1_managed_runtime_technologies.pdf}
}
@article{clar75,
author = "Douglas W. Clark",
title = "A Fast Algorithm for Copying Binary Trees",
journal = IPL,
publisher = NH,
volume = 9,
number = 3 ,
month = Dec,
year = 1975,
pages = "62--63",
comment = {algorithm for copying lists without using a atack or mark bits.
It differs from the moving algorithms in that the altered contents of old lists
are later restored to their original values.},
}

@article{clar76,
author = "Douglas W. Clark",
title = "An Efficient List Moving Algorithm Using Constant Workspace",
journal = CACM,
publisher = ACM,
volume = 19,
number = 6 ,
month = Jun,
year = 1976,
pages = "352--354",
comment = {Presents an optimization to the copying algorithm (feni69) by moving a list into
a contiguous area of the memory space with the stack implicit in the list being
moved. Clark (clar76) shows that his algorithm is in most cases more efficient
than both Cheney's (chen70) and Reingold's (rein73).},
}

@article{clar77,
author = "Douglas W. Clark and C. Cordell Green",
title = "An Empirical Study of List Structure in {L}isp",
journal = CACM,
publisher = ACM,
volume = 20,
number = 2,
month = Feb,
year = 1977,
pages = "78--86",
doi={10.1145/359423.359427},
comment = {
On average, in list structures used in practice, non-atomic car fields 1/3 of
time, non-atomic cdr fields 3/4 time (implies average list length = 4).
Thus preorder traversal restricts depth
of stack to be proportional to longest car path in pre-order spanning tree.
Longest car path is likely to be shorter than the longest cdr path.
[What about difference between APP cells and CONS cells? -- rej]
Only 2--10 percent have RC>1.
Using a Fenichel and Yochelson type copying algorithm, and following list cdr's
before car's (post-order), get over 98 percent cdr-direction linearisation (i.e. cdr
points to next cell). Percentage of off-page pointers following linearisation
varied between 2.7 and 8.4 percent.
Clever cons routine (to attempt to place cons cells on the same page as
arguments) are no more effective than naive routines.
Integers 0--15 account for a significant proportion of pointers to atoms.
Allocation ordering is usually more similar to subsequent access orderings
than arbitrary orderings imposed by a garbage collector.  }
}

@article{clar78a,
author = "Douglas W. Clark",
title = "A Fast Algorithm for Copying List Structures",
journal = CACM,
publisher = ACM,
volume = 21,
number = 5 ,
month = May,
year = 1978,
pages = "351--357",
comment = {algorithm for copying lists without using a stack or mark bits.
It differs from the moving algorithms in that the altered contents of old lists
are later restored to their original values.},
}

@article{clar78b,
author = "Douglas W. Clark and C. Cordell Green",
title = "A Note on Shared List Structure in {L}isp",
journal = IPL,
publisher = NH,
volume = 7,
number = 6,
month = Oct,
year = 1978,
pages = "312--314",
}

@article{clar79,
author = "Douglas W. Clark",
title = "Measurements of Dynamic List Structure in {L}isp",
journal = TransSWE,
publisher = ACM,
volume = 5,
number = 1,
month = Jan,
year = 1979,
pages = "51--59",
comment = {Allocation ordering is usually more similar to subsequent access orderings
than arbitrary orderings imposed by a garbage collector.  }
}

@article{clar96,
author = "Charles L. A. Clarke and Dave Mason",
title = "Compacting Garbage Collection can be Fast and Simple",
journal = SPE,
publisher = Wiley,
pages = "177--194",
volume = 26,
number = 2,
month = feb,
year = 1996,
URL = "http://plg.uwaterloo.ca/~claclark/gc.ps"
}

@inproceedings{clar01,
author = {David Clarke},
title = {On Deleting Aggregate Objects},
crossref = {SPACE01},
}

@inproceedings{cleb13,
author = {Clebsch, Sylvan and Drossopoulou, Sophia},
title = {Fully Concurrent Garbage Collection of Actors on Many-core Machines},
crossref = {OOPSLA13},
pages = {553--570},
doi = {10.1145/2509136.2509557},
abstract = {Disposal of dead actors in actor-model languages is as important as
disposal of unreachable objects in object-oriented languages. In current
practice, programmers are required to either manually terminate actors, or they
have to rely on garbage collection systems that monitor actor mutation through
write barriers, thread coordination through locks etc. These techniques,
however, prevent the collector from being fully concurrent.
We developed a protocol that allows garbage collection to run fully concurrently
with all actors. The main challenges in concurrent garbage collection is the
detection of cycles of sleeping actors in the actors graph, in the presence of
concurrent mutation of this graph. Our protocol is solely built on message
passing: it uses deferred direct reference counting, a dedicated actor for the
detection of (cyclic) garbage, and a confirmation protocol (to deal with the
mutation of the actor graph).
We present our ideas informally through an example, and then present a formal
model, prove soundness and argue completeness. We have implemented the protocol
as part of a runtime library. As a preliminary performance evaluation, we
discuss the performance of our approach as currently used at a financial
institution, and use four benchmarks from the literature to compare our approach
with other actor-model systems. These preliminary results indicate that the
overhead of our approach is small.}
}

@misc{clic03,
author = {Cliff Click},
title = {Performance Myths Exposed},
year = 2003,
howpublished = {Talk at JavaOne 2003},
URL = {http://servlet.java.sun.com/javaone/resources/content/sf2003/conf/sessions/pdfs/1522.pdf}
}

@inproceedings{clic05,
  title =	 {The {P}auseless {GC} Algorithm},
  author =	 {Cliff Click and Gil Tene and Michael Wolf},
  crossref =	 {VEE05},
  pages =	 {46--56},
  doi =		 {10.1145/1064979.1064988}
}

@inproceedings{clif14,
title = {Allocation Folding Based on Dominance},
author = {Daniel Clifford and Hannes Payer and Michael Starzinger and Ben L.  Titzer},
pages = {15--24},
crossref = {ISMM14},
doi = {10.1145/2602988.2602994},
abstract = {Memory management system performance is of increasing importance in
today's managed languages. Two lingering sources of overhead are the direct
costs of memory allocations and write barriers. This paper introduces it
allocation folding, an optimization technique where the virtual machine
automatically folds multiple memory allocation operations in optimized code
together into a single, larger it allocation group. An allocation group
comprises multiple objects and requires just a single bounds check in a
bump-pointer style allocation, rather than a check for each individual object.
More importantly, all objects allocated in a single allocation group are
guaranteed to be contiguous after allocation and thus exist in the same
generation, which makes it possible to statically remove write barriers for
reference stores involving objects in the same allocation group. Unlike object
inlining, object fusing, and object colocation, allocation folding requires no
special connectivity or ownership relation between the objects in an allocation
group. We present our analysis algorithm to determine when it is safe to fold
allocations together and discuss our implementation in V8, an open-source,
production JavaScript virtual machine. We present performance results for the
Octane and Kraken benchmark suites and show that allocation folding is a strong
performance improvement, even in the presence of some heap fragmentation.
Additionally, we use four hand-selected benchmarks JPEGEncoder, NBody, Soft3D,
and Textwriter where allocation folding has a large impact.}
}

@inproceedings{clin88,
author = "William D. Clinger and Anne Hartheimer and Erik Ost",
title = "Implementation Strategies for Continuations",
crossref = "LFP88",
pages = "124--131",
}

@inproceedings{clin97,
  author =	 {William D. Clinger and Lars T. Hansen},
  institution =	 {Northeastern University},
  title =	 {Generational Garbage Collection and the Radioactive Decay
                  Model},
  crossref =	 {PLDI97},
  pages =	 {97--108},
  doi =		 {10.1145/258915.258925}
}

@article{clin06,
title = {Linear Combinations of Radioactive Decay Models for Generational Garbage Collection},
author = {William D. Clinger and Fabio V. Rojas},
editor =	 {Richard Jones},
journal =	 SCP,
volume =	 62,
number =	 2,
publisher =	 "Elsevier",
month =	 oct,
year =	 2006,
pages = {184--203},
doi = {10.1016/j.scico.2006.02.005}
}

@inproceedings{clin09,
title = {Scalable Garbage Collection with Guaranteed {MMU}},
author = {William D. Clinger and Felix S. Klock},
booktitle = {Scheme and Functional Programming 2009},
address = {Boston, MA},
month = aug,
year = 2009,
URL = {http://www.ccs.neu.edu/home/will/Research/SW2009/gfremsets.pdf},
abstract = {
Regional garbage collection offers a useful compromise between real-time and
generational collection. Regional collectors resemble generational collectors,
but are scalable: our main theorem guarantees a positive lower bound,
independent of mutator and live storage, for the theoretical worst-case minimum
mutator utilization (MMU). The theorem also establishes fixed upper bounds for
space usage and collection pauses.
Standard generational collectors are not scalable. Some real-time collectors are
scalable, while others assume a well-behaved mutator or provide no worst-case
guarantees at all.
Regional collectors cannot compete with hard real-time collectors at millisecond
resolutions, but offer efficiency comparable to contemporary generational
collectors combined with improved latency and MMU at resolutions on the order of
hundreds of milliseconds to a few seconds.}
}

@article{cock84,
author = "Cockshott,  W. and Malcolm Atkinson and K. Chisholm and P. Bailey
and Ron Morrison",
title = "Persistent Object Management System",
journal = SPE,
volume = 14,
number = 1,
month = jan,
year = 1984,
pages = "49--71"        }

@manual{code93,
title = "Alloc-{GC}: The Garbage Collecting Replacement for malloc()",
key = "Codewright's Toolworks",
organization = "Codewright's Toolworks, San Pedro, CA",
year = 1993
}

@article{coff83,
author = "{Coffman, Jr.}, E. G.",
title = "An Introduction to Combinatorial Models of Dynamic Storage Allocation",
journal = "SIAM Review",
volume = 25,
number = 3,
month = jul,
year = 1983,
pages = "311--325"
}

@article{coff85,
author = "{Coffman, Jr.}, E. G. and T. T. Kadota and L. A. Shepp",
title = "On the Asymptotic Optimality of First-Fit Storage Allocation",
journal = IEEETransSWE,
publisher = IEEE,
volume = "SE-11",
number = 2,
month = feb,
year = 1985,
pages = {235--239}
}

@article{coff89,
author = "{Coffman, Jr.}, E. G. and F. T. Leighton",
title = "A Provably Efficient Algorithm for Dynamic Storage Allocation",
journal = "Journal of Computer and System Sciences",
volume = 38,
number = 1,
month = feb,
year = 1989,
pages = "2--35"
}

@article{cohe67a,
author = "Jacques Cohen",
title = "A Use of Fast and Slow Memories in List-Processing Languages",
journal = CACM,
publisher = ACM,
volume = 10,
number = 2,
month = Feb,
year = 1967,
pages = "82--86",
}

@article{cohe67b,
author = "Jacques Cohen and  Laurent Trilling",
title = "Remarks on Garbage Collection Using a Two Level Storage",
journal = "BIT",
volume = 7,
number = 1,
year = 1967,
pages = "22--30",
comment = "2 pointer compactor"
}

@article{cohe72,
author = "Jacques Cohen and  C. Zuckerman",
title = "Evalquote in Simple {F}ortran: A Tutorial on Interpreting {L}isp",
journal = "BIT",
volume = 12,
number = 3,
year = 1972,
pages = "299--317",
comment = {convenient manner of implementing the tag bit in certain lisp
machines. It takes advantage of the fact that all pointers refer to only odd
(or only even) addresses, since two words are always used to implement a lisp
cell},
}

@article{cohe81,
author = "Jacques Cohen",
title = "Garbage Collection of Linked Data Structures",
journal = "Computing Surveys",
publisher = ACM,
volume = "13(3)",
pages = "341--367",
month = sep,
year = "1981",
abstract = {A concise and unified view of the numerous existing algorithms for
performing garbage collection of linked data structures is presented.  The
emphasis is on garbage collection proper, rather than on storage
allocation.
First, the classical garbage collection algorithms are , and their
marking and collecting phases, with and without compacting, are
discussed.
Algorithms describing these phases are classified according to the type of
cells to be collected = "those for collecting single-sized cells are simpler than
those for varisized cells.  Recently proposed algorithms are presented and
compared with the classical ones.  Special topics in garbage collection are
also covered.  A bibliography with topical annotations is included},
comment = {Classical reference in the field --- excellent paper}
}

@article{cohe83,
title = "Comparison of Compacting Algorithms for Garbage Collection",
author = "Jacques Cohen and Alexandru Nicolau",
journal = TOPLAS,
publisher = ACM,
year = 1983,
mon = oct,
volume = 5,
number = 4,
pages = "532--553",
doi={10.1145/69575.357226},
abstract = {Storage management is an important component of the execution-time
environment for many higher-level languages being developed at this time.
An important technique for storage management is compaction of the active
cells toward one end of memory, leaving a single, large, unallocated block
to satisfy further allocation requests. This paper compares four
compaction algorithms.
The methodology for algorithm comparison is that of deriving mathematical
equations for their behavior. Each of them is largely linear in  a, the
ratio of occupied memory to total memory. These equations are then
evaluated for a set of conditions similar to LISP on a DEC--10. The paper
claims that this method can easily be applied to other conditions, though
it does little to justify this claim.
The methods studied are those of LISP 2 [1], Jonkers [2], Fitch and Norman
[3], and Morris [4, 5]. The last of these is shown to be considerably
slower than the others. The LISP 2 collector is fastest by a small margin,
but requires an entire extra word in each allocated cell. This leaves two
methods, with little to choose between them; on the basis of the data, I
would choose Jonkers' method because it was slightly faster, and is
somewhat shorter and simpler to code.}
}

@inproceedings{cohe06,
author = {M. Cohen and S. Kooi and Witiwas Srisa-an},
title = {Clustering the Heap in Multi-Threaded Applications for Improved Garbage Collection},
booktitle = {ACM Genetic and Evolutionary Computation Conference (GECCO)},
address = {Seattle, WA},
month =jul,
year = 2006,
doi = {http://doi.acm.org/10.1145/1143997.1144314},
pages = {1901--1908}
}

@inproceedings{cohe13,
author = {Cohen, Nachshon and Petrank, Erez},
title = {Limitations of Partial Compaction: Towards Practical Bounds},
crossref = {PLDI13},
doi = {10.1145/2491956.2491973},
abstract = {Compaction of a managed heap is considered a costly operation, and
is avoided as much as possible in commercial runtimes. Instead, partial
compaction is often used to defragment parts of the heap and avoid space blow
up. Previous study of compaction limitation provided some initial asymptotic
bounds but no implications for practical systems. In this work, we extend the
theory to obtain better bounds and make them strong enough to become meaningful
for modern systems.}
} 

@inproceedings{cohn97,
title = {Predicting Lifetimes in Dynamically Allocated Memory},
author = {David Cohn and Satinder Singh},
booktitle = {Advances in Neural Information Processing Systems 9},
editor = {M. Mozer and others},
year = 1997,
URL = {http://www.cs.cmu.edu/~cohn/memory.ps}
}

@article{coll60,
  author =	 "George E. Collins",
  title =	 "A Method for Overlapping and Erasure of Lists",
  journal =	 CACM,
  publisher =	 ACM,
  volume =	 3,
  number =	 12,
  month =	 dec,
  year =	 1960,
  pages =	 "655--657",
  doi =		 {10.1145/367487.367501},
  comment =	 "The classic Reference Counting reference."
}

@article{coll61,
author = "George E. Collins",
title = "Experience in Automatic Storage Allocation",
journal = CACM,
publisher = ACM,
volume = 4,
number = 10,
month = oct,
year = 1961,
pages = "436--440"
}

@techreport{coll65,
title = "{REFCO III}, a Reference Count List Processing System for the {IBM} 7094",
author = "George E. Collins",
type = "Research Report",
institution = IBM,
number = "{RC}-1436",
year = 1965,
month = may
}

@inproceedings{coll06,
title = {Bunching for Region and Location Models},
author = {Matthew Collinson and David Pym},
pages = {14--22},
crossref = {SPACE06}
}

@inproceedings{coln98,
author = {Dominique Colnet and Philippe Coucaud and Olivier Zendra},
title = {Compiler Support to Customize the Mark and Sweep Algorithm},
pages = {154--165},
crossref = {ISMM98},
abstract = {Mark and sweep garbage collectors (GC) are classical but
still very efficient automatic memory management systems. Although
challenged by other kinds of systems, such as copying collectors, mark
and sweep collectors remain among the best in terms of performance.

This paper describes our implementation of an efficient mark and sweep
garbage collector tailored to each program. Compiler support provides
the type information required to statically and automatically generate
this customized garbage collector. The segregation of objects by type
allows the production of a more efficient GC code. This technique,
implemented in SmallEiffel, our compiler for the object-oriented
language Eiffel, is applicable to other languages and other garbage
collection algorithms, be they distributed or not.

We present the results obtained on programs featuring a variety of
programming styles and compare our results to other high quality
garbage collectors. }
}

@techreport{coln98a,
author = {Dominique Colnet and Olivier Zendra and Philippe Coucaud},
title = {Using Type Inference to Customize the Garbage Collector in an
Object-Oriented Language. The {S}mall{E}iffel Compiler},
institution = {INRIA Lorraine},
type = {Rapport de Recherche},
year = 1998,
URL = {http://www.loria.fr/~zendra/publications/rr98.pdf}
}



@article{colv95,
author = {G. Colvin},
title = {Smart Pointer for {C++} Garbage Collection},
journal = {{C/C++} Users Journal},
volume = 12,
number = 12,
month = dec,
year = 1995
}

@article{comf64,
author = "W. T. Comfort",
title = "Multiword List Items",
journal = CACM,
publisher = ACM,
volume = 7,
number = 6,
month = jun,
year = 1964,
pages = {357--362},
doi={10.1145/512274.512288}
}

@techreport{conr74,
title = "A Compactifying Garbage Collector for {ECL}'s Non-Homogenous Heap",
author = "W. R. Conrad",
type = "Research Report",
institution = "Center for Research in Computing Technology, Harvard",
number = "2--74",
year = 1974,
month = feb
}

@article{cons06,
title = {Formal and incremental construction of distributed algorithms: On the
distributed reference counting algorithm},
author = {Dominique Cansella and Dominique M\'{e}ry},
journal = {Theoretical Computer Science},
volume = 363,
number = 3,
pages = {318--337},
month = nov,
year = 2006,
publisher = {Elsevier},
abstract = {The development of distributed algorithms and, more generally,
distributed systems, is a complex, delicate and challenging process. Refinement
techniques of (system) models improve the process by using a proof assistant,
and by applying a design methodology aimed at starting from the most abstract
model and leading, in an incremental way, to the most concrete model, for
producing a distributed solution. We show, using the distributed reference
counting (DRC) problem as our study, how models can be produced in an elegant
and progressive way, thanks to the refinement and how the final distributed
algorithm is built starting from these models. The development is carried out
within the framework of the event B method and models are validated with a proof
assistant.}
}
@techreport{cook93,
author = "Jonathan E. Cook and Alexander L. Wolf and Benjamin G. Zorn",
title = "The Performance of Partitioned Garbage Collection in Object Databases",
institution = "University of Colorado",
type = "Computer Science Technical Report",
number = "CU-CS-653-93",
URL = "ftp://ftp.cs.colorado.edu/pub/cs/techreports/zorn/CU-CS-653-93.ps.Z",
address = "Campus Box 430, Boulder, CO 80309",
month = jun,
year = 1993,
abstract = {The automatic reclamation of storage for unreferenced objects is very
important in object databases.  Existing language system algorithms for
automatic storage reclamation have been shown to be inappropriate.  In this
paper, we describe and evaluate several improved algorithms for automatic
storage reclamation. The algorithms are based on a technique called
partitioned garbage collection, in which a subset of the entire
database is collected independently of the rest.  Our initial investigation
concerns the policy for selecting which partition to collect.  The policies
that we developed for the algorithms are based on the intuition that the
values of overwritten pointers provide good hints about where to find garbage.
Using trace-driven simulations of the algorithms, we show that our algorithms
require less I/O to collect more garbage than existing algorithms.}
}

@techreport{cook93a,
author = "Jonathan E. Cook and Alexander L. Wolf and Benjamin G. Zorn",
title = "The Design of a Simulation System for Persistent Object Storage Management",
institution = "University of Colorado",
type = "Computer Science Technical Report",
number = "CU-CS-647-93",
address = "Campus Box 430, Boulder, CO 80309",
month = mar,
year = 1993,
URL = {ftp://ftp.cs.colorado.edu/pub/cs/techreports/zorn/CU-CS-647-93.ps.Z},
abstract = {Efficient storage management of objects is an important part of any
persistent object system.  Storage management algorithms, such as those for
clustering, caching, and garbage collection, are often complex, since they
must simultaneously satisfy a number of constraints, including low CPU
overhead, minimum space usage, and low latency.  We have designed a
simulation system that can be used to evaluate a wide variety of such
algorithms.  The system is innovative in that it uses trace-driven
simulation as well as a loosely-coupled architecture that separates out
different aspects of storage management policy, machine hardware, and
simulation control into separate modules. Examples of such modules are those
for storage allocation, object connectivity, physical characteristics, and
cost modeling.  The modules communicate using message multicast (i.e.,
selective broadcast).  This approach supports rapid
prototyping and rapid evaluation of alternative storage management algorithms.}
}

@inproceedings{cook94,
author = "Jonathan E. Cook and Alexander L. Wolf and Benjamin G. Zorn",
title = "Partition Selection Policies in Object Databases Garbage Collection",
booktitle = SIGMOD,
address = "Minneapolis",
editor = "Richard T. Snodgrass and Marianne Winslett",
publisher = ACM,
volume = "23(2)",
pages = "317--382",
month = may,
year = 1994
}

@inproceedings{cook96,
title = "Semi-automatic, Self-adaptive Control of Garbage Collection Rates in Object Databases",
author = "Jonathan E. Cook and Artur Klauser and Alexander L. Wolf and Benjamin G. Zorn",
pages = "377--388",
booktitle = SIGMOD,
editor = "H. V. Jagadish and Inderpal Singh Mumick",
address = "Montreal, Quebec, Canada",
month = jun,
year = 1996,
note = "\emph{SIGMOD Record} 25(2), " # jun #" 1996",
}

@article{cook98,
title = {A Highly Effective Partition Selection Policy for Object Database Garbage Collection},
author = "Jonathan E. Cook and Alexander L. Wolf and Benjamin G. Zorn",
pages = "153--172",
journal = "IEEE Transactions on Knowledge and Data Engineering",
volume = 10,
number = 1,
year = 1998
}

@inproceedings{coop92,
author = "Eric Cooper and Scott Nettles and Indira Subramanian",
title = "Improving the Performance of {SML} Garbage Collection using Application-Specific Virtual Memory Management",
crossref = "LFP92",
pages = "43--52",
doi = {10.1145/141471.141501},
comment = "
Improve the performance of the SML--NJ memory system in
the presence of paging by a factor of up to 4.	The first factor of 2
was achieved by decreasing the size of the youngest generation.	 The
other factor of 2 was from a user-defined paging server that threw
away (didn't page out) useless pages and provided uninitialized new pages."
}

@inproceedings{coop13,
title = {Teaching Garbage Collection without Implementing Compilers or Interpreters},
author = {Gregory H. Cooper and Arjun Guha and Sriram Krishnamurthi and Jay
McCarthy and Robert Bruce Findler},
booktitle = {ACM Special Interest Group on Computer Science Education (SIGCSE)
2013},
year = 2013,
URL = {http://www.eecs.northwestern.edu/~robby/pubs/papers/cooper-sigcse2013.pdf}
}

@book{copl92,
author = "James Coplien",
title = "Advanced {C++} Programming Styles and Idioms",
publisher = AW,
year = 1992,
comment = "Includes various GC matters including counted pointers."
}

@inproceedings{corp88,
title = "Reference Weight-Based Garbage Collection for Distributed Systems",
author = "H. Corporaal and T. Veldman and van de Goor, A. J.",
booktitle = "{SION} Conference on Computing Science in the Netherlands",
address = "Utrecht",
month = nov,
year = 1988
}

@techreport{corp89,
title = "Garbage Collection in Distributed Systems.",
author = "H. Corporaal",
type = "Internal report",
institution = "Technical University, Delft",
year = 1989
}

@inproceedings{corp90,
title = "Efficient, Reference Weight-Based Garbage Collection Method for
Distributed Systems.",
author = "H. Corporaal and T. Veldman and van de Goor, A. J.",
booktitle = "{PARBASE-90}: International Conference on Databases, Parallel
Architectures, and Their Applications",
address = "{M}iami {B}each",
month = "7--9 March",
publisher = IEEE,
pages = "463--465",
year = 1990,
abstract = {A method of distributed garbage collection using reference counting
had been developed previously (see D. I. Bevan, PARLE'87).
This method is correct but has one severe
drawback --- the time overhead caused by the use of indirection cells.  In the
present work, the authors describe an alternative --- the reference weight table
method.  It is shown that this method does not suffer from as much time
overhead and offers general improvements.},
comment = "Appears to require communication to maintain the reference
weight tables."
}

@inproceedings{corr06,
title = {Optimistic Stack Allocation for {J}ava-like Languages},
author = {Erik Corry},
pages = {162--173},
crossref = {ISMM06},
doi={10.1145/1133956.1133978}
}

@techreport{cour86,
author = "Anthony J. Courtemanche",
title = "{MultiTrash}, a Parallel Garbage Collector for {MultiScheme}",
type = "Bachelor's thesis",
institution = MIT,
month = jan,
year = 1986
}

@article{cour88,
title = "Improving Locality Of Reference In A Garbage-Collecting Memory
Management-System",
author = "Robert Courts",
address = "Texas Instruments Inc, Data Syst Grp, Pob 2909, Ms 2201, Austin, Tx,
78769",
journal = CACM,
publisher = ACM,
year = 1988,
volume = 31,
number = 9,
pages = "1128--1138",
abstract = {Modern Lisp systems make heavy use of a garbage-collecting style of
memory management.  Generally, the locality of reference in garbage-collected
systems has been very poor.  In virtual memory systems, this poor locality of
reference generally causes a large amount of wasted time waiting on page
faults or uses excessively large amounts of main memory.  An adaptive memory
management algorithm, described in this article, allows substantial
improvement in locality of reference.  Performance measurements indicate that
page-wait time typically is reduced by a factor of four with constant memory
size and disk technology.  Alternately, the size of memory typically can be
reduced by a factor of two with constant performance.
Generational. Used exit tables indirecting pointers {\em out} of each
generation.
Texas Instruments Explorer.}
}

@techreport{couv89,
author = {Andr\'{e} Couvert and Aomar Maddi and Ren\'{e} Pedrono},
title = {Partage d'Objets dans les Syst\`{e}mes Distribu\'{e}s. Principes des
Ramasse-Miettes},
institution = INRIA,
type = "Rapport de recherche",
number = 963,
month = jan,
year = 1989
}

@inproceedings{crac08,
title = {A Compacting Real-Time Memory Management System},
author = {Silviu S. Craciunas and Christoph M. Kirsch and Hannes Payer and Ana
Sokolova and Horst Stadler and Robert Staudinger},
booktitle = {USENIX Annual Technical Conference},
address = {Boston, MA},
pages = {349--362},
year = 2008,
URL = {http://cs.uni-salzburg.at/~hpayer/publications/payer08.pdf},
slides = {http://cs.uni-salzburg.at/~hpayer/publications/usenix08.pdf}
}

@article{cram88,
title = "A Garbage Collection Algorithm For Shared Memory Parallel Processors",
author = "Jim Crammond",
address = "University of  London, Imperial College of Science and Technology,
Department of Computing, London SW7 2AZ,  England",
journal = "International Journal Of Parallel Programming",
year = 1988,
volume = 17,
number = 6,
pages = "497--522",
doi={10.1007/BF01407816}
}

@inproceedings{cram95,
author = "Jim Crammond and Tim Lindholm",
title = "Memory Management in {Q}uintus {P}rolog",
booktitle = "Implementations of Logic Programming Systems, Budapest",
editor = "Kluwer",
year = 1995,
comment = "or is it ICLP Implementations workshop 1993?"
}

@article{cran75,
author = "B. Cranston and R. Thomas",
title = "A Simplified Recombination Scheme for the {F}ibonacci Buddy System",
journal = CACM,
volume = 18,
number = 6,
month = jul,
publisher = ACM,
year = 1975,
pages = "331--332"
}

@techreport{crar98,
author = {Karl Crary and David Walker and Greg Morrisett},
title = {Typed Memory Management in a Calculus of Capabilities},
month = jul,
year = 1998,
institution = Cornell,
URL = {http://www.cs.cornell.edu/talc/papers/capabilities.ps.gz}
}

@inproceedings{craw91,
author = "S. C. Crawley",
title = "Local and Global Distributed Garbage Collection",
crossref = "OOPSLA91-gc",
}

@inproceedings{crar99,
title = {Typed Memory Management in a Calculus of Capabilities},
author = {Karl Crary and David Walker and Greg Morrisett},
crossref = {POPL99},
URL = {http://simon.cs.cornell.edu/home/jgm/papers/capabilities.ps}
}

@inproceedings{crid92,
author = "Regis Cridlig",
title = "An Optimising {ML} to {C} Compiler",
booktitle = "{ACM} {SIGPLAN} {W}orkshop on {ML} and its Applications",
address = "San Francisco",
editor = "David MacQueen",
publisher = ACM,
year = 1992,
month = jun
}

@mastersthesis{crit92,
author = "Critchlow, Terence J.",
title = "A Distributed Garbage Collection Algorithm",
month = aug,
year = 1992,
school = "Department of Computer Science, University of Utah",
note = "University of Utah Technical report CSTD--92--011",
URL = "ftp://ftp.cs.utah.edu/techreports/1992/UUCS-92-011.ps.Z",
abstract = "Concurrent Scheme extends the Scheme programming language, providing parallel
program execution on a distributed network.  The Concurrent Scheme environment
requires a garbage collector to reclaim global objects; objects that exist in
a portion of the global heap located on the node that created them.  Because a
global object may be referenced by several nodes, traditional garbage
collection algorithms cannot be used.  The garbage collector used must be able
to reclaim global objects with minimal disturbance to the user program, and
without the use of global state information.  It must operate asynchronously,
have a low network overhead, and be able to handle out-of-order messages.
This thesis describes a distributed reference counting garbage collector
appropriate for the reclamation of global objects in the Concurrent Scheme
environment."
}

@inproceedings{curi08,
title = {Memory Pooling Assisted Data Splitting ({MPADS})},
author = {Stephen Curial and Peng Zhao and Jose Nelson Amaral and Yaoqing Gao
and Shimin Cui and Raul Silvera and Roch Archambault},
crossref = {ISMM08},
pages = {101--110},
doi = {10.1145/1375634.1375649},
abstract = {This paper describes Memory-Pooling-Assisted Data
Splitting (MPADS), a framework that combines data structure splitting
with memory pooling --- Although it MPADS may call to mind memory
padding, a distintion of this framework is that is does not insert
padding. MPADS relies on pointer analysis to ensure that splitting
is safe and applicable to type-unsafe language. MPADS makes no
assumption about type safety. The analysis can identify cases in
which the transformation could lead to incorrect code and thus MPADS
abandons those cases.  To make data structure splitting efficient
in a commercial compiler, MPADS is designed with great attention
to reduce the number of instructions required to access the data
after the data-structure splitting. Moreover the implementation of
MPADS reveals that architecture details should be considered carefully
when re-arranging data allocation. For instance one of the most
significant gains from the introduction of data-structure splitting
in code targetting the IBM POWER architecture is a dramatic decrease
in the amount of data prefetched by the hardware prefetch engine
without a noticeable decrease in the cache utilization. Triggering
fewer hardware prefetch streams frees memory bandwidth and cache
space. Fewer prefetching streams also reduce the interference between
the data accessed by multiple cores in modern multicore processors.}
}

@book{daco93,
author = "Michael C. Daconta",
title = "{C} Pointers and Dynamic Memory Management",
publisher = "QED Publishing",
ISBN = "0-471-56152-5",
year = 1993
}

@book{daco95,
author = "Michael C. Daconta",
title = "{C++} Pointers and Dynamic Memory Management",
publisher = Wiley,
ISBN = "0-471-04998-0",
year = 1995,
comment = {It's more about pointers than memory management.  The
pointer part is not bad, if you're a C++ beginner; the memory
management part is disappointing.
It's written in a clear style and starts from the basics ("Memory
Location: a container that can store a binary number").  The view of
OO programming is rather naive and C++-oriented.  It explains
references (slightly wrong), pointer arithmetic, malloc/free,
new/delete, constructors, destructors, set_new_handler, pointer
arrays, inheritance, templates (simple ones), and many other things.
The coverage of pointers is pretty comprehensive, but there's nothing
about automatic memory management.  The approach is rather practical,
often ignoring the subtleties of the standard.  It comes with a floppy
of source code.
There's a chapter on MM internals.  It explains the basics in simple
language, but fairly well.  It doesn't discuss sophisticated free list
structures.  There's decent debugging malloc/new replacement,
explained in detail (there's a bug in dbg_realloc, though: it can
overwrite the object when making it smaller).  There's an interview
with Arthur D. Applegate, the developer of SmartHeap, where many wise
things are said, and Lisp and Smalltalk are mentioned as doing these
things better.  Quote of the day: "I have benchmarked a _single_ call
to malloc at [...] over 20 minutes with Watcom C under OS/2."  He says
garbage collection is too slow (he worked at Inference Corp. many
years ago).
There's a chapter of the quirks of Intel x86 segmented pointers and
Mac handles.-PP}
}

@techreport{dahl63,
title = {The {SIMULA} Storage Allocation Scheme},
author = {O. J. Dahl},
institution = {Norsk Regnesentral},
year = 1963,
month = nov,
type = {NCC Document},
number = 62,
}

@article{dahl66,
author = "O. J. Dahl and K. Nygaard",
title = "Simula --- an {A}lgol-Based Simulation Language",
journal = CACM,
volume = 9,
publisher = ACM,
pages = "671--678",
year = 1966
}

@techreport{danv86,
author = "Olivier Danvy",
title = "{LILA}: a Virtual Machine for Functional and Declarative Languages",
institution = "LITP, France",
month = may,
number = "86--38",
year = 1986,
note = "Workshop on Future Directions in Computer Science and Software"
}

@techreport{danv86a,
author = "Olivier Danvy",
title = {Agir avec {LILA}: le Manuel de R\'{e}f\'{e}rence},
institution = "LITP, France",
month = may,
number = "86--40",
year = 1986
}

@techreport{danv86b,
author = "Olivier Danvy and Danielle Jean",
title = {Langage d'Imple\'{e}mentation pour Langages Applicatifs: contribution
\'{a} l'\'{e}tude d'une r\'{e}alisation informatique},
institution = "LITP, France",
month = jan,
number = "86--23",
note = {Also Bigre+Globule 48, 3e journ\'{e}es d'\'{e}tude sur les Langages Orient\'{e}s Objet},
year = 1986
}

@article{danv87,
author = "Olivier Danvy",
title = "Memory Allocation and Higher-Order Functions",
journal = sigplan,
publisher = ACM,
volume = 22,
number = 7,
pages = "241--252",
month = Jun,
year = 1987
}

@inproceedings{dau98,
author = {C. H. Daugherty and J. Morris Chang},
title = {Common List Method: A Simple, Efficient Allocator Implementation},
booktitle = {6th Annual High-Performance Computing Symposium},
address = {Boston, MA},
month = apr,
year = 1998,
pages = {180--185}
}

@article{davi84,
title = "Memory Occupancy Patterns in Garbage Collection Systems",
author = "D. Julian M. Davies",
journal = CACM,
publisher = ACM,
month = aug,
year = 1984,
volume = 27,
number = 8,
pages = "819--825"
}

@inproceedings{davi12,
title = {Towards Region Based Memory Management for {G}o},
author = {Matthew Davis and Harald Sondergaard and Peter Schachte and Zoltan Somogyi},
crossref = {MSPC12},
 pages = {58--67},
 doi = {10.1145/2247684.2247695},
abstract = {Region-based memory management aims to lower the cost of deallocation through
bulk processing: instead of recovering the memory of each object separately, it
recovers the memory of a region containing many objects. It relies on static
analysis to determine the set of memory regions needed by a program, the program
points at which each region should be created and removed, and, for each memory
allocation, the region that should supply the memory. The concurrent language Go
has features that pose interesting challenges for this analysis. We present a
novel design for region-based memory management for Go, combining static
analysis, to guide region creation, and lightweight runtime bookkeeping, to help
control reclamation. The main advantage of our approach is that it greatly
limits the amount of re-work that must be done after each change to the program
source code, making our approach more practical than existing RBMM systems. Our
prototype implementation covers most of the sequential fragment of Go, and
preliminary results are encouraging.}
}

@inproceedings{davi13,
title = {A Low Overhead Method for Recovering Unused Memory Inside Regions},
author = {Matthew Davis and Peter Schachte and Zoltan Somogyi and Harald S\ondergaard},
doi = {10.1145/2492408.2492415},
crossref = {MSPC13},
abstract = {Automating memory management improves both resource safety and
programmer productivity. One approach, region-based memory management [9]
(RBMM), applies compile-time reasoning to identify points in a program at which
memory can be safely reclaimed. The main advantage of RBMM over traditional
garbage collection (GC) is the avoidance of expensive runtime analysis, which
makes reclaiming memory much faster. On the other hand, GC requires no static
analysis, and, operating at runtime, can have significantly more accurate
information about object lifetimes. In this paper we propose a hybrid system
that seeks to combine the advantages of both methods while avoiding the
overheads that previous hybrid systems incurred. Our system can also reclaim
array segments whose elements are no longer reachable.}
}

@inproceedings{daws82,
author = "Jeffrey L. Dawson",
title = "Improved Effectiveness from a Real-Time {LISP} Garbage Collector",
crossref = "LFP82",
pages = "159--167",
comment = "
Described as a variation of Baker but is an incremental update scheme, similar
to Dijkstra."
}

@article{day83,
author = "J. D. Day and H. Zimmermann",
title = "The {OSI} {R}eference {M}odel",
journal = "Proceedings of the IEEE",
publisher = IEEE,
volume = 71,
pages = "1334--1340",
month = Dec,
year = 1983,
doi = {10.1109/PROC.1983.12775}
}

@article{day94,
title = {References to Remote Mobile Objects in {T}hor},
author = {M. Day and Barbara Liskov and Umesh Maheshwari and A. Myers},
journal = {ACM Letters on Programming Languages and Systems},
volume = 2,
number = {1--4},
month = mar,
year = 1994,
URL = {http://pauillac.inria.fr/~lefessan/dgc/papers/00032-DLMM94.ps.gz}
}

@inproceedings{dayl04,
author = {Edgar G. Daylight and Bart Demoen and Francky Catthor},
title = {Formally Specifying Dynamic Data Structures for Embedded Software Design: An Initial Approach},
crossref = {SPACE04},
}

@inproceedings{dayn97,
author = {Laurent Dayn{\`e}s and Malcolm P. Atkinson},
title = {Main-Memory Management to support Orthogonal Persistence for {J}ava},
booktitle = {2nd International Workshop on Persistence and {J}ava ({PJW2})},
address = {Half Moon Bay, CA},
URL = {http://www.sunlabs.com/research/forest/COM.Sun.Labs.Forest.PJava.PJW2.9_ps.ps},
month = aug,
year = 1997,
note = {To be published.}
}

@inproceedings{dear92,
author = "Alan Dearle and di Bona, Rex  and James Farrow and Frans Henskens and Anders Lindstrom and John Rosenberg and Francis Vaughan",
title = "Grasshopper --- A Persistent Operating System for Conventional Hardware",
crossref = "IWOOOS92",
pages = {81--85}
}

@inproceedings{dear92a,
author = "Alan Dearle and others",
title = "An Examination of Operating System Support for Persistent Object System
s",
booktitle = "25th Hawaii International Conference on Systems Sciences, vol. 1",
year = 1992,
pages = {779--789},
}

@techreport{deb84,
author = "Ashoke Deb",
title = "An efficient garbage collector for graph machines",
institution = "Oregon Graduate Center",
year = 1984,
number = "CS/E-84-003"
}

@inproceedings{deb87,
author = "Ashoke Deb",
title = "Parallel Garbage Collection in a Parallel Virtual Memory
Environment",
booktitle = "Graph Reduction: Proceedings of a Workshop at {S}anta {F}e, {N}ew {M}exico",
editor = "J. H. Fasel and R. M. Keller",
pages = "252--264",
publisher = SV,
series = LNCS,
volume =279,
address = "New York, NY",
year = "1987"
}

@inproceedings{dela92,
title = "Allocation Regions and Implementation Contracts",
author = "V. Delacour",
crossref = "IWMM92",
pages = {426--439},
doi = {10.1007/BFb0017205}
}

@article{dell80,
  author =	 "C. N. R. Dellar",
  title =	 "Removing Backing Store Administration from the {CAP}
                  Operating System",
  journal =	 SIGOPS,
  volume =	 14,
  number =	 4,
  pages =	 "41--49",
  year =	 1980
}

@inproceedings{deme90,
title = "Combining Generational and Conservative Garbage Collection: Framework and Implementations",
author = "Alan Demers and Mark Weiser and Barry Hayes and Hans Boehm and Daniel G. Bobrow and Scott  Shenker",
crossref = "POPL90",
pages = "261--269",
doi = {10.1145/96709.96735},
abstract = {Two key ideas in garbage collection are generational collection and
conservative pointer-finding.  Generational collection and conservative
pointer-finding are hard to use together, because generational collection
is usually expressed in terms of copying objects, while conservative
pointer-finding precludes copying.
We present a new framework for defining garbage collectors.
When applied to generational collection, it generalizes the notion of
younger/older to a partial order.  It can describe traditional generational
and conservative techniques, and lends itself to combining different
techniques in novel ways.
We study in particular two new garbage collectors inspired by this
framework.  Both these collectors use conservative pointer-finding.
The first one is based on a rewrite of an existing trace-and-sweep collector
to use one level of generation.  The second one has a single parameter,
which controls how objects are partitioned into generations;
the value of this parameter can be changed dynamically with no overhead.
We have implemented both collectors and
present measurements of their performance in practice.}
}

@inproceedings{demo96,
author = "Bart Demoen and Geert Engels and Paul Tarau",
title = "Segment Preserving Copying Garbage Collection for {WAM}-Based {P}rolog",
booktitle = "ACM Symposium on Applied Computing",
editor = "Jim Hightower",
publisher = ACM,
address = "Philadelphia",
month = feb,
year = 1996,
note = "Programming languages track"
}

@inproceedings{demo98,
author = {Bart Demoen and Konstantinos Sagonas},
title = {Memory Management for {P}rolog with Tabling},
pages = {97--106},
crossref = {ISMM98},
abstract = {Tabling can be implemented in a Prolog system by means of
SLG-WAM: consumers suspend by freezing the execution stacks. XSB is an
implementation that does so. The memory model is quite complex and
attempts to understand the notion of usefulness of data in XSB well
enough to build a precise garbage collector have failed in the past.
CAT is a recent alternative to SLG-WAM: it suspends consumers by
copying parts of the execution stacks. The memory model is simpler and
the design of a more precise garbage collector became feasible. CAT
also provided the necessary insights in the usefulness of data in the
context of the SLG-WAM. This paper describes the memory management of
tabled logic programming systems, whether based on the SLG-WAM or on
CAT.  Since CAT can perform arbitrarily worse than SLG-WAM space-wise,
also a minor garbage collection on creation of the CAT areas is
described and its effectiveness is discussed. }
}

@inproceedings{demo02,
author = {Bart Demoen},
title = {A Different Look at Garbage Collection for the {WAM}},
crossref = {ICLP02},
}

@inproceedings{demo02a,
author = {Bart Demoen and Phuong-Lan Nguyen and Ruben Vandeginste},
title = {Copying Garbage Collection for the {WAM}: To Mark or Not to Mark?},
crossref = {ICLP02},
}

@article{denn68,
author = "P. J. Denning",
title = "The Working Set Model for Program Behaviour",
journal = CACM,
publisher = ACM,
volume = 11,
pages = "323--333",
year = 1968
}

@inproceedings{denn68a,
author = "P. J. Denning",
title = {Thrashing: Its Causes and Prevention},
month = jun,
year = 1968,
booktitle = {AFIPS 1968 Fall Joint Computer Conference},
volume = 33,
pages = {915--922},
}

@article{denn70,
author = "P. J. Denning",
title = "Virtual Memory",
publisher = ACM,
journal = {ACM Computing Surveys},
volume = 2,
number = 3,
pages = "153-190",
month = sep,
year = 1970
}

@article{denn72,
author = "P. J. Denning and Scwartz",
title = "Properties of the Working-set Model",
journal = CACM,
publisher = ACM,
volume = 15,
number = 3,
pages = "191--198",
month = mar,
year = 1972
}

@article{denn80,
author = "Peter Denning",
title = "Working Sets Past and Present",
journal = IEEETransSWE,
publisher = IEEE,
volume = "SE-6",
number = 1,
month = jan,
year = 1980,
pages = "64--84"
}

@techreport{derb87,
author = "Margaret H. Derbyshire",
title = "Garbage Collection on the {IRM}: Report Number 6",
institution = "University of Manchester, Department of Computer Science",
type = "Departmental Research Report",
number = "FS/MU/MHD/004--87",
year = "1987",
abstract = "A mark-scan algorithm for the IRM. Flagship project"
}

@article{derb90,
author = "Derbyshire, Margaret H.",
title = "Mark Scan Garbage Collection on a Distributed Architecture",
journal = LSC,
year = 1990,
month = apr,
volume = 3,
number = 2,
pages = "135 -- 170"
}

@article{ders80,
author = "N. Dershowitz",
title = "The {S}chorr--{W}aite Marking Algorithm Revisited",
journal = IPL,
publisher = NH,
volume = 11,
number = 3,
month = Nov,
year = 1980,
pages = "141--143",
comment = "{Paper shows that imposing a depth-first marking order a simple proof of
correctness of {S}chorr-{W}aite algorithm follows naturally}",
}

@inproceedings{deso06,
title = {Improving the Performance of the Deferrable Server Based Garbage Collection Scheduling Strategy},
author = {El Desokey, Ali Ebrahim and El Gawad, Aida Abd and Amany Sarhan and Seham Moawed},
booktitle = {ITI 4th International Conference on Information and Communications
Technology},
address = {Cairo, Egypt},
year = 2006,
URL = {http://www.icict.gov.eg/ICICT-2006/Papers/Human-Computer%20Interaction%20(HCI)/PAPER.pdf}
}

@inproceedings{dete02,
title = {Automated Discovery of Scoped Memory Regions for Real-Time {J}ava},
author = {Morgan Deters and Ron Cytron},
crossref = {ISMM02},
pages = {25--35}
}

@inproceedings{dete04,
  title =	 {Automated Reference-Counted Object Recycling for Real-Time
                  {J}ava},
  author =	 {Morgan Deters and Nicholas A. Leidenfrost and M Matthew
                  P. Hampton and James C. Brodman and Ron Cytron},
  booktitle =	 {10th Real-Time and Embedded Technology
                  and Applications Symposium (RTAS)},
  pages =	 {424--433},
  year =	 2004,
  publisher =	 IEEE,
  doi =		 {10.1109/RTTAS.2004.1317289}
}

@techreport{detl90,
author = "David L. Detlefs",
title = "Concurrent Garbage Collection for {C++}",
institution = CMU,
address = "Pittsburgh, PA",
number = "CMU--CS--90--119",
month = May,
year = 1990,
abstract = "Automatic storage management, or garbage collection,
is a feature usually associated with languages oriented toward
'symbolic processing,' such as Lisp or Prolog; it is seldom
associated with 'systems' languages, such as C and C++.  This
report surveys techniques for performing garbage collection for
languages such as C and C++, and presents an implementation of a
concurrent copying collector for C++.  The report includes
performance measurements on both a uniprocessor and a
multiprocessor."
}

@inproceedings{detl90a,
author = "David L. Detlefs",
title = "Concurrent, Atomic Garbage Collection",
crossref = "OOPSLA90-gc",
}

@phdthesis{detl91,
author = "David L. Detlefs",
title = "Concurrent, Atomic Garbage Collection",
school = CMU,
address = "Pittsburgh, PA, 15213",
number = "CMU--CS--90--177",
month = nov,
year = 1991,
abstract = {We describe a concurrent, atomic garbage collection
algorithm for transaction-based languages, a class of languages
intended to support reliable distributed systems.  A garbage
collection algorithm for reliable distributed systems must be
atomic: a crash during a garbage collection should result in no
loss of data.  A concurrent collector allows programs to continue
operating as their heaps are collected, minimizing delays imposed
by collection.  A concurrent collector can be used in reliable
distributed systems that must service interactive requests.
We introduce concurrency into an atomic collector by breaking
collection into a series of garbage collection segments, which
are similar to transactions, but satisfy weaker properties than
are required by transaction semantics.  These weaker properties
allow better performance.  Thus, our collection algorithm
enhances the reliability of programs written in transaction-based
languages, without necessarily imposing severe performance
penalties.  We also describe a concurrent "mostly-copying"
collection algorithm for C++, and present measurements of the
performance of an implementation of this algorithm.
We survey garbage collection techniques applicable to "systems"
languages such as C++, and show how these techniques may be
combined with concurrent collection.  Performance measurements of
the resulting collector (on both a uniprocessor and a
multiprocessor) indicate that interruptions caused by concurrent
collection are quite short, and that adequate mutator performance
is sustained during collection.  Finally, we prove the
correctness of most aspects of the concurrent, atomic collection
algorithm.  The proof hinges on showing that the routines of the
algorithm preserve a novel property called partial idempotence,
which ensures that partial effects of routines interrupted by
crashes can be undone or completed during recovery.}
}

@incollection{detl91a,
author = "David L. Detlefs",
title = "Concurrent Garbage Collection for {C++}",
booktitle = "Topics in Advanced Language Implementation",
editor = "Peter Lee",
publisher = MIT,
year = 1991
}

@inproceedings{detl92,
title = "Garbage Collection and Runtime Typing as a {C}++ Library",
author = "David L. Detlefs",
booktitle = "{USENIX} {C}++ Conference",
publisher = UA,
address = "Portland, OR",
year = 1992,
month = aug
}

@techreport{detl93,
author = "David L. Detlefs and Al Dosser and Benjamin Zorn",
title = "Memory Allocation Costs in Large {C} and {C++} Programs",
institution = "Digital Equipment Corporation and University of Colorado",
type = "Computer Science Technical Report",
number = "CU-CS-665-93",
address = "130 Lytton Avenue, Palo Alto, CA 94301 and Campus Box 430, Boulder, CO 80309",
month = aug,
year = 1993,
URL = "ftp://ftp.cs.colorado.edu:/pub/cs/techreports/zorn/CU-CS-665-93.ps.Z",
abstract = "Dynamic storage allocation is an important part of a large class of
computer programs written in C and C++.  High-performance algorithms
for dynamic storage allocation have been, and will continue to be, of
considerable interest.  This paper presents detailed measurements of
the cost of dynamic storage allocation in 11 diverse C and C++
programs using five very different dynamic storage allocation
implementations, including a conservative garbage collection
algorithm.  Four of the allocator implementations measured are
publicly-available on the Internet.  A number of the programs used in
these measurements are also available on the Internet to facilitate
further research in dynamic storage allocation.  Finally, the data
presented in this paper is an abbreviated version of more extensive
statistics that are also publically-available on the Internet."
}

@inproceedings{detl93a,
author = "David L. Detlefs",
title = "Empirical Evidence for using Garbage Collection in {C} and {C++} Programs",
crossref = "OOPSLA93-gc",
}

@article{detl94,
author = "David Detlefs and Al Dosser and Benjamin Zorn",
title = "Memory Allocation Costs in Large {C} and {C++} Programs",
institution = "Digital Equipment Corporation and University of Colorado",
journal = SPE,
publisher = Wiley,
volume = 24,
number = 6,
year = 1994
}

@inproceedings{detl95,
title = "Debugging Storage Management Problems in Garbage-Collected
Environments",
author = "Dave Detlefs and Bill Kalsow",
booktitle = "{USENIX} Conference on Object-Oriented Technologies",
month = jun,
publisher = UA,
year = 1995,
URL = {ftp://ftp.digital.com/pub/misc/detlefs/detlefs-coots95.ps},
abstract = "Garbage collection does not solve all storage management problems; programs
allocate too much garbage, requiring excess collection, and may retain too much
storage, causing heaps to grow too large. This paper discusses these problems
and presents tools implemented in the SRC Modula-3 system that help solve them."
}

@inproceedings{detl01,
title = {Lock-Free Reference Counting},
author = {David L. Detlefs and Paul A. Martin and Mark Moir and Guy L. Steele},
booktitle = {20th ACM Symposium on Distributed Computing},
publisher = ACM,
month = aug,
year = 2001,
pages = {190--199},
address = {Newport, Rhode Island},
doi={10.1145/383962.384016}
}

@inproceedings{detl02,
title = {Concurrent Remembered Set Refinement in Generational Garbage Collection},
author = {David Detlefs and William D. Clinger and Matthias Jacob and Ross Knippel},
crossref = {JVM02},
URL = {http://research.sun.com/jtech/pubs/02-clog.pdf}
}

@article{detl02a,
title = {Lock-Free Reference Counting},
author = {David L. Detlefs and Paul A. Martin and Mark Moir and Guy L. Steele},
journal = {Distributed Computing},
publisher = SV,
volume = 15,
pages = {255--271},
year = 2002,
doi={10.1007/s00446-002-0079-z},
url = {http://research.sun.com/people/moir/pubs/LFRC-DC02.pdf}
}

@inproceedings{detl04,
author = {David Detlefs},
title = {Automatic Inference of Reference-Count Invariants},
crossref = {SPACE04},
}

@inproceedings{detl04a,
title = {Garbage-First Garbage Collection},
author = {David Detlefs and Christine Flood and Steven Heller and Tony Printezis},
pages = {37--48},
crossref = {ISMM04},
doi={10.1145/1029873.1029879}
}

@inproceedings{detl04b,
title = {A Hard Look at Hard Real-Time Garbage Collection},
author = {David Detlefs},
crossref = {ISORC04},
pages = {23--32},
note = {Invited paper},
doi={10.1109/ISORC.2004.1300325}
}

@techreport{detr90,
author = "John DeTreville",
title = "Experience with Concurrent Garbage Collectors for {M}odula-2+",
institution = DECSRC,
number = 64,
month = Aug,
year = 1990,
comment = "Reference counting + mark-sweep.
Reference counting may give better locality than other
techniques (based on experience with the Topaz system)."
}

@techreport{detr90a,
author = "John DeTreville",
title = "Heap Usage in the {Topaz} Environment",
institution = DECSRC,
number = 63,
month = Aug,
year = 1990
}

@inproceedings{detr90b,
author = "John DeTreville",
title = "Experience with Garbage Collection for {M}odula-2+ in the {T}opaz Environment",
crossref = "OOPSLA90-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC90/DeTreville.ps.Z"
}

@inproceedings{deut73,
author = "L. Peter Deutsch",
title = "A {LISP} Machine with Very Compact Programs",
booktitle = "International Joint Conference on Artificial Intelligence",
address = "Stanford, CA",
year = 1973,
pages = "697--703"
}

@article{deut76,
author = "L. Peter Deutsch and Daniel G. Bobrow",
title = "An Efficient Incremental Automatic Garbage Collector",
journal = CACM,
publisher = ACM,
volume = 19,
number = 9,
month = sep,
year = 1976,
pages = "522--526",
doi={10.1145/360336.360345},
comment = "Deferred Reference Counting, invented by Peter Deutsch and Danny Bobrow.
The idea is not to reference count the stack, which accounts for the vast
majority of references.
Halved the time cost of reference counting at the cost of 10 percent storage
overhead."
}

@incollection{deut83,
author = "L. Peter Deutsch",
title = "The {D}orado {S}malltalk-80 Implementation: Hardware
architecture's impact on software architecture",
crossref = "Smalltalk-BHWA",
pages = "113--125",
}

@inproceedings{deut84,
author = "Deutsch, Peter L. and A. M. Schiffman",
title = "Efficient Implementation of the {S}malltalk-80 System",
crossref = "POPL84",
pages = "297--302",
}

@inproceedings{deut90,
author = "A. Deutsch",
title = "On Determining Lifetime and Aliasing of Dynamically Allocated Data
in Higher-Order Functional Specifications",
crossref = "POPL90",
pages = "157 -- 168",
abstract = {Compile-time garbage collection}
}

@inproceedings{deut94,
  author =	 "Alain Deutsch",
  title =	 {Interprocedural May-Alias Analysis for Pointers: Beyond
                  k-limiting},
  crossref =	 {PLDI94},
  pages =	 {230--241},
  doi =		 {10.1145/178243.178263}
}

@article{dewa77,
author = "Robert B. K. Dewar and A. P. McCann",
title = "{MACRO} {SPITBOL} --- A {SNOBOL4} Compiler",
journal = SPE,
publisher = Wiley,
volume = 7,
number = 1,
pages = "95--113",
year = 1977,
comment = "Compaction using a threaded algorithm"
}

@article{dewa82,
title = "Transformational Derivation of a Garbage Collection Algorithm",
author = "Robert B. K. Dewar and Micha Sharir and Elia Weixelbaum",
journal = TOPLAS,
publisher = ACM,
year = 1982,
month = Oct,
volume = 4,
number = 4,
pages = "650--667",
abstract = {This paper is about what might be called programming by stepwise
transformation. Starting with a short high-level algorithm, the program is
successively transformed by correctness-preserving local
transformations,
which improve efficiency but also introduce more and more low-level
details. The technique is illustrated by a garbage-collection algorithm:
starting with a 5-statement version 1, the authors eventually arrive at a
28-statement version 8 which resembles a previously known algorithm.
An interesting point is that the authors express all versions of their
program in a real programming language, SETL, a language which allows both
high-level and low-level expression. Thus all versions of the program can
be subjected to testing as well as formal reasoning.
The authors claim that their transformations required very little insight
into the problem and could largely be automated. This reviewer is not
convinced by that argument. To paraphrase a 1973 comment by Urs
Ammann (on stepwise refinement), what we need now is to see the transformational
technique applied to a large problem which has not already been solved.}
}

@inproceedings{dhur03,
  title =	 {Memory Safety without Runtime Checks or Garbage Collection},
  author =	 {Dinakar Dhurjati and Sumant Kowshik and Vikram Adve and
                  Chris Lattner},
  crossref =	 {LCTES03},
  pages =	 {69-80},
  doi =		 {10.1145/780732.780743}
}

@article{diaz94,
author = {Manuel D\'{i}az and E. Pimentel and Jos\'{e} M. Troya},
title = {{DROL}: a Distributed and Real-Time Object-Oriented Logic Environment},
journal = CompJ,
volume = 37,
pages = {407--421},
year = 1994
}

@article{diaz97,
author = {Manuel D\'{i}az and Bartolom\'{e} Rubio and Jos\'{e} M. Troya},
title = {{DRL}: a Distributed Real-Time Logic Language},
journal = {Journal of Computing Languages, special issue on Extensions of Logic Programming},
year = 1997
}

@inproceedings{dice02,
title = {Mostly Lock-Free Malloc},
author = {Dave Dice and Alex Garthwaite},
crossref = {ISMM02},
pages = {163--174}
}

@inproceedings{dick91,
author = "Peter Dickman",
title = "Effective Load Balancing in a Distributed Object-Support Operating System",
crossref = "IWOOOS91",
}

@phdthesis{dick92,
author = "Peter Dickman",
title = "Distributed Object Management in a Non-Small Graph of Autonomous Networ
ks With Few Failures",
school = "University of Cambridge",
month = sep,
year = 1992
}

@unpublished{dick92b,
title = "Optimising Weighted Reference Counts for Scalable Fault-Tolerant
Distributed Object-Support Systems",
author = "Peter Dickman",
year = 1992,
note = {Unpublished note},
comment = "Message failure resilience: weight >= sum remote reference
weights. This tolerates message loss but not duplication.
Indirections avoided by using special null weight + a global tracing GC",
}

@inproceedings{dick96,
  title =	 "Incremental, Distributed Orphan Detection and Actor Garbage
                  Collection Using Graph Partitioning and {E}uler Cycles",
  author =	 "Peter Dickman",
  crossref =	 "WDAG96",
  pages =	 {141-158},
  doi =		 {10.1007/3-540-61769-8_10},
  URL =		 "http://www.dcs.gla.ac.uk/~pd/papers/wdag96.ps",
}

@unpublished{dick96a,
title = "Efficient, Incremental, Distributed Orphan Detection and Actor Garbage Collection",
author = "Peter Dickman",
note = "In preparation",
year = 1996
}

@inproceedings{dick00,
author = {Peter Dickman},
title = {Diffusion Tree Redirection for Indirect Reference Counting},
pages = {167--177},
crossref = {ISMM2000},
abstract = {
A new algorithm for distributed acyclic garbage detection is presented for
use in hybrid collectors. It is based on Piquer's Indirect Reference Counting
(IRC), but qualitatively improves the fault-tolerance. The insight that
underpins this work is the observation that the parent of a node in the IRC
diffusion tree need not remain constant. The new algorithm exploits
standard mechanisms for implementing remote references and diffusion
trees, using three low-cost techniques to dynamically restructure the IRC
diffusion trees to reduce their depth. This variant thereby reduces the
third-party dependencies which make standard IRC vulnerable to process
failure, without affecting the existing tolerance of message reordering. The
paper carefully motivates the algorithm, presents the full technical basis for
its development, provides a detailed explanation of its implementation and
includes an analysis of performance issues. }
}

@inproceedings{diec99,
title = {A Study of the Allocation Behaviour of the {SPECjvm98} {J}ava Benchmarks},
author = {Sylvia Dieckmann and Urs H\"{o}lzle},
crossref = {ECOOP99},
pages = {92--115},
doi={10.1007/3-540-48743-3_5}
}

@incollection{diec01,
title = {The Allocation Behaviour of the {SPECjvm98} {J}ava Benchmarks},
author = {Sylvia Dieckmann and Urs H\"{o}lzle},
booktitle = {Performance Evaluation and Benchmarking with Realistic Applications},
editor = {Rudolf Eigenman},
chapter = 3,
pages = {77--108},
publisher = MIT,
year = 2001
}

@unpublished{dijk75,
author = "Edsgar W. Dijkstra",
title = "Notes on a Real-Time Garbage Collection System",
note = "From a conversation with D. E. Knuth (private collection of D. E. Knuth)",
year = 1975,
comment = {These notes later evolved to paper \cite{dijk76b}}
}

@book{dijk76a,
author = "Edsgar W. Dijkstra",
title = "A Discipline of Programming",
publisher = "Prentice-Hall,  Englewood Cliffs, N. J.",
chapter = 14,
year = 1976,
}

@incollection{dijk76b,
  author =	 "Edsgar W. Dijkstra and Leslie Lamport and A. J. Martin and
                  C. S. Scholten and E. F. M. Steffens",
  title =	 "On-The-Fly Garbage Collection: An Exercise in Cooperation",
  booktitle =	 {Language Hierarchies and Interfaces: International Summer
                  School},
  series =	 LNCS,
  volume =	 46,
  pages =	 {43-56},
  publisher =	 SV,
  address =	 "Marktoberdorf, Germany",
  year =	 1976,
  doi =		 {10.1007/3-540-07994-7_48},
  comment =	 {Shared memory algorithm for parallel mark-scan with
                  tri-colour marking.}
}

@article{dijk78,
  author =	 "Edsgar W. Dijkstra and Leslie Lamport and A. J. Martin and
                  C. S. Scholten and E. F. M. Steffens",
  title =	 "On-The-Fly Garbage Collection: An exercise in Cooperation",
  journal =	 CACM,
  publisher =	 ACM,
  volume =	 21,
  number =	 11,
  month =	 Nov,
  doi =		 {10.1145/359642.359655},
  pages =	 "965--975",
  year =	 1978,
  comment =	 {New version of \cite{dijk76b} with fine grain solution.
                  Incremental write-barrier GC.  Wilson thinks it has an
                  advantage over Baker or Yuasa, since objects are allocated
                  as unreachable. If they die young, they may never be
                  reached.}
}

@article{dijk80,
author = "Edsgar W. Dijkstra and C. S. Scholten",
title = "Termination Detection for Diffusing Computations",
journal = IPL,
publisher = NH,
volume = 11,
pages = {1--4},
month = Aug,
year = 1980
}

@inproceedings{dill08,
title = {The {CLOSER}: Automating Resource Management in {J}ava},
author = {Isil Dillig and Thomas Dillig and Eran Yahav and Satish Chandra},
crossref = {ISMM08},
pages = {1--10},
doi = {10.1145/1375634.1375636},
abstract = {While automatic garbage collection has relieved programmers
from manual memory management in Java-like languages, managing
resources remains a considerable burden and a source of performance
problems. In this paper, we present a novel technique for automatic
resource management based on static approximation of resource
lifetimes. Our source-to-source transformation tool, Closer,
automatically transforms program code to guarantee that resources
are properly disposed and handles arbitrary resource usage patterns.
Closer generates code for directly disposing any resource whose
lifetime can be statically determined; when this is not possible,
Closer inserts conditional disposal code based on interest-reference
counts that identify when the resource can be safely disposed. The
programmer is only required to identify which types should be treated
as resources, and what method to invoke to dispose each such resource.
We successfully applied Closer on a moderate-sized graphics application
that requires complex reasoning for resource management.}
}

@article{dimp00,
author = {Robert Dimpsey and Rajiv Arora and Kean Kuiper},
title = {{J}ava Server Performance: A Case Study of Building Efficient, Scalable {JVM}s},
journal = ISJ,
volume = 39,
number = 1,
pages = {151--174},
year = 2000,
doi={10.1147/sj.391.0151},
URL = {http://www.research.ibm.com/journal/sj/391/dimpsaut.html},
abstract = {The importance of the Java platform has shifted from
a client-centered paradigm to the server. In particular, the Java
language has matured into a viable programming model for server
applications. Correspondingly, the requirements on the Java virtual
machine (JVM) have shifted. This paper details the server-specific
performance enhancements made to the core JVM and just-in-time (JIT)
compiler, which have allowed the IBM Developer Kits that implement
Java code for Intel processors to become industry performance
leaders. The paper focuses on synchronization implementation and
granularity improvements that have greatly increased the scalability
of the Java language on multiprocessor machines. Focus is also given
to memory management, specifically, object allocation, garbage
collection, and heap management. Details of communication and
connection scaling are also provided. Finally, server-specific
enhancements to the JIT compiler are discussed. All component
enhancements in the paper are explained, and their performance
implications are quantified with results from representative
multithreaded server workloads. The paper summarizes work from
across IBM. The authors' specific contributions include the three-tier
spin lock, the thread local heap and freelist merge, the dynamic
heap growth algorithm, bitwise sweep, compaction avoidance, and the
suite of network enhancements. }
}

@inproceedings{ding99,
  author =	 {Chen Ding and Ken Kennedy},
  title =	 {Improving Cache Performance of Dynamic Applications through
                  Data and Computation Reorganization at Run Time},
  crossref =	 {PLDI99},
  pages =	 {229--241},
  doi =		 {10.1145/301618.301670}
}

@inproceedings{ding05,
author = {Ding, Chen and Zhang, Chengliang and Shen, Xipeng and Ogihara, Mitsunori},
title = {Gated Memory Control for Memory Monitoring, Leak Detection and Garbage Collection},
crossref = {MSP05},
pages = {62--67},
doi = {10.1145/1111583.1111593},
}

@inproceedings{ding02,
author = {Yuping Ding and Xining Li},
title = {Cache Performance of Chronological Garbage Collection},
booktitle = {IEEE Canadian Conference on  Electrical and Computer Engineering,
1998},
year = 2002,
doi = {10.1109/CCECE.1998.682534},
abstract = {he paper presents the cache performance analysis of the
Chronological Garbage Collection algorithm used in the LVM system. The LVM is a
new Logic Virtual Machine for Prolog. It adopts one stack policy for all dynamic
memory requirements and cooperates with an efficient garbage collection
algorithm, Chronological Garbage Collection to recuperate space, not as
deliberate garbage collection operation but as a natural activity of the LVM
engine to gather useful objects. This algorithm takes advantages of the
traditional copying, mark-compact, generational, and incremental garbage
collection schemes. In order to determine the improvement of cache performance
under our garbage collection algorithm, we developed an emulator to do the trace
driven cache simulation. Direct mapped cache and set-associative cache with
different cache sizes, block sizes and set associativities are simulated and
measured. The objectives of this simulation are to verify and validate our
experimental results, and to find important factors which influence the
performance of the CGC algorithm},
comment = {Note the meeting in 1998 but this version in 2002}
}

@inproceedings{diwa91,
author = "Amer Diwan",
title = "Stack Tracing In A Statically Typed Language",
crossref = "OOPSLA91-gc",
}

@inproceedings{diwa92,
  title =	 "Compiler Support for Garbage Collection in a Statically
                  Typed Language",
  author =	 "Amer Diwan and J. Eliot B. Moss and Richard L. Hudson",
  crossref =	 "PLDI92",
  pages =	 "273--282",
  doi =		 {10.1145/143095.143140},
  URL =		 "ftp://ftp.cs.umass.edu/pub/osl/papers/sigplan92.ps.Z",
  abstract =	 "... extend the compiler to emit tables of live pointers and
                  values derived from pointers at each program location where
                  collection may occur ...",
  comment =	 "Goal: copying collector, no tagged data, efficiency.
                  Conclusion: it seems to work.  The compiler produces a set
                  of tables that describe what the stack and registers look
                  like at every potential garbage collection point.  There are
                  various complications (weird ways the compiler could mangle
                  pointers), but they handle all the cases that the gcc
                  compiler actually produces. Pending threads are allowed to
                  execute on to gc points.  Various compaction of tables gets
                  them down from 50 percent of code size to about 15 percent."
}

@techreport{diwa93,
title = "Memory Subsystem Performance of Programs with Intensive Heap Allocation",
author = "Amer Diwan and David Tarditi and J. Eliot B. Moss",
number = "CMU-CS-93-227",
institution = CMU,
month = dec,
year = 1993,
URL = "ftp://reports.adm.cs.cmu.edu/usr/anon/1993/CMU-CS-93-227.ps",
note = "Also appears as Fox Memorandum CMU-CS-FOX-93-07.",
abstract = "Heap allocation with copying garbage collection is a general
storage-management technique for modern programming languages.
It is believed to have poor memory-subsystem performance.
To investigate this, we conducted an  in-depth study of the
memory-subsystem performance of heap allocation for memory subsystems
found on many machines.   We studied the performance of mostly-functional
Standard ML programs which made heavy use of heap allocation.

We found that most machines support heap-allocation poorly. However,
with the appropriate memory-subsystem organization, heap allocation
can have good performance.  The memory-subsystem property crucial for
achieving good performance was the ability to allocate and initialize
a new object into the cache without a penalty.   This can be achieved
by having  subblock placement with a subblock size of one word with a
write-allocate policy, along with fast page-mode writes or a write
buffer.  For caches with subblock placement, the data-cache overhead
was under 9\% for a 64K of larger data cache; without subblock placement
the overhead was often higher than 50\%."
}

@inproceedings{diwa94,
title = "Memory Subsystem Performance of Programs using Copying Garbage Collection",
author = "Amer Diwan and David Tarditi and J. Eliot B. Moss",
crossref = "POPL94",
doi = {10.1145/174675.174710},
pages = {1--14},
URL = "http://www.cs.cmu.edu:8001/afs/cs/project/fox-1/dtarditi/papers/cmu-tr-93-210.ps",
}

@article{diwa95,
title = "Memory Subsystem Performance of Programs with Intensive Heap Allocation",
author = "Amer Diwan and David Tarditi and J. Eliot B. Moss",
journal = TransCompSys,
volume = 13,
number = 4,
pages = "244--273",
month = aug,
year = 1995
}

@techreport{diwa02,
title = {Energy Consumption and Garbage Collection in Low-Powered Computing},
author = {Amer Diwan and Han Lee and Dirk Grunwald and Keith Farkas},
institution = {University of Colorado, Boulder},
number = {CU--CS--930--02},
year = 2002,
URL = {http://www-plan.cs.colorado.edu/diwan/gcpower.pdf},
}

@inproceedings{dohe04,
  author =	 {Simon Doherty and David L. Detlefs and Lindsay Groves and
                  Christine H. Flood and Victor Luchangco and Paul A. Martin
                  and Mark Moir and Nir Shavit and Steele, Jr., Guy L.},
  title =	 {{DCAS} is not a silver bullet for nonblocking algorithm
                  design},
  booktitle =	 {16th Annual ACM Symposium on
                  Parallelism in Algorithms and Architectures},
  address =	 {Barcelona, Spain},
  year =	 2004,
  pages =	 {216--224},
  doi =		 {10.1145/1007912.1007945}
}

@inproceedings{dolb97,
  title =	 {Automatic Inline Allocation of Objects},
  author =	 {Julian Dolby},
  crossref =	 {PLDI97},
  pages =	 {7-17},
  doi =		 {10.1145/258915.258918},
  URL =		 {http://www-csag.cs.uiuc.edu/papers/pldi97.ps}
}

@inproceedings{dolb98,
title = {An Evaluation of Automatic Object Inline Allocation Techniques},
author = {Julian Dolby and Andrew A. Chien},
crossref = {OOPSLA98},
doi={10.1145/286936.286943},
pages={1--20},
URL = {http://www-csag.cs.uiuc.edu/papers/oopsla-98.ps}
}

@inproceedings{dolb00,
  author =	 {Julian Dolby and Andrew A. Chien},
  title =	 {An Automatic Object Inlining Optimization and its
                  Evaluation},
  crossref =	 {PLDI00},
  pages =	 {345--357},
  doi =		 {10.1145/349299.349344}
}

@inproceedings{doli93,
title = "A Concurrent Generational Garbage Collector for a Multi-Threaded Implementation of {ML}",
author = "Damien Doligez and Xavier Leroy",
crossref = "POPL93",
pages = "113--123",
doi={10.1145/158511.158611},
URL = {ftp://ftp.inria.fr/INRIA/Projects/cristal/Xavier.Leroy/publications/concurrent-gc.ps.gz},
comment = "Immutable objects kept in private heaps collected by a
replication based stop-and-copy collector into a shared heap
which is collected by a Dijkstra-type collector."
}

@inproceedings{doli94,
title = "Portable, Unobtrusive Garbage Collection for Multiprocessor Systems",
author = "Damien Doligez and Georges Gonthier",
crossref = "POPL94",
doi={10.1145/174675.174673},
pages={70--83},
URL = "ftp://ftp.inria.fr/INRIA/Projects/para/doligez/DoligezGonthier94.ps.gz"
}

@inproceedings{dols04,
title = {Imposing a Memory Management Discipline on Software Deployment},
author = {Eelco Dolstra and Eelco Visser and de Jonge, Meijn},
crossref = {ICSE04}
}

@inproceedings{doma00,
  title =	 {A Generational On-the-fly Garbage Collector for {J}ava},
  author =	 {Tamar Domani and Elliot K. Kolodner and Erez Petrank},
  crossref =	 {PLDI00},
  pages =	 {274-284},
  doi =		 {10.1145/349299.349336},
  URL =		 {http://www.cs.technion.ac.il/~erez/papers.html},
}

@techreport{doma00a,
title = {A Generational On-the-fly Garbage Collector for {J}ava},
author = {Tamar Domani and Elliot Kolodner and Erez Petrank},
number = {88.385},
institution = {IBM Haifa Research Laboratory},
year = 2000,
URL = {http://www.cs.technion.ac.il/~erez/gen.ps},
note = {Fuller version of \cite{doma00}}
}

@inproceedings{doma00b,
author = {Tamar Domani and Elliot K.  Kolodner and Ethan Lewis and Elliot E. Salant and Katherine Barabash and Itai Lahan and Erez Petrank and Igor Yanover and Yossi Levanoni},
title = {Implementing an On-the-fly Garbage Collector for {J}ava},
URL = {http://www.cs.technion.ac.il/~erez/papers.html},
pages = {155--166},
crossref = {ISMM2000},
abstract = {
Java uses garbage collection (GC) for the automatic reclamation of
computer memory no longer required by a running application. GC
implementations for Java Virtual Machines (JVM) are typically designed for
single processor machines, and do not necessarily perform well for a server
program with many threads running on a multiprocessor. We designed and
implemented an on-the-fly GC, based on the algorithm of Doligez, Leroy
and Gonthier~\cite{doli93,doli94} (DLG) for Java in this environment. An
{\em on-the-fly collector}, a collector that does not stop the program
threads, allows all processors to be utilized during collection and provides
uniform response times. We extended and adapted DLG for Java (e.g.,
adding support for weak references) and for modern multiprocessors
without sequential consistency, and added performance improvements (e.g.,
to keep track of the objects remaining to be traced). We compared the
performance of our implementation with stop-the-world mark-sweep GC.
Our measurements show that the performance advantage for our collector
increases as the number of threads increase and that it provides uniformly
low response times.}
}

@inproceedings{doma02,
title = {Thread-Local Heaps for {J}ava},
author = {Tamar Domani and Elliot K.  Kolodner and Ethan Lewis and Erez Petrank and Dafna Sheinwald},
crossref = {ISMM02},
doi={10.1145/512429.512439},
URL = {http://www.cs.technion.ac.il/~erez/papers.html},
pages = {76--87}
}

@inproceedings{dona01,
author = {Steven M. Donahue and Matthew P. Hampton and Morgan Deters and Jonathan M. Nye and Ron K. Cytron and Krishna M. Kavi},
title = {Storage Allocation for Real-Time, Embedded Systems},
crossref= {EMSOFT01},
pages = {131--147},
URL = {http://link.springer-ny.com/link/service/series/0558/bibs/2211/22110131.htm}
}

@inproceedings{donn06,
title = {Formal Semantics of Weak References},
author = {Kevin Donnelly and Joe Hallett and Assaf Kfoury},
pages = {126--137},
crossref = {ISMM06},
doi={10.1145/1133956.1133974}
}

@inproceedings{dor98,
title = {Detecting Memory Errors via Static Pointer Analysis},
author = {Nurit Dor and Michael Rodeh and Mooly Sagiv},
crossref = {PASTE98},
pages = {27--34},
doi = {10.1145/277631.277637}
}

@book{dorf,
title = {{C++} Memory Management},
author = {Len Dorfman and Marc J. Neuberger},
publisher = MGH,
note = {Out of print}
}

@inproceedings{doro91,
author = {M. Dorochevsky and K. Schuerman and A. V\'{e}ron and J. Xu},
title = "Contraint Handling, Garbage Collection and Execution Models in
{E}lip{S}ys",
booktitle = "{ICLP'91} Workshop on Parallel Execution of Logic Programs",
editor = "A. Beaumont and G. Gupta",
pages = "17--28",
year = 1991,
series = LNCS,
volume = 569,
publisher = SV,
}

@inproceedings{doro92,
author = {Dorochevsky, M. and V\'{e}ron, A.},
title = "Binding Techniques and Garbage Collection for {OR}-Parallel {CLP} Systems",
crossref = "PLILP92",
pages = "39--53",
}

@article{doug91,
author = {Fred Douglis and M. Frans Kaashoek ad John K. Ousterhout and Andrew S. Tanenbaum},
title = {A Comparison of Two Distributed Operating Systems : {A}moeba and {S}prite},
journal = {Computing Systems},
volume = 4,
number = 4,
pages = {353--384},
month = sep,
year = 1991
}

@inproceedings{doug93,
author = "Fred Douglis",
title = "The Compression Cache: Using On-line Compression to Extend
Physical Memory",
booktitle = "1993 Winter {USENIX} Conference",
publisher = UA,
pages = "519-529",
address = "San Diego, CA",
month = jan,
year = 1993,
}

@inbook{doug02,
title = {Real-Time Design Patterns: Robust Scalable Architecture for Real-Time Systems},
author = {Bruce Powel Douglass},
chapter = 6,
publisher = AW,
year = 2002,
comment = {Chapter 6. Memory Patterns includes GC `patterns'},
}
@article{drez86,
author ={Z. Drezner and A. Barak},
title = {An Asynchronous Algorithm for Scattering Information between the Active Nodes of a Multi-Computer System},
journal = {Journal of Parallel and Distributed Computing},
volume = 3,
number = 3,
pages = {344--351},
month = sep,
year = 1986
}

@article{debu96,
author = {Danny Dub\'{e} and Marc Feeley and Manuel Serrano},
title = {Un {GC} temps r\'{e}el semi-compactant},
journal = {Journ\'{e}es Francophones des Langages Applicatifs},
month = jan,
year = 1996,
pages = {165--181},
URL = {http://www.iro.umontreal.ca/~feeley/papers/jfla96.ps.gz}
}

@inproceedings{dufo04,
author = {Bruno Dufour and Christopher Goard and Laurie Hendren and de Moor,
Oege and Ganesh Sittampalam and Clark Verbrugge},
title = {Measuring the dynamic behaviour of {A}spect{J} programs},
crossref  = {OOPSLA04},
}

@mastersthesis{duim89,
author = "Duimovich, John",
title = "Garbage Collection in a Multiprocessor {S}malltalk System",
year = 1990,
school = "Carleton University, Canada"
}

@article{duri84,
author = {Jean-Louis Durieux and Danielle Jean and Fran\,{c}oise Carr\'{e} and Patrick Sall\'{e}},
title = {Langage d'Impl\'{e}mentation pour Logique et Acteurs},
journal = "Bigre+Globule",
month = nov,
note = {2e journ\'{e}es d'\'{e}tude sur les Langages Orient\'{e}s Objet},
year = 1984
}

@inproceedings{durd91,
author = "Durdanovic, Igor",
title = "A Fast Garbage Collection Algorithm for {WAM}-Based {PROLOG}",
booktitle = "4th Workshop on Computer Science Logic, Heidelberg",
series = LNCS,
number = 533,
publisher = SV,
pages = "110--127",
year = 1991,
month = oct
}

@article{dwye73,
author = "B. Dwyer",
title = "Simple Algorithms for Traversing a Tree without an Auxiliary Stack",
journal = "Inf Process. Lett.",
volume = 2,
number = 5,
month = dec,
year = 1973,
pages = "143--145",
comment = {algorithm for traversing trees without a stack or mark bits},
}

@inproceedings{dybv93,
  title =	 "Guardians in a Generation-Based Garbage Collector",
  author =	 "R. Kent Dybvig and Carl Bruggeman and David Eby",
  crossref =	 "PLDI93",
  pages =	 "207--216",
  doi =		 {10.1145/155090.155110},
  URL =
                  "ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/guardians/ps.gz"
}

@techreport{dybv94,
title = "Don't Stop the {BIBOP}: Flexible and Efficient Storage Management for Dynamically-Typed Languages",
author = "R. Kent Dybvig and David Eby and Carl Bruggeman",
institution = "Indiana University Computer Science Department",
number = 400,
month = mar,
year = 1994,
URL = "ftp://ftp.cs.indiana.edu/pub/techreports/TR400.ps.Z"
}

@inproceedings{dyks02,
author = {L. Dykstra and Witiwas Srisa-an and J. Morris Chang},
title = {An Analysis of the Garbage Collector Performance in {S}un's {H}ot{S}pot
{JVM}},
booktitle = {21st {IEEE} International Performance
Computing and Communications Conference ({IPCCC})},
address = {Phoenix, AZ},
pages = {335--339},
year = 2002,
month = apr
}

@article{ecka87,
title = "Distributed Garbage Collection",
author = "J. Dana Eckart and Richard J. Leblanc",
address = "Georgia Inst Technol, Atlanta, Ga, 30332",
journal = Sigplan,
publisher = ACM,
year = 1987,
volume = 22,
number = 7,
pages = "264--273",
}

@phdthesis{ecka87a,
author = "Eckart, J. Dana",
title = "Garbage Collection for Functional Languages in a Distributed
System",
year = 1987,
school = "Georgia Institute of Technology, 1988"
}

@masterstheSis{edel90,
author = "Daniel R. Edelson",
title = "Dynamic Storage Reclamation in {C++}",
school = UCSC,
volume = "UCSC--CRL--90--19",
month = Jun,
year = 1990,
}

@inproceedings{edel90a,
author = "Daniel R. Edelson and Ira Pohl",
title = "The Case for Garbage Collection in {C++}",
crossref = "OOPSLA90-gc",
note = "Also " # UCSC # " technical report
UCSC-CRL-90-37",
abstract = "C++ is an object-oriented imperative programming
language that provides low-level access to the machine and
efficient run- time code.  C++ provides access to dynamically
allocated storage in a way that allows class designers to create
customized memory allocators and deallocators.  Unlike Eiffel and
Modula-3, C++ does not provide garbage collection.  The benefits
of garbage collection are substantial: rapid-prototyping and
runtime efficiency.  However, it has not been clear that garbage
collection could be provided for C++ in a way that is consistent
with the language's design goals.  We argue that garbage
collection should be an option for C++ programmers.
We cite an implementation that demonstrates that it can be
provided in a way that is consistent with the C++ design goals
and philosophy."
}

@inproceedings{edel91,
author = "Daniel R. Edelson and Ira Pohl",
title = "A Copying Collector for {C++}",
booktitle = "Usenix {C++} Conference",
publisher = UA,
editor = "",
pages = "85--102",
year = 1991,
}

@inproceedings{edel92,
title = "A Mark-and-Sweep Collector for {C++}",
author = "Daniel R. Edelson",
address = UCSC,
crossref = "POPL92",
}

@inproceedings{edel92a,
title = "Precompiling {C++} for Garbage Collection",
author = "Daniel  R. Edelson",
crossref = "IWMM92",
pages = {299--314},
doi = {10.1007/BFb0017197},
URL = "http://www-sor.inria.fr/SOR/docs/PC++GC_iwmm92.html",
}

@inproceedings{edel92b,
author = "Daniel R. Edelson",
title = "Smart Pointers: They're Smart, but They're Not Pointers",
booktitle = "USENIX C++ Conference",
address = {Portland, OR},
month = aug,
publisher = "USENIX",
URL = "http://www-sor.inria.fr/SOR/docs/SPC++_usenixC++92.html",
year = 1992
}

@techreport{edel93,
author = "Daniel R. Edelson",
title = "Comparing Two Garbage Collectors for {C++}",
institution = UCSC,
number = "UCSC-CRL-93-20",
year = 1993,
month = jan,
URL = {ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-93-20.ps.Z}
}

@phdthesis{edel93a,
author = "Daniel Ross Edelson",
school = UCSC,
title = "Type-Specific Storage Management",
number = "UCSC-CRL-93-26",
year = 1993,
month = may,
}

@techreport{edwa,
title = {{Lisp} {II} Garbage Collector},
author = {Daniel J. Edwards},
institution = MITAI,
type = {AI Memo},
pages = 2,
year = {Date unknown},
number = 19,
URL = {ftp://publications.ai.mit.edu/ai-publications/0-499/AIM-019.ps},
}

@inproceedings{effi06,
title = {Garbage Collection for Trailer Arrays},
author = {Laura Effinger-Dean and Chris Erickson and Melissa O Neill and Darren
Strash},
pages = {83--90},
crossref = {SPACE06}
}

@inproceedings{effi06a,
title = {Extending Garbage Collection to Complex Data Structures},
author = {Laura Effinger-Dean and Chris Erickson and Melissa O Neill and Darren
Strash},
pages = {91--97},
crossref = {SPACE06}
}

@article{egud92,
author = "Egudo, R.",
title = "An Analysis of a Garbage Collection Operation",
journal = "International journal of mathematical education in science and technology",
volume = 23,
number = 1,
pages = "89-96",
month = Jan,
year = 1992
}

@article{ehn89,
title = "A Contribution to the Increase of Efficiency of On-The-Fly Garbage Collection",
author = "L. Ehn",
address = "Slovak Hydrometeoroly Inst., Department of Minicomputer Operating Systems,
Jeseniova 17,  CS--83315 Bratislava, Czechoslovakia",
journal = "Computers And Artificial Intelligence",
year = 1989,
volume = 8,
number = 1,
pages = "83--91",
abstract = {LISP interpreters consist of two processes, the mutator and the
garbage collector.  Their actions are performed on the common memory, which
contains LISP cells.  A new, more efficient operation design of the mutator and
on-the-fly garbage collector is presented.  The Dijkstra model of three colour
garbage collection system is used.  The result of this is the decrease of a
number of marked garbage cells produced by the mutator.}
}

@article{ehn89a,
title = "Performance Analysis of On-The-Fly Garbage Collection Systems",
author = "L. Ehn",
address = "Slovak Hydrometeoroly Inst., Jeseniova 17, CS--83315 Bratislava,
Czechoslovakia",
journal = "Computers And Artificial Intelligence",
year = 1989,
volume = 8,
number = 2,
pages = "141--152"
}

@inproceedings{elha90,
author = "El-Habbash, Ahmed and Chris Horn and Neville Harris",
title = "Garbage Collection in an Object Oriented, Distributed, Persistent Environment",
crossref = "OOPSLA90-gc",
}

@article{elli88a,
author = "C. S. Ellis and T. J. Olson",
title = "Algorithms for Parallel Memory Allocation",
journal = "International Journal of Parallel Programming",
volume = 17,
number = 4,
year = 1988,
pages = "303--345"
}

@techreport{elli88,
title = "Real-Time Concurrent Collection on Stock Multiprocessors",
author = "John R. Ellis and Kai Li and Andrew W. Appel",
number = "DEC--SRC--TR--25",
institution = DECSRC,
month = feb,
year = 1988
}

@inproceedings{elli93,
author = "John R. Ellis",
title = "Put Up or Shut Up",
crossref = "OOPSLA93-gc",
}

@techreport{elli93a,
author = "John R. Ellis and David L. Detlefs",
title = "Safe, Efficient Garbage Collection for {C++}",
institution = PARC,
year = 1993,
URL = "ftp://ftp.digital.com/pub/DEC/SRC/research-reports/SRC-102.ps.Z"
}

@inproceedings{elli95,
  author =	 "John R. Ellis",
  title =	 "Tutorial: Is Safe {C++} an Oxymoron?",
  crossref =	 {PLDI95}
}

@book{ARM,
author = "Margaret A. Ellis and Bjarne Stroustrup",
title = "The Annotated {C++} Reference Manual",
publisher = AW,
year = 1990
}

@techreport{elsm95,
author = {Martin Elsman and Niels Hallenberg},
title = {An Optimizing Back-end for the {ML} {K}it Using a Stack of Regions},
type = {Student Project},
number = {95--7--8},
institution = DIKU,
month = jul,
year = 1995
}

@inproceedings{elsm03,
  author =	 {Martin Elsman},
  title =	 {Garbage Collection Safety for Region-based Memory
                  Management},
  crossref =	 {TLDI03},
  pages =	 {123--134},
  doi =		 {10.1145/604174.604190}
}

@inproceedings{elsm01,
author = {Martin Elsman},
title = {A Stack Machine for Region Based Programs},
crossref = {SPACE01},
}

@book{elso75,
author = "M. Elson",
title = "Data Structures",
publisher = "Science Research Associates",
year = 1975,
comment = {book with sections on garbage collection},
}

@manual{emacs98,
title = {{GNU} {E}macs {L}isp Reference Manual},
author = {Bill Lewis and Dan LaLiberte and Richard Stallman and the {GNU} Manual Group},
month = may,
year = 1998,
organization = {{GNU} Project},
URL = {http://www.gnu.org/manual/elisp-manual-20-2.5/html_node/elisp_661.html}
}

@inproceedings{endo97,
author = "Toshio Endo and Kenjiro Taura and Akinori Yonezawa",
title = "A Scalable Mark-Sweep Garbage Collector on Large-Scale Shared-Memory Machines",
booktitle = "ACM/IEEE Conference on Supercomputing",
year = 1997,
address = {San Jose, CA},
month = nov,
doi = {10.1109/SC.1997.10059}
}

@mastersthesis{endo98,
author = "Toshio Endo",
title = "A Scalable Mark-Sweep Garbage Collector on Large-Scale Shared-Memory Machines",
school = {University of Tokyo},
year = 1998,
month = feb,
URL={http://ftp.yl.is.s.u-tokyo.ac.jp/pub/papers/endo-mthesis-a4.ps.gz}
}

@phdthesis{endo01,
author = "Toshio Endo",
title = "Scalable Dynamic Memory Management Module on Shared Memory Multiprocessors",
school = {University of Tokyo},
year = 2001,
month = sep,
}

@inproceedings{endo02,
title = {Reducing Pause Time of Conservative Collectors},
author = {Toshio Endo and Kenjiro Taura and Akinori Yonezawa},
crossref = {ISMM02},
pages = {12--24},
doi = {10.1145/512429.512432}
}

@inproceedings{enge91,
author = "Steven L. Engelstad and James E. Vandendorpe",
title = "Automatic Storage Management for Systems with Real Time Constraints",
crossref = "OOPSLA91-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/engelstad.ps",
}

@inproceedings{eran13,
author = {H. Eran and E. Petrank},
title = {A Study of Data Structures with a Deep Heap Shape},
pages = {21–-28},
doi = {10.1145/2492408.2492413},
crossref = {MSPC13},
abstract = {Computing environments become increasingly parallel, and it seems
likely that we will see more cores on tomorrow's desktops and server platforms.
In a highly parallel system, tracing garbage collectors may not scale well due
to deep heap structures that hinder parallel tracing. Previous work has
discovered vulnerabilities within standard Java benchmarks. In this work we
examine these standard benchmarks and analyze them to expose the data structures
that make current Java benchmarks create deep heap shapes. It turns out that the
problem is manifested mostly with benchmarks that employ queues and
linked-lists. We then propose a new construction of a lock-free queue data
structure with extra references that enables better garbage collector
parallelism at a low overhead.}
}

@article{ersh58,
  author =	 "A. P. Ershov",
  title =	 "On programming of arithmetic operations",
  journal =	 CACM,
  year =	 1958,
  volume =	 1,
  number =	 8,
  pages =	 "3--6",
  month =	 aug,
  doi =		 {10.1145/368892.368907},
  annote =	 "Describes a technique later called hash-consing, for sharing
                  subtrees of arithmetic expressions. CACM printed a
                  translation of the original article from a Russian journal."
}

@inproceedings{etie04,
author = {Lozes Etienne},
title = {Separation Logic Preserves the Expressive Power of Classical Logic},
crossref = {SPACE04},
}

@inproceedings{evan96,
  author =	 "David Evans",
  title =	 "Static Detection of Dynamic Memory Errors",
  crossref =	 "PLDI96",
  pages =	 "44--53",
  doi =		 {10.1145/231379.231389}
}

@inproceedings{evan97,
author = {Huw Evans and Peter Dickman },
title = {Garbage Collection and Memory Management},
crossref = {OOPSLA97},
pages = {138-143},
note = {Addendum to proceedings}
}

@article{even81,
title = "An On-Line Edge-Deletion Problem",
author = "Shimon Even and Yossi Shiloach",
journal = jacm,
publisher = ACM,
volume = 28,
number = 1,
month = jan,
year = 1981,
pages = "1--4"
}

@inproceedings{fabr79,
  author =	 "Janet Fabri",
  title =	 "Automatic Storage Optimization",
  crossref =	 "PLDI79",
  pages =	 "83--91",
  doi =		 {10.1145/800229.806957}
}

@inproceedings{faes05,
author= {Faes, Philippe and  Christiaens, Mark and  Buytaert, Dries and  Stroobandt, Dirk},
title= {{FPGA}-Aware Garbage Collection in {J}ava},
booktitle= {2005 International Conference on Field Programmable Logic and Applications (FPL)},
year= 2005,
month= 1,
pages= {675--680},
editor= {Rissa, T. and   Wilton, S. and  Leong, P.},
publisher= {IEEE},
address= {Tampere, Finland},
abstract = {During codesign of a system, one still runs into the impedance
mismatch between the software and hardware worlds. This paper identifies the
different levels of abstraction of hardware and software as a major culprit of
this mismatch. For example, when programming in high-level object-oriented
languages like Java, one has disposal of objects, methods, memory management,
... that facilitates development but these have to be largely abandoned when
moving the same functionality into hardware.},
URL = {http://escher.elis.UGent.be/publ/Edocs/DOC/P105_110.pdf}
}

@incollection{falc83,
author = "J. R. Falcone and J. R. Stinger",
title = "The  {S}malltalk-80 Implementation at {H}ewlett--{P}ackard",
crossref = "Smalltalk-BHWA",
pages = "79--112",
}

@inproceedings{fark00,
author = {Keith I. Farkas and Jason Flinn and Godmar Back and Dirk Grunwald and Jennifer Anderson},
title = {Quantifying the Energy consumption of a Pocket Computer and a {J}ava Virtual Machine},
booktitle = SIGMETRICS,
year = 2000
}

@inproceedings{farr91,
author = "Matthew Farrens and Arvin Park",
title = "Dynamic Base Register Caching:  A Technique for Reducing Address Bus Width",
crossref = {ISCA91},
pages = "128--137"
}

@inproceedings{feel90,
author = "Feeley, Marc and James S. Miller",
title = "A Parallel Virtual Machine for Efficient {S}cheme Compilation",
crossref = "LFP90",
pages = "119--130"      }

@inproceedings{feel93,
author = {Marc Feeley},
title = {Polling Efficiently on Stock Hardware},
crossref = {FPCA93},
pages = {179--187},
URL = {http://www.iro.umontreal.ca/~feeley/papers/polling.ps.gz}
}

@inproceedings{feiz05,
title = {Java Garbage Collection Scheduling in Utility Accrual Scheduling Environments},
author = {Shahrooz Feizabadi and Godmar Back},
crossref = {JTRES05},
URL = {http://people.cs.vt.edu/~gback/papers/jtres2005-cadus.pdf}
}

@article{feiz07,
  title =	 {Garbage Collection-Aware Sheduling Utility Accrual
                  Scheduling Environments},
  author =	 {Shahrooz Feizabadi and Godmar Back},
  journal =	 {Real-Time Systems},
  volume =	 36,
  number =	 {1--2},
  month =	 jul,
  year =	 2007,
  publisher =	 {Kluwer Academic Publishers},
  doi =		 {10.1007/s11241-007-9020-7}
}


@article{feni69,
author = "Robert R. Fenichel and Jerome C. Yochelson",
title = "A {L}isp Garbage Collector for Virtual Memory Computer Systems",
journal = CACM,
publisher = ACM,
volume = 12,
number = 11,
month = nov,
year = 1969,
pages = "611--612",
doi={10.1145/363269.363280},
comment = {The original copying (2 semi-space) garbage collector.
A variant of Minsky's 1963 algorithm (mins63).  }
}

@article{feni71,
author = "Robert R. Fenichel",
title = "List Tracing in Systems Allowing Multiple Cell Types",
journal = CACM,
volume = 14,
number = 8,
month = aug,
publisher = ACM,
year = 1971,
pages = "522--526",
}

@article{feni71a,
author = "Robert R. Fenichel",
title = "Comment on Cheney's List-Compaction Algorithm",
journal = CACM,
publisher = ACM,
volume = 14,
number = 9,
month = sep,
year = 1971,
pages = "603--604"
}

@inproceedings{fent74,
author = "J. S. Fenton and D. W. Payne",
title = "Dynamic Storage Allocation of Arbitrary Sized Segments",
booktitle = "Proceedings of IFIPS",
year = 1974,
pages = "344--348"
}

@article{ferg76,
author = "H. R. P. Ferguson",
title = "On a Generalization of the {F}ibonacci Numbers useful in Memory Allocation Schema",
journal = "The Fibonacci Quarterly",
volume = 14,
number = 3,
month = oct,
year = 1976,
pages = "233--243"
}

@article{fern92,
author = "Fernandez, Mary F. and Hanson, David R.",
address = "Princeton Univ, Princeton, NJ",
title = "Garbage Collection Alternatives for {I}con",
year = 1992,
journal = SPE,
publisher = Wiley,
volume = 22,
number = 8,
month = aug,
pages = "659--672",
abstract = {Copying garbage collectors are becoming the collectors of
choice for very high-level languages and for functional and
object-oriented languages. Copying collectors are
particularly efficient for large storage regions because
their execution time is proportional only to the amount of
accessible data, and they identify and compact this data in
one pass. In contrast, mark-and-sweep collectors execute in
time proportional to the memory size and compacting
collectors require another pass to compact accessible data.
The performance of existing systems with old compacting mark-
and-sweep collectors might be improved by replacing their
collectors with copying collectors. This paper explores this
possibility by describing the results of replacing the
compacting mark-and-sweep collector in the Icon programming
language with four alternative collectors, three of which
are copying collectors. Copying collectors do indeed run
faster than the original collector, but at a significant
cost in space. An improved variant of the compacting mark-
and-sweep collector ran even faster and used little
additional space. (Author abstract)}
}

@article{ferr74,
author = "Domenico Ferrari",
title = "Improving Locality by Critical Working Sets",
journal = CACM,
volume = 17,
number = 11,
month = nov,
pages = "614--620",
publisher = ACM,
year = 1974,
abstract = {A new approach to program locality improvement via
restructuring is described. The method is particularly
suited to those systems where primary memory is managed
according to a working set strategy. It is based on the
concept of critical working set, a working set which
does not contain the next memory reference. The data
the method operates upon are extracted from a trace of
the program to be restructured. It is shown that,
except in some special cases, the method is not
optimum. However, the experimental results obtained by
using the method to restructure an interactive text
editor and the file system module of an operating
system have shown its substantial superiority over the
other methods proposed in the literature.},
}

@inproceedings{ferr90,
author = "Paulo Ferreira",
title = "Storage Reclamation",
crossref = "OOPSLA90-gc",
}

@inproceedings{ferr91,
author = "Paulo Ferreira",
title = "Garbage Collection in {C++}",
crossref = "OOPSLA91-gc",
}

@inproceedings{ferr91a,
author = "Paulo Ferreira",
title = "Reclaiming Storage in an Object-Oriented Platform Supporting
Extended {C++} and {O}bjective-{C} Applications",
crossref = "IWOOOS91",
URL = {http://cretina.inesc.pt/people/pjpf-home/iwooos91.ps}
}

@inproceedings{ferr91b,
author = "Paulo Ferreira",
title = "Garbage Collection in {C++}",
booktitle = {Workshop on Extensions to {C++}},
address = {Lisbon},
month = jun,
year = 1991
}

@mastersthesis{ferr92,
author = "Paulo Ferreira",
title = {Reciclagem Autom\'{a}tica de Mem\'{o}ria num Sistema Orientado a Objectos},
school = {Technical University of Lisbon},
month = jun,
year = 1992,
URL = {http://cretina.inesc.pt/people/pjpf-home/master.ps}
}

@inproceedings{ferr94,
author = "Paulo Ferreira and Marc Shapiro",
title = "Garbage Collection and {DSM} Consistency",
month = nov,
year = 1994,
booktitle = "1st Symposium on Operating Systems Design and Implementation",
address = "Monterey, CA",
pages = "229--241",
publisher = ACM,
URL = "http://www-sor.inria.fr/SOR/docs/GC-DSM-CONSIS_OSDI94.html",
abstract = {This paper presents the design of a copying garbage
collector for persistent distributed shared objects in a loosely
coupled network with weakly consistent distributed shared memory
(DSM).
The main goal of the design for this garbage collector is to minimize
the communication overhead due to collection between nodes of the
system, and to avoid any interference with the DSM memory consistency
protocol.
Our design is based on the observation that, in a weakly consistent DSM
system, the memory consistency requirements of the garbage collector
are less strict than those of the applications. Thus, the garbage
collector reclaims objects independently of other copies of the same
objects without interfering with the DSM consistency protocol.
Furthermore, our design does not require reliable communication
support, and is capable of reclaiming distributed cycles of dead
objects.}
}

@inproceedings{ferr94a,
author = "Paulo Ferreira and Marc Shapiro",
title = "Garbage Collection of Persistent Objects in Distributed Shared Memory",
pages = "176--191",
crossref = "POS94",
URL = "http://www-sor.inria.fr/SOR/docs/GC-PERS-DSM_POS94.html",
abstract = {This paper describes a garbage collection algorithm for
distributed persistent objects in a loosely coupled network of
workstations. Objects are accessed via a weakly consistent shared
distributed virtual memory with recoverable properties. We address the
specific problem of garbage collecting a large amount of distributed
persistent objects, cached on several nodes for efficient sharing.
For clustering purposes, objects are allocated within segments, and
segments are logically grouped into bunches . The garbage collection
subsystem combines three sub-algorithms: the bunches garbage collector
that cleans one bunch (possibly multiply-cached) independently of any
other, the scion cleaner that propagates accessibility information
across bunches, and the group collector aimed at reclaiming inter-bunch
cycles of dead objects.
These three sub-algorithms are highly independent. Thus, the garbage
collection subsystem has a high degree of scalability and parallelism.
On top of this, it reclaims cycles of garbage, it does not require any
particular communication support such as causality or atomicity, and is
well suited to large scale networks.}
}

@inproceedings{ferr94b,
author = {Paulo Ferreira and Marc Shapiro},
title = {Distributed Shared Memory Consistency and Garbage Collection},
booktitle = {Workshop {I}nter-{PRS}},
address = {Paris},
month = dec,
year = 1994
}

@inproceedings{ferr94c,
author = {Paulo Ferreira and Marc Shapiro},
title = {Garbage Collection of Persistent Objects in Distributed Shared Memory},
booktitle = {Workshop {F}ranco-{I}sralienne},
address = {St Malo, France},
month = sep,
year = 1994
}

@inproceedings{ferr95,
author = "Paulo Ferreira and Marc Shapiro",
title = "Garbage Collection in the {L}archant Persistent Distributed Shared Store",
booktitle = "5th Workshop on Future Trends in Distributed Computing Systems",
month = aug,
year = 1995,
address = "Cheju Island, Korea",
URL = "http://www-sor.inria.fr/SOR/docs/GCLPDSS_ftdcs95.html"
}

@unpublished{ferr96,
author = "Paulo Ferreira and Marc Shapiro",
title = "Asynchronous Distributed Garbage Collection in the {L}archant Cached Shared Store",
month = may,
year = 1996,
note = "Available from Marc Shapiro"
}

@inproceedings{ferr96a,
author = "Paulo Ferreira and Marc Shapiro",
title = "Larchant: Persistence by Reachability in Distributed Shared Memory through Garbage Collection",
booktitle = "16th International Conference on Distributed Computer Systems",
address = "Hong Kong",
month = may,
year = 1996,
URL = "http://www-sor.inria.fr/SOR/docs/LPRDSMGC_icdcs96.html"
}

@phdthesis{ferr96b,
title = "Larchant: garbage collection in a cached distributed
shared store with persistence by reachability",
author = "Paulo Ferreira",
month = may,
year = 1996,
school = {Universit\'{e} Paris VI, Pierre et Marie Curie},
URL = "http://www-sor.inria.fr/publi/summaries/1996/ferreira_thesis96.html",
abstract = "The model of Larchant is that of a Shared Address Space
(spanning every site in a network including secondary storage) with
Persistence By Reachability. To provide the illusion of a shared
address space across the network, despite the fact that site memories
are disjoint, Larchant implements a distributed shared memory
mechanism. Reachability is accessed by tracing the pointer graph,
starting from the persistent root, and reclaiming unreachable objects.
This is the task of Garbage Collection (GC).
GC was until recently thought to be intractable in a large-scale
system, due to problems of scale, incoherence, asynchrony, and
performance. This thesis presents the solutions that Larchant proposes
to these problems.
The GC algorithm in Larchant combines tracing and reference-listing. It
traces whenever economically feasible, i.e., as long as the memory
subset being collected remains local to a site, and counts references
that would cost I/O traffic to trace. GC is orthogonal to coherence,
i.e., makes progress even if only incoherent replicas are locally
available. The garbage collector runs concurrently and asynchronously
to applications.  The reference-listing boundary changes dynamically
and seamlessly, and independently at each site, in order to collect
cycles of unreachable objects.
We prove formally that our GC algorithm is correct, i.e., it is safe
and live. The performance results from our Larchant prototype show that
our design goals (scalability, coherence orthogonality, and good
performance) are fulfilled."
}

@inproceedings{ferr98,
author = {Paulo Ferreira and Marc Shapiro},
title = {Modelling a Distributed Cached Store for Garbage Collection: the
Algorithm and its Correctness Proof},
crossref = {ECOOP98},
URL = {http://cretina.inesc.pt/people/pjpf-home/ecoop98.ps}
}

@techreport{ferr98a,
author = {Paulo Ferreira and Marc Shapiro and Xavier Blondel and Olivier
Fambon and Jo\~{a}o Garcia and Sytse Kloosterman and Nicolas Richer and
Marcus Roberts and Fadi Sandakly and George Colouris and Jean Dollimore
and Paulo Guedes and Daniel Hagimont and Sacha Krakowiak},
title = {{PerDiS}: Design, Implementation and Use of a {PER}sistent
{DI}stributed {S}tore},
number = {QMW TR 752, CSTB ILC/98-1392, INRIA RR 3525, INESC RT/5/98},
institution = {QMW, CSTB INRIA and INESC},
month = oct,
year = 1998,
URL = {http://www-sor.inria.fr/publi/PDIUPDS_rr3525.html}
}

@inproceedings{ferr00,
author = {Paulo Ferreira and Marc Shapiro and Xavier Blondel and Olivier
Fambon and Jo\~{a}o Garcia and Sytse Kloosterman and Nicolas Richer and
Marcus Roberts and Fadi Sandakly and George Colouris and Jean Dollimore
and Paulo Guedes and Daniel Hagimont and Sacha Krakowiak},
title = {{PerDiS}: Design, Implementation and Use of a {PER}sistent
{DI}stributed {S}tore},
pages = {427--452},
URL = {http://link.springer.de/link/service/series/0558/papers/1752/17520427.pdf},
crossref = {krak00}
}

@article{ferr03a,
title = {{OBIWAN}: Design and Implementation of a Middleware Platform},
author = {Paulo Ferreira and Luis Veiga and Carlos Ribeiro},
journal ={IEEE Transactions on Parallel and Distributed Systems},
month = nov,
year = 2003,
volume = 14,
number = 11,
pages = {1086--1099},
URL = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1247670}
}

@misc{ferr05,
author = {Paulo Ferreira and Luis Veiga},
title = {Garbage Collection Curriculum},
howpublished= {MSDN Academic Alliance Curriculum Repository, object ID 6812},
publisher = {Microsoft},
month = jul,
year = 2005
}

@incollection{ferr06,
title = {Mobile Middleware -- Seamless Service Access via Resource Replication},
author = {Paulo Ferreira and Luis Veiga},
booktitle = {The Handbook of Mobile Middleware},
editor = {Paolo Bellavista and Antonio Corradi},
publisher = {Auerbach Publications, Taylor and Francis-CRC Press},
month = oct,
year = 2006
}


@inproceedings{fess97,
author = {Le Fessant, Fabrice and Ian Piumarta and Marc Shapiro},
title = {A Detection Algorithm for Distributed Cycles of Garbage},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/piumarta.ps},
crossref = {OOPSLA97-gc}
}

@inproceedings{fess98,
  author =	 "Le Fessant, Fabrice and Ian Piumarta and Marc Shapiro",
  title =	 "An Implementation for Complete, Asynchronous, Distributed,
                  Garbage Collection",
  crossref =	 {PLDI98},
  pages =	 {152--161},
  doi =		 {10.1145/277650.277715},
  URL =		 "http://www-sor.inria.fr/publi/ICADGC_pldi98.html",
  abstract =	 {We expand an acyclic distributed garbage collector (the
                  cleanup protocol of Stub-Scion Pair Chains) with a detector
                  of distributed cycles of garbage. The whole result is as a
                  complete and asynchronous distributed garbage collector.
                  The detection algorithm for free distributed cycles is
                  inspired by Hughes. A local collector marks outgoing
                  references with dates, which are propagated asynchronously
                  between spaces. A central server computes the minimum of
                  allowed dates, permitting cycles to be detected and cut.
                  Our algorithm is both asynchronous and
                  fault-tolerant. Moreover, it can be adapted to large-scale
                  systems.  Finally, it requires few resources and it is easy
                  to implement.}
}

@misc{fess99,
title = {Detection of Free Distributed Cycles in  Large-Scale Networks},
author = {Le Fessant, Fabrice},
month = jan,
year = 1999,
url = {http://beaune.inria.fr:1976/files/00040.ps.gz}
}

@inproceedings{fess01,
title = {Detecting Distributed Cycles of Garbage in  Large-Scale Systems},
author = {Le Fessant, Fabrice},
booktitle = {Principles of Distributed Computing (PODC)},
address = {Rhodes Island},
month = aug,
year = 2001,
URL = {http://pauillac.inria.fr/~lefessan/papers/podc2001.ps.gz}
}

@book{fiel88,
author = "Anthony J. Field and Peter G. Harrison",
title = "Functional Programming",
publisher = AW,
year = "1988",
comment = "Chapter 16 looks at garbage collection algorithms"
}

@inproceedings{fink03,
author = {Stephen J. Fink and Feng Qian},
title = {Design, Implementation and Evaluation of Adaptive Recompilation
         with On-Stack Replacement},
pages = {241--252},
doi = {10.1109/CGO.2003.1191549},
crossref = {CGO03}
}

@article{fish74,
author = "David A. Fisher",
title = "Bounded Workspace Garbage Collection in an Address Order Preserving List Processing Environment",
journal = IPL,
publisher = NH,
volume = 3,
number = 1,
month = Jul,
year = 1974,
pages = "29--32",
doi={10.1016/0020-0190(74)90044-1}
}

@article{fish75,
author = "David A. Fisher",
title = "Copying Cyclic List Structure in Linear Time Using Bounded Workspace",
journal = CACM,
publisher = ACM,
volume = 18,
number = 5,
month = may,
year = 1975,
pages = "251--252",
comment = {algorithm for copying trees and general lists without using
a stack or mark bits.
It differs from the moving algorithms in that the altered contents of old lists
are later restored to their original values.},
}

@article{fitc78,
author = "John P. Fitch and Arthur C. Norman",
title = "A Note on Compacting Garbage Collection",
journal = CompJ,
publisher = BCS,
volume = 21,
number = 1,
month = Feb,
year = 1978,
pages = "31--34",
}

@inproceedings{fitz00,
author = {Robert Fitzgerald and David Tarditi},
title = {The Case for Profile-Directed Selection of Garbage Collectors},
pages = {111--120},
crossref = {ISMM2000},
doi={10.1145/362422.362472},
abstract = {
Many garbage-collected systems use a single garbage collection
algorithm across all applications. It has long been known that this can
produce poor performance on applications for which that collector is
not well suited. In some systems, such as those that execute
stand-alone compiled executables, an appropriate collector for each
application can be selected from a pool of available collectors and
tuned by using profile information. In a study of 20 benchmarks and 6
collectors compiled with the Marmot optimizing Java-to-native compiler,
for every collector there was at least one benchmark that would have
been at least 15\% faster with a more appropriate collector. A detailed
analysis of storage management costs shows how they vary by application
and collector.
}
}

@inproceedings{flan96,
title = {\textit{p{H}luid}: the Design of a Parallel Functional Language Implementation on Workstations},
author = {Cormac Flanagan and Rishiyur S. Nikhil},
pages = {169--179},
crossref = {ICFP96}
}

@inproceedings{flei89,
author = "B. D. Fleisch",
title = "Mirage: A Coherent Distributed Shared Memory Design",
booktitle = "12th " # SOSP,
publisher = ACM,
pages = "211--213",
month = Dec,
year = 1989
}

@inproceedings{floo01,
author = {Christine Flood and Dave Detlefs and Nir Shavit and Catherine Zhang},
title = {Parallel Garbage Collection for Shared Memory Multiprocessors},
crossref = {JVM01},
URL = {http://www.usenix.org/events/jvm01/flood.html}
}

@inproceedings{flue04,
author = {Matthew Fluet},
title = {Monadic Regions},
crossref = {SPACE04},
}

@inproceedings{flue04a,
author = {Matthew Fluet and Daniel Wang},
title = {Implementation and Performance Evaluation of a Safe Runtime System in {C}yclone},
crossref = {SPACE04},
}

@inproceedings{flue08,
author = {Matthew Fluet and Mike Rainey and John Reppy and Adam Shaw},
title = {Implicitly-Threaded Parallelism in {M}anticore},
crossref = {ICFP08},
pages = {119--130}
}

@inproceedings{fode81,
author = "John K. Foderaro and Richard J. Fateman",
title = "Characterization of {VAX} {M}acsyma",
booktitle = "1981 {ACM} Symposium on Symbolic and Algebraic Computation",
address ="Berkeley, CA",
year = 1981,
pages = "14--19",
publisher = ACM,
doi={10.1145/800206.806364},
comment = {By the early 1980s Lisp programs spending 25--40 percent of their time marking and
sweeping, and users were waiting an average of 4.5s every 79s.}
}

@manual{fode85,
author = "John K. Foderaro and Keith Sklower and Kevin Layer and others",
title = "Franz {L}isp Reference Manual",
organization = "Franz Inc.",
year = 1985
}

@article{ford88,
author = "R. Ford",
title = "Concurrent Algorithms for Real-Time Memory Management",
journal = "IEEE Software",
publisher = IEEE,
month = sep,
year = 1988,
pages = "10--23"
}

@inproceedings{fori89,
author = "A. Forin and J. Barrera and M. Young and R. Rashid",
title = "Design, Implementation, and Performance Evaluation
of a Distributed Shared Memory Server for {Mach}",
booktitle = "Winter USENIX Conference",
publisher = UA,
month = Jan,
year = 1989
}

@techreport{fost88,
author = "Ian Foster",
title = "An Asynchronous Parallel Garbage Collector for a Single-Assignment Language",
institution = "Imperial College, London",
month = may,
year = 1988
}

@article{fost89,
title = "A Multicomputer Garbage Collector for a Single-Assignment Language.",
author = "Ian Foster",
journal = "International Journal of Parallel Programming",
volume = 18,
number = 3,
pages = "181--203",
year = "1989",
abstract = {An asynchronous garbage collector for a message-passing
multiprocessor (multicomputer) is described.  This combines Weighted Reference
Counting (WRC) interprocessor collection and tracing intraprocessor collection
to permit individual processors to reclaim local storage independently.  A
novel feature is the integration of Weighted Reference Counting collection and
the communication algorithms required to support a global address space in a
single assignment language.  This significantly reduces communication overhead
and space requirements attributable to garbage collection.  In addition,
techniques are described that avoid the creation of cyclic structures that
cannot be reclaimed using WRC.  Experimental studies performed in a concurrent
logic programming system that incorporates the collector confirm its efficiency
and the benefits of integrating garbage collector and language
implementation.}
}

@techreport{fost89a,
author = "Ian Foster",
title = "Copy Avoidance through Local Reuse",
institution = "Argonne National Laboratory",
number = "MCS--P99--0989",
year = 1989
}

@inproceedings{fost91,
author = "Ian Foster and William Winsborough",
title = "Copy Avoidance through Compile-Time Analysis and Local Reuse",
booktitle = "International Logic Programming Symposium",
pages = "455--469",
year = 1991
}

@book{fost68,
author = "J. M. Foster",
title = "List Processing",
series = "Elsevier Computer Monographs",
publisher = ENH,
address = "New York",
year = 1968,
comment = {book with sections on garbage collection},
}

@mastersthesis{fost85,
author = "Foster, Mark H.",
title = "Design of a List-Structure Memory Using Parallel Garbage
Collection",
year = 1985,
school = "Oregon Graduate Center"
}

@article{foth,
author = "J. A. Fotheringham",
title = "Dynamic Storage Allocation in the {A}tlas Computer Including an Automatic Use of the Backing Store",
journal = CACM,
publisher = ACM,
volume = 4,
pages = 435,
year = 1961
}

@inproceedings{frad94,
  author =	 "Pascal Fradet",
  title =	 "Collecting More Garbage",
  crossref =	 "LFP94",
  pages =	 "24--33",
  doi =		 {10.1145/182409.182417},
  comment =	 "ftp://ftp.irisa.fr/local/lande/pf-lisp94.ps.Z",
}

@techreport{fram03,
author = {Daniel Frampton},
title = {An Investigation into Automatic Dynamic Memory Management Strategies
using Compacting Collection},
type = {Honours thesis},
institution = {Australian National University},
year = 2003,
doi = {1885/39951}
}

@inproceedings{fram07,
title = {Generational Real-Time Garbage Collection: A Three-Part Invention
for Young Objects},
author = {Daniel Frampton and David F. Bacon and Perry Cheng and David Grove},
crossref = {ECOOP07},
pages = {101--125},
doi = {10.1007/978-3-540-73589-2_6}
}

@techreport{fram09,
author = {Daniel Frampton and Stephen M. Blackburn and Luke N. Quinane and John
N. Zigman},
title = {Efficient Concurrent Mark-Sweep Cycle Collection},
institution = {The Australian National University},
number = {TR-CS-09-02},
month = oct,
year = 2009,
URL = {http://cs.anu.edu.au/techreports/2009/TR-CS-09-02.pdf}
}

@inproceedings{fram09a,
author = {Frampton, Daniel and Blackburn, Stephen M. and Cheng, Perry and
Garner, Robin J. and
Grove, D. and Moss, J. Eliot B. and Salishev, S. I.},
title =  {Demystifying Magic: High-level Low-level Programming},
crossref ={VEE09},
pages = {81--90},
doi = {10.1145/1508293. 1508305}
}

@phdthesis{fram10,
author = {Daniel Frampton},
title = {Garbage Collection and the Case for High-level Low-level Programming},
school = {Australian National University},
month = jun,
year = 2010,
URL = {http://cs.anu.edu.au/people/Daniel.Frampton/DanielFrampton_Thesis_Jun2010.pdf}
}

@article{fran78,
author = "Nissim Francez",
title = "An Application of a Method for Analysis of Cyclic Programs",
journal = TransSWE,
publisher = ACM,
volume = 4,
number = 5,
month = Sep,
year = 1978,
pages = "371--377",
}

@article{fran80,
title = "Distributed Termination",
author = "Nissim Francez",
journal = TOPLAS,
publisher = ACM,
year = 1980,
month = jan,
volume = 2,
number = 1,
pages = "42--55",
}

@inproceedings{fran84,
title = "Generalized Fair Termination",
author = "Nissim Francez and Dexter Kozen",
crossref = "POPL84",
pages = "46--53",
}

@techreport{fran89,
title = {What's Different About Garbage Collection for Persistent Programming Languages},
author = {Michael Franklin and G. Copeland and G. Weikum},
institution = {Microelectronics and Computer Technology Corporation},
number = {ACA-ST-062-89},
pages = 11,
year = 1989,
abstract = {Work in garbage collection in the programming language
community dates back over twenty-five years to early work on list
processing languages. With the advent of persistent programming
languages and database systems which provide general purpose
programming capabilities, garbage collection issues are becoming more
relevant to designers of systems that manage persistent data. Although
much of the earlier work is applicable to persistent programming, there
are a number of new constraints that must be addressed in order to
provide efficient garbage collection for systems with large amounts of
persistent data. This paper describes these constraints and the
problems that they give rise to. It then proposes some techniques that
may lead toward a solution of these problems.}
}

@manual{fran88,
key = "Franz, 1988",
organization = "Franz Inc.",
title = "Allegro {CL} User Guide",
edition = "Release 3.0 (beta)",
month = apr,
year = 1988
}

@manual{fran92,
key = "Franz, 1992",
organization = "Franz Inc.",
title = "Allegro {CL} User Guide, Version 4.1",
edition = "Revision 2",
month = mar,
year = 1992
}

@article{frei75,
author = "W. F. Freiburger and U. Grenander and P. D. Sampson",
title = "Patterns in Program References",
journal = "IBM Journal of Research and Development",
volume = 19,
number = 3,
month = may,
year = 1975,
pages = "230--243"
}

@article{frie76,
author = "Daniel P. Friedman and David S. Wise",
title = "Garbage Collecting a Heap which included a Scatter Table",
journal = IPL,
publisher = NH,
volume = 5,
number = 6,
month = dec,
year = 1976,
pages = "161--164",
}

@article{frie77,
crossref = {wise77}
}

@article{frie78,
author = "Daniel P. Friedman and David S. Wise",
title = "Aspects of Applicative Programming for Parallel Processing",
journal = IEEETransComp,
publisher = IEEE,
volume = 27,
number = 4,
pages = "289--296",
month = Apr,
year = 1978
}

@article{frie79,
author = "Daniel P. Friedman and David S. Wise",
title = "Reference Counting Can Manage the Circular Environments of Mutual Recursion",
journal = IPL,
publisher = NH,
volume = 8,
number = 1,
month = jan,
year = 1979,
pages = "41--45",
doi={10.1016/0020-0190(79)90091-7}
}

@inproceedings{fu05,
author = {Wei Fu and Carl Hauser},
title = {A Real-Time Garbage Collection Framework for Embedded Systems},
booktitle = {Workshop on Software and Compilers for Embedded Systems},
address = {Dallas, TX},
year =2005,
pages = {20--26},
doi = {10.1145/1140389.1140392}
}

@inproceedings{fu07,
title = {Modeling Real-time Garbage Collection Cost},
author = {Wei Fu and Carl Hauser},
crossref = {RTCSA07},
URL = {http://www.eecs.wsu.edu/~hauser/Publications/WCET_RTSCA_IEEE.pdf}
}

@inproceedings{fuch95,
title = "Garbage Collection on an Open Network",
author = "Matthew Fuchs",
crossref = "IWMM95",
pages = {251--265},
doi = {10.1007/3-540-60368-9_27}
}

@inproceedings{furu91,
author = "Shinichi Furusou and Satoshi Matsuoka and Akinori Yonezawa",
title = "Parallel Conservative Garbage Collection with Fast Allocation",
crossref = "OOPSLA91-gc",
}

@inproceedings{gabr82,
author = "Richard P. Gabriel and L. M. Mansinter",
title = "Performance of {L}isp Systems",
crossref = "LFP82",
pages = "123--142",
}

@book{gabr85,
author = "Richard P. Gabriel",
title = "Performance and Evaluation of {Lisp} Systems",
series = "MIT Press Series in Computer Science",
publisher = "MIT Press",
address = "Cambridge, MA",
year = 1985
}

@article{gai85,
author = "S. Gai and M. Mezzalama",
title = "Dynamic Storage Allocation: Experiments Using the {C} Language",
journal = SPE,
publisher = Wiley,
volume = 15,
number = 7,
month = jul,
year = 1985,
pages = "693--704"
}

@mastersthesis{gane94,
author = "Ravichandran Ganesan",
title = "Local Variable Allocation for Accurate Garbage Collection of {C++}",
school = "Iowa State University",
month = jul,
year = 1994,
note = "Technical Report ISUTR 94--12",
URL = "http://www.cs.iastate.edu/tech-reports/TR94-12.ps"
}

@article{gann88,
author = "D. Gannon and W. Jalby and K. Gallivan",
title = "Strategies for Cache and Local Memory Management by Global Program Transformation",
journal = "Journal of Parallel and Distributed Computing",
volume = 5,
pages = "587--616",
year = 1988
}

@techreport{gao94,
author = "Hong Gao and Kelvin Nilsen",
title = "Reliable General Purpose Dynamic Memory Management for Real-Time Systems",
institution = "Iowa State University",
number = "TR94--09",
month = jul,
year = 1994,
URL = "http://www.cs.iastate.edu/tech-reports/TR94-09.ps",
comment = "Presents an overview of a hardware-assisted real-time (copying)
garbage collector for C++, comparing its average and worst-case performance
and heap utilization with several standard non-GC allocators."
}

@inproceedings{gao13,
author = {Gao, Tiejun and Strauss, Karin and Blackburn, Stephen M. and McKinley, Kathryn S. and Burger, Doug and Larus, James},
title = {Using Managed Runtime Systems to Tolerate Holes in Wearable Memories},
crossref = {PLDI13},
doi = {10.1145/2462156.2462171},
abstract = {New memory technologies, such as phase-change memory (PCM), promise
denser and cheaper main memory, and are expected to displace DRAM. However, many
of them experience permanent failures far more quickly than DRAM. DRAM
mechanisms that handle permanent failures rely on very low failure rates and, if
directly applied to PCM, are extremely inefficient: Discarding a page when the
first line fails wastes 98\% of the memory.
This paper proposes low complexity cooperative software and hardware that handle
failure rates as high as 50\%. Our approach makes error handling transparent to
the application by using the memory abstraction offered by managed languages.
Once hardware error correction for a memory line is exhausted, rather than
discarding the entire page, the hardware communicates the failed line to a
failure-aware OS and runtime. The runtime ensures memory allocations never use
failed lines and moves data when lines fail during program execution. This paper
describes minimal extensions to an Immix mark-region garbage collector, which
correctly utilizes pages with failed physical lines by skipping over failures.
This paper also proposes hardware support that clusters failed lines at one end
of a memory region to reduce fragmentation and improve performance under
failures. Contrary to accepted hardware wisdom that advocates for wear-leveling,
we show that with software support non-uniform failures delay the impact of
memory failure. Together, these mechanisms incur no performance overhead when
there are no failures and at failure levels of 10\% to 50\% suffer only an average
overhead of 4\% and 12\%, respectively. These results indicate that hardware and
software cooperation can greatly extend the life of wearable memories.},
} 

@inproceedings{gare72,
author = "M. R. Garey and R. L. Graham and Jeffrey D. Ullman",
title = "Worst-Case Analysis of Memory Allocation Algorithms",
booktitle = "4th Annual ACM Symposium on the Theory of Computing",
publisher = ACM,
year = 1972
}

@techreport{garn03,
title = {{JMTk}: A Portable Memory Management Toolkit},
author = {Robin J. Garner},
institution = {Australian National University},
month = dec,
year = 2003,
doi = {1885/39952},
type = {Bachelor of Science (Honours) thesis},
comment = {Describes porting JMTk for use in C/C++ based language runtimes. The
project has used the gcj ahead-of-time Java compiler and a source transformation
technique to produce a version of JMTk that can efficiently perform memory
management for traditionally compiled systems. Also describes an attempt top
incorporate JMTk into the Glasgow Haskell Compiler, ghc.}
}

@techreport{garn03a,
title = {Porting the {JMTk} Memory Management Toolkit},
author = {Robin J. Garner},
institution = {Australian National University},
year = 2007,
URL = {http://cs.anu.edu.au/~Robin.Garner/07-garner-1.pdf},
comment = {Short summary of \cite{garn03}.}
}

@inproceedings{garn07,
  title =	 {Effective Prefetch for Mark-Sweep Garbage Collection},
  author =	 {Robin Garner and Stephen M. Blackburn and Daniel Frampton},
  pages =	 {43--54},
  doi =		 {10.1145/1296907.1296915},
  crossref =	 {ISMM07},
}

@inproceedings{garn11,
title = {A Comprehensive Evaluation of Object Scanning Techniques},
author = {Robin J. Garner and Stephen M. Blackburn and Daniel Frampton},
crossref = {ISMM11},
pages = {33--42},
doi = {1993478.1993484},
abstract = {At the heart of all garbage collectors lies the process of
identifying and processing reference fields within an object. Despite its key
role, and evidence of many different implementation approaches, to our knowledge
no comprehensive quantitative study of this design space exists. The lack of
such a study means that implementers must rely on `conventional wisdom',
hearsay, and their own costly analysis. Starting with mechanisms described in
the literature and a variety of permutations of these, we explore the impact of
a number of dimensions including: a) the choice of data structure, b) levels of
indirection from object to metadata, and c) specialization of scanning code. We
perform a comprehensive examination of these tradeoffs on four different
architectures using eighteen benchmarks and hardware performance counters. We
inform the choice of mechanism with a detailed study of heap composition and
object structure as seen by the garbage collector on these benchmarks. Our
results show that choice of scanning mechanism is important. We find that a
careful choice of scanning mechanism alone can improve garbage collection
performance by 16\% and total time by 2.5\%, on average, over a well tuned
baseline. We observe substantial variation in performance among architectures,
and find that some mechanisms--particularly specialization, layout of reference
fields in objects, and encoding metadata in object headers--yield consistent,
significant advantages.}
}

@phdthesis{garn12,
title = {The Design and Construction of High Performance Garbage Collectors},
author = {Robin Garner},
school = {Australian National University},
month = may,
year = 2012,
URL = {http://hdl.handle.net/1885/9053},
abstract = {Garbage collection is a performance-critical component of modern
language implementations. The performance of a garbage collector depends in part
on major algorithmic decisions, but also significantly on implementation details
and techniques which are often incidental in the literature. In this
dissertation I look in detail at the performance characteristics of garbage
collection on modern architectures. My thesis is that a thorough understanding
of the characteristics of the heap to be collected, coupled with measured
performance of various design alternatives on a range of modern architectures
provides insights that can be used to improve the performance of any garbage
collection algorithm. The key contributions of this work are: 1) A new analysis
technique (replay collection) for measuring the performance of garbage
collection algorithms; 2) a novel technique for applying software prefetch to
non-moving garbage collectors that achieves significant performance gains; and
3) a comprehensive analysis of object scanning techniques, cataloguing and
comparing the performance of the known methods, and leading to a new technique
that optimizes performance without significant cost to the runtime environment.
These contributions are applicable to a wide range of garbage collectors, and
can provide significant measurable speedups to a design point where each
implementer in the past has had to trust intuition or their own benchmarking.
The methodologies and implementation techniques contributed in this dissertation
have the potential to make a significant improvement to the performance of every
garbage collector.}
}

@article{garn80,
author = "N. H. Garnett and Roger M. Needham",
title = "An Asynchronous Garbage Collector for the {C}ambridge File Server",
journal = SIGOPS,
publisher = ACM,
volume = 14,
number = 4,
pages = "36--40",
year = 1980
}

@inproceedings{gart97,
author = {Alex Garthwaite and Scott Nettles},
title = {Concurrent Collection for the {J}ava {D}evelopment {K}it},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/nettles-javaGC.ps},
crossref = {OOPSLA97-gc}
}

@inproceedings{gart98,
author = {Alex Garthwaite and Scott Nettles},
title = {{TJ}ava: a Transactional {J}ava},
booktitle = {IEEE International Conference on Computer Languages},
year = 1998,
publisher = IEEE
}

@inproceedings{gart01,
author = {Alex Garthwaite},
title = {Memory Management = Partitioning + Alpha-Renaming},
crossref = {SPACE01},
}

@inproceedings{gart05,
  title =	 {Supporting Per-Processor Local-Allocation Buffers Using
                  Lightweight User-Level Preemption Notification},
  author =	 {Alex Garthwaite and Dave Dice and Derek White},
  crossref =	 {VEE05},
  pages =	 {24--34},
  doi =		 {10.1145/1064979.1064985}
}

@phdthesis{gart05a,
title = {Making the Trains Run On Time},
author = {Alex Garthwaite},
school = {University of Pennsylvania},
year = 2005,
}

@techreport{gart06,
title = {Method and mechanism for Finding References in a Card in Time Linear in
the Size of the Card in a Garbage-Collected Heap},
author = {Alexander T. Garthwaite and David L. Detlefs and Antonios Printezis
and Y. Srinivas Ramakrishna},
institution = {Sun Microsystems},
type = {United States Patent},
number = {7,136,887 B2},
month = nov,
year = 2006,
URL =
{http://www.freepatentsonline.com/pdfb/documents/uspt/patent_pdf/7136/US7136887/pdf/US7136887.pdf},
}

@inproceedings{gay98,
  author =	 {David Gay and Alexander Aiken},
  title =	 {Memory Management with Explicit Regions},
  crossref =	 {PLDI98},
  pages =	 {313--323},
  doi =		 {10.1145/277650.277748},
  URL =
                  {http://www.acm.org/pubs/articles/proceedings/pldi/277650/p313-gay/p313-gay.pdf}
}

@techreport{gay98a,
author = {David Gay and Bjarne Steensgaard},
title = {Stack Allocating Objects in {J}ava},
institution = {Microsoft Research},
month = oct,
year = 1998,
URL = {http://research.microsoft.com/apl/stackalloc-abstract.pdf}
}

@inproceedings{gay00,
author = {David Gay and Bjarne Steensgaard},
title = {Fast Escape Analysis and Stack Allocation for Object-Based Programs},
crossref = {CC00},
pages = {82--93},
doi={10.1007/3-540-46423-9_6},
URL = {http://research.microsoft.com/copyright/accept.asp?path=/research/apl/pubs/stackalloc.ps&pub=15},
}

@inproceedings{gay01,
  author =	 {David Gay and Alexander Aiken},
  title =	 {Language Support for Regions},
  crossref =	 {PLDI01},
  pages =	 {70-80},
  doi =		 {10.1145/378795.378815}
}

@inproceedings{gay01a,
author = {David Gay},
title = {A Type System for Reference-Counted Regions},
crossref = {SPACE01},
}

@inproceedings{gay07,
title = {Safe Manual Memory Management},
author = {David Gay Rob Ennals and Eric Brewer},
pages = {2--14},
crossref = {ISMM07},
URL = {http://berkeley.intel-research.net/dgay/pubs/07-ismm-heapsafe.pdf}
}

@article{gee93,
author = "Jeffrey D. Gee and Mark D. Hill and Dionisios N. Pnevmatikatos
and Alan J. Smith",
title = "Cache Performance of the {SPEC92} Benchmark Suite",
journal = "IEEE Micro",
publisher = IEEE,
volume = 13,
number = 4,
pages = "17--27",
year = 1993
}


%check names
@inproceedings{gehr93,
author = "Edward F. Gehringer and Ellis Chang",
title = "Hardware-Assisted Memory Management",
crossref = "OOPSLA93-gc",
}

@article{gele60,
author = "H. Gelernter and J. R. Hansen and C. L. Gerberich",
title = "A {F}ortran-compiled List Processing Language",
journal = JACM,
publisher = ACM,
volume = 7,
number = 2,
month = Apr,
year = 1960,
pages = "87--101",
comment = {The earliest? paper on reference counting. Lists had owners and
users; the user was required to maintain the reference count (and therefore
decide when to delete a list). All sorts of scope for error, dangling pointers.
Collins described the method as quite useless.  }
}

@article{gele71,
author = "E. Gelenbe",
title = "The Two-Thirds Rule for Dynamic Storage Allocation under Equilibrium",
journal = IPL,
publisher = NH,
volume = 1,
year = 1971,
pages = "59--60",
}

@inproceedings{geof08,
author = {N. Geoffray and G. Thomas and C. Cl\'{e}mentand  and B. Folliot},
title = {A Lazy Developer Approach: Building a {JVM} with Third Party Software},
crossref = {PPPJ08},
pages = {73--82}
}

@inproceedings{geof10,
title = {{VMK}it: a Substrate for Managed Runtime Environments},
author = {Nicolas Geoffray and Ga\"{e}l Thomas and Julia Lawall and Gilles
Muller and Bertil Folliot},
crossref = {VEE10},
pages = {51--61},
abstract = {Managed Runtime Environments (MREs), such as the JVM and the CLI,
form an attractive environment for program execution, by providing portability
and safety, via the use of a bytecode language and automatic memory management,
as well as good performance, via just-in-time (JIT) compilation. Nevertheless,
developing a fully featured MRE, including e.g. a garbage collector and JIT
compiler, is a herculean task. As a result, new languages cannot easily take
advantage of the benefits of MREs, and it is difficult to experiment with
extensions of existing MRE based languages.
This paper describes and evaluates VMKit, a first attempt to build a common
substrate that eases the development of high-level MREs. We have successfully
used VMKit to build two MREs: a Java Virtual Machine and a Common Language
Runtime. We pro- vide an extensive study of the lessons learned in developing
this infrastructure, and assess the ease of implementing new MREs or MRE
extensions and the resulting performance. In particular, it took one of the
authors only one month to develop a Common Language Runtime using VMKit. VMKit
furthermore has perfor- mance comparable to the well established open source
MREs Ca- cao, Apache Harmony and Mono, and is 1.2 to 3 times slower than
JikesRVM on most of the DaCapo benchmarks.}
}

@inproceedings{geor04,
title = {Method-Level Phase Behavior in {J}ava Workloads},
author = {Andy Georges and Dries Buytaert and Lieven Eeckhout and De Bosschere, Koen},
pages = {270--287},
crossref = {OOPSLA04},
abstract = {Java workloads are becoming more and more prominent on
various computing devices. Understanding the behavior of a Java
workload which includes the interaction between the application and the
virtual machine, is thus of primary importance during performance
analysis and optimization. Moreover, as contemporary software projects
are increasing in complexity, automatic performance analysis techniques
are indispensable. This paper proposes an off-line method-level phase
analysis approach for Java workloads that consists of three steps. In
the first step, the execution time is computed for each method
invocation. Using an off-line tool, we subsequently analyze the dynamic
call graph (that is annotated with the method invocations' execution
times) to identify method-level phases. Finally, we measure performance
characteristics for each of the selected phases. This is done using
hardware performance monitors. As such, our approach allows for linking
microprocessor-level information at the individual methods in the Java
application's source code. This is extremely interesting information
during performance analysis and optimization as programmers can use
this information to optimize their code. We evaluate our approach in
the Jikes RVM on an IA-32 platform using the SPECjvm98 and SPECjbb2000
benchmarks. This is done according to a number of important criteria:
the overhead during profiling, the variability within and between the
phases and its applicability in Java workload characterization
(measuring performance characteristics of the various VM components)
and application bottleneck identification.}
}

@inproceedings{geor07,
title = {Statistically Rigorous {J}ava Performance Evaluation},
author = {Andy Georges and Dries Buytaert and Lieven Eeckhout},
crossref = {OOPSLA07},
pages = {57--76},
doi={10.1145/1297027.1297033}
}

@inproceedings{geor08,
title = {Java Performance Evaluation through Rigorous Replay Compilation},
author = {Andy Georges and Lieven Eeckhout and Dries Buytaert},
crossref = {OOPSLA08},
pages = {367--384},
doi = {10.1145/1449764.1449794},
abstract = {A managed runtime environment, such as the Java virtual machine, is
non-trivial to benchmark. Java performance is affected in various complex ways
by the application and its input, as well as by the virtual machine (JIT
optimizer, garbage collector, thread scheduler, etc.). In addition,
non-determinism due to timer-based sampling for JIT optimization, thread
scheduling, and various system effects further complicate the Java performance
benchmarking process.
Replay compilation is a recently introduced Java performance analysis
methodology that aims at controlling non-determinism to improve experimental
repeatability. The key idea of replay compilation is to control the compilation
load during experimentation by inducing a pre-recorded compilation plan at
replay time. Replay compilation also enables teasing apart performance effects
of the application versus the virtual machine.
This paper argues that in contrast to current practice which uses a single
compilation plan at replay time, multiple compilation plans add statistical
rigor to the replay compilation methodology. By doing so, replay compilation
better accounts for the variability observed in compilation load across
compilation plans. In addition, we propose matched-pair comparison for
statistical data analysis. Matched-pair comparison considers the performance
measurements per compilation plan before and after an innovation of interest as
a pair, which enables limiting the number of compilation plans needed for
accurate performance analysis compared to statistical analysis assuming unpaired
measurements.}
}


@article{gerh79,
author = "S. L. Gerhart",
title = "A Derivation Oriented Proof of {S}chorr--{W}aite Marking Algorithm",
journal = LNCS,
publisher = SV,
address = "New York",
volume = 69,
year = 1979,
pages = "472--492",
comment = {proves the correctness of the link reversal algorithm by Deutsch-Schorr-Waite},
}

@techreport{ghar,
author = {Bashar Gharaibeh and J. Morris Chang},
title = {Meaningful Object Lifetime Measurement for Multithreaded Applications},
institution = {Iowa State University},
year = 2009, 
url = {http://archives.ece.iastate.edu/archive/00000530/},
abstract = {Object-oriented languages that rely on automatic dynamic memory
management (i.e. Garbage Collection) are gaining popularity. More and more
applications are developed using such languages. How- ever, the performance of
memory management for such applications de- pends on how these applications
allocate and use objects. Researchers have relied on information about object
lifetime, allocation sites and ob- ject sizes to understand the performance of
garbage collection and to design better collection schemes. This set of
information, also referred to as Object demographics, are crucial for memory
management research. However, little effort has been made to investigate schemes
to obtain demographics information. The lack of demographics studies especially
affects multi-threaded applications. Current schemes for tracing object
lifetimes does not take into consideration the complexities associated with
multi-threaded applications. With the increased interest in multi- threaded
applications, the research community is in need for a thread- specific view on
object demographics.
Traditionally, lifetime is expressed by how many allocations were made between
the object birth and death. For multi-threaded applications, the lifetime is
equal to the amount of allocations made by the allocat- ing thread and any other
running threads. Therefor, lifetime results are inflated by allocations from
other threads and can vary with different thread scheduling scenarios.
We propose a new measurement methodology that uses a vector clock of allocation.
our scheme is capable of detecting needed allocations for calculating lifetime
and neglect those that are a result of thread schedul- ing. In addition to
accuracy, the use of vector clock allows us to observe dependencies between
allocation events. The new methodology is com- pared to the conventional
measurement methodology showing that the conventional method inflates object’s
lifetime by up to 13\% for some benchmarks. In addition, using the proposed
measurement method, we investigate objects demographics while showing per-thread
behavior. We also show an example of using per-thread VC to understand minor
col- lection cost.}
}

@inproceedings{gheo03,
title = {Interprocedural Compatibility Analysis for Static Object Preallocation},
author = {Ovidiu Gheorghioiu and Alexandru Salcianu and Martin Rinard},
crossref = {POPL03}
}

@inproceedings{ghes03,
author= {Ghesquiere, T. and  Choi, J.-D. and  De Bosschere, K.},
title= {Memory Management Replay in {D}eja{V}u},
booktitle= {Program Acceleration through Application and Architecture driven Code Transformations: Symposium Proceedings},
year= 2003,
month = sep,
pages= {113--115},
address= {Edegem, Belgium}
}

@inproceedings{ghes03a,
author= {Ghesquiere, T. and  Choi, J.-D. and  De Bosschere, K.},
title= {Accurate Replay of Memory Management in {J}ava},
booktitle= {4th FTW PhD Symposium},
year= 2003,
month= dec,
address= {Gent, Belgium},
}

@inproceedings{ghiy01,
  title =	 {On the Importance of Points-to Analysis and Other Memory
                  Disambiguation Methods for {C} Programs},
  author =	 {Rakesh Ghiya and Daniel M. Lavery and David C. Sehr},
  crossref =	 {PLDI01},
  pages =	 {47-58},
  doi =		 {10.1145/378795.378806}
}

@techreport{ghos94,
author = {Kaushik Ghosh},
title = {Reconfigurable Garbage Collection of Data Structures in a Speculative Real-Time System},
institution = {Georgia Institute of Technology},
number = {GIT-CC-94-57},
year = 1994,
URL = {ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1994/GIT-CC-94-57.ps.Z}
}

@inproceedings{gibb05,
author = {Celina Gibbs and Yvonne Coady},
title = {Aspects of Memory Management},
booktitle = {38th Annual Hawaii International Conference on
System Sciences (HICSS) -- Track 9},
pages = {275.2},
year = 2005
}

@inproceedings{gidr11,
title = {Assessing the Scalability of Garbage Collectors on Many Cores},
author = {Lokesh Gidra and Ga\"{e}l Thomas and Julien Sopena and Marc Shapiro},
booktitle = {6th Workshop on Programming Languages and Operating Systems (PLOS 2011)},
address = {Cascais, Portugal},
pages = 5,
month = oct,
year = 2011,
doi = {2039239.2039249},
abstract = {Managed Runtime Environments (MRE) are increasingly used for
application servers that use large multi-core hardware. We find that the
garbage collector is critical for overall performance in this setting. We
explore the costs and scalability of the garbage collectors on a contemporary
48-core multiprocessor machine. We present experimental evaluation of the
parallel and concurrent garbage collectors present in OpenJDK, a widely-used
Java virtual machine. We show that garbage collection represents a substantial
amount of an application's execution time, and does not scale well as the number
of cores increases. We attempt to identify some critical scalability bottlenecks
for garbage collectors.}
}

@inproceedings{gidr13,
author = {Gidra, Lokesh and Thomas, Ga\"{e}l and Sopena, Julien and Shapiro, Marc},
title = {A Study of the Scalability of Stop-the-world Garbage Collectors on Multicores},
booktitle = {Proceedings of the Eighteenth International Conference on
Architectural Support for Programming Languages and Operating Systems (ASPLOS)},
year = 2013,
location = {Houston, TX},
pages = {229--240},
doi = {10.1145/2451116.2451142},
publisher = ACM,
abstract = {Large-scale multicore architectures create new challenges for
garbage collectors (GCs). In particular, throughput-oriented stop-the-world
algorithms demonstrate good performance with a small number of cores, but have
been shown to degrade badly beyond approximately 8 cores on a 48-core with
OpenJDK 7. This negative result raises the question whether the stop-the-world
design has intrinsic limitations that would require a radically different
approach. Our study suggests that the answer is no, and that there is no
compelling scalability reason to discard the existing highly-optimised
throughput-oriented GC code on contemporary hardware. This paper studies the
default throughput-oriented garbage collector of OpenJDK 7, called Parallel
Scavenge. We identify its bottlenecks, and show how to eliminate them using
well-established parallel programming techniques. On the SPECjbb2005,
SPECjvm2008 and DaCapo 9.12 benchmarks, the improved GC matches the performance
of Parallel Scavenge at low core count, but scales well, up to 48~cores.}
}

@misc{gill,
title = {An Introduction to Garbage Collection},
author = {Richard Gillam},
URL = {http://oss.software.ibm.com/icu/docs/papers/cpp_report/an_introduction_to_garbage_collection_part_i.html}
}

@mastersthesis{gint91,
author = "Andrew Ginter",
title = "Cooperative Garbage Collection using Smart Pointers in the {C++}
Programming Language",
school = "University of Calgary",
year = 1991,
month = dec,
note = "Technical report 91/451/45",
}

@article{gira87,
author = "J.-Y. Girard",
title = "Linear Logic",
journal = "Theoretical Computer Science",
volume = 50,
pages = "1--102",
year = 1987,
comment = "Linear variables must be used exactly once hence optimising away
reference counts for instance."
}

@inproceedings{glas86,
title = "Another Implementation Technique for Applicative Languages",
author = "Hugh W. Glaser and S. Hayes",
crossref = {ESOP86},
pages = "70--81",
abstract = {This paper will present a particularly simple data flow model which
is similar to supercombinator reduction, supporting higher order functions,
garbage collection and a form of lazy evaluation in a clear and natural
manner.
The paper will also show how the model can be made to execute on a conventional
processor.  Such a method has shown significant speed increases over other
available methods of evaluating functional programs, and the hardware
implementation holds the promise of a machine that executes applicative
languages at a comparable speed to conventional hardware executing control flow
programs.  In addition, unlike other proposed models, the extensions to a
multi-processor machine are natural and well defined, with the potential
of even greater speedups.}
}

@article{glas87,
author = "Hugh W. Glaser and P. Thompson",
title = "Lazy Garbage Collection",
journal = SPE,
publisher = Wiley,
volume = 17,
number = 1,
pages = "1--4",
month = jan,
year = "1987",
comment = {\cite{lins91} shows that the decrease
in main-memory access using this algorithm is not big.
Unable to deal with cyclic structures.},
}

@techreport{glas87a,
author = "Hugh W. Glaser",
title = "On Minimal Overhead Reference Count Garbage Collection in Distributed Systems",
institution = "Department of Computing, Imperial College, London",
year = 1987,
abstract = {In this paper we present a garbage collection scheme that does not
require any access to main memory by the garbage collection process.
We achieve this by the combination of two recently proposed garbage collection
techniques: Lazy Garbage Collection and Weighted Reference Count garbage collection...}
}

@techreport{glas89,
author = "Hugh W. Glaser and  Michael Reeve and S. Wright",
title = "An Analysis of Reference Count Garbage Collection Schemes for
Declarative Languages",
institution = "Department of Computing, Imperial College, London",
year = 1989,
abstract = "Considers different methods of implementing reference count
garbage collection and presents a new scheme, the Lazy/Weighted method.
It gives a comparison of the methods based on efficiency, real-time
operation and applicability for both centralised and distributed systems and
then uses the data gathered from experiments with the ALICE parallel machine to
quantify the comparison. The results show that the Lazy/Weighted method
is the most promising.",
comment = "I am not convinced that the Lazy/Weighted method is any better
than the original Weighted algorithm"
}

@inproceedings{goa95,
author = {H. Goa and Kelvin Nielsen},
title = {The Real-Time Behaviour of Dynamic Memory Management in {C++}},
booktitle = {Real-Time Techniques and Applications Symposium},
address = {Chicago, IL},
month = may,
year = 1995
}

@misc{goet03,
author = {Brian Goetz},
title = {{J}ava Theory and Practice: A Brief History of Garbage Collection},
month = oct,
year = 2003,
URL = {http://www-106.ibm.com/developerworks/java/library/j-jtp10283/},
note = {First of a series of three articles}
}

@misc{goet03a,
author = {Brian Goetz},
title = {{J}ava Theory and Practice: Garbage Collection in the 1.4.1 {JVM}},
month = nov,
year = 2003,
URL = {http://www-106.ibm.com/developerworks/java/library/j-jtp11253/},
note = {Second of a series of three articles}
}

@misc{goet04,
author = {Brian Goetz},
title = {{J}ava Theory and Practice: Garbage Collection and Performance},
month = jan,
year = 2004,
URL = {http://www.ibm.com/developerworks/java/library/j-jtp01274.html},
note = {Last of a series of three articles}
}

@misc{gogu98,
author = {Healfdene Goguen and Richard Brooksby and Rod Burstall},
title = {An Abstract Formulation of Memory Management},
month = dec,
year = 1998,
note = "draft",
URL = {http://www.dcs.ed.ac.uk/home/hhg/mm.dvi.gz}
}

@inproceedings{gogu99,
author = "Healfdene Goguen and Richard Brooksby and Rod M.~Burstall",
title = {Memory Management: An Abstract Formulation of Incremental Tracing},
booktitle = {Types for Proofs and Programs, International Workshop TYPES'99},
year = 2000,
pages  = "148--161",
publisher = {Springer}
}

@inproceedings{goh06,
title = {Integrated Scheduling with Garbage Collection for Real-Time Embedded
Applications in {CLI}},
author = {O. Goh and Yann-Hang Lee and Z. Kaakani and E. Rachlin},
crossref = {ISORC06},
doi={10.1109/ISORC.2006.41},
abstract = {We present a schedulable garbage collection for realtime
applications in virtual machine environments. The design objective is to make
the pause time caused by garbage collection operations controllable, and the
invocation of garbage collection predictable. Thus, real-time applications can
be schedulable along with garbage collection. We develop a prototype for a
schedulable garbage collection in MONO CLI execution environment. A cost model
of garbage collection is established based on measured WCET to predict the
execution time and overhead of garbage collection operations. A scheduling
algorithm of garbage collection and application tasks is presented to illustrate
how the time and memory constraints of real-time systems can be met. The
experiment result of the scheduling algorithm for a periodic task set on the
prototype is included in the paper.},
URL = {http://ieeexplore.ieee.org/Xplore/defdeny.jsp?url=/iel5/10852/34193/01630468.pdf&code=2}
}

@inproceedings{gont96,
author = {Georges Gonthier},
title = {Verifying the Safety of a Practical Concurrent Garbage Collector},
booktitle = {Computer Aided Verification CAV'96},
address = {New Brunswick, NJ},
editor = {R. Alur and T. Henzinger},
series = LNCS,
publisher = SV,
year = 1996
}

@inproceedings{gold74,
author = "Ron P. Goldberg and R. Hassinger",
title = "The Double Paging Anomaly",
booktitle = "AFIPS National Computer Conference",
year = 1974,
month = May,
pages = {195--199}
}

@book{gold83,
author = "Adele Goldberg and D. Robson",
title = "Smalltalk-80: The Language and its Implementation",
publisher = AW,
year = 1983,
comment = "Reference counter + second collector"
}

@inproceedings{gold89,
  author =	 "Benjamin Goldberg",
  title =	 "Generational Reference Counting: A Reduced-Communication
                  Distributed Storage Reclamation Scheme",
  crossref =	 "PLDI89",
  pages =	 "313--320",
  doi =		 {10.1145/73141.74846},
  comment =	 "Claims similar communication overhead to Weighted reference
                  counting.  However storage overheads are greater.  (Nothing
                  to do with generational GC.)"
}

@article{gold91,
title = "Tag-Free Garbage Collection for Strongly Typed Programming Languages",
author = "Benjamin Goldberg",
crossref={PLDI91},
pages={165--176},
doi={10.1145/113445.113460},
comment = "For a purely statically-typed language, no per-object runtime type
information is necessary, except the types of the root set variables."
}

@inproceedings{gold92,
author = "Benjamin Goldberg and Michael Gloger",
title = "Polymorphic Type Reconstruction for Garbage Collection Without Tags",
crossref = "LFP92",
pages = "53--65",
doi={10.1145/141471.141504},
comment = "
By doing type unifications at garbage collection time
the garbage collector can re-derive almost all type information.  And
what it cannot derive doesn't matter.  Interesting, but probably impractical."
}

@inproceedings{gold92a,
author = "Benjamin Goldberg",
title = "Incremental Garbage Collection Without Tags",
crossref = {ESOP92},
doi={10.1007/3-540-55253-7_12},
pages={200-218},
URL = {http://www.cs.nyu.edu/goldberg/pubs/gold92.pdf}
}

@phdthesis{gold92b,
author = {Richard A. Golding},
title = {Weak-Consistency Group Communication and Membership},
school = UCSC,
month = dec,
year = 1992,
note = {UCSC--CRL-92-52}
}

@inproceedings{gold88,
author = "Goldman, Ron and Richard P. Gabriel",
title = "Preliminary Results with the Initial Implementation of {Q}lisp",
crossref = "LFP88",
pages = "143--152"
}

@techreport{gonc94,
title = "Cache Performance of Fast-Allocating Programs",
author = {Marcelo J. R. Gon\c{c}alves and Andrew W. Appel},
institution = Princeton,
number = "CS--TR--482--94",
month = dec,
year = 1994,
URL = "http://ncstrl.cs.Princeton.EDU/expand.php?id=TR-482-94"
}

@inproceedings{gonc95,
title = "Cache Performance of Fast-Allocating Programs",
author = {Marcelo J. R. Gon\c{c}alves and Andrew W. Appel},
doi={10.1145/224164.224219},
pages={293--305},
crossref = "FPCA95",
}

@phdthesis{gonc95a,
author = {Marcelo J. R. Gon\c{c}alves},
title = "Cache Performance of Programs with Intensive Heap Allocation
and Generational Garbage Collection",
school = Princeton,
month = may,
year = 1995,
}

@inproceedings{gorm08,
title = {Supporting Superpage Allocation without Additional Hardware Support},
author = {Mel Gorman and Patrick Healy},
crossref = {ISMM08},
pages = {41--50},
doi = {10.1145/1375634.1375641},
abstract = {Today, many modern processors support more than one
page size. The larger pages, called superpages, have been identified
as one means of reducing the time spent servicing translation
lookaside buffer (TLB) misses in the early 1990s by increasing TLB
reach. Widespread usage of superpages has been limited by the
requirement that superpages consist of physically contiguous and
naturally-aligned small pages. This makes external fragmentation a
serious problem for an operating system, one that is almost
non-existent when processes use only one page size. Hardware solutions
to mitigate this limitation such as sub-blocking, shadow page-tables
and a variety of hybrid solutions have not seen wide-spread adoption.
This has curtailed automatic superpage support as it is known that
superpage availability will decrease during the system's lifetime
as external fragmentation grows.  This paper presents a placement
policy for an operating system's physical page allocator to mitigate
external fragmentation problems by grouping pages based on the
system's ability to relocate the data. Secondly, the necessary
changes to the page reclamation algorithm for it to be contiguity-aware
are described while minimising impact to the reclamation algorithms'
normal decisions. The performance impact on different machine types
is illustrated and it is shown that the superpage allocation success
rate is improved. These mechanisms are complementary to any of the
hardware solutions proposed in the past.}
}

@book{gosl97,
title = {The {J}ava Language Specification},
author = {James Gosling and Bill Joy and Guy Steele},
publisher = AW,
series = {The {J}ava Series},
ISBN = {0-201-63451-1},
pages =864,
year = 1997,
URL = {http://www.aw.com/cp/gosling-joy-etal.html}
}

@book{gosl05,
author = {James Gosling and Bill Joy and Guy Steele and Gilad Bracha},
title = {The {J}ava Language Specification},
edition = {Third Edition},
publisher = AW,
month = may,
year = 2005
}

@book{gotl78,
author = "C. C. Gotlieb and L. R. Gotlieb",
title = "Data Types and Structures",
publisher = PH,
year = 1978,
comment = {book with sections on garbage collection.
Presents an optimization to the copying algorithm (feni69) by moving a list into
a contiguous area of the memory space with the stack implicit in the list being
moved. Clark (clar76) shows that his algorithm is in most cases more efficient
than both Cheney's (chen70) and Reingold's (rein73).},
}

@techreport{gott82,
author = "A. Gottlieb and J. Wilson",
title = "Parallelizing the Usual Buddy Algorithm",
institution = "Courant Institute, New York University",
number = "System Software Note 37",
year = 1982
}

@techreport{goto74,
author = "Eiichi Goto",
title = "Monocopy and associative algorithms in an extended {LISP}",
institution =  "Information Science Laboratories, Faculty of Science, University of Tokyo",
year = 1974,
number = "74-03"
}

@inproceedings{goto79,
author = "E. Goto and I. Tetsuo and K. Hiraki and M. Susuki and N. Inada",
title = "{FLATS}, A Machine for Numerical, Symbolic and Associative Computing",
booktitle = "6th Annual " # ISCA,
pages = "102--110",
year = 1979,
month = apr
}

@inproceedings{goto88,
author = "Atsuhiro Goto and Y. Kimura and T. Nakagawa and T. Chikayama",
title = "Lazy Reference Counting: An Incremental Garbage Collection Method
for Parallel Inference Machines",
crossref = "ICLP88",
pages = "1241--1256",
note = "Also ICOT Technical Report TR-354, 1988"
}

@inproceedings{gour92,
author = "Y. Gourhant and S. Louboutin and V. Cahill and A. Condon and G. Starovic and B. Tangney",
title = "Dynamic Clustering in an Object-Oriented Distributed System",
booktitle = "Proceedings of {OLDA-II} (Objects in Large Distributed Applications)",
year = 1992,
address = "Ottawa, Canada",
month = oct,
abstract = "In an O-O distributed system, object grouping is crucial in
order to optimize communications between objects and disk I/O
transfers. In this paper, we present a general purpose and
scalable object clustering method which is integrated with
garbage collection and load balancing processing. We proposed
a mixed dynamic and user-driven approach.",
URL = "ftp://ftp.dsg.cs.tcd.ie/pub/doc/dsg-24.ps.gz",
}

@incollection{goye71,
author = "P. Goyer",
title = "A Garbage Collector to be Implemented on a {CDC} 3100",
crossref = "Algol68",
pages = "303--317",
}

@mastersthesis{gray87,
author = "Gray, Stanley M.",
title = "Garbage Collection in a Parallel Processing Environment",
year = 1987,
school = "East Texas State University"
}

@techreport{gree74,
author = "Richard Greenblat",
title = "The {LISP} Machine",
institution = MITAI,
type = "Working Paper",
number = 79,
month = nov,
year = 1974,
comment = "MIT Lisp machine"
}

@incollection{gree84,
author = "Richard Greenblatt",
title = "The {LISP} Machine",
booktitle = "Interactive Programming Environments",
editor = "D. R. Barstow and H. E. Shrobe and E. Sandewall",
publisher = MGH,
year = 1984,
comment = "MIT Lisp Machines have special purpose hardware to detect pointers
into fromspace and trap to a handler.
The cost of this checking on a conventional machine is in the tens of percent
for a high performance system.
Uses Lieberman and Hewitt."
}

@article{grie77,
author = "David Gries",
title = "An Exercise in Proving Parallel Programs Correct",
journal = CACM,
publisher = ACM,
volume = 20,
number = "12",
month = dec,
year = 1977,
pages = "921--930",
doi={10.1145/359897.359903},
comment = "Proof of correctness of Dijkstra {\it et al.}'s on-the-fly
algorithm."
}

@article{grie77a,
author = "David Gries",
title = "On Believing Programs to be Correct",
journal = CACM,
publisher = ACM,
volume = 20,
number = "1",
month = jan,
year = 1977,
pages = "49--50",
comment = "Proof of correctness of Dijkstra {\it et al.}'s on-the-fly
algorithm."
}

@article{grie79,
author = "David Gries",
title = "The {S}chorr--{W}aite Graph Marking Algorithm",
journal = ActInf,
publisher = SV,
volume = 11,
number = 3,
year = 1979,
pages = "223--232",
comment = {proves the correctness of the link reversal algorithm by Deutsch-Schorr-Waite},
}

@inproceedings{grif05,
  title =	 {An Energy Efficient Garbage Collector for {Java} Embedded
                  Devices},
  author =	 {Paul Griffin and Witawas Srisa-An and J. Morris Chang},
  crossref =	 {LCTES05},
  pages =	 {230-238},
  doi =		 {10.1145/1070891.1065943}
}

@inproceedings{grif05a,
title = {On Designing a Low-Power Garbage Collector for {J}ava Embedded Devices:
A Case Study},
author = {Paul Griffin and Witawas Srisa-An and J. Morris Chang},
booktitle = {ACM Symposium on Applied Computing},
address = {Santa Fe, NM},
pages = {868--873},
year = 2005,
doi = {10.1145/1066677.1066875}
}


@mastersthesis{grim89,
title = "Multiple Prefetch Adaptive Disk Caching with Strategic Data Layout",
author = "Knut S. Grimsrud",
school = "Brigham Young University",
year = 1989,
month = dec
}

@misc{gris72,
author = "R. E. Griswold",
title = "The Macro Implementation of {S}nobol 4",
publisher = "W. H. Freeman",
address = "San Francisco",
year = 1972,
comment = "should find a proper reference to this work"
}

@book{gris83,
author = "Ralph E. Griswold and Madge T. Griswold",
title = "The {I}con Programming Language",
publisher = PH,
year = 1983
}

@book{gris86,
author = {Ralph E. Griswold and Madge T. Griswold},
title = {The Implementation of the {I}con Programming Language},
publisher = {Princeton University Press},
year = 1986,
URL = {http://www.cs.arizona.edu/icon/ibsale.htm},
note = {Out of print.}
}

@article{grit81,
title = "Deleting Irrelevant Tasks in an Expression-Oriented Multiprocessor System",
author = "Dale H. Grit and Rex L. Page",
journal = TOPLAS,
publisher = ACM,
year = 1981,
month = jan,
volume = 3,
number = 1,
pages = "49--59",
}

@inproceedings{gron04,
author = {van Groningen, J.},
title = {Faster Garbage Collection Using Prefetching},
booktitle = {16th International Workshop on Implementation
and Application of Functional Languages (IFL)},
address = {L\"{u}beck, Germany},
editor = {C.Grelck and F. Huch},
pages = {142--152},
year = 2004
}

@inproceedings{gros02,
  title =	 {Region-Based Memory Management in {Cyclone}},
  author =	 {Dan Grossman and Greg Morrisett and Trevor Jim and Michael
                  Hicks and Yanling Wang and James Cheney},
  crossref =	 {PLDI02},
  pages =	 {282--293},
  doi =		 {10.1145/512529.512563},
  abstract =	 {Cyclone is a polymorphic, type-safe programming language
                  derived from C. The primary design goals of Cyclone are to
                  let programmers control data representations and memory
                  management without sacrificing type-safety. In this paper,
                  we focus on the region-based memory management of Cyclone
                  and its static typing discipline. The design incorporates
                  several advancements, including support for region subtyping
                  and a coherent integration with stack allocation and a
                  garbage collector. To support separate compilation, Cyclone
                  requires programmers to write some explicit region
                  annotations, but uses a combination of default annotations,
                  local type inference, and a novel treatment of region
                  effects to reduce this burden. As a result, we integrate C
                  idioms in a region-based framework.  In our experience,
                  porting legacy C to Cyclone has required altering about 8
                  percent of the code; of the changes, only 6 percent (of the
                  8 percent) were region annotations.}
}

@inproceedings{gros07,
title = {The Transactional Memory / Garbage Collection Analogy},
author = {Dan Grossman},
pages = {695--706},
crossref = {OOPSLA07},
note = {Essay session.}
}

@mastersthesis{grou99,
author = {Morten Grouleff},
title = {A Concurrent Garbage Collector for {BETA}},
school = {University of Aarhus},
month = dec,
year = 1999,
URL = {http://grouleff.com/~mg/A-Concurrent-Garbage-Collector-for-BETA.html}
}

@inproceedings{grui05,
author = {Gruian, Flavius and Salcic, Zoran},
affiliation = {Department of Electrical and Computer Engineering, The University of Auckland, Private Bag 92019, Auckland New Zealand},
title = {Designing a Concurrent Hardware Garbage Collector for Small Embedded Systems},
booktitle = {Advances in Computer Systems Architecture},
editor = {Srikanthan, Thambipillai and Xue, Jingling and Chang, Chip-Hong},
series = LNCS,
volume = 3740,
publisher = SV,
pages = {281--294},
year = 2005
}


@techreport{grun92,
author = "Dirk Grunwald and Benjamin Zorn",
title = "{CUSTOMALLOC}: Efficient Synthesized Memory Allocators",
institution = "University of Colorado",
type = "Computer Science Technical Report",
number = "CU-CS-602-92",
address = "Campus Box 430, Boulder, CO 80309",
month = jul,
year = 1992,
}

@inproceedings{grun93,
  title =	 "Improving the Cache Locality of Memory Allocation",
  author =	 "Dirk Grunwald and Benjamin G. Zorn and Robert Henderson",
  crossref =	 "PLDI93",
  pages =	 "177--186",
  doi =		 {10.1145/155090.155107},
  URL =
                  {ftp://ftp.cs.colorado.edu/pub/cs/techreports/grunwald/PLDI-93-locality.ps.Z},
  abstract =	 {The allocation and disposal of memory is a ubiquitous
                  operation in most programs. Rarely do programmers concern
                  themselves with details of memory allocators; most assume
                  that memory allocators provided by the system perform well.
                  This paper presents a performance evaluation of the
                  reference locality of dynamic storage allocation algorithms
                  based on trace-driven simulation of five large
                  allocation-intensive C programs.  In this paper, we show how
                  the design of a memory allocator can significantly affect
                  the reference locality for various applications.  Our
                  measurements show that poor locality in sequential-fit
                  allocation algorithms reduces program performance, both by
                  increasing paging and cache miss rates.  While increased
                  paging can be debilitating on any architecture, cache misses
                  rates are also important for modern computer architectures.
                  We show that algorithms attempting to be space-efficient by
                  coalescing adjacent free objects show poor reference
                  locality, possibly negating the benefits of space
                  efficiency.  At the other extreme, algorithms can expend
                  considerable effort to increase reference locality yet gain
                  little in total execution performance.}
}

@article{grun93a,
author = "Dirk Grunwald and Benjamin Zorn",
title = "CustoMalloc: Efficient, Synthesised Memory Allocators",
journal = SPE,
publisher = Wiley,
volume = 23,
pages = "851--869",
year = 1993,
URL = "http://www.cs.colorado.edu/homes/grunwald/public_html/SPE93-customalloc.ps"
}

@inproceedings{grze07,
author = {Chris Grzegorczyk and Sunil Soman and Chandra Krintz and Rich Wolski},
title = {{I}sla {V}ista Heap Sizing: Using Feedback to Avoid Paging},
crossref = {CGO07},
pages = {325--340},
doi = {10.1109/CGO.2007.20}
}

@inproceedings{gu09,
title = {A Component Model of Spatial Locality},
author = {Xiaoming Gu and Ian Christopher and Tongxin Bai and Chengliang Zhang and Chen Ding},
pages = {99--108},
doi = {10.1145/1542431.1542446},
crossref = {ISMM09}
}

@inproceedings{guan09,
title = {Investigating the Effects of Using Different Nursery Sizing Policies on Performance},
author = {Xiaohua Guan and Witawas Srisa-an and Chenghuan Jia},
pages = {59--68},
doi = {10.1145/1542431.1542441},
crossref = {ISMM09}
}

@techreport{gude93,
author = "David Gudeman",
title = "Representing Type Information in Dynamically-Typed Languages",
year = 1993,
number = "TR93-27",
institution = "University of Arizona, Department of Computer Science",
address = "Tucson, AZ"
}

@mastersthesis{gugg94,
author = "Satish Kumar Guggilla",
title = "Generational Garbage Collection of {C++} Targeted to {SPARC} Architectures",
school = "Iowa State University",
month = jul,
year = 1994,
note = "Technical report ISUTR 94-11",
URL = "http://www.cs.iastate.edu/tech-reports/TR94-11.ps"
}

@inproceedings{gupt88,
title = "Reliable Garbage Collection in Distributed Object Oriented Systems",
author = "Aloke Gupta and W. K. Fuchs",
booktitle = "12th Annual International Computer
Software  Applications Conference (COMPSAC)",
address = "Chicago",
month = oct,
publisher = IEEE,
pages = "324--328",
year = 1988,
abstract = {The authors examine the problem of reliable storage reclamation in
a distributed object-oriented system.  A distributed algorithm is proposed that
utilizes a modified reference counting strategy for internode pointers and
mark-and-sweep for local garbage collection.  The algorithm allows nodes to fail
in a failstop manner, in which case the global garbage collection functions in
a gracefully degraded mode of operation.  Compaction of objects is supported
and object locality is exploited to reduce overhead.},
comment = "Fault-tolerance is achieved be entering candidate garbage into tables until
they can be removed.
Cycles handled by migration of local garbage (when of sufficient age)."
}

@mastersthesis{gupt90,
author = "Gupta, Aloke",
title = "Low Overhead Garbage Collection in a Distributed Object-Oriented System",
year = 1990,
school = "University of Illinois at Urbana-Champaign"
}

@article{gupt93,
author = "Gupta, Aloke and W. K. Fuchs",
title = "Garbage Collection in a Distributed Object-Oriented System",
journal = "IEEE Transactions on Knowledge and Data Engineering",
publisher = IEEE,
volume = 5,
number = 2,
month = apr,
year = 1993
}

@misc{gupt03,
author = {Alka Gupta},
title = {{GC} Portal},
month = jul,
year = 2003,
URL = {http://java.sun.com/developer/technicalArticles/Programming/GCPortal/},
abstract = {The GC Portal enables analysis and performance tuning of
Java applications from a garbage collection (GC) perspective by mining
the verbose:gc logs generated by the JVM. GC Portal is a one-stop page
for GC issues and includes an extensive collection of whitepapers, case
studies and other material. The Portal is intended to be used with
HotSpot JVM from Sun Microsystems, distributed as part of Java 2,
Standard Edition (J2SE). Use of the GC Portal enables developers to
model application and JVM behaviors from a GC perspective. This article
introduces the design and features of the GC Portal, to enable
developers to use it as a tool for analyzing and tuning GC.}
}
@article{gutt95,
title = {The {VLISP} verified {S}cheme System},
author = {J.D. Guttman and J.D. Ramsdel and V. Swarup},
journal = LSC,
volume = 8,
number = {1/2},
month = mar,
year = 1995,
pages = {33-110}
}

@inproceedings{guye04,
title = {Finding Your Cronies: Static Analysis for Dynamic Object Colocation},
author = {Samuel Guyer and Kathryn McKinley},
pages = {237--250},
crossref = {OOPSLA04},
doi={10.1145/1028976.1028996},
abstract = {This paper introduces cooperative object colocation, an
optimization to reduce copying costs in generational and other
incremental garbage collectors by allocating connected objects together
in the same space. Previous work indicates that connected objects die
together, but generational copying collectors allocate new objects in a
nursery regardless of the location of an older object that points to
it. Cooperative colocation consists of (1) a flow insensitive static
compiler analysis that finds potential colocation allocation sites; (2)
a modified allocator which takes a colocation object as a parameter;
and (3) a runtime test that allocates a new object together with its
colocator.  At runtime in a generational setting, the allocator places
the object in the old space if the colocator resides in the old space,
and otherwise allocates the new object in the nursery. Unlike
pretenuring, colocation makes precise per object allocation decisions,
and does not require lifetime analysis or allocation site homogeneity.
Experimental results for SPEC Java Benchmarks using MMTk, a Java Memory
Management Toolkit in JikesRVM, show colocation can reduce nursery
collection work, improving the performance of two generational
collectors by up to a factor of 2, and total performance by up to
10\%.}
}

@inproceedings{guye06,
  title =	 {{Free-Me}: A Static Analysis for Automatic Individual Object
                  Reclamation},
  author =	 {Samuel Z. Guyer and Kathryn S. McKinley and Daniel Frampton},
  crossref =	 {PLDI06},
  pages =	 {364--375},
  doi =		 {10.1145/1133981.1134024}
}

@inproceedings{guzm90,
author = {J. C. Guzm\'{a}n and Paul Hudak},
title = "Single Threaded Polymorphic Lambda Calculus",
booktitle = "5th IEEE Symposium on Logic in Computer Science",
publisher = IEEE,
year = 1990
}

@article{hadd67,
author = "B. K. Haddon and  W. M. Waite",
title = "A Compaction  Procedure  for  Variable Length Storage Elements",
journal = CompJ,
publisher = BCS,
volume = 10,
month = Aug,
year = 1967,
pages = "162--165",
comment = {algorithm for compacting varisized cells},
}

@article{haga96,
author = "Tom Hagan",
title = "Not Just A Stopgap",
journal = "Information Week",
month = jan,
year = 1996,
publisher = "CMP Publications, Inc",
comment = "Two page article on Geodesic Systems Great Circle collector"
}

@inproceedings{hagg98,
author = {Daniel H\"{a}ggander and  Lars Lundberg},
title = {Optimizing Dynamic Memory Management in a Multithreaded Application Executing on a Multiprocessor},
booktitle = {27th International Conference on Parallel Processing (ICPP)},
address = {Minneapolis, MN},
month = aug,
year = 1998,
URL = {http://www.ide.hk-r.se/~dha/icpp-98.ps}
}

@inproceedings{hagg99,
author = {Daniel H\"{a}ggander and  Lars Lundberg},
title = {Memory Allocation Prevented Telecommunication Application to be Parallelized for Better Database Utilization},
booktitle = {6th International Australasian Conference on Parallel and Real-Time
Systems (PART)},
address = {Melbourne},
month = nov,
year = 1999,
URL = {http://www.ide.hk-r.se/~dha/part-99.ps}
}

@inproceedings{hagg00,
author = {Daniel H\"{a}ggander and  Lars Lundberg},
title = {Attacking the Dynamic Memory Problem for {SMP}s},
booktitle = {13th International Conference on Parallel and Distributed Computing System (PDCS)},
year = 2000
}

@inproceedings{hagg01,
author = {Daniel H\"{a}ggander and Per Liden and Lars Lundberg},
title = {A Method for Automatic Optimization of Dynamic Memory Management in {C++}},
booktitle = {30th International Conference on Parallel Processing (ICPP)},
address = {Valencia, Spain},
month = sep,
year = 2001,
URL = {http://www.ide.hk-r.se/~dha/icpp-01.ps}
}

@techreport{hall96,
author = {Niels Hallenberg},
title = {A Region Profiler for a {S}tandard {ML} Compiler Based on Region Inference},
type = {Student Project},
number = {96--5--7},
institution = DIKU,
month = jun,
year = 1996
}

@mastersthesis{hall99,
author = {N. Hallenberg},
title = {Combining Garbage Collection and Region Inference in the {ML} {K}it},
school = DIKU,
month = jun,
year = 1999,
URL = {http://www.it-c.dk/people/nh/mypapers/root260699-a4.ps.gz}
}

@inproceedings{hall02,
  title =	 {Combining Region Inference and Garbage Collection},
  author =	 {Niels Hallenberg and Martin Elsman and Mads Tofte},
  crossref =	 {PLDI02},
  pages =	 {141--152},
  doi =		 {10.1145/512529.512547},
  abstract =	 {This paper describes a memory discipline that combines
                  region-based memory management and copying garbage
                  collection by an extension of Cheney's copying garbage
                  collection algorithm. The paper presents empirical evidence
                  that region inference very significantly reduces the number
                  of garbage collections; and evidence that the fastest
                  execution is obtained by using regions alone, without
                  garbage collection.  The memory discipline is implemented
                  for Standard ML in the ML Kit compiler and measurements show
                  that for a variety of benchmarks, code generated by the
                  compiler is as efficient, both with respect to execution
                  time and memory usage, as programs compiled with a
                  state-of-the-art Standard ML compiler.}
}

@inproceedings{halp84,
title = "The Semantics of Local Storage, or What Makes the Free-List Free?",
author = "Joseph Y. Halpern and Albert R. Meyer and B. A. Trakhtenbrot",
crossref = "POPL84",
pages = "245--257"
}

@techreport{hals78,
author = "Robert H. Halstead",
title = "Multiple-Processor Implementations of Message Passing Systems",
institution = MITLCS,
number = "TR--198",
month = Apr,
year = 1978
}

@inproceedings{hals84,
author = "Robert H. Halstead",
title = "Implementation of {M}ultilisp: {L}isp on a Multiprocessor",
crossref = "LFP84",
doi={10.1145/800055.802017},
pages={9--17}
}

@article{hals85,
title = "Multilisp: A Language for Concurrent Symbolic Computation",
author = "Robert H. Halstead",
journal = TOPLAS,
publisher = ACM,
year = "1985",
month = oct,
volume = 7,
number = 4,
pages = "501--538",
doi={10.1145/4472.4478},
abstract = {MULTILISP is a dialect of LISP (actually a version of the SCHEME dialect)
with added constructs for parallel execution. MULTILISP has been
implemented on the 32-processor Concert multiprocessor. It is destined for
implementation on larger multiprocessors.
The principal language extension provided by MULTILISP is ``future (x).''
Upon executing ``future (x),'' an immediate ``undetermined'' value is
returned. The computation of ``x'' occurs in parallel and the result
replaces ``undetermined'' when complete. Of course, any use of the result
would block the parent process until the computation is finished.
The paper goes into great detail discussing the motivating issues in
parallel language design. The author includes an excellent set of
references on competing work. The author discusses the issues of lazy
evaluation, resource allocation, and implementation. The implementation
issues include intermediate instruction-set architecture (MCODE),
synchronization, implementation of futures, task management, heap
management, and garbage collection. The author also presents
performance
analysis based on the number of processors and the granularity of the
parallelism in the algorithm (number of futures).
The paper is well written, with extensive footnotes and references. A
background in LISP fundamentals and the issues involved in distributed
processing will be helpful, but is not necessary.}
}

@inproceedings{hami92,
author = {T. Hamid and M.K. Crowe},
title = {Garbage Collection in Large Scale Distributed Object Stores},
booktitle = {Objects in Large Distributed Applications (OLDA II) --- OOPSLA'92},
year = 1992,
}

@mastersthesis{hami97,
title = {Measuring the Performance of Disk Garbage Collectors: Garbage Collecting Persistent {J}ava Stores},
author = {Craig Hamilton},
school = {University of Glasgow},
year = 1997,
URL = {http://www.dcs.gla.ac.uk/~craig/project/thesis.ps.gz}
}

@inproceedings{hami90,
author = "G. W. Hamilton and Simon B. Jones",
title = "Compile-Time Garbage Collection by Necessity Analysis",
crossref = "glasgow90",
pages = "66--70",
}

@techreport{hami90a,
author = "G. W. Hamilton and Simon B. Jones",
title = "Compile-Time Garbage Collection by Necessity Analysis",
institution = "Department of Computer Science and Mathematics, University of Stirling",
number = 67,
year = 1990
}

@phdthesis{hami93,
author = "G. W. Hamilton",
title = "Compile-Time Optimisation of Store Usage in Lazy Funtional Programs",
school = "University of Stirling",
year = 1993
}

@inproceedings{hami95,
title = "Compile-Time Garbage Collection for Lazy Functional Languages",
author = "G. W. Hamilton",
crossref = "IWMM95",
pages = {119--144},
doi = {10.1007/3-540-60368-9_21}
}

@inproceedings{hamm08,
title = {Memory Management for Self-Adjusting Computation},
author = {Matthew Hammer and Umut Acar},
crossref = {ISMM08},
pages = {51--60},
doi = {10.1145/1375634.1375642},
abstract = {The cost of reclaiming space with traversal-based garbage
collection is inversely proportional to the amount of free memory,
i.e., O(1/(1-f)), where f is the fraction of memory that is live.
Consequently, the cost of garbage collection can be very high when
the size of the live data remains large relative to the available
free space. Intuitively, this is because allocating a small amount
of memory space will require the garbage collector to traverse a
significant fraction of the memory only to discover little garbage.
This is unfortunate because in some application domains the size
of the memory-resident data can be generally high. This can cause
high GC overheads, especially when generational assumptions do not
hold. One such application domain is self-adjusting computation,
where computations use memory-resident execution traces in order
to respond to changes to their state (e.g., inputs) efficiently.
This paper proposes memory-management techniques for self-adjusting
computation that remain efficient even when the size of the live
data is large. More precisely, the proposed techniques guarantee
O(1) amortized cost for each reclaimed memory object. We propose a
set of primitives for self-adjusting computation that support the
proposed memory management techniques. The primitives provide an
operation for allocating memory; we reclaim unused memory automatically.
We implement a library for supporting the primitives in the C
language and perform an experimental evaluation. Our experiments
show that the approach can be implemented with reasonably small
constant-factor overheads and that the programs written using the
library behave optimally. Compared to previous implementations, we
measure up to an order of magnitude improvement in performance and
up to a 75\% reduction in space usage.}
}

@unpublished{hamm94,
author = "Kevin Hammond and Geoff L. Burn and D. B. Howe",
title = "Spiking Your Caches",
note = "Glasgow University",
year = 1994
}

@mastersthesis{hamp03,
author = {Matthew Hampton},
title = {Using Contaminated Garbage Collection and Reference Counting Garbage
Collection to Provide Automatic Reclamation for Real-Time Systems},
school = {Washington University},
year = 2003,
url =
{http://cse.seas.wustl.edu/Research/FileDownload.asp?263#search=%22Using%20Contaminated%20Garbage%20Collection%20and%20Reference%20Counting%20Garbage%20Collection%20to%20Provide%20Automatic%20Reclamation%20for%20Real-Time%20Systems%22}
}

@inproceedings{hamz10,
author = {Hamza, H. and Counsell, S.},
title = {The Impact of Varying Memory Region Numbers and Nesting on {RTSJ}
Execution Time},
booktitle = {Proceedings of the 3rd International Conference on Computer and
Electrical Engineering (ICCEE 2010)},
year = 2010
}

@inproceedings{hamz10a,
author = {Hamza, H. and Counsell, S.},
title = {Improving the Performance of Scoped Memory in {RTSJ} Applications},
booktitle = {Proceedings of the 36th EUROMICRO Conference on Software
Engineering and Advanced Applications (SEAA 2010)}, 
year = 2010
}

@inproceedings{hamz11,
author = {Hamza, H. and Counsell, S.},
title = {Using Scoped Memory in {RTSJ} Applications: Dynamic Analysis of Memory Consumption}, 
booktitle = {Proceedings of the 37th EUROMICRO Conference on Software
Engineering and Advanced Applications},
year = 2011
}

@inproceedings{han06,
title = {An Intelligent Garbage Collection Algorithm for Flash Memory Storages},
author = {Long-zhe Han and Yeonseung Ryu and Tae-sun Chung and Myungho Lee and Sukwon
Hong},
booktitle = {Computational Science and its Applications, ICCSA 2006},
series = LNCS,
volume = 3980,
publisher = SV,
year = 2006,
pages = {1018--1027},
doi = {10.1007/11751540_111}
}

@inproceedings{han06a, 
author = {Longzhe Han and Yeonseung Ryu and Keunsoo Yim},
title = {{CATA}: A Garbage Collection Scheme for Flash Memory File Systems},
booktitle = {Ubiquitous Intelligence and Computing},
series = LNCS, 
year = 2006,
publisher = SV,
volume = 4159,
doi = {0.1007/11833529_11},
abstract = {The problem of flash memory is that it cannot be overwritten unless
erased in advance. In order to avoid having to erase during every update,
non-in-place-update schemes have been widely used. In case of non-in-place
update mechanism, garbage collection is needed to reclaim the obsolete space. In
this paper, we study a new garbage collection scheme to reduce its cost such as
the number of erase operations and the number of data copies. The proposed
scheme determines the victim blocks by exploiting usage information of data
blocks such as age, utilization and erase count. In addition, the proposed
scheme predicts the future I/O workload and controls the number of victims to
avoid disturbing the normal I/O operations. Experimental results show that the
proposed scheme can perform well especially when the degree of locality is
high.}
}

@inproceedings{hann95,
author = {J. Hannon},
title = {A Type-based Analysis for Stack Allocation in Functional Languages},
booktitle = {2nd International Static Analysis Symposium (SAS)},
series = LNCS,
volume = 983,
pages = {172--188},
mon = sep,
publisher = {Springer},
year = 1995
}

@article{hans77,
author = "David R. Hanson",
title = "Storage Management for an Implementation of {SNOBOL4}",
journal = SPE,
publisher = Wiley,
volume = 7,
number = 2,
pages = "179--192",
year = "1977",
doi={10.1002/spe.4380070206},
comment = {variant of Deutsch-Schorr-Waite algorithm for varisized cells.},
}

@article{hans90,
author = "David R. Hanson",
title = "Fast Allocation and Deallocation of Memory Based on Object Lifetimes",
journal = SPE,
publisher = Wiley,
volume = 20,
number = 1,
pages = "5--12",
month = jan,
year = "1990",
abstract = {This paper describes a simple algorithm that is very efficient
when there are only a few object lifetimes.
In terms of instructions executed per byte allocated, the algorithm is almost
half the cost of quick fit and less than twice the cost of stack allocation.
Space for all objects with the same lifetime is allocated from a list of large
arenas, and the entire list is deallocated at once.
An implementation in ANSI C is included}
}

@mastersthesis{hans92,
title = "The Impact of Programming Style on the Performance of {S}cheme Programs",
author = "Lars Thomas Hansen",
school = "University of Oregon",
month = aug,
year = 1992,
comment = "
My M.S. thesis asks this -- and some related -- questions for some smaller
programs (more representative of inner loops than entire applications) for
several types of garbage collectors, generational and not. The basic answer
is that given a generational collector, unless you can guarantee that the
data you're mutating lives in the youngest generation (where mutation is
cheap), consing is likely to be competitive in terms of performance. ",
URL = "ftp://ftp.cs.uoregon.edu/pub/lth"
}

@phdthesis{hans00,
author = "Lars Thomas Hansen",
title = {Older-first Garbage Collection in Practice},
school = {Northeastern University},
month = nov,
year = 2000
}

@inproceedings{hans02,
  author =	 {Lars Thomas Hansen and William D. Clinger},
  title =	 {An Experimental Study of Renewal-Older-First Garbage
                  Collection},
  crossref =	 {ICFP02},
  pages =	 {247--258},
  doi =		 {10.1145/581478.581502}
}

@article{hans69,
author = "Wilfred J. Hansen",
title = "Compact List Representation: Definition, Garbage Collection, and System Implementation",
journal = CACM,
publisher = ACM,
volume = 12,
number = 9,
month = sep,
year = 1969,
pages = "499--507",
}

@article{harr99,
  author =	 {Timothy Harris},
  title =	 {Early storage reclamation in a tracing garbage collector},
  journal =	 SIGPLAN,
  publisher =	 ACM,
  volume =	 34,
  number =	 4,
  pages =	 {46--53},
  month =	 apr,
  year =	 1999,
  URL =		 {http://www.cl.cam.ac.uk/~tlh20/partitioned-gc.ps.gz},
  abstract =	 {This article presents a technique for allowing the early
                  recovery of storage space occupied by garbage data.  The
                  idea is similar to that of generational garbage collection,
                  except that the heap is partitioned based on a static
                  analysis of data type definitions rather than on the
                  approximate age of allocated objects.  A prototype
                  implementation is presented, along with initial results and
                  ideas for future work.}
}

@inproceedings{harr00,
author = {Timothy Harris},
title = {Dynamic Adaptive Pre-Tenuring},
pages = {127--136},
crossref = {ISMM2000},
doi={10.1145/362422.362476},
abstract = {
In a generational garbage collector, a pre-tenured object is one that is
allocated directly in the old generation. Pre-tenuring long-lived objects can
reduce the number of times that they are scanned or copied during garbage
collection. Previous work has investigated pre-tenuring based on off-line
analysis of execution traces. In contrast, this paper presents a dynamic
technique in which the decision to pre-tenure a particular kind of object is
taken at run-time. This allows decisions to depend on the inputs of a
particular application run and also allows decisions to be changed as the
application enters different phases. An implementation is presented for the
Java Virtual Machine. }
}

@techreport{harr06,
author = {Tim Harris},
title = {Leaky Regions: Linking Reclamation Hints to Program Structure},
month = jun,
year = 2006,
institution = {Microsoft Research},
number = {MSR-TR-2006-84},
URL = {http://research.microsoft.com/~tharris/papers/2006-leaky-tr.pdf}
}

@inproceedings{harr02,
  author =	 {Timothy L. Harris and Keir Fraser and Ian A. Pratt},
  title =	 {A Practical Multi-word Compare-and-Swap Operation},
  booktitle =	 {International Conference on Distributed Computing},
  pages =	 {265--279},
  year =	 2002,
  editor =	 {Dahlia Malkhi},
  volume =	 2508,
  series =	 lncs,
  address =	 {Toulouse, France},
  month =	 oct,
  doi =		 {10.1007/3-540-36108-1_18}
}

@inproceedings{harr03,
  author =	 {Tim Harris and Keir Fraser},
  title =	 {Language Support for Lightweight Transactions},
  crossref =	 {OOPSLA03},
  pages =	 {388--402},
  doi =		 {10.1145/949305.949340}
}

@techreport{harr98,
title = {Applet Lifecycle in {N}etscape {C}ommunicator},
author = {Warren Harris},
institution = {Netscape Communications Corporation},
number = {TN-JAVA-05-9707 },
URL = {http://developer.netscape.com:80/docs/technote/java/appletlife.html},
year = 1998
}

@misc{harr98a,
title = {The Design and Implementation of the {S}port {M}odel Garbage Collector},
author = {Warren Harris},
institution = {Netscape Communications Corporation},
month = jan # "19",
year = 1998,
howpublished = "incomplete draft"
}

@article{harl87,
  title =	 "{OBJEKT} --- A Persistent Object Store with an Integrated
                  Garbage Collector",
  author =	 "David M. Harland and Brune Beloff",
  pages =	 "70--79",
  journal =	 SIGPLAN,
  publisher =	 ACM,
  year =	 1987,
  volume =	 22,
  number =	 4
}

@techreport{harm89,
author = "Harms, Douglas E.",
title = "Efficient Initialization and Finalization of Data Structures: Why and How",
institution = "Ohio State University, Computer and Information Science Research Center",
year = 1989,
number = "OSU-CISRC-3/89-TR11",
month = feb
}

% crossref to the Fourth edition, 1974
@inproceedings{hart64,
author = "Timothy P. Hart and Thomas G. Evans",
title = "Notes on Implementing {LISP} for the {M--460} Computer",
pages = "191--203",
crossref = "berk74",
comment = "Uses a two pointer compactifying algorithm."
}

@phdthesis{hart88,
author = "Pieter H. Hartel",
title = "Performance Analysis of Storage Management in Combinator Graph
Reduction",
school = "Department of Computer Systems, University of Amsterdam",
address = "Amsterdam",
year = "1988",
abstract = {Fixed-set combinators slower because of the placeholders required to
transport arguments rather than small grain size.
Cycles in Turner combinator machines are caused more by recursive function
definitions than by cyclic data structures.
Fewer than 10 percent nodes shared (average RC = 1.2) }
}

@article{hart90,
title = "A Comparison Of 3 Garbage Collection Algorithms",
author = "Pieter H. Hartel",
address = "University of Amsterdam, Department of Computer Systems, Netherlands",
journal = "Structured Programming",
year = 1990,
volume = 11,
number = 3,
pages = "117--127",
abstract = {Compares RC, MS and Copying. Claims it is unnecessary to reclaim cycles as few
are cyclic data structures, most are recursive definitions (Turner m/c).
RC best for snug fit (store = =number of objects), all 3 the same for 2*size,
MS slightly faster than copying, more store doesn't necessarily improve
matters.  Not terribly interesting }
}

@inproceedings{hart94,
author = {Pieter H. Hartel and Marc Feeley and Martin Alt and Lennart
                  Augustsson and Peter Baumann and Marcel Beemster and
                  Emmanuel Chailloux and Christine H. Flood and Wolfgang
                  Grieskamp and John H. G. van Groningen and Kevin Hammond and
                  Bogumi\l Hausman and Melody Y. Ivory and Peter Lee and
                  Xavier Leroy and Sandra Loosemore and Niklas R\"{o}jemo and
                  Manuel Serrano and Jean-Pierre Talpin and Jon Thackray and
                  Pierre Weis and Peter Wentworth},
title = "Pseudoknot: A Float-Intensive Benchmark for Functional Compilers",
booktitle = "6th Implementation of Functional Languages",
editor = "J. R. W. Glauert",
publisher = "School of Information Systems, University of East Anglia, Norwich, UK",
month = Sep,
year = 1994,
pages = "13.1--13.34",
URL = "ftp.fwi.uva.nl:pub/computer-systems/functional/packages/pseudoknot.tar.Z"
}

@article{hart96,
author = {Pieter H. Hartel and Marc Feeley and Martin Alt and Lennart
                  Augustsson and Peter Baumann and Marcel Beemster and
                  Emmanuel Chailloux and Christine H. Flood and Wolfgang
                  Grieskamp and John H. G. van Groningen and Kevin Hammond and
                  Bogumi\l Hausman and Melody Y. Ivory and Richard Jones and
                  Peter Lee and Xavier Leroy and Rafael Lins and Sandra
                  Loosemore and Niklas R\"{o}jemo and Manuel Serrano and
                  Jean-Pierre Talpin and Jon Thackray and Stephen P. Thomas
                  and Pierre Weis and Peter Wentworth},
title = {Benchmarking Implementations of Functional Languages with
                  `{P}seudoknot', a Float-Intensive Benchmark},
journal = JFP,
publisher = CUP,
year = 1996,
volume = 6,
number = 4
}

@inproceedings{harv98,
  title =	 {Compiler-Controlled Memory},
  author =	 {Keith D. Cooper and Timothy J. Harvey},
  crossref =	 {ASPLOS98},
  pages =	 {2-11},
  doi =		 {10.1145/291069.291010}
}

@inproceedings{hasa04,
author = {Yusuf Hasan and J.  Morris Chang},
title = "A Hybrid Allocator",
booktitle = {IEEE International Symposium on Performance Analysis of Systems and Software (ISPASS)},
address = {Austin, TX},
month = mar,
year = 2003
}

@inproceedings{hast92,
author = "Reed Hastings and Bob Joyce",
title = "Fast Detection of Memory Leaks and Access Errors",
booktitle = "Winter {USENIX} Conference",
publisher = UA,
pages = "125--136",
year = 1992,
URL = "http://www.pureatria.com/products/purify/fast_detection.html",
comment = "Purify leak detector"
}

@manual{hat,
title = "Java Heap Analysis Tool ({HAT})",
key = "HAT",
organization = "Sun Microsystems",
note = {http://java.sun.com/people/billf/heap/},
URL = {http://java.sun.com/people/billf/heap/},
comment = {Tool for reading -Xhprof files}
}

@article{hatt87,
title = "{AI} Machine",
author = "A. Hattori and H. Masuzawa and H. Hayashi",
journal = "Fujitsu Scientific and Technical Journal",
volume = 23,
number = 4,
pages = "369--378",
year = 1987,
abstract = {The paper describes the system configuration of the FACOM alpha
Lisp machine and compares the FACOM alpha architecture with that of a
general-purpose computer.  It also covers CPU performance and the interaction
between the garbage collector and the virtual memory system.  The paper also
describes a parallel AI machine developed to operate according to a new parallel
inference method called KABU-WAKE.  The important features of this method and a
performance evaluation of the experimental machine are presented.  Tests
indicate that, for large problems, it is possible to obtain a level of
performance proportional to the number of processor elements used.}
}

@mastersthesis{haug99,
author = {Scott Haug},
title = {Automatic Storage Optimization via Garbage Collection},
school = {Washington University, St Louis},
year = 1999
}

@techreport{have97,
author = {Klaus Havelund and N. Shankar},
title = {A Mechanized Refinement Proof for a Garbage Collector},
institution = {Aalborg University},
year = 1997,
note = {Submitted to Formal Aspects of Computing},
URL = {http://ic-www.arc.nasa.gov/ic/projects/amphion/people/havelund/Publications/gc-refine-report.ps}
}

@inproceedings{have99,
author = {Klaus Havelund},
title = {Mechanical Verification of a Garbage Collector},
booktitle = {Parallel and Distributed Processing}, 
note = {11th IPPS/SPDP'99 Workshops held in conjunction with the 
        13th International Parallel Processing Symposium and
        10th Symposium on Parallel and Distributed Processing}, 
address = {San Juan, Puerto Rico}, 
series = lncs, 
volume = 1586, 
pages = {1258--1283}, 
month = apr, 
year = 1999,
URL = {http://ic-www.arc.nasa.gov/ic/projects/amphion/people/havelund/Publications/gc-fmppta99.ps},
doi = {10.1007/BFb0098007},
}

@inproceedings{hawb04,
author = {Chris Hawblitzel and Edward Wei and Heng Huang and Eric Krupski and Lea Wittie},
title = {Low-Level Linear Memory Management},
crossref = {SPACE04},
}

@inproceedings{hawb06,
title = {Linear Types for Aliased Resources},
author = {Chris Hawblitzel},
pages = {105--107},
crossref = {SPACE06}
}
@inproceedings{hawb07,
title = {A Garbage-Collecting Typed Assembly Language},
author = {Chris Hawblitzel and Heng Huang and Lea Wittie and Juan Chen},
booktitle = {ACM SIGPLAN Workshop on Types in Language Design and
Implementation},
address = {Nice, France},
month = jan,
year = 2007,
URL = {http://research.microsoft.com/~chrishaw/talgc2/gctal-tldi.pdf},
abstract = {Abstract Typed assembly languages usually support heap allocation
safely, but often rely on an external garbage collector to deallocate objects
from the heap and prevent unsafe dangling pointers. Even if the external garbage
collector is provably correct, verifying the safety of the interaction between
TAL programs and garbage collection is nontrivial. This paper introduces a typed
assembly language whose type system is expressive enough to type-check a
Cheney-queue copying garbage collector, so that ordinary programs and garbage
collection can co-exist and interact inside a single typed language. The only
built-in types for memory are linear types describing individual memory words,
so that TAL programmers can define their own object layouts, method table
layouts, heap layouts, and memory management techniques.}
}

@inproceedings{hawb09,
title = {Automated Verification of Practical Garbage Collectors},
author = {Chris Hawblitzel and Erez Petrank},
crossref = {POPL09},
pages = {441--453},
doi = {10.1145/1480881.1480935},
abstract = {Garbage collectors are notoriously hard to verify, due to their
low-level interaction with the underlying system and the general difficulty in
reasoning about reachability in graphs. Several papers have presented verified
collectors, but either the proofs were hand-written or the collectors were too
simplistic to use on practical applications. In this work, we present two
mechanically verified garbage collectors, both practical enough to use for
real-world C$\sharp$ benchmarks. The collectors and their associated allocators consist
of x86 assembly language instructions and macro instructions, annotated with
preconditions, postconditions, invariants, and assertions. We used the Boogie
verification generator and the Z3 automated theorem prover to verify this
assembly language code mechanically. We provide measurements comparing the
performance of the verified collector with that of the standard Bartok
collectors on off-the-shelf C# benchmarks, demonstrating their competitiveness.}
}


@techreport{haya,
author = "H. Hayashi and A. Hattori and H. Akimoto",
title = "{ALPHA}: High-Performance {L}isp Machine equipped with a New Stack
Structure and Real-Time Garbage Collection System",
institution = "Fujitsu Laboratories",
type = "Draft report",
comment = "cited by Moon84"
}

@inproceedings{haye90,
author = "Barry Hayes",
title = "Open Systems Require Conservative Garbage Collectors",
crossref = "OOPSLA90-gc",
}

@inproceedings{haye91,
author = "Barry Hayes",
title = "Using Key Object Opportunism to Collect Old Objects",
crossref  = "OOPSLA91",
pages = {33--46},
doi={10.1145/117954.117957},
comment = "Objects may tend to survive or die in groups in memory."
}

@inproceedings{haye92,
title = "Finalization in the Collector Interface",
author = "Barry Hayes",
crossref = "IWMM92",
pages={277--298},
doi={10.1007/BFb0017196},
}

@phdthesis{haye93,
author = "Barry Hayes",
title = "Key Objects in Garbage Collection",
school = "Stanford University",
month = mar,
year = 1993
}

@inproceedings{haye97,
title = {Ephemerons: A New Finalization Mechanism},
author = "Barry Hayes",
pages = {176--183},
crossref = {OOPSLA97},
doi={10.1145/263698.263733}
}

@inproceedings{haze09,
title = {Scalable Support for Multithreaded Applications on Dynamic Binary Instrumentation Systems},
author = {Kim Hazelwood and Greg Lueck and Robert Cohn},
pages = {20--29},
doi = {10.1145/1542431.1542435},
crossref = {ISMM09}
}

@inproceedings{heck92,
title = "An Implementation of an Applicative File System",
author = "Brian C. Heck and David S. Wise",
crossref = "IWMM92",
pages = {248--263},
doi = {10.1007/BFb0017194}
}

@mastersthesis{hede88,
title = "Compile-time Garbage Collection Using Reference Count Analysis",
author = "Lucy Hederman",
school = Rice,
month = Aug,
year = 1988,
URL = {https://www.cs.tcd.ie/Lucy.Hederman/LHMScDissertation.pdf},
note = "Also Rice University Technical Report TR88--75 but,
according to Rice University's technical report list, this report is no longer
available for distribution",
abstract = "Storage management overhead accounts for a
considerable proportion of execution time in straightforward
implementations of languages with dynamic storage allocation.
Our approach to reducing this overhead is to shift some of the
work to compile time.  With static reference count analysis, we
determine when an object becomes inaccessible, and insert
explicit deallocation code into the program at those points.
This will reduce the frequency and number of garbage collections
at run time.  We discuss previous approaches to storage analysis
and show that reference count analysis can allow more precise
modeling of storage accessibility that other approaces.
The analysis is extended to the interprocedural case.  It is
formulated as a set of path problems on a specially designed
summary graph.  The effectiveness of our implemented optimization
on a variety of programs is presented.",
}


@techreport{heeb91,
author = "Beat Heeb and Cuno Pfister",
title = "Oberon Technical Notes: An Integrated Heap Allocator/Garbage Collector",
pages = "30--39",
month = mar,
URL = "ftp://neptune.inf.ethz.ch/doc/tech-reports/1991/156.ps.Z",
year = 1991,
type = "ETH Technical Report",
number = 156,
institution = {ETH Eidgen\"{o}ssische Technische Hochschule Z\"{u}rich}
}

@inproceedings{heil00,
author = {Timothy Heil and James  E. Smith},
title = {Concurrent Garbage Collection using Hardware Assisted Profiling},
pages = {80--93},
crossref = {ISMM2000},
abstract = {
Virtual machines (VMs) execute programs coded in one instruction set
architecture (ISA), the virtual ISA (V-ISA), on hardware directly
supporting another implementation ISA (I-ISA). Co-designed VMs are
designed together with the underlying hardware to provide high
performance in a general-purpose environment. The I-ISA and
micro-architecture evolve together with the VM to aid those tasks the VM
must perform. Conversely, the VM is designed to improve processor
performance through dynamic recompilation, instruction hint bits, and
pipeline tuning. Unlike the single-threaded execution common today, VMs
have the potential to provide many service threads of execution. VM tasks
such as profile collection and analysis, dynamic optimization, and garbage
collection are conceptually parallel to program execution. Instead of
stopping the application to perform these tasks, service threads execute
these tasks concurrently. Hardware assisted profiling, in addition to playing
an important role in dynamic optimization, provides the communication
mechanism that holds the system together. A robust profiling mechanism
enables VM service threads to remotely monitor application execution
without impacting application performance. The Relational Profiling
Architecture (RPA) was designed from the top down to serve this purpose.
RPA is analogous to a relational database. Instructions selected for profiling
produce a record of information. A simple query engine examines these
records for patterns, and performs simple actions on matching records. The
power and flexibility of RPA is demonstrated by developing a concurrent
generational garbage collector for Java. Detailed execution driven
simulations show that this collector has an average runtime overhead of
0.6\%. The short pauses in the application required for synchronization with
the GC are typically less than 0.1ms, given a 1GHz clock frequency. }
}

@inproceedings{hein01,
  author =	 {Nevin Heintze and Olivier Tardieu},
  title =	 {Demand-Driven Pointer Analysis},
  crossref =	 {PLDI01},
  pages =	 {24-34},
  doi =		 {10.1145/378795.378802}
}

@inproceedings{hein01a,
  author =	 {Nevin Heintze and Olivier Tardieu},
  title =	 {Ultra-fast Aliasing Analysis using {CLA}: A Million Lines of
                  {C} Code in a Second},
  crossref =	 {PLDI01},
  pages =	 {254-263},
  doi =		 {10.1145/378795.378855}
}

@inproceedings{hell10,
author = {Hellyer, Laurence and Jones, Richard and Hosking, Antony L.},
title = {The Locality of Concurrent Write Barriers},
crossref = {ISMM10},
pages = {83--92},
doi = {10.1145/1806651.1806666},
abstract = {Concurrent and incremental collectors require barriers to ensure
correct synchronisation between mutator and collector. The overheads imposed by
particular barriers on particular systems have been widely studied. Somewhat
fewer studies have also compared barriers in terms of their termination
properties or the volume of floating garbage they generate. Until now, the
consequences for locality of different barrier choices has not been studied,
although locality will be of increasing importance for emerging architectures.
This paper provides a study of the locality of concurrent write barriers,
independent of the processor architecture, virtual machine, compiler or garbage
collection algorithm.},
}

@inproceedings{hels01,
author = {Simon Helsen},
title = {Syntactic Type Soundness for the Imperative Region Calculus},
crossref = {SPACE01},
}

@inproceedings{hend95,
author = "Fergus Henderson and Thomas Conway and Zoltan Somogyi",
title = "Compiling logic programs to {C} using {GNU} {C} as a portable assembler",
booktitle = "{ILPS'95} Post-conference Workshop on Sequential Implementation Technologies for Logic Programming",
address = "Portland, Or",
pages = "1--15",
URL = "http://www.cs.mu.oz.au/mercury/papers/mercury_to_c.ps.gz",
year = 1995
}

@inproceedings{hend02,
title = {Accurate Garbage Collection in an Uncooperative Environment},
author = {Fergus Henderson},
crossref = {ISMM02},
pages = {150--156},
doi={10.1145/512429.512449}
}

@phdthesis{hend90,
author = "Laurie J. Hendren",
title = "Parallelizing Programs with Recursive Data Structures",
year = 1990,
month = apr,
comment = "Not about memory allocation per se, but the analysis is
useful for that application",
school = Cornell
}

@mastersthesis{heng88,
author = "Seng-Lai Heng",
title = "Performance Evaluation of Numerous Garbage Collections by Real-Time Simulation",
school = "University of Texasat Austin",
year = 1988
}

@inproceedings{heng01,
author = {Fritz Henglein and Henning Makholm and H. Niss},
title = {A Direct Approach to Control-Flow Sensitive Region-Based Memory
Management},
booktitle = {International Conference on Principles and Practice of Declarative
Programming (PPDP)},
year = 2001,
pages = {175--186}
}

@inproceedings{henn93,
author = "Wade Hennessey",
title = "Real-Time Garbage Collection in a Multimedia Programming Language",
crossref = "OOPSLA93-gc",
}

@book{henn96,
author = "John L. Hennessy and David A. Patterson",
title = "Computer Architecture: A Quantitative Approach",
publisher = "Morgan Kaufman",
edition = "Second",
year = 1996
}

@article{henni98,
title = {Binding, Migration and Scalability in {CORBA}},
author = {Michi Henning},
journal = CACM,
number = 10,
volume = 41,
month = oct,
year = 1998,
pages = {62--71},
comment = {Brief account of some of the issues facing GC in CORBA}
}

@inproceedings{henr94,
author = "Roger Henriksson",
title = "Scheduling Real-Time Garbage Collection",
booktitle = "Proceedings of NWPER'94",
address = "Lund, Sweden",
year = 1994,
URL = "http://www.dna.lth.se/Research/ProgEnv/Papers/LU-CS-TR:94-129.ps"
}

@mastersthesis{henr96,
author = "Roger Henriksson",
title = "Scheduling Real-Time Garbage Collection",
school = "Department of Computer Science, Lund University",
year = 1996,
type = "Licentiate thesis",
URL = "http://www.dna.lth.se/Research/ProgEnv/Abstracts/Thesis.RH.abs.html",
note = "Lund technical report LU-CS-TR:96-161"
}

@techreport{henr96a,
author = "Roger Henriksson",
title = "Adaptive Scheduling of Incremental Copying Garbage Collection for Interactive Applications",
institution = Lund,
number = "96--174",
URL="ftp://mjolner.dna.lth.se/HD/ftp/pub/papers/LU-CS-TR.96-174.ps",
year = 1996
}

@inproceedings{henr97,
author = {Roger Henriksson},
title = {Predictable Automatic Memory Management for Embedded Systems},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/henriksson.ps},
crossref = {OOPSLA97-gc}
}

@phdthesis{henr98,
author = {Roger Henriksson},
title = {Scheduling  Garbage Collection in Embedded Systems},
school = {Lund Institute of Technology},
month = jul,
year = 1998,
URL = {http://www.dna.lth.se/home/Roger_Henriksson/}
}

@inproceedings{herh10,
  author = {S. Herhut and C. Joslin and S.B. Scholz and R. Poss and C. Grelck},
  title = {Concurrent Non-Deferred Reference Counting on the {M}icrogrid: First Experiences},
  editor = {J. Haage and M. Moraz\'an },
  booktitle = {22nd International Symposium on
               Implementation and Application of Functional Languages (IFL'10)},
  address = {Alphen a/d Rijn, Netherlands},
  publisher = {Springer},
  series = LNCS,
  volume = 6647,
  year = 2011,
  pages = {185-202},
  doi = {10.1007/978-3-642-24276-2},
  note = {Revised Selected Papers},
}

@techreport{herl90,
author = "Herlihy, Maurice and Moss, J. Eliot B",
title = "Non-Blocking Garbage Collection for Multiprocessors",
institution = "DEC Cambridge Research Laboratory",
number = "CRL 90/9",
year = 1990
}

@article{herl90a,
author    = {Maurice Herlihy and Jeannette M. Wing},
title     = {Linearizability: A Correctness Condition for Concurrent Objects},
journal   = TOPLAS,
volume    = 12,
number    = 3,
year      = 1990,
pages     = {463--492},
doi       = {10.1145/78969.78972}
}

@article{herl92,
author = "Herlihy, Maurice and Moss, J. Eliot B",
title = "Lock-Free Garbage Collection for Multiprocessors",
journal = "IEEE Transactions on Parallel and Distributed Systems",
pages = {304--311},
publisher = IEEE,
volume = 3,
number = 3,
month = may,
year = 1992,
doi={10.1109/71.139204}
}

@inproceedings{herl93,
author = "Maurice P. Herlihy and J. Eliot B. Moss",
title = "Transactional Memory: Architectural Support for Lock-Free Data Structures",
pages =  "289--300",
crossref = {ISCA93},
doi={10.1145/165123.165164}
}

@inproceedings{herl02,
author = {Maurice P. Herlihy and Victor Luchangco and Mark Moir},
title = {The Repeat Offender Problem: A Mechanism for Supporting Dynamic-Sized
Lock-Free Data Structures},
booktitle = {16th International Symposium on Distributed Computing},
pages = {339--353},
address = {Toulouse, France},
month = oct,
year = 2002,
publisher = SV,
series = LNCS,
volume = 2508,
doi={10.1007/3-540-36108-1_23},
URL = {research.sun.com/people/moir/Papers/ROPDISC.pdf}
}

@techreport{herl02a,
author = {Maurice P. Herlihy and Paul Martin and Victor Luchangco and Mark Moir},
title = {Dynamic-Sized and Lock-Free Data Structures},
number = {TR--2002--110},
institution = {Sun Microsystems Laboratories},
month = jun,
year = 2002,
URL = {http://labs.oracle.com/techrep/2002/abstract-110.html},
abstract = {We address the problem of integrating lock-free shared data
structures with standard dynamic allocation mechanisms (such as malloc and
free).
We have two main contributions. The first is the design and experimental
analysis of two dynamic-sized lock-free FIFO queue implementations, which extend
Michael and Scott's previous implementation by allowing unused memory to be
freed. We compare our dynamic-sized implementations to the original on
16-processor and 64-processor multiprocessors. Our experimental results indicate
that the performance penalty for making the queue dynamic-sized is modest, and
is negligible when contention is not too high. These results were achieved by
applying a solution to the Repeat Offender Problem (ROP), which we recently
posed and solved.
Our second contribution is another application of ROP solutions. Specifically,
we show how to use any ROP solution to achieve a general methodology for
transforming lock-free data structures that rely on garbage collection into ones
that use explicit storage reclamation.}
}

@book{herl08,
title = {The Art of Multiprocessor Programming},
author = {Maurice Herlihy and Nir Shavit},
month = apr,
year = 2008,
publisher = MK,
isbn = 0123705916
}

@inproceedings{hert02,
title = {Error-Free Garbage Collection Traces: How to Cheat and Not Get Caught},
author = {Matthew Hertz and Steve M. Blackburn and K. S. McKinley and J. Eliot
B. Moss and Darko Stefanovi\'{c}},
booktitle = SIGMETRICS,
address = {Marina Del Rey, CA},
month = jun,
year = 2002,
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/sigmetrics-2002-merlin.ps.gz}
}

@inproceedings{hertz02a,
author = {Matthew Hertz and N. Immerman and J. Eliot B. Moss},
title = {Framework for Analyzing Garbage Collection},
booktitle = {2nd IFIP Theoretical Computer Science Congress},
year = 2002,
pages = {230--241},
publisher = Kluwer,
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/tcs-2002-framework.ps.gz}
}

@techreport{hert04,
title = {Page-Level Cooperative Garbage Collection},
author = {Matthew Hertz and Yi Feng and Emery Berger},
institution = UMass,
number = {CS TR-04-16},
year = 2004,
URL = {http://www.cs.umass.edu/~emery/pubs/04-16.pdf},
}

@techreport{hert04a,
title = {Automatic vs. Explicit Memory Management: Settling the Performance Debate},
author = {Matthew Hertz and Emery Berger},
institution = UMass,
number = {CS TR-04-17},
year = 2004,
URL = {http://www.cs.umass.edu/~emery/pubs/04-17.pdf},
}

@inproceedings{hert05,
  title =	 {Garbage Collection Without Paging},
  author =	 {Matthew Hertz and Yi Feng and Emery D. Berger},
  crossref =	 {PLDI05},
  pages =	 {143-153},
  doi =		 {10.1145/1064978.1065028},
}

@inproceedings{hert05a,
title = {Quantifying the Performance of Garbage Collection vs. Explicit Memory Management},
author = {Matthew Hertz and Emery Berger},
doi={10.1145/1094811.1094836},
pages={313--326},
crossref = {OOPSLA05},
abstract = {Garbage collection yields numerous software engineering
benefits, but its quantitative impact on performance remains elusive. One
can measure the cost of conservative garbage collection relative to
explicit memory management in C/C++ programs by linking in an appropriate
collector. This kind of direct comparison is not possible for languages
designed for garbage collection (e.g., Java), because programs in these
languages naturally do not contain calls to free. Thus, the actual gap
between the time-space performance of explicit memory management and
precise, copying garbage collection remains unknown.

We take the first steps towards quantifying the performance of precise
garbage collection versus explicit memory management. We present a novel
experimental methodology that lets us treat unaltered Java programs as
if they used explicit memory management. Our system generates exact
object reachability information by processing heap traces with the
Merlin algorithm. It then re-executes the program, invoking free on
objects just before they become unreachable. Since this point is the
latest that a programmer could explicitly free objects, our approach
conservatively approximates explicit memory management. By executing
inside an architecturally-detailed simulator, this ``oracular'' memory
manager eliminates the effects of trace processing while measuring the
costs of calling malloc and free.

We compare explicit memory management to both copying and non-copying
garbage collectors across a range of benchmarks, and include non-simulated
runs that validate our results. Our results quantify the time-space
tradeoff of garbage collection: with five times as much memory, the
Appel-style generational garbage collector matches the performance of
explicit memory management. With only three times as much memory, it runs
on average 17\% slower than explicit memory management. However, with only
twice as much memory, garbage collection degrades performance by nearly
70\%. When physical memory is scarce, paging causes garbage collection
to run an order of magnitude slower than explicit memory management.},
}

@article{hert06,
author = {Matthew Hertz and Stephen M. Blackburn and J. Eliot B. Moss and
Kathryn McKinley and Darko Stefanovi\'{c}},
title = {Generating Object Lifetime Traces with {M}erlin},
journal = TOPLAS,
volume = 28,
number = 3,
month = may,
year = 2006,
pages = {476--516}
}

@phdthesis{hert06b,
title = {Quantifying and Improving the Performance of Garbage Collection},
author = {Matthew Hertz},
school = UMass,
year = 2006,
month = sep,
pages = 152,
url={http://www-cs.canisius.edu/~hertzm/thesis.pdf}
}

@techreport{hert09,
title = "Waste Not, Want Not --- Resource-based Garbage Collection in a Shared Environment",
author = "Matthew Hertz and Jonathan Bard and Stephen Kane and Elizabeth Keudel and Tongxin Bai and Kirk Kelsey and Chen Ding",
institution = "The University of Rochester",
number = "TR--951",
month = dec,
year = 2009,
doi = {1802/8838},
comment = "time/memory curves, like our allocation curves. Looks at how to allocate RAM to Java programs, given contention for physical memory",
}

@inproceedings{hert11,
  author =	 {Matthew Hertz and Stephen Kane and Elizabeth Keudel and
                  Tongxin Bai and Chen Ding and Xiaoming Gu and Jonathan
                  E. Bard},
  title =	 {Waste Not, Want Not: Resource-Based Garbage Collection in a
                  Shared Environment},
  crossref =	 {ISMM11},
  pages =	 {65--76},
  doi =		 {10.1145/1993478.1993487}
}

@article{hess01,
author = {Wim H. Hesselink and  Jan Friso Groote},
title = {Wait-Free Concurrent Memory Management by Create and Read until Deletion ({CaRuD})},
journal = {Distributed Computing},
volume = 14,
number = 1,
pages = {31--39},
year = 2001
}

@article{hess10,
author = {Wim H. Hesselink and M. I. Lali},
title = {Simple Concurrent Garbage Collection Almost Without Synchronization},
journal = {Formal Methods of System Design},
volume = 36,
number = 2,
pages = {148--166},
year = 2010,
doi={10.1007/s10703-009-0083-z}
}

@article{hewi77,
author = "Carl Hewitt",
title = "Viewing Control Structures as Patterns of Passing Messages",
journal = "Journal of Artificial Intelligence",
volume = 8,
number = 3,
pages = "323--364",
month = Jun,
year = 1977
}

@article{heym91,
title = "A Comprehensive Analytical Model for Garbage Collection Algorithms",
author = "J. Heymann",
journal = Sigplan,
publisher = ACM,
year = 1991,
volume = 26,
number = 8,
pages = "50--59"
}

@inproceedings{hibi80,
author = "Y. Hibino",
title = "A Practical Parallel Garbage Collection Algorithm and its
Implementation",
booktitle = "7th Annual " # ISCA,
pages = "113--120",
year = 1980,
month = may
}

@article{hick84,
title = "Performance Analysis of On-The-Fly Garbage Collection",
author = "Tim Hickey and Jacques Cohen",
journal = CACM,
publisher = ACM,
year = 1984,
month = nov,
volume = 27,
number = 11,
pages = "1143--1154",
comment = "Comparision of Dijkstra, Kung \& Song and classical mark-scan.
Upper limit on speedup was 150 percent."
}

@inproceedings{hick93,
title = "Experiences with Compiler-Directed Storage Reclamation",
author = "James Hicks",
address = "Motorola Cambridge Research Center",
crossref = "FPCA93",
}

@inproceedings{hick97,
title = {The Measured Cost of Copying Garbage Collection Mechanisms},
author = {Michael W. Hicks and Jonathan T. Moore and Scott M. Nettles},
pages = {292--305},
crossref = {ICFP97},
URL = {http://www.cis.upenn.edu/~oscar/icfp97.ps}
}

@inproceedings{hick98,
author = {Michael Hicks and Luke Hornof and Jonathan T. Moore and Scott Nettles },
title = {A Study of {L}arge {O}bject {S}paces},
pages = {138--145},
crossref = {ISMM98},
doi = {10.1145/286860.286875},
URL = {http://www.cis.upenn.edu/~oscar/ismm98.ps},
abstract = {Using a separate non-copy collected space for large objects
can result in significant performance improvements for copying garbage
collectors. Such collectors are a specific instance of a broad class of
collectors that mix copying and non-copying collection. Unfortunately
the published literature provides limited guidance about how to design
a large object space (LOS).
This paper surveys the LOS design space, and identifies a wide variety
of issues that might affect its design. It then places the literature
into this framework.
The main contribution of the paper is an examination of some LOS design
issues using the Oscar GC testbed. For this work, we have extended
Oscar to support a number of possible LOS designs. Our experiments are
run on benchmark heap snapshots, with varying policies for selecting
``large'' objects, as well as varying the non-copying GC technique used
for collecting them.
Our selection policies include varying size thresholds, as well as
whether or not the large objects may contain pointers. We also compare
a treadmill collector with a mark-and-sweep collector for the large
object space. Our benchmark heaps include those taken from instrumented
SML/NJ and JDK runtimes, and are run on Pentium II-based Linux
platforms.
Our initial experimental results indicate that in fact, there is a
tradeoff point for the hybrid collectors.  At least in some cases, as
the ``large'' objects become smaller, the benefits of avoiding copies
become unimportant. These findings are not substantially changed by
allowing pointer-containing large objects, although the tradeoff point
shifts, and our results suggest that pointer-full objects should be
included in the LOS. Our result are not sensitive to the collection
technique used for the LOS. }
}

@inproceedings{hick04,
author = {Michael Hicks and Dan Grossman and Trevor Jim},
title = {Combining Garbage Collection and Safe Manual Memory Management},
crossref = {SPACE04},
}

@inproceedings{hick04a,
title = {Experience with Safe Manual Memory-Management in {C}yclone},
author = {Michael Hicks and Greg Morrisett and Dan Grossman and Trevor Jim},
pages = {73--84},
crossref = {ISMM04}
}

@article{hieb90,
  title =	 "Representing Control in the Presence of First-Class
                  Continuations",
  author =	 "R. Hieb and R. K. Dybvig and C. Bruggeman",
  journal =	 SIGPLAN,
  publisher =	 ACM,
  volume =	 25,
  number =	 6,
  pages =	 "66--77",
  year =	 1990
}

@phdthesis{hiep91,
author = {Van Nguyen Hiep},
title = {Compilation et Environment d'Execution d'un Langage \`{a} Base d'Objects},
school = {Institut National Polytechnique de Grenoble},
month = feb,
year = 1991
}

@inproceedings{higu01a,
author = {M. Teresa Higuera-Toledano and Valerie Issarny},
title = {Analyzing the Performance of Memory Management in {RTSJ}},
crossref = {ISORC01},
doi = {10.1109/ISORC.2002.1003657},
abstract = {The memory models used in the Real-Time Specification for Java
(RTSJ) can incur high amounts of overhead; It is possible to reduce this
overhead by taking advantages of hardware features. This paper provides an
indepth analytical investigation of the overhead of write barriers in RTSJ VMs,
and describes and analyzes some solutions to reduce the overhead of write
barriers.}
}

@article{higu02,
author = {M. Teresa Higuera and Valerie Issarny and Michel Banatre and Gilbert Cabillic and Jean-Philippe Lesot and Frederic Parain},
title = {Memory Management for Real-Time {J}ava: an Efficient Solution using Hardware Support},
journal = {Real-Time Systems Journal},
year = 2002,
URL = {http://www-rocq.inria.fr/arles/doc/doc.html}
}

@article{higu03,
author = {M. Teresa Higuera},
title = {Memory Management Design to the Concurrent Execution of {RTSJ} Applications},
crossref = {JTRES03},
pages = {479--489},
URL = {http://asds.dacya.ucm.es/lib/exe/fetch.php?id=publications%3Ajava&cache=cache&media=publications:java:jtres_03.1.pdf}
}

@article{higu04,
title = {Memory Management for Real-Time {J}ava: an Efficient Solution Using
Hardware Support},
author = {M. Teresa Higuera-Toledano and Valerie Issarny and Michel Banatre and Gilbert Cabillic and Jean-Philippe Lesot and Frederic Parain},
journal   = {Real-Time Systems Journal},
volume    = {26},
number    = {1},
year      = {2004},
pages     = {63--87},
doi       = {10.1023/B:TIME.0000009306.22263.59},
publisher = {Kluwer},
URL = {http://asds.dacya.ucm.es/lib/exe/fetch.php?id=publications%3Ajava&cache=cache&media=publications:java:rt-journal.pdf}
}


@article{higu05,
author = {M. Teresa Higuera and Valerie Issarny},
title = {Improving the Memory Management Performance of {RTSJ}},
journal = CPE,
publisher = Wiley,
year = 2005,
URL = {http://asds.dacya.ucm.es/lib/exe/fetch.php?id=publications%3Ajava&cache=cache&media=publications:java:jgj.pdf}
}

@inproceedings{higu06,
author = {M. Teresa Higuera-Toledano},
title = {Towards an Analysis of Garbage Collection Techniques for Embedded
Real-Time {J}ava Systems},
booktitle = {12th international Conference on Embedded and Real-Time Computing Systems and Applications},
pages = {97-100},
publisher = IEEE,
year = 2006,
URL = {http://asds.dacya.ucm.es/lib/exe/fetch.php?id=publications%3Ajava&cache=cache&media=publications:java:rctas_06.pdf}
}

@inproceedings{higu06a,
author = {M. Teresa Higuera-Toledano},
title = {Analyzing the Memory Management Semantic and Requirements of the
{R}eal-{T}ime Specification of {J}ava},
crossref = {ISORC06},
pages = {419--423},
URL = {http://asds.dacya.ucm.es/lib/exe/fetch.php?id=publications%3Ajava&cache=cache&media=publications:java:isorc06.pdf}
}

@inproceedings{higu06b,
author = {M. Teresa Higuera-Toledano},
title = {The Indeterministic Behaviour of Scoped Memory in {R}eal-{T}ime {J}ava},
booktitle = {4th ACS/IEEE International Conference on Computer Systems and Applications (AICCSA-06)},
pages = {656--664},
publisher = IEEE,
year = 2006,
URL = {http://asds.dacya.ucm.es/lib/exe/fetch.php?id=publications%3Ajava&cache=cache&media=publications:java:aiccsa_06.pdf}
}

@inproceedings{higu07,
author = {M. Teresa Higuera-Toledano},
title = {Name-Based Write Barriers in Real-Time {J}ava},
booktitle = {IEEE international Conference on Computer and Information Technology (CIT-07)},
pages = {781-786},
publisher = IEEE,
year = 2007
}

@inproceedings{higu07a,
author = {M. Teresa Higuera-Toledano},
title = {Allowing Cycle's References among Scoped Memory Areas in the
{R}eal-{T}ime {S}pecification for {J}ava},
crossref = {ISORC07},
pages = {110-114},
}

@inproceedings{higu07b,
author = {M. Teresa Higuera-Toledano},
title = {Improving the Scoped Memory Region Garbage Collector of Real-Time {J}ava},
editor ={Olivier Zendra},
booktitle ={Implementation, Compilation, Optimization of Object-Oriented
Languages, Programs and Systems ({ICOOOLPS}'2006)},
pages = {1--14},
address = {Nantes, France},
month = jul,
year = 2006,
URL = {http://asds.dacya.ucm.es/lib/exe/fetch.php?id=publications%3Ajava&cache=cache&media=publications:java:higuera_icooolps_2006.pdf}
}

@inproceedings{higu08,
author = {M. Teresa Higuera-Toledano},
title = {Allowing Cycle References by Introducing Controlled Violations of the
Assignment Rules in Real-Time {J}ava},
crossref = {ISORC08},
pages = {463--467},
}

@inproceedings{higu11,
author = {M. Teresa Higuera-Toledano},
title = {Using Transactional Memory to Synchronize an Adaptive Garbage Collector in Real-Time {J}ava},
booktitle = {2nd IEEE Workshop on Self-Organizing Real-Time Systems},
address = {Newport Beach, CA},
month = mar,
year = 2011,
URL = {http://polaris.dit.upm.es/~str/jtr11/papers/003.pdf}
}

@phdthesis{hill87,
author = "Mark D. Hill",
title = "Aspects of Cache Memory and Instruction Buffer Performance",
school = UCB,
month = nov,
year = 1987,
note = "Also UCB/CSD Technical report 87/381"
}

@article{hill88,
author = "Hill, Mark D.",
title = "A Case for Direct-Mapped Caches",
journal = "IEEE Computer",
publisher = IEEE,
volume = 21,
number = 12,
month = Dec,
year = 1988,
pages = "25--40"
}

@article{hill89,
author = "Hill, Mark D. and Alan Jay Smith",
title = "Evaluating Associativity in {CPU} Caches",
journal = IEEETransComp,
publisher = IEEE,
volume = 38,
number = 12,
month = Dec,
year = 1989,
pages = "1612--1629"
}

@article{hind75,
author = "J. A. Hinds",
title = "An Algorithm for Locating Adjacent Storage Blocks in the Buddy System",
journal = CACM,
volume = 18,
number = 4,
year = 1975,
publisher = ACM,
month = apr,
pages = "221--222"
}

@inproceedings{hind01,
title = {Pointer Analysis: Haven't We Solved This Problem Yet?},
author = {Michael Hind},
crossref = {PASTE01},
pages = {54--61},
doi = {10.1145/379605.379665},
URL = {http://www.research.ibm.com/people/h/hind/paste01.ps},
abstract = {During the past twenty-one years, over seventy-five papers
and nine Ph.D. theses have been published on pointer analysis. Given
the tomes of work on this topic one may wonder, ``Haven't we solved
this problem yet?'' With input from many researchers in the field, this
paper describes issues related to pointer analysis and remaining open
problems.}
}

@article{hirs73,
author = "D. S. Hirschberg",
title = "A Class of Dynamic Memory Allocation Algorithms",
journal = CACM,
publisher = ACM,
month = oct,
year = 1973,
volume = 16,
number = 10,
pages = "615--618",
doi={10.1145/362375.362392}
}

@inproceedings{hirz00,
author = {Martin Hirzel and Amer Diwan},
title = {On the Type Accuracy of Garbage Collection},
pages = {1--11},
crossref = {ISMM2000},
abstract = {
We describe a novel approach to obtaining type-accurate information for
garbage collection in a hardware and language independent way. Our
approach uses a run-time analysis to propagate pointer/non-pointer
information from significant type events (such as allocation, which
always returns a pointer). We use this technique to perform a detailed
comparison of garbage collectors with different levels of accuracy and
explicit deallocation on a range of C programs. We take advantage of
the portability of our approach to conduct our experiments on three
hardware platforms, Alpha/Digital UNIX 4.0D, Pentium/Linux 2.2, and
SPARC/Solaris 2. We find that the choice of hardware platform (which
includes the architecture, operating system, and libraries) greatly
affects whether or not type-accuracy enhances a garbage collector's
ability to reclaim objects.  }
}

@mastersthesis{hirz00a,
author = {Martin Hirzel},
title = {Effectiveness of Garbage Collection and Explicit Deallocation},
school = {University of Colorado},
year = 2000,
URL = {http://csel.cs.colorado.edu/~hirzel/papers/index.htm}
}

@inproceedings{hirz01,
author = {Martin Hirzel and Amer Diwan and Antony L. Hosking},
title = {On the Usefulness of Liveness for Garbage Collection and Leak Detection},
crossref = {ECOOP01},
doi = {10.1007/3-540-45337-7_11}
}

@inproceedings{hirz02,
title = {Understanding the Connectivity of Heap Objects},
author = {Martin Hirzel and Johannes Henkel and Amer Diwan and Michael Hind},
crossref = {ISMM02},
pages = {36--49}
}

@article{hirz02a,
title = {On the Usefulness of Type and Liveness for Garbage Collection and Leak Detection},
author = {Martin Hirzel and Amer Diwan and Johannes Henkel},
journal = TOPLAS,
publisher = ACM,
volume = 24,
number = 6,
month = nov,
year = 2002,
pages = {593--624}
}

@inproceedings{hirz03,
title = {Connectivity-based Garbage Collection},
author = {Martin Hirzel and Amer Diwan and Matthew Hertz},
doi={10.1145/949305.949337},
pages={359--373},
crossref = {OOPSLA03}
}

@techreport{hirz03a,
title = {Choosing a Set of Partitions to Collect in a Connectivity-Based Garbage
Collector},
author = {Martin Hirzel and Harold N. Gabow and Amer Diwan},
institution = {University of Colorado},
number = {CU--CS--958--03},
month = aug,
year = 2003,
URL = {https://researcher.ibm.com/researcher/files/us-hirzel/CU-CS-958-03.pdf}
}

@inproceedings{hirz04,
title = {Pointer Analysis in the Presence of Dynamic Class Loading},
author = {Martin Hirzel and Amer Diwan and Michael Hind},
crossref = {ECOOP04},
URL = {http://www-plan.cs.colorado.edu/diwan/ecoop04-pointers-2up.pdf}
}

@phdthesis{hirz04a,
author = {Martin Hirzel},
title = {Connectivity-Based Garbage Collection},
school = {University of Colorado at Boulder},
month = jul,
year = 2004,
URL = {http://www-plan.cs.colorado.edu/diwan/hirzel-dissertation.pdf}
}

@inproceedings{hirz07,
title = {Data Layouts for Object-Oriented Programs},
author = {Martin Hirzel},
booktitle = SIGMETRICS,
page = {265--276},
month = jun,
year = 2007,
doi = {10.1145/1254882.1254915},
note = {This paper plus a 2-page appendix is available as IBM Research Report
RC24218, Watson.}
}

@article{hirz07a,
title = {Fast Online Pointer Analysis},
author = {Martin Hirzel and Daniel von Dincklage and Amer Diwan and Michael
Hind},
journal = TOPLAS,
month = apr,
year = 2007,
doi = {10.1145/1216374.1216379}
}

@article{hoar69,
author = "C. A. R. Hoare",
title = "An Axiomatic Basis for Computer Programming",
journal = CACM,
volume = 12,
publisher = ACM,
month = oct,
year = 1969
}

@article{hoar74,
author = "C. A. R. Hoare",
title = "Optimisation of Store Size for Garbage Collection",
journal = IPL,
publisher = NH,
volume = 2,
number = 6,
month = Apr,
year = 1974,
pages = "165--166",
}

@inproceedings{hoar09,
  author =	 {C. A. R. Hoare},
  title =	 {Null References: The Billion Dollar Mistake},
  booktitle = {Proceedings of QCon},
  year =	 2009,
  series =	 {Historically Bad Ideas},
  address =	 {London, UK},
  month =	 mar,
  abstract =	 {I call it my billion-dollar mistake. It was the invention of
                  the null reference in 1965. At that time, I was designing
                  the first comprehensive type system for references in an
                  object oriented language (ALGOL W). My goal was to ensure
                  that all use of references should be absolutely safe, with
                  checking performed automatically by the compiler. But I
                  couldn't resist the temptation to put in a null reference,
                  simply because it was so easy to implement. This has led to
                  innumerable errors, vulnerabilities, and system crashes,
                  which have probably caused a billion dollars of pain and
                  damage in the last forty years. In recent years, a number of
                  program analysers like PREfix and PREfast in Microsoft have
                  been used to check references, and give warnings if there is
                  a risk they may be non-null. More recent programming
                  languages like Spec# have introduced declarations for
                  non-null references. This is the solution, which I rejected
                  in 1965.}
}

@inproceedings{hofm01,
author = {Martin Hofmann},
title = {A Type System for Controlling Heap Space and its Translation to {J}ava{C}ard},
crossref = {SPACE01},
}

@inproceedings{hofm03,
title = {Static Prediction of Heap Usage for First-Order Functional Programs},
author = {Martin Hofman and Steffen Jost},
crossref = {POPL03}
}

@techreport{hoge93,
author = "Hogen, Guido and Loogen, Rita",
title = "A New Stack Technique for the Management of Runtime Structures in Distributed Implementations",
institution = "{RWTH} {A}achen",
year = 1993,
address = "{A}hornstr. 55, 52056 {A}achen, {G}ermany",
URL = "ftp://ftp.informatik.rwth-aachen.de/pub/reports/1993/93-03.ps.gz",
number = "93-3",
type = "{A}achener {I}nformatik-{B}erichte"
}

@inproceedings{hoge94,
author = "Hogen, Guido and Loogen, Rita",
title = "Efficient Organization of Control Structures in Distributed Implementations",
year = 1994,
URL = "ftp://ftp.informatik.rwth-aachen.de/pub/reports/others/cc94.ps.gz",
editor = "Fritzson, Peter A.",
pages = "98--112",
publisher = SV,
series = LNCS,
volume =  786,
booktitle = "Compiler Construction"
}

@techreport{hoge94a,
author = "Hogen, Guido and Loogen, Rita",
institution = "{RWTH} {A}achen",
title = "Parallel Functional Implementations: Graphbased vs. Stackbased Reductions",
year = 1994,
address = "ghogen@zesu.informatik.rwth-aachen.de, lllgen@informatik.uni-marburg.de"
}

@techreport{holl80,
author = "Jack Holloway and Guy L. Steele and Gerald Jay Sussman and Alan Bell",
title = "The {SCHEME}--79 Chip",
institution = "MIT AI Laboratory",
type = "AI Memo",
number = 559,
month = jan,
year = 1980,
comment = "Danvy says 80 per cent of time spent in GC."
}

@inproceedings{holm83,
title = "A Simple and Efficient Way to Handle Large Datastructures in Applicative Languages",
author = {S. Holmstr\"{o}m},
booktitle = "Joint {SERC}/{C}halmers Workshop on Declarative Programming, {U}niversity {C}ollege, {L}ondon",
year = 1983
}

@article{holt61,
author = "Anatol W. Holt",
title = "Program Organization and Record Keeping for Dynamic Storage Allocaton",
journal = CACM,
publisher = ACM,
volume = 4,
number = 10,
month = oct,
year = 1961
}

@inproceedings{holz91,
author = {Urs H\"{o}lzle},
title = "The Myth of High Object Creation Rates",
crossref = "OOPSLA91-gc",
}

%also available from http://www.cs.ucsb.edu/oocsb/papers/write-barrier.html
@inproceedings{holz93,
author = {Urs H\"{o}lzle},
title = "A Fast Write Barrier for Generational Garbage Collectors",
crossref = "OOPSLA93-gc",
URL = "ftp://self.stanford.edu/pub/papers/write-barrier.ps.Z"
}

@inproceedings{holz95,
author = {Urs H\"{o}lzle and David Ungar},
title = "Do Object-Oriented Languages Need Special Hardware Support?",
crossref = "ECOOP95",
}

@book{horo77,
author = "E. Horowitz and  S. Sahni",
title = "Fundamentals of Data Structures",
publisher = "Computer Science Press",
address = "Woodland Hills, CA",
year = 1977,
comment = {book with sections on garbage collection},
}

@article{hors87,
title = "Analysis and Development of Demand Prepaging Policies",
author = "R. Nigel Horspool and Ronald M. Huberman",
journal = JSS,
year = 1987,
volume = 7,
pages = "183-194"
}

@inproceedings{horw89,
  author =	 "Susan Horwitz and Phil Pfeiffer and Thomas W. Reps",
  title =	 "Dependence Analysis for Pointer Variables",
  crossref =	 "PLDI89",
  pages =	 "28--40",
  doi =		 {10.1145/73141.74821}
}

@inproceedings{hosk91,
  author =	 "Antony L. Hosking",
  title =	 "Main Memory Management for Persistence",
  crossref =	 "OOPSLA91-gc",
  URL =		 "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/hosking.ps"
}

@inproceedings{hosk92,
author = {Antony L. Hosking and J. Eliot B. Moss and Darko Stefanovi\'{c}},
title = "A Comparative Performance Evaluation of Write Barrier Implementations",
crossref = "OOPSLA92",
pages = "92--109",
doi={10.1145/141936.141946},
URL = "ftp://ftp.cs.umass.edu/pub/osl/papers/oopsla92.ps.Z"
}

@inproceedings{hosk93,
author = "Antony L. Hosking and Richard L. Hudson",
title = "Remembered Sets Can Also Play Cards",
crossref = "OOPSLA93-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC93/hosking.ps"
}

@inproceedings{hosk93a,
  title =	 "Object Fault Handling for Persistent Programming Languages:
                  A Performance Evaluation",
  author =	 "Antony L. Hosking and J. Eliot B. Moss",
  crossref =	 "OOPSLA93",
  doi =		 {10.1145/165854.165907}
}

@inproceedings{hosk93b,
  title =	 "Protection Traps and Alternatives for Memory Management of
                  an Object-Oriented Language",
  author =	 "Antony L. Hosking and J. Eliot B. Moss",
  crossref =	 "SOSP93",
  pages =	 {106--119},
  doi =		 {10.1145/168619.168628},
  URL =		 {ftp://ftp.cs.umass.edu/pub/osl/papers/sosp93.ps.Z}
}

@techreport{hosk95,
title = {Lightweight Write Detection and Checkpointing for Fine-Grained Persistence},
author = {Antony L. Hosking and J. Eliot B. Moss},
institution = Purdue,
number = {95-084},
year = 1995,
UTL = {ftp://ftp.cs.purdue.edu/pub/hosking/papers/tods.ps.gz}
}

@inproceedings{hosk97,
author = {Antony L. Hosking and Aria P. Novianto},
title = {Reachability-based Orthogonal Persistence for {C}, {C++} and Other Intransigents},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/hoskings.ps},
crossref = {OOPSLA97-gc}
}

@inproceedings{hosk98,
title = {Optimizing the Read and Write Barrier for Orthogonal Persistence},
author = {Antony L. Hosking and Nathaniel Nystrom and Quintin Cutts and Kumar Brahnmath},
crossref = {POS98},
pages = {149--159},
URL = {ftp://ftp.cs.purdue.edu/pub/hosking/papers/pos98.ps.gz}
}

@inproceedings{hosk99,
  title =	 {Mostly-Copying Reachability-Based Orthogonal Persistence},
  author =	 {Antony L. Hosking and Jiawan Chen},
  crossref =	 {OOPSLA99},
  pages =	 {382--398},
  doi =		 {10.1145/320384.320427},
  comment =	 {Reachability-based orthogonal persistent system outperforms
                  C++ one}
}

@inproceedings{hosk06,
  title =	 {Portable, Mostly-Concurrent, Mostly-Copying Garbage
                  Collection for Multi-processors},
  author =	 {Antony L Hosking},
  pages =	 {40--51},
  crossref =	 {ISMM06},
  doi =		 {10.1145/1133956.1133963}
}

@inproceedings{hoso98,
author = {Haruo Hosoya and Akinori Yonezawa},
title = {Garbage Collection via Dynamic Type Inference --- A Formal Treatment},
booktitle = {2nd Workshop on Types in Compilation},
URL = {http://ftp.yl.is.s.u-tokyo.ac.jp/pub/papers/tigc98.ps.gz},
year = 1998,
pages = {215--239}
}

@misc{hotspot01,
author = {{Sun Microsystems}},
title = {The {J}ava {H}ot{S}pot {V}irtual {M}achine},
year = 2001,
note = {Technical White Paper}
}

@misc{hotspot06,
author = {{Sun Microsystems}},
title = {Memory Management in the {J}ava {H}ot{S}pot {V}irtual {M}achine},
month = apr,
year = 2006,
note = {Technical White Paper},
URL = {http://java.sun.com/j2se/reference/whitepapers/memorymanagement_whitepaper.pdf}
}

@misc{hotspot-gctune-se6,
author = {{Sun Microsystems}},
title = {{J}ava {SE}~6 {H}ot{S}pot Virtual Machine garbage Collection Tuning},
year = 2009,
URL ={http://java.sun.com/javase/technologies/hotspot/gc/gc_tuning_6.html}
}


@article{hsie97,
author = {Hsieh, Cheng-Hsueh A. and Conte, Marie T. and Johnson, Teresa L. and Gyllenhaal, John C. and Hwu, Wen-mei W.},
title = {Compilers for Improved {Ja}va Performance},
journal = {Computer},
volume = 30,
issue = 6,
month = jun,
year = 1997,
pages = {67--75},
doi = {10.1109/2.587551},
publisher = IEEEcomp,
}

@article{hu03,
author = {Hu, Y. Charlie and Yu, Weimin and Cox, Alan and Wallach, Dan and Zwaenepoel, Willy},
title = {Run-time Support for Distributed Sharing in Safe Languages},
journal = TransCompSys,
volume = 21,
issue = 1,
month = feb,
year = 2003,
issn = {0734-2071},
pages = {1--35},
doi = {10.1145/592637.592638},
publisher = ACM,
} 

@inproceedings{huan13,
author = {Huang, Jipeng and Bond, Michael D.},
title = {Efficient Context Sensitivity for Dynamic Analyses via Calling Context Uptrees and Customized Memory Management},
pages = {53--72},
doi = {10.1145/2544173.2509510},
crossref= {OOPSLA13},
abstract = {State-of-the-art dynamic bug detectors such as data race and memory
leak detectors report program locations that are likely causes of bugs. However,
programmers need more than static program locations to understand the behavior
of increasingly complex and concurrent software. Dynamic calling context
provides additional information, but it is expensive to record calling context
frequently, e.g., at every read and write. Context-sensitive dynamic analyses
can build and maintain a calling context tree (CCT) to track calling
context--but in order to reuse existing nodes, CCT-based approaches require an
expensive lookup.
This paper introduces a new approach for context sensitivity that avoids this
expensive lookup. The approach uses a new data structure called the calling
context uptree (CCU) that adds low overhead by avoiding the lookup and instead
allocating a new node for each context. A key contribution is that the approach
can mitigate the costs of allocating many nodes by extending tracing garbage
collection (GC): GC collects unused CCU nodes naturally and efficiently, and we
extend GC to merge duplicate nodes lazily.
We implement our CCU-based approach in a high-performance Java virtual machine
and integrate it with a staleness-based memory leak detector and happens-before
data race detector, so they can report context-sensitive program locations that
cause bugs. We show that the CCU-based approach, in concert with an extended GC,
provides a compelling alternative to CCT-based approaches for adding context
sensitivity to dynamic analyses.}
}

@inproceedings{huan04a,
author = {Wei Huang and Witiwas Srisa-an and J. Morris Chang},
title = {Adaptive Pretenuring for Generational Garbage Collection},
booktitle = {IEEE International Symposium on Performance Analysis of Systems and Software (ISPASS)},
address = {Austin, TX},
month = mar,
year = 2004,
pages = {133--140}
}

@inproceedings{huan04b,
author = {Wei Huang and Y. Qian and Witiwas Srisa-an and J. Morris Chang},
title = {Object Allocation and Memory Contention Study of {J}ava Multithreaded Application},
booktitle = {IEEE International Performance Computing and
Communications Conference (IPCCC)},
address = {Phoenix, AZ},
month = apr,
year = 2004
}

@techreport{huan03,
author = {Huang, Xianlong and Moss, J. Eliot B. and McKinley, Kathryn S. and Blackburn, Stephen M.  and Burger, D.},
title = {{D}ynamic {S}imple{S}calar: Simulating {J}ava Virtual Machines},
number = {TR--03--03},
institution = {University of Texas at Austin},
month = feb,
year = 2003
}

@inproceedings{huan04,
author = {Huang, Xianlong and Blackburn, Stephen M. and McKinley, Kathryn S. and  Moss, J. Eliot B. and Wang, Z. and Cheng, Perry},
title = {The Garbage Collection Advantage: Improving Program Locality},
pages = {69--80},
crossref = {OOPSLA04},
doi = {10.1145/1028976.1028983},
abstract = {As increases in processor speed continue to outpace increases in
cache and memory speed, programs are losing more performance to poor locality.
Because copying garbage collectors move objects, they have the opportunity to
improve locality for languages such as Java. This paper introduces a new dynamic,
online class analysis for finding and exploiting locality in a copying collector.
The analysis exploits method sampling in a JIT (just-in-time) optimizing compiler.
For each hot (frequently accessed) method, object reordering analysis marks the
class fields that the method accesses as hot. Then at garbage collection time,
the collector copies referents of hot fields together with their parent.
Enhancements to this basic technique include heuristics that decay heat to respond
to phase changes, group objects of hot classes together in a separate copy space,
and static analysis to exclude cold basic blocks from the reordering analysis. In
experiments with Jikes RVM using MMTk on a range of Java programs, the overhead of
dynamic class reordering is on average negligible and at most 1.9\%. We compare
class reordering with a number of static class oblivious orderings (e.g., breadth
and depth first). The overall time variation between static orderings can be up
to 25\% and there is no consistent winner. In contrast, dynamic class reordering
always matches or improves over the best static ordering since its history-based
copying order tunes memory layout to program traversal.}
}

@inproceedings{huan06,
title = {Fast and Efficient Partial Code Reordering: Taking Advantage of Dynamic Recompilation},
author = {Xianglong Huang and Stephen M Blackburn and David Grove and Kathryn S McKinley},
pages = {184--192},
crossref = {ISMM06},
}

@techreport{huda81,
author = "Paul R. Hudak",
title = "Call-graph reclamation: an alternative storage reclamation scheme",
type = "{AMPS} Technical Memorandum",
number = 4,
institution = "University of Utah",
month = aug,
year = 1981
}

@inproceedings{huda82,
author = "Paul R. Hudak and R. M. Keller",
title = "Garbage Collection and Task Deletion in Distributed Applicative
Processing Systems",
crossref = "LFP82",
pages = "168--178",
comment = "Deletes both unwanted objects and garbage tasks in a distributed
applicative system. Processing can continue during marking.",
}

@phdthesis{huda82a,
title = "Object and Task Reclamation in Distributed Applicative Processing Systems",
author = "Paul R. Hudak",
school = "University of Utah",
address = "Salt Lake City, Utah",
year = 1982
}

@techreport{huda83,
author = "Paul R. Hudak",
title = "Distributed Graph Marking",
institution = "University of Yale",
type = "Departmental Research Report",
number = 268,
year = 1983
}

@inproceedings{huda83a,
author = "Paul R. Hudak",
title = "Distributed Task and Memory Management",
booktitle = "ACM Symposioum on the Principles of Distributed Computing",
publisher = ACM,
month = aug,
year = 1983,
pages = "277--89"
}

@inproceedings{huda84,
author = "Paul Hudak and Adrienne Bloss",
title = "The Aggregate Update Problem in Functional Programming Systems",
year = 1985,
pages = "300--314",
crossref = "POPL84",
}

@inproceedings{huda86,
author = "Paul R. Hudak",
title = "A Semantic Model of Reference Counting and its Abstraction (detailed summary)",
crossref = "LFP86",
pages = "351--363",
abstract = {Compile-time garbage collection}
}

@incollection{huda87,
author = "Paul R. Hudak",
title = "A Semantic Model of Reference Counting and its Abstraction",
booktitle = "Abstract Interpretation of Declarative Languages",
editor = "Samson Abramsky and Chris Hankin",
publisher = "Ellis Horward",
pages = "45--62",
year = 1987,
abstract = "Compile-time garbage collection"
}

@article{huda92,
  author =	 "Paul Hudak and Peyton Jones, Simon L. and Phillip Wadler",
  title =	 "Report on the Programming Language {H}askell, a Non-strict
                  Purely Functional Language (Version 1.2)",
  journal =	 SIGPLAN,
  publisher =	 ACM,
  volume =	 27,
  number =	 5,
  month =	 may,
  year =	 1992
}

@inproceedings{huds90,
author = "Richard L. Hudson and Amer Diwan",
title = "Adaptive Garbage Collection for {M}odula-3 and {S}malltalk",
crossref = "OOPSLA90-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC90/Hudson.ps.Z"
}

@techreport{huds91,
title = "A Language-Independent Garbage Collector Toolkit",
author = "Hudson, Richard L. and J. Eliot B. Moss and Amer Diwan and Christopher F. Weight",
institution = UMass,
year = 1991,
number = "COINS 91-47",
month = sep,
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/tr9147.ps.Z},
abstract = "We describe a memory management toolkit for language
implementors.  It offers efficient and flexible generation
scavenging garbage collection.  In addition to providing a core
of language-independent algorithms and data structures, the
toolkit includes auxiliary components that ease implementation of
garbage collection for programming languages.  We have detailed
designs for Smalltalk and Modula-3 and are confident the toolkit
can be used with a wide variety of languages.  The toolkit
approach is itself novel, and our design includes a number of
additional innovations in flexibility, efficiency, accuracy, and
cooperation between the compiler and the collector."
}

@inproceedings{huds91a,
author = "Richard L. Hudson",
title = "Finalization in a Garbage Collected World",
crossref = "OOPSLA91-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/hudson.ps"
}

@inproceedings{huds92,
title = "Incremental Collection of Mature Objects",
author = "Richard L. Hudson and J. Eliot B. Moss",
crossref = "IWMM92",
pages={388--403},
doi = {10.1007/BFb0017203},
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/iwmm92.ps.Z},
abstract = "
We present a garbage collection algorithm
that extends generational scavenging to collect large older
generations ({\em mature objects}) non-disruptively.  The algorithm's
approach is to process bounded-size pieces of mature object space at
each collection; the subtleties lie in guaranteeing that it eventually
collects any and all garbage. The algorithm does not assume any
special hardware or operating system support, e.g., for forwarding
pointers or protection traps. The algorithm copies objects, so it
naturally supports compaction and reclustering."
}

@inproceedings{huds97,
title = {Garbage Collecting the World: One Car at a Time},
author = {Richard L. Hudson and Ron Morrison and J. Eliot B. Moss and David S. Munro},
crossref = {OOPSLA97},
URL = {http://www.dcs.st-and.ac.uk/research/publications/download/HMM+97b.pdf}
}

@techreport{huds97a,
title = {Training Distributed Garbage: The {DMOS} collector},
author = {Richard L. Hudson and Ron Morrison and J. Eliot B. Moss and David S. Munro},
institution = {University of St Andrews},
URL = {http://www.dcs.st-and.ac.uk/research/publications/download/HMM+97a.pdf},
year = 1997
}

@inproceedings{huds98,
title = {Where Have All The Pointers Gone?},
author = {Richard L. Hudson and Ron Morrison and J. Eliot B. Moss and David S. Munro},
booktitle = {21st Australasian Computer Science Conference (ACSC)},
address = {Perth},
pages = {107--119},
URL = {http://www.dcs.st-and.ac.uk/research/publications/download/HMM+98.pdf},
year = 1998
}

@inproceedings{huds00,
author = {Richard L. Hudson and J. Eliot B. Moss and Sreenivas Subramoney and Weldon Washburn},
title = {Cycles to Recycle: Garbage Collection on the {IA}-64},
pages = {101--110},
crossref = {ISMM2000},
abstract = {
The IA-64, Intel's 64-bit instruction set architecture, exhibits a number of
interesting architectural features. Here we consider those features as they
relate to supporting garbage collection (GC). We aim to assist GC and
compiler implementors by describing how one may exploit features of the
IA-64. Along the way, we record some previously unpublished object
scanning techniques, and offer novel ones for object allocation (suggesting
some simple operating system support that would simplify it) and the Java
"jsr" problem. We also discuss ordering of memory accesses and how the
IA-64 can achieve publication safety efficiently. While our focus is not on
any particular GC implementation or programming language, we draw on
our experience designing and implementing GC for the Intel Java Virtual
Machine for the IA-64.
}
}

@inproceedings{huds01,
title = {Sapphire: Copying {GC} Without Stopping The World},
author = {Richard L. Hudson and J. Eliot B. Moss},
booktitle = {Joint ACM-ISCOPE Conference on Java Grande},
address = {Palo Alto, CA},
month = jun,
year = 2001,
publisher = ACM,
pages = {48--57},
doi = {10.1145/376656.376810},
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/jgrande-2001.ps.gz}
}

@article{huds03,
title = {Sapphire: Copying Garbage Collection Without Stopping the World},
author = {Richard L. Hudson and J. Eliot B. Moss},
journal = CPE,
volume = 15,
number = {3--5},
pages = {223--261},
year = 2003,
doi = {10.1002/cpe.712},
abstract = {The growing use in concurrent systems of languages that require
garbage collection (GC), such as Java, is raising practical interest in
concurrent GC. Sapphire is a new algorithm for concurrent copying GC for Java.
It stresses minimizing the amount of time any given application thread may need
to block to support the collector. In particular, Sapphire is intended to work
well in the presence of a large number of application threads, on small- to
medium-scale shared memory multiprocessors.

Sapphire extends previous concurrent copying algorithms, and is most closely
related to replicating copying collection, a GC technique in which application
threads observe and update primarily the old copies of objects. The key
innovations of Sapphire are: (1) the ability to flip one thread at a time
(changing the thread's view from the old copies of objects to the new copies),
as opposed to needing to stop all threads and flip them at the same time; (2)
exploiting Java semantics and assuming any data races occur on volatile fields,
to avoid a barrier on reads of non-volatile fields; and (3) working in concert
with virtually any underlying (non-concurrent) copying collection algorithm.}
}

@inproceedings{huds06,
title = {{McRT}-Malloc --- A Scalable Transactional Memory Allocator},
author = {Richard L. Hudson and Bratin Saha and Ali-Reza Adl-Tabatabai and Benjamin Hertzberg},
pages = {74--83},
crossref = {ISMM06},
}

@article{huds92a,
author = "Hudson, S. and Hannah, J. M.",
address = "Roke Manor Research Ltd, Romsey, England",
title = "Structured Knowledge Manipulation System for Real-Time Engineering Applications",
year = 1992,
journal = "IEE Proceedings, Part E: Computers and Digital Techniques",
volume = 139,
number = 1,
month = jan,
pages = "59--63",
abstract = {A structured knowledge manipulation system (SKMS), which
incorporates a relational processing unit based on a
structured knowledge representation, providing real-time
relational accesses of a knowledge base, is described.
Direct hardware support is provided for set operations and
'between bounds' matching. Additionally, 'garbage
collection' is performed concurrently, with no memory
overheads and very little speed penalty. Experimental
results and projected performance figures are presented,
which demonstrate the suitability of the SKMS approach for
realtime applications. (Author abstract)}
}

@inproceedings{huel93,
author = "Lorenz Huelsbergen and James R. Larus",
title = "A Concurrent Copying Garbage Collector for Languages that Distinguish (Im)mutable Data",
crossref = "PPoPP93",
pages = "73--82",
comment = "Replication-based copying."
}

@inproceedings{huel98,
author = {Lorenz Huelsbergen and Phil Winterbottom},
title = {Very Concurrent Mark-\&-Sweep Garbage Collection without Fine-Grain Synchronization},
pages = {166--175},
crossref = {ISMM98},
abstract = {We describe a new incremental algorithm for the concurrent
reclamation of a program's allocated, yet unreachable, data. Our
algorithm is a variant of mark-\&-sweep collection that - unlike prior
designs - runs mutator, marker, and sweeper threads concurrently
without explicit fine-grain synchronization. A global, but infrequent,
synchronization coordinates the per-object coloring marks used by the
three threads; fine-grain synchronization is achieved without locking
via the basic memory consistency guarantees commonly provided by
multiprocessor hardware. We have implemented two versions of this
algorithm (called VCGC): in the Inferno operating system and in the
SML/NJ ML compiler. Measurements, compared to a sequential generational
collector, indicate that VCGC can substantially reduce worst-case pause
latencies as well as reduce overall memory usage. We remark that the
degrees of freedom on the rates of marking and sweeping enable
exploration of a range of resource tradeoffs, but makes ``optimal''
tuning for even a small set of applications difficult. }
}

@techreport{hugh83,
author = "R. John M. Hughes",
title = "Reference Counting with Circular Structures in Virtual Memory
Applicative Systems",
institution = "Programming Research Group, Oxford",
type = "Internal paper",
year = "1983"
}

@article{hugh82a,
title = "A Semi-Incremental Garbage Collection Algorithm",
author = "R. John M. Hughes",
journal = SPE,
publisher = Wiley,
year = 1982,
month = Nov,
volume = 12,
number = 11,
pages = "1081--1082",
doi={10.1002/spe.4380121108}
}

@inproceedings{hugh85,
author = "R. John M. Hughes",
title = "A Distributed Garbage Collection Algorithm",
crossref = "FPCA85",
pages = "256--272",
comment = "Uses time-stamps so that each local GC contributes to global GC.
Can take a long time for a GC to complete.
Not real-time.",
}

@techreport{hugh87,
author = "R. John M. Hughes",
title = "Managing Reduction Graphs with Reference Counts",
institution = "University of Glasgow",
type = "Departmental Research Report",
number = "CSC/87/R2",
month = mar,
year = "1987",
comment = {Based on \cite{bobr80}. Suitable for referentially
transparent languages}
}

@phdthesis{hugh91,
author = "Simon Hughes",
title = "Static Analysis of Store Use in Functional Programs",
school = "Imperial College, University of London",
year = 1991
}

@article{hugh92,
author = "Simon Hughes",
title = "Compile-Time Garbage Collection for Higher-Order Functional Languages",
journal = "Journal of Logic and Computation",
note = "Special Issue on Abstract Interpretation",
volume = 2,
number = 4,
pages = "483--509",
month = aug,
year = 1992,
}

@inproceedings{huit90,
author = "S. {Le Huitouze}",
title = "A New Data Structure for Implementing Extensions to {P}rolog",
booktitle = "International Workshop on Programming Languages Implementation
and Logic Programming",
series = LNCS,
volume = 456,
publisher = SV,
editor = {P. Deransart and J. Maluszy\'{n}ski},
year = 1990,
comment = "Some variable may be come irreversibly substituted.
Variable shunting.",
}

@inproceedings{hump97,
title = {A Framework for Storage Management Evaluation in Persistent Object Systems},
author = {Thorna O. Humphries and Alexander L. Wolf and Benjamin G. Zorn},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/zorn.ps},
crossref = {OOPSLA97-gc}
}

@techreport{hump00,
title = {{POSSE} Trace Format, Version 1.0},
author = {Thorna O. Humphries and Artur W. Klauser and Alexander L. Wolf and Benjamin G. Zorn},
number = {CU-CS-897-00},
institution = {University of Colorado, Boulder, CO},
month = jan,
year = 2000
}

@inproceedings{hund11,
author = {Robert Hundt},
title = {Loop Recognition in {C}++/{J}ava/{G}o/{S}cala},
booktitle = {Proceedings of the 2nd Scala Workshop (ScalaDays)},
year = 2011,
comment = {Finds tuning the GC has a disproportionate effect on performance}
}

@inproceedings{hunt03,
author = {Rob Hunter and Shriram Krishnamurthi},
title = {A Model of Garbage Collection for {OO} Languages},
booktitle = {10th International Workshop on Foundations of Object-Oriented
Languages (FOOL)},
year = 2003
}

@phdthesis{hutc87a,
author = "Norman Hutchinson",
title = "Emerald: An Object-Based Language for Distributed Programming",
school = "University of Washington",
month = Jan,
year = 1987
}

@techreport{hutc87b,
author = "Norman Hutchinson and R. K. Raj and Andrew P. Black and Henry M. Levy and Eric Jul",
title = "The {E}merald Programming Language Report",
number = "87--10--07",
institution = "University of Washington",
month = Oct,
year = 1987
}

@misc{ibm-sdk50,
author = {Mattias Persson},
title = {{J}ava Technology, {IBM} style: Garbage Collection Policies},
month = may,
year = 2006,
URL = {http://www.ibm.com/developerworks/java/library/j-ibmjava2/},
note = {Garbage collection in the IBM SDK 5.0}
}

@techreport{ibm-gc14,
title = {{JVM} Garbage Collection and Storage Allocation Techniques},
key = IBM,
institution = IBM,
month = nov,
year = 2003,
URL =
{http://download.boulder.ibm.com/ibmdl/pub/software/dw/jdk/diagnosis/GCandMemory-042005.pdf},
note = {Details of the IBM Developer Kit and Runtime Environment, version
1.4.1}}

@inproceedings{ichi90,
author = "Ichisuki, Yuuji and Akinori Yonezawa",
title = "Distributed Garbage Collection Using Group Reference Counting",
crossref = "OOPSLA90-gc",
abstract = "Reference counting schemes are suitable to garbage
collection on distributed systems because they do not require
global information to find garbage.  However, reference counting
schemes have a serious drawback: they cannot reclaim garbage
which form cyclic structures.  In this paper, we propose an
extension of the traditional reference counting scheme, group
reference counting, which alleviates the drawback.  This scheme
is able to reclaim circularly referenced objects which are
contained in object groups.  We describe how this scheme can be
implemented on distributed object-oriented concurrent systems.
The overhead of this scheme does not depend on the number of
nodes.  Thus this scheme works efficiently on distributed systems
containing large number [sic] of nodes.",
URL = {http://ftp.yl.is.s.u-tokyo.ac.jp/pub/papers/sse89-grc-a4.ps.Z}
}

@techreport{ichi90a,
author = "Ichisuki, Yuuji and Akinori Yonezawa",
title = "Distributed Garbage Collection Using Group Reference Counting",
institution = "University of Tokyo",
number = "90--014",
year = 1990
}

@inproceedings{ichi94,
author = {Ichisuki, Yuuji and Masao Morita},
title = {A Shared-Memory Parallel Extension of {KLIC} and its Garbage
Collection.},
booktitle = {FGCS Workshop on Parallel Logic Programming},
pages = {113--126},
year = 1994
}

@techreport{ilia10,
author = {Ilias Iliadis},
title = {Performance of the Greedy Garbage-Collection Scheme in Flash-Based
Solid-State Drives},
type = {Research Report},
number= {RZ 3769 (\# 99779)},
institution = {IBM Research -- Zurich},
month = mar,
year = 2010,
URL = {http://domino.research.ibm.com/library/cyberdig.nsf/papers/B104BCD5AD7CD29C852576F20056D7D9/$File/rz3769.pdf}
}

@article{illi62,
author = "J. K. Iliffe and J. G. Jodeit",
title = "A Dynamic Storage Allocation Scheme",
journal = COMPJ,
volume = 5,
number = 3,
month = oct,
year = 1962,
pages = "200--209"
}

@mastersthesis{ilso01,
author = {Peer M{\o}ller Ils{\o}e and Simon Hem Pedersen},
title = {Garbage Collection in a {B}eta Virtual Machine with the {T}rain {A}lgorithm},
month = jun,
year = 2001,
school = {Aalborg University},
abstract = {In this project a virtual machine, gbvm, with a unique
train algorithm garbage collector is implemented for the programming
language gbeta. The main focus of this thesis is memory management
using the train algorithm and experiments with the implementation.
Firstly, this thesis introduces relevant theories and work including an
introduction to gbeta, a overview of virtual machine architectures, and
descriptions of garbage collection concepts, properties, and
algorithms. Secondly, the design and implementation details of gbvm are
presented Thirdly, experiments investigating the performance of both
parameter but also algorithm changes of the train algorithm are
conducted and discussed. The experimental framework implemented for
this thesis allows for further experiments with gbvm. Finally, it is
concluded that it is difficult to find a fixed general setting, which
is both time and space efficient with all the tested programs.}
}

@techreport{imai90,
author = "Imai, Akira and Hirata, Keiji and Taki, Kazuo",
title = "A Parallel Copying Garbage Collection for KL1 on a Shared Memory Multiprocessor",
institution = "Institute for New Generation Computer Technology",
year = 1990,
type = "ICOT technical memorandum",
number = "TM-0967",
month = Nov,
abstract = "We propose an efficient parallel copying GC which is
an extension of Baker's sequential algorithm on a shared memory
multiprocessor."
}

@techreport{imai91,
author = "Imai, Akira and Tick, Evan",
title = "Evaluation of Parallel Copying Garbage Collection on a Shared-Memory Multiprocessor",
institution = "Institute for New Generation Computer Technology",
year = 1991,
type = "ICOT technical report",
number = "TR-650",
month = May,
abstract = "A parallel copying garbage collection algorithm for
symbolic languages executing on shared-memory multiprocessors is
proposed. The algorithm is an extension of Baker's sequential
algorithm with a novel method of heap allocation to prevent
fragmentation and facilitate load distribution during garbage
collection.  An implementation of the algorithm within a
concurrent logic programming system, VPIM, has been evaluated and
the results, for a wide selection of benchmarks, are analyzed
here.
We show (1) how much the algorithm reduces the contention for
critical sections during garbage collection, (2) how well the
load-balancing strategy works and its expected overheads, and
(3) the expected speedup achieved by the algorithm."
}

@techreport{imai91a,
author = "Imai, Akira and Tick, Evan",
title = "A Shared-Memory Multiprocess or [sic] Garbage Collector and its Evaluation for Committed-Choice Logic Programs",
institution = "Institute for New Generation Computer Technology",
year = 1991,
type = "ICOT technical report",
number = "TR-653",
month = Jun,
abstract = "A parallel copying garbage collection algorithm for
symbolic languages executing on shared-memory multiprocessors is
proposed.  The algorithm is an extension of Baker's sequential
algorithm with a novel  method of heap allocation to prevent
fragmentation and facilitate load distribution during garbage
collection.  An implementation of the algorithm  within a
concurrent logic programming system, VPIM, has been evaluated and
the results, for a wide selection of benchmarks, are analyzed
here.  We show (1) how much the algorithm reduces the contention
for critical sections during garbage collection, (2) how well the
load-balancing strategy works and its expected overheads, and (3)
the expected speedup achieved by the algorithm."
}

@article{imai93,
author = "Imai, Akira and Tick, Evan",
title = "Evaluation of Parallel Copying Garbage Collection on a Shared-Memory Multiprocessor",
journal = {Transactions on Parallel and Distributed Systems},
volume = 4,
number = 9,
pages = {1030--1040},
publisher = IEEE,
year = 1993,
doi = {10.1109/71.243529},
abstract = {A parallel copying garbage collection algorithm for symbolic
languages executing on shared-memory multiprocessors is proposed. The algorithm
is an extension of Baker's sequential algorithm with a novel method of heap
allocation to prevent fragmentation and facilitate load distribution during
garbage collection. An implementation of the algorithm within a concurrent logic
programming system, VPIM, has been evaluated and the results, for a wide
selection of benchmarks, are analyzed here. The authors show 1) how much the
algorithm reduces the contention for critical sections during garbage
collection, 2) how well the load-balancing strategy works and its expected
overheads, and 3) the expected speedup achieved by the algorithm},
comment = {same as imai91a?}
}

@article{inou88,
title = "Analysis of Functional Programs to Detect Run-Time Garbage Cells",
author = "Inoue, Katsuro and Seki, Hiroyuki and Yagi, Hikaru",
pages = "555--578",
journal = TOPLAS,
publisher = ACM,
year = 1988,
month = Oct,
volume = 10,
number = 4,
abstract = {We propose a method for detecting the generation of garbage cells
by analyzing a source text written in a functional programming language which
uses ordinary linked lists to implement list-type values.  For a subexpression
such as F(G(.  .  .  )) in a program where the function values of F and G are
of list type, if a cell c is created during the computation of G and if c does
not appear in a list-type value of F, then c becomes a garbage cell at the
end of the computation of F. We discuss this problem on the basis of formal
languages derived from the functional program text and show some sufficient
conditions that predict the generation of garbage cells.  Also, we give an
efficient algorithm to detect at compile time the generation of garbage cells
which are linearly linked.  We have implemented these algorithms in an
experimental LISP system.  By executing several sample programs on the system,
we conclude that our method is effective in detecting the generation of
garbage cells.}
}

@article{inou91,
author = "Katsuro Inoue and K. Torii",
title = "Implementation and Analysis of Compile-Time Garbage Collection",
journal = "New Generation Computing",
volume = 10,
number = 1,
pages = "101--119",
year = 1991
}

@techreport{inou03,
author = {H. Inoue and Darko Stefanovi\'{c} and S. Forrest},
title = {Object Lifetime Prediction in {J}ava},
institution = {University of New Mexico},
number = {TR--CS--2003--28},
month = may,
year = 2003,
URL = {http://www.cs.unm.edu/~darko/papers/objlife.pdf}
}

@inproceedings{inou09,
  title =	 {A Study of Memory Management for Web-based Applications on
                  Multicore Processors},
  author =	 {Hiroshi Inoue and Hideaki Komatsu and Toshio Nakatani},
  crossref =	 {PLDI09}
}

@inproceedings{inou12,
 author = {Inoue, Hiroshi and Nakatani, Toshio},
 title = {Identifying the Sources of Cache Misses in {J}ava Programs Without Relying on Hardware Counters},
 crossref = {ISMM12},
 pages = {133--142},
 doi = {10.1145/2258996.2259014},
 abstract = {Cache miss stalls are one of the major sources of performance
 bottlenecks for multicore processors. A Hardware Performance Monitor (HPM) in
 the processor is useful for locating the cache misses, but is rarely used in
 the real world for various reasons. It would be better to find a simple
 approach to locate the sources of cache misses and apply runtime optimizations
 without relying on an HPM. This paper shows that pointer dereferencing in hot
 loops is a major source of cache misses in Java programs. Based on this
 observation, we devised a new approach to identify the instructions and objects
 that cause frequent cache misses. Our heuristic technique effectively
 identifies the majority of the cache misses in typical Java programs by
 matching the hot loops to simple idiomatic code patterns. On average, our
 technique selected only 2.8\% of the load and store instructions generated by
 the JIT compiler and these instructions accounted for 47\% of the L1D cache
 misses and 49\% of the L2 cache misses caused by the JIT-compiled code. To prove
 the effectiveness of our technique in compiler optimizations, we prototyped
 object placement optimizations, which align objects in cache lines or collocate
 paired objects in the same cache line to reduce cache misses. For comparison,
 we also implemented the same optimizations based on the accurate information
 obtained from the HPM. Our results showed that our heuristic approach was as
 effective as the HPM-based approach and achieved comparable performance
 improvements in the SPECjbb2005 and SPECpower_ssj2008 benchmark programs.}
} 
@inproceedings{iosi00,
author = {R. Iosif and R. Sisto},
title = {Using Garbage Collection in Model Checking},
booktitle = {7th International {SPIN} Workshop on Model Checking of Software},
series = LNCS,
volume = 1885,
publisher = SV,
address = {Stanford, CA},
month = sep,
year = 2000,
pages = {20--33},
URL = {http://www.dai-arc.polito.it/dai-arc/auto/papers/papers190.shtml}
}

@mastersthesis{irel89,
author = "E. Ireland",
title = "Writing Interactive and File-Processing Functional Programs",
school = "Victoria University of Wellington",
year = 1989,
month = mar,
comment = {Generational GC with a "paradoxical area" for all updatable
objects, scanned at each minor collection. Reportedly unconvincing
performance}
}

@mastersthesis{ishi83,
author = "Ishii, Carol Y.",
title = "A Comparative Study of Garbage Collection and Compaction Algorithms",
year = 1983,
school = "Emory University"
}

@article{isod71,
author = "S. Isoda and E. Goto and I. Kimura",
title = {An Efficient Bit Table Technique for Dynamic Storage Allocation of $2^{n}$-Word Blocks},
journal = CACM,
publisher = ACM,
volume = 14,
number = 9,
year = 1971,
month = sep,
pages = "589--592"
}

@inproceedings{ito97,
  author =	 {Takayasu Ito and Toshihiro Asai},
  institution =	 {Tokyo University},
  title =	 {Timed-{GC} for a Real-Time {L}isp System},
  booktitle =	 {Workshop on Languages, Compilers, and Tools for Real-Time
                  Systems (LCT-RTS97)},
  publisher =	 ACM,
  journal =	 SIGPLAN,
  address =	 {Las Vegas, Nevada},
  month =	 jun,
  year =	 1997
}

@phdthesis{iyen92,
author = "Arun Iyengar",
title = "Dynamic Storage Allocation on a Multiprocessor",
school = "MIT Laboratory for Computer Science",
note = "Technical Report MIT/LCS/TR-560",
year = 1992
}

@inproceedings{iyen93,
author = "Arun K. Iyengar",
title = "Parallel Dynamic Storage Allocation Algorithms",
booktitle = "5th {IEEE} Symposium on Parallel and Distributed Processing",
publisher = IEEE,
year = 1993
}

@phdthesis{iyen12,
 author = {Iyengar, Balaji},
 title = {Non-Blocking Algorithms for Garbage Collected Environments},
 school = {North Carolina State University},
 year = 2012,
 url = {http://www.lib.ncsu.edu/resolver/1840.16/7645},
}

@inproceedings{iyen12a,
 author = {Iyengar, Balaji and Gehringer, Edward and Wolf, Michael and Manivannan, Karthikeyan},
 title = {Scalable Concurrent and Parallel Mark},
 crossref = {ISMM12},
 pages = {61--72},
 doi = {10.1145/2258996.2259006},
 abstract = {Parallel marking algorithms use multiple threads to walk through
 the object heap graph and mark each reachable object as live. Parallel marker
 threads mark an object "live" by atomically setting a bit in a mark-bitmap or a
 bit in the object header. Most of these parallel algorithms strive to improve
 the marking throughput by using work-stealing algorithms for load-balancing and
 to ensure that all participating threads are kept busy. A purely
 "processor-centric" load-balancing approach in conjunction with a need to
 atomically set the mark bit, results in significant contention during parallel
 marking. This limits the scalability and throughput of parallel marking
 algorithms.
We describe a new non-blocking and lock-free, work-sharing algorithm, the
primary goal being to reduce contention during atomic updates of the mark-bitmap
by parallel task-threads. Our work-sharing mechanism uses the address of a word
in the mark-bitmap as the key to stripe work among parallel task-threads, with
only a subset of the task-threads working on each stripe. This filters out most
of the contention during parallel marking with 20\% improvements in performance.
In case of concurrent and on-the-fly collector algorithms, mutator threads also
generate marking-work for the marking task-threads. In these schemes, mutator
threads are also provided with thread-local marking stacks where they collect
references to potentially "gray" objects, i.e., objects that haven't been
"marked-through" by the collector. We note that since this work is generated by
mutators when they reference these objects, there is a high likelihood that
these objects continue to be present in the processor cache. We describe and
evaluate a scheme to distribute mutator generated marking work among the
collector's task-threads that is cognizant of the processor and cache topology.
We prototype both our algorithms within the C4 [28] collector that ships as part
of an industrial strength JVM for the Linux-X86 platform.}
} 

@inproceedings{iyen12b,
author = {Iyengar, Balaji and Tene, Gil and Wolf, Michael and Gehringer, Edward},
title = {The {C}ollie: a Wait-Free Compacting Collector},
crossref = {ISMM12},
pages = {85--96},
doi = {10.1145/2258996.2259009},
abstract = {We describe the Collie collector, a fully concurrent compacting
collector that uses transactional memory techniques to achieve wait-free
compaction. The collector uses compaction as the primary means of reclaiming
unused memory, and performs "individual object transplantations" as
transactions. We introduce new terms and requirements useful for analyzing
concurrent relocating collectors, including definitions of referrer sets,
object transplantation and the notion of individually transplantable objects.
The Collie collector builds on these terms and on a detailed analysis of an
object's legal states during compaction.
Collie uses a combination of read barriers, write barriers and transactional
memory operations. Its read-barrier supports fast, direct object referencing
while using a bound, constant time, wait-free triggering path. Collie thereby
avoids the constant indirection cost of Brooks [9] style barriers or
handle-based heaps [25]. Collie is demonstrated using speculative multi-address
atomicity [11], a form of hardware transactional memory supported by the Azul
Vega architecture [2].
We evaluate the Collie collector on the Azul platform, on which previous
concurrent collectors such as the Pauseless Collector [12] and its generational
variant [30] have been commercially available for several years. We discuss
Collie's performance while running sustained workloads, and compare it to the
Pauseless collector on the same platform. The Collie collector provides
significant MMU [5] improvements even in the 1-msec time windows compared to the
Pauseless collector. At the same time, it matches Pauseless in throughput and in
the ability to scale to large heap sizes.
We believe that the Collie collector is the first garbage collector to leverage
hardware-assisted transactional memory. While Collie directly leverages Vega's
speculative multi-address atomicity feature (SMA) [11], its design can be easily
adapted to other hardware- assisted transactional memory systems. Specifically,
the upcoming Intel TSX instruction set extensions [21] include capabilities
similar to SMA. We expect Collie to be easily implementable on future commodity
servers based on Intel Haswell processors and following processor generations.}
}

@manual{j2ee,
title={{J}ava 2 Platform, Enterprise Edition ({J2EE}), 1.4 Specification},
year=2002,
organization = "Sun Microsystems",
URL = {http://java.sun.com/j2ee/j2ee-1_4-pfd3-spec.pdf},
}

@inproceedings{jack91,
author = "Frank Jackson",
title = "Garbage Collection Bugs That {I} Have Known",
crossref = "OOPSLA91-gc",
}

@inproceedings{jack98,
author = {Paul B. Jackson},
title = {Verifying a Garbage Collection Algorithm},
booktitle = {11th International Conference on Theorem Proving in Higher Order Logics (TPHOLs)},
address = {Canberra},
series = LNCS,
volume = 1479,
pages = {225--244},
publisher = SV,
month = sep,
year = 1998
}

@inproceedings{jaco89,
author = "D. Jacobs and A. Langen",
title = "Accurate and Efficient Approximation of Variable Aliasing in Logic Programs",
booktitle = "North American Conference on Logic Programming",
pages = "154--165",
year = 1989
}

@inproceedings{jaga94,
title = "Dali: A High Performance Main Memory Storage Manager",
author = "H. V. Jagadish and Daniel Lieuwen and Rajeev Rastogi and Avi Silbersch
atz",
booktitle = "20th International Conference on Very Large Data Bases",
year = 1994
}

@article{jans86,
title = "Message Passing and Graph Transformations: a Model of {A}ctor Computation",
author = "D. Janssens",
journal = "Microprocessing and Microprogramming",
volume = 18,
number = "1--5",
other = "Twelfth EUROM ICRO Symp on Microprocess and Microprogram,
Venice, Italy, Sep 15--18 1986",
pages = "307--318",
year = "1986",
abstract = {
Actor systems are a model of massively parallel computation.  In an
actor system a computation is performed by a number of independent active
elements, called actors.  Communication between these actors happens by
asynchronous message passing.  The aim of this paper is to develop a
comprehensive description of actor systems, based on techniques from the
area of graph grammars.}
}

@phdthesis{jans90,
author = "G. Janssens",
title = "Deriving Run-Time Properties of Logic Programs by Means of Abstract Interpretation",
school = "Katholieke University of Leuven, Belgium",
year = 1990
}

@article{janss92,
author = "G. Janssens and Maurice Bruynooghe",
title = "Deriving Descriptions of Possible Values of Program Variables by Means of Abstract Interpretation",
journal = "Journal of Logic Programming",
month = jul,
number = "2, 3",
pages = "205--258",
volume = 13,
year = 1992
}

@manual{java02,
title={Java 2 Platform, Standard Edition, v 1.4.0: API Specification},
year=2002,
organization = "Sun Microsystems",
URL = {http://java.sun.com/j2se/1.4/docs/api/},
comment="Citation for java.lang.ref.WeakReference, PhantomReference, etc"
}

@manual{javarmi,
key={Java RMI},
title =        {{J}ava {R}emote {M}ethod {I}nvocation Specification},
organization =  {Sun Microsystems},
year =         1996,
number =       {Rev 1.1},
month =        nov
}

@article{jaza81,
title = "Space-Efficient Storage Management in an Attribute Grammar Evaluator",
author = "Medhi Jazayeri and Diane Pozefsky",
pages = "388--404",
journal = TOPLAS,
publisher = ACM,
year = 1981,
month = oct,
volume = 3,
number = 4
}

@article{jeff85,
author = "D. R. Jefferson",
title = "Virtual Time",
journal = TOPLAS,
publisher = ACM,
volume = 7,
number = 3,
month = jul,
year = 1985,
pages = "404--425"
}

@inproceedings{jeff87,
author = "D. R. Jefferson and others",
title = "Distributed Simulation and the {T}ime {W}arp Operating System",
booktitle = "11th " # SOSP,
publisher = ACM,
month = nov,
year = 1987
}

@inproceedings{jens90,
author = "Thomas P. Jensen and Torben Mogensen",
title = "A Backwards Analysis for Compile-Time Garbage Collection",
crossref = {ESOP90},
pages = "227--239",
publisher = SV,
doi = {10.1007/3-540-52592-0_66},
abstract = {Compile-time garbage collection}
}

@mastersthesis{jens90a,
author = "Thomas P. Jensen",
title = "Context Analysis of Functional Programs",
school = DIKU,
year = "1990",
month = Jan,
comment = "Contexts are introduced as a means for describing
the use of a data structure. A backwards analysis
for determining contexts is developed and used to
optimise the use of storage in functional programs.",
keywords = "backwards analysis, compile-time garbage collection"
}

@phdthesis{jesc95,
title = "An Architecture for Parallel Symbolic Processing based on Suspending Construction",
author = "Eric R. Jeschke",
school = "Indiana University",
month = apr,
year = 1995,
URL = "ftp://ftp.cs.indiana.edu/",
comment = "GC based on distributed mark-compact"
}

@mastersthesis{jew87,
author = "Jew, Yanni K.",
title = "Distributed Garbage Collection",
year = 1987,
school = "Carleton University, Canada"
}

@inproceedings{jiba11,
author = {Ivan Jibaja and Stephen M. Blackburn and Mohammad R. Haghighat and Kathryn S. McKinley}, 
title = {Deferred Gratification: Engineering for High Performance Garbage Collection from the Get Go}, 
crossref = {MSPC11},
doi = {1988915.1988930}, 
abstract = {Implementing a new programming language system is a daunting task. A
common trap is to punt on the design and engineering of exact garbage collection
and instead opt for reference counting or conservative garbage collection (GC).
For example, AppleScript, Perl, Python, and PHP implementers chose reference
counting (RC) and Ruby chose conservative GC. Although easier to get working,
reference counting has terrible performance and conservative GC is inflexible
and performs poorly when allocation rates are high. However, high performance GC
is central to performance for managed languages and only becoming more critical
due to relatively lower memory bandwidth and higher memory latency of modern
architectures. Unfortunately, retrofitting support for high performance
collectors later is a formidable software engineering task due to their exact
nature. Whether they realize it or not, implementers have three routes: (1)
forge ahead with reference counting or conservative GC, and worry about the
consequences later; (2) build the language on top of an existing managed runtime
with exact GC, and tune the GC to scripting language workloads; or (3) engineer
exact GC from the ground up and enjoy the correctness and performance benefits
sooner rather than later.
We explore this conundrum using PHP, the most popular server side scripting
language. PHP implements reference counting, mirroring scripting languages
before it. Because reference counting is incomplete, the implementors must (a)
also implement tracing to detect cyclic garbage, or (b) prohibit cyclic data
structures, or (c) never reclaim cyclic garbage. PHP chose (a), AppleScript
chose (b), and Perl chose (c). We characterize the memory behavior of five
typical PHP programs to determine whether their implementation choice was a good
one in light of the growing demand for high performance PHP. The memory behavior
of these PHP programs is similar to other managed languages, such as Java --- they
allocate many short lived objects, a large variety of object sizes, and the
average allocated object size is small. These characteristics suggest copying
generational GC will attain high performance. Language implementers who are
serious about correctness and performance need to understand deferred
gratification: paying the software engineering cost of exact GC up front will
deliver correctness and memory system performance later.}
}

@inproceedings{jin11,
author = {Jin, Dongyun and Meredith, Patrick O'Neil and Griffith, Dennis and Rosu, Grigore},
title = {Garbage Collection for Monitoring Parametric Properties},
crossref = {PLDI11},
pages = {415--424},
doi = {10.1145/1993498.1993547},
abstract = {Parametric properties are behavioral properties over program events
that depend on one or more parameters. Parameters are bound to concrete data or
objects at runtime, which makes parametric properties particularly suitable for
stating multi-object relationships or protocols. Monitoring parametric
properties independently of the employed formalism involves slicing traces with
respect to parameter instances and sending these slices to appropriate
non-parametric monitor instances. The number of such instances is theoretically
unbounded and tends to be enormous in practice, to an extent that how to
efficiently manage monitor instances has become one of the most challenging
problems in runtime verification. The previous formalism-independent approach
was only able to do the obvious, namely to garbage collect monitor instances
when all bound parameter objects were garbage collected. This led to
pathological behaviors where unnecessary monitor instances were kept for the
entire length of a program. This paper proposes a new approach to garbage
collecting monitor instances. Unnecessary monitor instances are collected lazily
to avoid creating undue overhead. This lazy collection, along with some careful
engineering, has resulted in RV, the most efficient parametric monitoring system
to date. Our evaluation shows that the average overhead of RV in the DaCapo
benchmark is 15\%, which is two times lower than that of JavaMOP and orders of
magnitude lower than that of Tracematches.}
} 

@manual{jinsight,
key = {Jinsight},
organisation = {IBM Research},
title = {Jinsight},
URL = {http://www.research.ibm.com/jinsight/},
note = {Visualisation tools for {J}ava}
}

@manual{JNI97,
key = {Sun JNI, 1997},
organisation = {JavaSoft},
title = {Java Native Interface},
year = 1997,
URL = {http://java.sun.com/products/jdk/1.2/docs/guide/jni/index.html},
note = {Javasoft's Native Interface for Java}
}

@inproceedings{joha02,
title = {Heap Architectures for Concurrent Languages using Message Passing},
author = {Erik Johansson and Konstantinos Sagonas and Jesper Wilhelmsson},
crossref = {ISMM02},
pages = {88-99},
doi={10.1145/512429.512440}
}

@techreport{john88,
author = "Douglas Johnson",
title = "Trap Architectures for {Lisp} Systems",
number = "UCB/CSD/88/470",
institution = UCB,
month = nov,
year = 1988,
absstract =
"Recent measurement of Lisp systems show a dramatic
skewing of operation frequency. For example, small
integer (fixation) arithmetic dominates most programs,
but other number types can occur on almost any
operation. Likewise, few memory references trigger
special banding for garbage collection, but nearly all
memory operations could trigger such special handling.
Systems like SPARC and SPUR have shown that small
amounts of special hardware can significantly reduce
the need for inline software checks by trapping when an
unusual condition is detected. A system's trapping
architecture now becomes key to performance. In most
systems, the trap architecture now becomes key to
performance. In most systems, the trap architecture is
intended to handle errors (e.g., address faults). The
requirements for Lisp traps are quite different. In
particular, the trap frequency is higher, processing
time per trap is shorter, and must need to be handled
in the user's address space and context. This paper
looks at these requirements, evaluates current trap
architectures, and proposes enhancements for meeting
those requirements. These enhancements increase
performance for Lisp 9-32 percent at cost of about 1.4 percent more
CPU logic."
}

@article{john91,
title = "The Case for a Read Barrier",
author = "Douglas Johnson",
address = "Texas Instruments Inc, Dallas, Tx, 75265",
journal = Sigplan,
publisher = ACM,
year = 1991,
volume = 26,
number = 4,
pages = "279--287",
comment = "Lisp Machines have special purpose hardware to detect pointers
into fromspace and trap to a handler.
The cost of this checking on a conventional machine is in the tens of percent
for a high performance system."
}

@inproceedings{john91a,
author = "Douglas Johnson",
title = "Comparing Two Garbage Collectors",
crossref = "OOPSLA91-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/johnson.ps"
}

@inproceedings{john94,
author = {Eric E. Johnson and Jiheng Ha},
title = {{PDATS}: Lossless address space compression for reducing file size and access time},
booktitle = {IEEE International Phoenix Conference on Computers and Communication},
month = apr,
year = 1994
}

@inproceedings{john99,
author = {Eric E. Johnson},
title = {{PDATS} {II}: Improved compression of traces},
booktitle = {1999 IEEE International Performance, Computing and Communications Conference},
month = feb,
year = 1994
}

@article{john92,
title = "Reducing the Latency of a Real-Time Garbage Collector",
author = "Ralph E. Johnson",
journal = "{L}etters on Programming Languages and Systems",
publisher = ACM,
volume = 1,
number = 1,
pages = "46--58",
month = mar,
year = 1992,
comment = "Variation of Appel, Ellis, Li using lazier copying of objects to fromspace."
}

@techreport{john85,
author = "Steven D. Johnson",
title = "Storage Allocation for List Processing",
number = 168,
institution = "Indiana University",
month = mar,
year = 1985
}

@phdthesis{john87,
author = "Thomas Johnsson",
title = "Compiling Lazy Functional Languages",
school = "Chalmers University of Technology",
year = 1987,
comment = "The G-machine compiler for LML"
}

@techreport{john91b,
title = "A Concurrent Fast Fit Memory Manager",
author = "Theodore Johnson",
institution = "University of Florida",
number = "91-009",
year = 1991
}

@article{johns92a,
author = "Theodore Johnson and D. Sasha",
title = "Parallel Buddy Memory Management",
journal = "Parallel Processing Letters",
volume = 2,
number = 4,
year = 1992,
pages = "391--398"
}

@misc{john92b,
author = "Theodore Johnson and Tim Davis",
title = "Space Efficient Parallel Buddy Memory Management",
year = 1992
}

@inproceedings{john97,
title = {The Memory Fragmentation Problem: Solved?},
author = {Mark S. Johnstone and Paul R. Wilson},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/wilson.ps},
crossref = {OOPSLA97-gc}
}

@phdthesis{john97a,
title = {Non-Compacting Memory Allocation and Real-Time Garbage Collection},
author = {Mark S. Johnstone},
school = {University of Texas at Austin},
month = dec,
year = 1997,
URL = {ftp://ftp.cs.utexas.edu/pub/garbage/johnstone-dissertation.ps.gz},
abstract = {
Dynamic memory use has been widely recognized to have profound effects
on program performance, and has been the topic of many research studies
over the last forty years.  In spite of years of research, there is
considerable confusion about the effects of dynamic memory allocation.
Worse, this confusion is often unrecognized, and memory allocators are
widely thought to be fairly well understood.

In this research, we attempt to clarify many issues for both manual and
automatic non-moving memory management. We show that the traditional
approaches to studying dynamic memory allocation are unsound, and
develop a sound methodology for studying this problem. We present
experimental evidence that fragmentation costs are much lower than
previously recognized for most programs, and develop a framework for
understanding these results and enabling further research in this area.
For a large class of programs using well-known allocation policies, we
show that fragmentation costs are near zero. We also study the locality
effects of memory allocation on programs, a research area that has been
almost completely ignored. We show that these effects can be quite
dramatic, and that the best allocation policies in terms of
fragmentation are also among the best in terms of locality at both the
cache and virtual memory levels of the memory hierarchy.

We extend these fragmentation and locality results to real-time garbage
collection. We have developed a hard real-time, non-copying
generational garbage collector which uses a write-barrier to coordinate
collection work only with modifications of pointers, therefore making
coordination costs cheaper and more predictable than previous
approaches. We combine this write-barrier approach with implicit
non-copying reclamation, which has most of the advantages of copying
collection (notably avoiding both the sweep phase required by
mark-sweep collectors, and the referencing of garbage objects when
reclaiming their space), without the disadvantage of having to actually
copy the objects. In addition, we present a model for non-copying
implicit-reclamation garbage collection. We use this model to compare
and contrast our work with that of others, and to discuss the tradeoffs
that must be made when developing such a garbage collector. }
}

@inproceedings{john98,
author = {Mark S. Johnstone and Paul R. Wilson},
title = {The Memory Fragmentation Problem: Solved?},
pages = {26--36},
crossref = {ISMM98},
doi = {10.1145/301589.286864},
abstract = {We show that for 8 real and varied C and C++ programs, several
conventional dynamic storage allocators provide near-zero
fragmentation, once overheads due to implementation details (headers,
alignment, etc.) are properly accounted for. This substantially
strengthens our previous results showing that the memory
fragmentation problem has generally been misunderstood, and that
good allocator policies can provide good memory usage for most
programs. The new results indicate that for most programs, excellent
allocator policies are readily available, and efficiency of
implementation is the major challenge. While we believe that our
experimental results are state-of-the-art and our methodology is
superior to most previous work, more work should be done to identify
and study unusual problematic program behaviors not represented in
our sample.}
}

@inproceedings{jois06,
title = {Compiler Optimizations for Nondeferred Reference-Counting Garbage Collection},
author = {Pramod Joisha},
pages = {150--161},
crossref = {ISMM06},
}

@inproceedings{jois07,
title = {Overlooking Roots: A Framework for Making Nondeferred
Reference-Counting Garbage Collection Fast},
author = {Pramod Joisha},
pages = {141--158},
crossref = {ISMM07},
}

@inproceedings{jois08,
author = {Pramod Joisha},
title = {A Principled Approach to Nondeferred Reference-Counting Garbage
Collection},
crossref = {VEE08},
}

@inproceedings{jois14,
title = {Sticky Tries: Fast Insertions, Fast Lookups, No Deletions for Large Key Universes},
author = {Pramod G. Joisha},
pages = {35--46},
crossref = {ISMM14},
doi = {10.1145/2602988.2602998},
abstract = {We present the sticky trie, a new variant of the standard trie data
structure that achieves high-performing atomic insertions and lookups for large
key universes by precluding deletions. It has applications in several areas,
including address tracking, logging, and garbage collection. By leveraging
features of a modern operating system, we show how a runtime can exploit the
absence of deletions to realize an efficient sticky-trie implementation.
We report on an evaluation of two representative uses---compelling Bloom-filter
alternative and fast substitute for a garbage collector's sequential store
buffer (SSB). We demonstrate that a sticky trie, when compared with what is
perhaps among the simplest Bloom filters, can be over 43\% faster, scale
substantially better with increasing threads, and yet be free of false
positives. By introducing the concept of an ideal SSB, we also demonstrate that
a sticky trie could be competitive in performance with a class of SSBs.}
}

@article{joki89,
title = "Customizable Garbage Collectors",
author = "M. O. Jokinen",
pages = "115--118",
journal = IPL,
publisher = NH,
month = feb,
year = 1989,
volume = 30,
number = 3,
abstract = {Conventional garbage collectors retain components of data
structures as long as the structure itself is accessible.  In some
applications, however, the components of a data structure are useful only if
they are referred by external pointers.  Recognition and deletion of useless
components requires co-operation between the garbage collector and the user
program --- the analysis of accessibility is carried out by the garbage collector
but user-defined routines are necessary to remove obsolete components from the
structure.  Two different co-operation mechanisms are discussed; the first
can be used with garbage collectors based on reference counters, the other
with mark-and-sweep collector.}
}

@inproceedings{joao09,
  author =	 {Jos\'{e} A. Joao and Onur Mutlu and Yale N. Patt},
  title =	 {Flexible Reference-Counting-Based Hardware Acceleration for
                  Garbage Collection},
  crossref =	 {ISCA09},
  pages =	 {418-428},
  doi =		 {10.1145/1555754.1555806}
}

@incollection{jone81,
author = "Neil D. Jones and Steven S. Muchnick",
title = "Flow Analysis and Optimization of {LISP}-like Structures",
booktitle = "Program Flow Analysis: Theory and Applications",
pages = "102--131",
publisher = PH,
year = 1981
}

@techreport{jone92,
author = "Richard E. Jones and Rafael D. Lins",
title = "Cyclic Weighted Reference Counting without Delay",
institution = UKC,
number = "28--92",
URL = "ftp://unix.hensa.ac.uk/pub/misc/ukc.reports/comp.sci/reports/28-92.ps.Z",
month = dec,
year = 1992,
comment = {Improves on \cite{lins91c} by allowing processors to
continue to perform useful work in all circumstances.}
}

@article{jone92a,
title = "Tail recursion without space leaks",
author = "Richard E. Jones",
pages = "73--79",
journal = jfp,
month = jan,
year = 1992,
volume = 2,
number = 1
}

@inproceedings{jone93,
author = {Richard E. Jones and Rafael D. Lins},
title = {Cyclic Weighted Reference Counting without Delay},
crossref = {PARLE93},
pages = {712--715},
comment = {briefer version of \cite{jone92}}
}

@book{jone96,
author = "Richard E. Jones",
title = "Garbage Collection: Algorithms for Automatic Dynamic Memory Management",
publisher = Wiley,
address = {Chichester},
month = jul,
year = 1996,
pages = 403,
ISBN = "0--471--94148--4",
URL = "http://www.cs.ukc.ac.uk/people/staff/rej/gcbook/gcbook.html",
note = "With a chapter on Distributed Garbage Collection by R. Lins.",
comment = {Reprinted February 1997, November 1997, January 1999, April 2000.}
}

@techreport{jone04,
title = {Collecting the Garbage Without Blocking the Traffic},
author = {Richard E. Jones and Andy C. King},
institution = UoK,
number = {18--04},
month = sep,
year = 2004,
URL = {http://www.cs.kent.ac.uk/pubs/2004/1970/},
note = {This report summarises \cite{king04}.}
}

@inproceedings{jone05,
title = {A Fast Analysis for Thread-Local Garbage Collection with Dynamic Class
Loading},
author = {Richard E. Jones and Andy C. King},
booktitle = {5th {IEEE} International Workshop on Source Code Analysis and
Manipulation (SCAM)},
address = {Budapest},
month = sep,
year = 2005,
publisher = IEEEcomp,
isbn = {0-7695-2292-0},
pages = {129--138},
doi={10.1109/SCAM.2005.1},
URL = {http://www.cs.kent.ac.uk/pubs/2005/2228/},
note = {This is a shorter version of \cite{jone04}.}
}

@inproceedings{jone06,
title = {Garbage Collection Should Be Lifetime Aware},
author = {Richard Jones and Chris Ryder},
editor ={Olivier Zendra},
booktitle ={Implementation, Compilation, Optimization of Object-Oriented
Languages, Programs and Systems ({ICOOOLPS}'2006)},
pages = 8,
address = {Nantes, France},
month = jul,
year = 2006,
URL = {http://www.cs.kent.ac.uk/pubs/2006/2376/}
}

@article{jone06a,
title =	 {Five Perspectives on Modern Memory Management: Systems, Hardware and Theory},
author = {Richard Jones},
editor = {Richard Jones},
journal = SCP,
volume = 62,
number = 2,
publisher = "Elsevier",
pages =	 {95--204},
month =	oct,
year =	2006,
doi = {10.1016/j.scico.2006.05.003}
}

@inproceedings{jone07,
author = {Richard Jones},
title = {Dynamic Memory Management: Challenges for Today and Tomorrow},
month = apr,
year = 2007,
pages = {115--124},
note = {Invited presentation.},
URL = {http://www.cs.kent.ac.uk/pubs/2007/2506},
ISBN = {978-1-59593-618-9},
booktitle = {International Lisp Conference},
address = {Cambridge},
publisher = {Association of Lisp Users},
}

@inproceedings{jone08,
title = {A Study of {J}ava Object Demographics},
author = {Richard Jones and Chris Ryder},
crossref = {ISMM08},
pages = {121--130},
doi = {10.1145/1375634.1375652},
abstract = {Researchers have long strived to exploit program behaviour
in order to improve garbage collection efficiency. For example, by
using a simple heuristic, generational GC manages short-lived objects
well, although longer-lived objects will still be promoted to an
older generation and may be processed repeatedly thereafter. In
this paper, we provide a detailed study of Java object lifetimes
which reveals a richer landscape than the generational view offers.
Allocation site has been claimed to be a good predictor for object
lifetime, but we show that object lifetime can be categorised more
precisely than 'short-lived/long-lived/immortal'. We show that (i)
sites allocate objects with lifetimes in only a small number of
narrow ranges, and (ii) sites cluster strongly with respect to the
lifetime distributions of the objects they allocate. Furthermore,
(iii) these clusterings are robust against the size of the input
given to the program and (iv) are likely to allocate objects that
are live only in particular phases of the program's execution.
Finally, we show that, in contrast to previous studies, (v) allocation
site alone is not always sufficient as a predictor of object lifetime
distribution but one further level of stack context suffices.}
}

@book{jone11,
  author =	 {Richard Jones and Antony Hosking and Eliot Moss},
  title =	 {The Garbage Collection Handbook: The Art of Automatic Memory
                  Management},
  publisher =	 {Chapman \& Hall},
  year =	 2012,
  series =	 {CRC Applied Algorithms and Data Structures},
  month =	 aug,
  isbn =	 {978-1420082791}
}

@misc{jone95a,
title = "Bounds Checking for {C}",
author = "Richard Jones and Paul Kelly",
URL = "http://www-ala.doc.ic.ac.uk/~phjk/BoundsChecking.html",
}

@inproceedings{jone88,
author = {Simon B. Jones and le M\'{e}tayer, D.},
title = "Optimisation of Storage Management in Functional Languages by Static Analysis of Programs",
crossref = "glasgow88",
pages = "87--100",
}

@inproceedings{jone89,
author = {Simon B. Jones and D. le M\'{e}tayer},
title = "Compile-Time Garbage Collection by Sharing Analysis",
crossref = "FPCA89",
pages = "54--74",
abstract = "This paper describes an analysis technique to reduce the cost in
processing time of the storage management operations implied by a program
(possibly to zero)."
}

@inproceedings{jone90,
title = "Is Compile Time Garbage Collection Worth the Effort",
author = "Simon B. Jones and M. White",
crossref = "glasgow90",
pages = "172--176",
}

@inproceedings{jone93a,
title = "The Implementer's Dilemma: A Mathematical Model of Compile-Time Garbage Collection",
author = "Simon B. Jones and Andrew S. Tyas",
crossref = "glasgow93",
pages = "139--144",
URL = "ftp://ftp.cs.stir.ac.uk/pub/tr/cs/1994/TR118.ps.Z",
abstract = "Optimization by compile time garbage collection is one
possible weapon in the functional language implementer's armoury for
combatting the excessive memory allocation usually exhibited by functional
programs. It is an interesting idea, but the practical question of whether
it yields benefits in practice has still not been answered convincingly
one way or the other.

In this short paper we present a mathematical model of the performance
of straightforward versions of mark-scan and copying garbage collectors
with programs optimized for explicit deallocation. A mark-scan heap
manager has a free list, whereas a copying heap manager does not ---
herein lies the dilemma, since a copying garbage collector is usually
considered to be faster than a mark-scan, but it cannot take advantage
of this important optimization.

For tractability we consider only heaps with fixed cells.

The results reported show that the garbage collection scheme of choice
depends quite strongly on the heap occupancy ratio: the proportion of
the total heap occupied by accessible data structures averaged over the
execution of the program. We do not know what typical heap occupancy
ratios are, and so are unable to make specific recommendations, but
the results may be of use in tailoring applications and heap management
schemes, or in controlling schemes where the heap size varies dynamically.

An important result arising from the work reported here is that when
optimizing for explicit deallocation, a very large proportion of cell
releases must be optimized before very much performance benefit is
obtained."
}

@techreport{jone95,
author = "Simon B. Jones",
title = "An Experiment in Compile Time Garbage Collection",
institution = {Programming Methodology Group, G\"{o}teborg University and Chalmers University of Technology},
number = 84,
month = jan,
year = 1995,
URL = "ftp://ftp.cs.stir.ac.uk/pub/tr/cs/1994/TR127.ps.Z",
comment = "Performs sharing analysis of strict, first-order functional programs.
A non-trivial Haskell program is adapted to run as a strict, first-order LML
program and re-use optimisation is applied.
The results are disappointing.
Bytes allocated: -8 percent
GC time: -8 percent (but GC is only 10 percent of total exection time)
Cell allocation time not improved,
Locality: slightly improved
Cache penalty: -3 percent
Total time: -4.5 percent",
abstract = "This report presents the details and conclusions of an
experiment designed to assess the potential benefits to be obtained
from a particular proposal for optimizing the execution of functional
programs by compile time garbage collection. The optimizations proposed
comprise the compile time insertion of code to directly re-use heap cells
which are released and can be statically reallocated immediately. The
optimizations are determined by the static sharing analysis of
strict, first order functional programs using list (tree-like) data
structures. The method is powerful enough to detect many places in
programs where the optimization can be applied, but the effect on the
performance of ``typical'' programs has not been practically assessed
before. In this experiment a non-trivial Haskell program is adapted to run
as a strict, first order LML program. Re-use optimization is performed
(simple deallocation is not possible in LML as it has no free list in
the heap), and the performance of the unoptimized and optimized versions
are compared. The results turn out to be (surprisingly) disappointing:
although the number of bytes allocated from the heap is reduced by about
8\% and the time for garbage collections reduces by about 15\%, the cell
allocation time itself is not improved, and the garbage collection time
amounts to only 10\% of the total program execution time. There is a
slight improvement in the locality of memory references, reducing the
cache penalty overhead by about 3\%. The total time reductions are of
the order of 4.5\% --- which is not encouraging."
}

@article{jonk92,
author = "Jonker, J. E.",
title = "On-The-Fly Garbage Collection for Several Mutators",
journal = "Distributed computing",
volume = 5,
number = 4,
pages = "187-200",
month = apr,
year = 1992
}

@article{jonk79,
author = "H. B. M. Jonkers",
title = "A Fast Garbage Compaction Algorithm",
journal = IPL,
publisher = NH,
volume = 9,
number = 1,
month = Jul,
year = 1979,
pages = "26--30",
doi={10.1016/0020-0190(79)90103-0}
}

@book{jonk83,
title = "Abstraction, Specification and Implementation Techniques: With an
Application to Garbage Collection",
author = "H. B. M. Jonkers",
publisher = "Mathematical Centre, Amsterdam, the Netherlands",
year = 1983,
pages = "317",
ISBN = "90--6196--263--3"
}

@article{jord78,
author = "M. J. Jordan",
title = "SLP: A Paged Processor for Compact Lists",
journal = SPE,
publisher = Wiley,
volume = 8,
number = 3,
year = 1978,
pages = "285--301"
}

@inproceedings{jost04,
author = {Steffen Jost},
title = {{lfd\_infer}: An Implementation of a Static Inference on Heap Space Usage},
crossref = {SPACE04},
}

@inproceedings{joup90,
author = "Jouppi, Norman P.",
title = "Improving Direct-Mapped Cache Performance by the Addition of a
Small Fully-Associative Cache and Prefetch Buffers",
crossref = {ISCA90},
pages = "346--373",
comment = "Cost of cache miss may rise to 100 cycles"
}

@inproceedings{joup93,
author = "Jouppi, Norman P.",
title = "Cache Write Policies and Performance",
crossref = "ISCA93",
pages = "191--201"
}

@book{joy00,
author = {Bill Joy and Guy Steele and James Gosling and Gilad Bracha},
title = {The Java Language Specification},
edition = {Second Edition},
publisher = AW,
month = jun,
year = 2000
}

@manual{jpda,
title = "Java Platform Debugger Architecture ({JPDA})",
key = "JPDA",
organization = "Sun Microsystems",
note = {http://java.sun.com/j2se/1.3/docs/guide/jpda/},
URL = {http://java.sun.com/j2se/1.3/docs/guide/jpda/},
comment = {Debugger architecture for {J}ava. Includes:
Java Virtual Machine Debugger Interface (JVMDI) which defines the services a
VM must provide for debugging;
Java Debug Wire Protocol (JDWP) which defines the format of information and
requests transferred between the process being debugged and the debugger
front end that implements the
Java Debug Interface  (JDI) which defines information and requests at the
user code level}
}

@manual{jprobe,
title = "The JProbe Profiler",
key = "JProbe",
organization = "Sitraka Inc.",
note = {http://www.jprobe.com},
URL = {http://www.jprobe.com},
comment = {Profiling and debugging tools for {J}ava}
}

@manual{jrockit,
title = {Understanding Memory Management},
key = {JRockit},
organization = {BEA Systems Inc.},
note = {The BEA JRockit JVM R27.6},
URL = {http://e-docs.bea.com/jrockit/geninfo/diagnos/garbage_collect.html},
year = 2008
}

@inproceedings{juil07,
author = {Nicolas Juillerat and Stefan M\"{u}ller Arisona and Simon Schubiger-Banz},
title = {Real-Time, Low Latency Audio Processing in {J}ava},
booktitle = {International Computer Music Conference, ICMC 2007},
address = {Copenhagen, Denmark},
month = aug,
year = 2007,
URL =
{http://diuf.unifr.ch/pai/wiki/doku.php?id=Publications&page=publication&kind=single&ID=16},
comment= {Jitter problems due to GC nearly unnoticeable if OS does priority
inheritance. HotSpot pauses less than 1ms, IBM SE 8ms}
}

@inproceedings{jula09,
title = {Two Memory Allocators that Use Hints to Improve Locality},
author = {Alin Jula and Lawrence Rauchwerger},
pages = {109--118},
doi = {10.1145/1542431.1542447},
crossref = {ISMM09}
}

@phdthesis{juli85,
author = "Danielle Julien",
title = {Etude et R\'{e}alisation de la Machine Virtuelle {LILA} Adapt\'{e}e \`{a} l'\'{E}criture d'Interpr\`{e}tes},
school = {Universit\'{e} Paul Sabatier, Toulouse, France},
month = may,
year = 1985
}

@inproceedings{jul87,
author = "Eric Jul and Henry Levy and Norman Hutchinson and Andrew Black",
title = "Fine-Grained Mobility in the {E}merald System",
booktitle = "11th " # SOSP,
publisher = ACM,
pages = "105--106",
year = 1987,
month = dec,
note = "See also \cite{jul88}."
}

@article{jul88,
title = "Fine-Grained Mobility in the {E}merald System",
author = "Eric Jul and Henry Levy and Norman Hutchinson and Andrew Black",
pages = "109--133",
journal = TransCompSys,
publisher = ACM,
year = 1988,
month = jan,
volume = 6,
number = 1,
abstract = {Emerald is an object-based language and system designed for the
construction of distributed programs.
--- From the Authors' Abstract
This paper is divided into five sections. In Section 1, the introduction,
the authors recall the advantages of process migration and fine grain
mobility. Section 2 is an overview of Emerald. Using examples coded in
Emerald, the authors show how an Emerald object is described and how
abstract types are defined. They explain the set of mobility primitives
and a new parameter passing scheme (call-by-move), and give a
description of a process attached to an object.
Section 3, titled ``Implementing Mobility in Emerald,'' is devoted to the
description of the data structures, algorithms, and protocols involved in
the kernel. Some significant differences between Emerald and other systems
are given below. There are three object implementations (global, local, and
direct) with separate addressing options. Emerald uses an algorithm for
object searching based on Fowler's forwarding address, modified for
efficiency. It uses direct pointers (as opposed to indirect references as
in Smalltalk). Process moving is possible without code copying. Emerald
uses machine registers for efficiency (and has an algorithm for moving
them). There are two garbage collectors, local and distributed, which can
work in parallel with Emerald processes.
Section 4 covers performance. At the time this paper was written, the
system worked on a network of MicroVAXes connected by a 10 megabit/second
Ethernet. A newer version runs on Sun workstations. Tables summarize
the execution times for the mobility primitives and the network traffic in
the Emerald Mail System. Section 5 is a summary of the paper.
This paper is well written. It contains many references covering a large
amount of work in the area. The authors discuss the implementation choices
and include comparisons with other schemes. There are examples and figures,
and the text is clear. Nevertheless, some knowledge in the fields of
distributed computing and object-oriented languages and their
implementation is desirable. This paper should be read by anyone involved
in the construction of distributed systems. Other papers about Emerald
have already been published.}
}

@phdthesis{jul88a,
author = "Eric Jul",
title = "Object Mobility in a Distributed Object-Oriented System",
school = "Department of Computer Science, University of Washington",
address = "Seattle, WA",
month = dec,
year = 1988,
note = "Technical Report 88-12-6. Also {DIKU} Report (Blue Series) 89/1,
Department of Computer Science, University of Copenhagen, Denmark",
}

@inproceedings{jump04,
author = {Maria Jump and Stephen M. Blackburn and Kathryn S. McKinley},
title = {Dynamic Object Sampling for Pretenuring},
pages = {152--162},
crossref = {ISMM04},
doi={10.1145/1029873.1029892}
}

@inproceedings{jump07,
author = {Maria Jump and Kathryn S. McKinley},
title = {Cork: Dynamic Memory Leak Detection for Garbage-Collected Languages},
crossref = {POPL07},
doi = {10.1145/1190216.1190224},
pages = {31--38}
}

@inproceedings{jump09,
title = {Dynamic Shape Analysis via Degree Metrics},
author = {Maria Jump and Kathryn S. McKinley},
pages = {119--128},
doi = {10.1145/1542431.1542449},
crossref = {ISMM09}
}

@article{jump10,
author = {Maria Jump and Kathryn S. McKinley},
title = {Detecting Memory Leaks in Managed Languages with Cork},
journal = SPE,
year = 2010,
month = jan,
volume = 40,
number = 1,
pages = {1--22},
doi = {10.1002/spe.945}
}

@inproceedings{jung08,
title = {Practical Memory Leak Detector Based on Parameterized Procedural Summaries},
author = {Yungbum Jung and Kwangkeun Yi},
crossref = {ISMM08},
pages = {131--140},
doi = {10.1145/1375634.1375653},
abstract = {We present a static analyzer that detects memory leaks
in C programs. It achieves relatively high accuracy at a relatively
low cost on SPEC2000 benchmarks and several open-source software
packages, demonstrating its practicality and competitive edge against
other reported analyzers: for a set of benchmarks totaling 1,777
KLOCs, it found 332 bugs with 47 additional false positives (a
12.4\% false-positive ratio), and the average analysis speed was
720 LOC/sec.  We separately analyze each procedure's memory behavior
into a summary that is used in analyzing its call sites. Each
procedural summary is parameterized by the procedure's call context
so that it can be instantiated at different call sites. What
information to capture in each procedural summary has been carefully
tuned so that the summary should not lose any common memory-leak-related
behaviors in real-world C programs.  Because each procedure is
summarized by conventional fixpoint iteration over the abstract
semantics (a la abstract interpretation), the analyzer naturally
handles arbitrary call cycles from direct or indirect recursive
calls.}
}

@inproceedings{juul90,
author = "Nils Christian Juul",
title = "Report on the 1990 Workshop on Garbage Collection in Object-Oriented Systems",
crossref = "OOPSLA90",
note = "Addendum",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC90/workshopReport.ps.Z",
year = 1990
}

@inproceedings{juul90a,
author = "Nils Christian Juul",
title = "A Distributed, Faulting Garbage Collector for {E}merald",
crossref = "OOPSLA90-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC90/Juul.ps.Z"
}

@inproceedings{juul92,
title = "Comprehensive and Robust Garbage Collection in a Distributed System",
author = "Neils-Christian Juul and Eric Jul",
crossref = "IWMM92",
pages = {103--115},
doi = {10.1007/BFb0017203},
comment = "Concurrent, tri-colour mark-sweep scheme. Uses faulting a la Appel.
2 sets of collectors: (a) local, expedient, non-comprehensive; (b) global,
aims to be comprehensive."
}

@phdthesis{juul92a,
author = "Niels Christian Juul",
title = "Comprehensive, Concurrent, and Robust Garbage Collection in the
Distributed, Object-Based System, {E}merald",
school = DIKU,
year = 1992,
}

@manual{jvmpi,
title = "Java Virtual Machine Profiling Interface ({JVMPI})",
key = "JVMPI",
organization = "Sun Microsystems",
note = {http://java.sun.com/j2se/1.3/docs/guide/jvmpi/},
URL = {http://java.sun.com/j2se/1.3/docs/guide/jvmpi/},
comment = {Profiling interface for {J}ava}
}

@article{kaas89,
author = "M. Frans Kaashoek and Andrew Tanenbaum and S. Hummel and Henri E. Bal",
title = "An Efficient Reliable Broadcast Protocol",
journal = SIGOPS,
publisher = ACM,
volume = 23,
number = 4,
pages = "5--19",
month = Oct,
year = 1989
}

@mastersthesis{kabu92,
author = "Kaburlasos, Nikos",
title = "Hardware Support for Garbage Collection in the {C} Programming Language",
year = 1992,
school = "University of Texas at Austin"
}

@article{kaeh81,
author = "Kaehler, Ted",
title = "Virtual Memory for an Object-Oriented Language",
journal = "Byte",
volume = 6,
number = 8,
month = aug,
year = 1981,
pages = "378--387"
}

@incollection{kaeh83,
author = "Kaehler, Ted and Glenn Krasner",
title = "{LOOM} --- Large Object-Oriented Memory for {S}malltalk-80 Systems",
crossref = "Smalltalk-BHWA",
pages = "251--271",
}

@inproceedings{kaeh86,
author = "Kaehler, Ted",
title = "Virtual Memory on a Narrow Machine for an Object-Oriented Language",
crossref = "OOPSLA86",
pages = "87--106"
}

@inproceedings{kafu90,
author = "Dennis Kafura and Doug Washabaugh and Jeff Nelson",
title = "Garbage Collection of Actors",
crossref = "OOPSLA90",
pages = "126--134"
}

@article{kafu95,
author = "Dennis Kafura and Manibrata Mukherji and Doug Washabaugh",
title = "Concurrent and Distributed Garbage Collection of Active Objects",
journal = "IEEE Transactions on Parallel and Distributed Systems",
volume = 6,
number = 4,
month = apr,
year = 1995
}

@inproceedings{kage97,
author = "Andreas Kagedal and Saumya K. Debray",
title = "A Practical Approach to Structure Reuse of Arrays in Single Assignment Languages",
booktitle = "International Conference on Logic Programming",
pages = "18--32",
year = "1997",
url = "http://citeseer.nj.nec.com/agedal97practical.html"
}

@inproceedings{kagi91,
title = "Adaptive Storage Management for Very Large Virtual/Real Storage Systems",
author = "T. Kagimasa and K. Takahashi and S. Yoshizumi",
crossref = "ISCA91",
pages = "372--379"
}

@article{kain69,
author = "Y. Kain",
title = "Block Structures, Indirect Addressing,  and  Garbage  Collection",
journal = CACM,
publisher = ACM,
volume = 12,
number = 7,
month = Jul,
year = 1969,
pages = "395--398",
}

@inproceedings{kali09,
  author =	 {Tomas Kalibera and Filip Pizlo and Antony L. Hosking and Jan
                  Vitek},
  title =	 {Scheduling Hard Real-time Garbage Collection},
  booktitle =	 {30th IEEE Real-Time Systems Symposium},
  publisher =	 IEEEcomp,
  year =	 2009,
  month =	 dec,
  pages =	 {81--92},
  address =	 {Washington, DC},
  doi =		 {10.1109/RTSS.2009.40}
}

@inproceedings{kali09a,
title = {Replicating Real-time Garbage Collector for {J}ava},
author = {Tomas Kalibera},
crossref = {JTRES09},
doi={10.1145/1620405.1620420},
pages={100--109},
URL = {http://www.cs.purdue.edu/homes/jv/soft/ovm/replication/replication.pdf}
}

@inproceedings{kali09b,
author = {Tomas Kalibera and Marek Prochazka and Filip Pizlo and
          Martin Decky and Jan Vitek and Marco Zulianello},
title = {Real-Time {J}ava in Space: Potential Benefits and Open Challenges},
booktitle = {Eurospace Conference on Data Systems in
          Aerospace (DASIA)},
month = jan,
year = 2009,
address = {Istanbul, Turkey},
URL = {http://dsrg.mff.cuni.cz/publications/KaliberaProchazkaPizloDeckyVitekZulianello-RT_Java.pdf}
}

@inproceedings{kali09c,
author = {Tomas Kalibera and Jeff Hagelberg and Filip Pizlo and Ales
          Plsek and Ben Titzer and Jan Vitek},
title = {{CDx}: A Family of Real-time {J}ava Benchmarks},
crossref = {JTRES09},
pages = {41--50},
doi =	 {10.1145/1620405.1620412},
URL = {http://dsrg.mff.cuni.cz/publications/cdx09.pdf}
}

@inproceedings{kali11,
title = {Handles Revisited: Optimising Performance and Memory Costs in a Real-Time Collector},
author = {Tomas Kalibera and Richard Jones},
crossref = {ISMM11},
pages = {89--98},
doi = {10.1145/1993478.1993492},
abstract = {Compacting garbage collectors must update all references to objects
they move. Updating is a lengthy operation but the updates must be transparent
to the mutator. The consequence is that no space can be reclaimed until all
references have been updated which, in a real-time collector, must be done
incrementally. One solution is to replace direct references to objects with
handles. Handles offer several advantages to a real-time collector. They
eliminate the updating problem. They allow immediate reuse of the space used by
evacuated objects. They incur no copy reserve overhead. However, the execution
time overhead of handles has led to them being abandoned by most modern systems.
We re-examine this decision in the context of real-time garbage collection, for
which several systems with handles have appeared recently. We provide the first
thorough study of the overheads of handles, based on an optimised implementation
of different handle designs within Ovm's Minuteman real-time collector. We find
that with a good set of optimisations handles are not very expensive. We
obtained zero overhead over the widely used Brooks-style compacting collector
(1.6\% and 3.1\% on two other platforms) and 9\% increase in memory usage. Our
optimisations are particularly applicable to mark-compact collectors, but may
also be useful to other collectors.}
}

@article{kali11a,
author = {Tomas Kalibera and Jeff Hagelberg and Petr Maj and Filip Pizlo and Ben
Titzer and Jan Vitek},
title = {A Family of Real-time {J}ava Benchmarks},
journal = CPE,
volume = 23,
number = 14,
pages = {1679--1700},
year = 2011,
doi = {10.1002/cpe.1677}
}

@Article{kali11b,
  author =       {Tomas Kalibera and Filip Pizlo and Antony L. Hosking and Jan
                  Vitek},
  title =        {Scheduling real-time garabage collection on uniprocessors},
  journal =      {ACM Transactions on Computer Systems},
  year =         2011,
  volume =       3,
  number =       1,
  pages =        {8:1--29},
  month =        aug,
  doi =          {10.1145/2003690.2003692}
}

@inproceedings{kali12,
title = {A Black-Box Approach to Understanding Concurrency in {D}a{C}apo},
author = {Tomas Kalibera and Matthew Mole and Richard Jones and Jan Vitek},
crossref = {OOPSLA12},
abstract = {Increasing levels of hardware parallelism are one of the main challenges for
programmers and implementers of managed runtimes. Any concurrency or scalability
improvements must be evaluated experimentally. However, application benchmarks
available today may not reflect the highly concurrent applications we anticipate
in the future. They may also behave in ways that VM developers do not expect. We
provide a set of platform independent concurrency-related metrics and an
in-depth observational study of current state of the art benchmarks, discovering
how concurrent they really are, how they scale the work and how they synchronise
and communicate via shared memory.},
URL = {http://www.cs.kent.ac.uk/pubs/2012/3246}
}

@inproceedings{kali13,
author = {Kalibera, Tomas and Jones, Richard},
title = {Rigorous Benchmarking in Reasonable Time},
crossref = {ISMM13},
doi = {10.1145/2464157.2464160},
abstract = {Experimental evaluation is key to systems research. Because modern
systems are complex and non-deterministic, good experimental methodology demands
that researchers account for uncertainty. To obtain valid results, they are
expected to run many iterations of benchmarks, invoke virtual machines (VMs)
several times, or even rebuild VM or benchmark binaries more than once. All this
repetition costs time to complete experiments. Currently, many evaluations give
up on sufficient repetition or rigorous statistical methods, or even run
benchmarks only in training sizes. The results reported often lack proper
variation estimates and, when a small difference between two systems is
reported, some are simply unreliable.
In contrast, we provide a statistically rigorous methodology for repetition and
summarising results that makes efficient use of experimentation time. Time
efficiency comes from two key observations. First, a given benchmark on a given
platform is typically prone to much less non-determinism than the common
worst-case of published corner-case studies. Second, repetition is most needed
where most uncertainty arises (whether between builds, between executions or
between iterations). We capture experimentation cost with a novel mathematical
model, which we use to identify the number of repetitions at each level of an
experiment necessary and sufficient to obtain a given level of precision.
We present our methodology as a cookbook that guides researchers on the number
of repetitions they should run to obtain reliable results. We also show how to
present results with an effect size confidence interval. As an example, we show
how to use our methodology to conduct throughput experiments with the DaCapo and
SPEC CPU benchmarks on three recent platforms.},
} 

@manual{kals89,
author = "Bill Kalsow and Eric Muller",
title = "{SRC} {M}odula-3, Version 1.2",
organisation = DECSRC,
month = dec,
year = 1989
}

@article{kala03,
title = {Mash That Trash --- Incremental Compaction in the {IBM} {JDK} Garbage Collector:
How to minimize pause times and free the heap from dark matter},
author = {Aruna Kalagnanam and Sripathi Kodi},
journal = {IBM developerWorks},
month = jun,
year = 2003,
abstract = {This article discusses incremental compaction, a new
feature in the memory management component of IBM JDK 1.4.0.
Incremental compaction is a way of spreading compaction work across
different garbage collection cycles, thereby reducing pause times. The
authors discuss the need for incremental compaction, the compaction
phases at a high level, and some runtime parameters. They also explain
how to interpret changes in the verbosegc output.},
URL = {http://www-106.ibm.com/developerworks/ibm/library/i-incrcomp}
}

@inproceedings{kakk98,
author = {Sheetal V. Kakkad and Mark S. Johnstone and Paul R. Wilson },
title = {Portable Run-Time Type Description for Conventional Compilers},
pages = {146--153},
crossref = {ISMM98},
abstract = {Many useful programming language extensions and support
libraries require knowledge of the locations of fields within objects
at run time. Examples include orthogonal persistent object stores,
precise garbage collectors, data structure picklers and parameter
marshaling schemes.

For clean and efficient implementation as libraries, these systems
require run-time knowledge of in-memory layouts of data objects, which
is unavailable in most traditionally-compiled and linked programming
languages, such as C, C++, and Ada. Even C++'s recently-standardized
run-time type identification (RTTI) feature is insufficient, because it
describes language-level features of the type hierarchy and not
compiler-dependent object layout decisions.

We present a facility for run-time type description or RTTD, which
extracts low-level layout information from debugging information
generated by conventional compilers, and makes it available to user
programs. We believe this to be the simplest and most portable approach
to run-time type description, requiring no changes to existing
compilers. In this paper, we describe the basic strategies and present
details of our implementation for C++. We also sketch some extensions
that we have implemented, including special treatment of C++'s virtual
function table pointers to match persistent or foreign data objects
with the actual code in a particular application.

Our implementation of run-time type description is freely available. It
is in regular use with multiple operating systems and compilers, in
both free and commercial products, including a high-performance
persistent object storage system for C++ and a real-time garbage
collector. }
}

@article{kaku86,
title = "Parallel Reference Counting Algorithm.",
author = "K. Kakuta and H. Nakamura and S. Iida",
journal = IPL,
publisher = NH,
volume = 23,
number = 1,
pages = "33--37",
year = "1986",
comment = {Presents a parallel architecture based on reference counting.
Unable to recycle all cyclic structures in parallel.}
}

@inproceedings{kama93,
author = "Tomio Kamada and Satoshi Matsuoka and Akinori Yonezawa",
title = "Efficient Parallel Global Garbage Collection on Massively Parallel Computers",
crossref = "OOPSLA93-gc",
}

@inproceedings{kama94,
author = "Tomio Kamada and Satoshi Matsuoka and Akinori Yonezawa",
title = "Efficient Parallel Global Garbage Collection on Massively Parallel Computers",
booktitle = "Supercomputing'94",
pages = "79--88",
publisher = IEEE,
editor = "G.M. Johnson",
year = 1994,
URL = "http://www.computer.org/p3/kamadat.ps",
}

@inproceedings{kand87,
title = "Network Simulation of Synchronous Garbage Collection Algorithm",
author = "B. Kandu and S. Heng and C. Wu and Nader Bagherzadeh",
pages = "215--222",
booktitle = "Simulation of computer networks1987 Symposium on the
simulation of computer networks, Colorado Springs, Aug. 4--7, 1987",
editor = "P. Roth",
publisher = IEEE,
year = "1987",
isbn = "0--8186--0782--3"
}

@inproceedings{kand01,
author = {M. Kandemir and J. Ramanujam and M. J. Irwin and N. Vijaykrishnan and
I. Kadayif and A. Parikh},
title = {Dynamic management of scratch-pad memory space},
booktitle = {DAC},
year = 2001
}

@mastersthesis{katz86,
author = "M. J. Katz",
title = "{ParaTran}:  A Transparent, Transaction Based Runtime
Mechanism for Parallel Execution of {S}cheme",
school = MIT,
month = jun,
year = 1986
}

@inproceedings{kapl02,
title = {Adaptive Caching for Demand Prepaging},
author = {Scott Kaplan and Lyle McGeoch and Megan Cole},
crossref = {ISMM02},
pages = {114--126}
}

@misc{kark04,
title = {Effectiveness of Garbage Collection in {MIT}/{GNU} {S}cheme},
author = {Amey Karkare and Amitabha Sanyal and Uday Khedker},
URL = {http://arxiv.org/pdf/cs.PL/0611093},
month = nov,
year = 2006
}


@article{kauf84,
title = "Tailored-List and  Recombination-Delaying Buddy Systems",
author = "Arie Kaufman",
journal = TOPLAS,
publisher = ACM,
volume = 6,
number = 4,
year = 1984,
pages = "118--125"
}

@inproceedings{kawa86,
title = "Scalable Dataflow Structure Store",
author = " K. Kawakami and J. R. Gurd",
booktitle = "13th Annual International Symposium on Computer
Architecture (ISCA)",
address = {Tokyo},
month = jun,
publisher = IEEE,
year = 1986,
abstract = {A design for a highly parallel data structure store for the
prototype Manchester Dataflow Computer is presented.  The main design objective
is to allow all storage functions to be performed concurrently.  The functions
include space allocation and garbage collection, as well as operations for
reading and writing the store.  The resulting design is scalable in that an
incremental increase in performance for any function can be achieved by adding
appropriate hardware modules to the system.  A relative balance in performance
between the different functions can therefore be achieved.  In the hardware
structure store, the logical and the physical function units are designed
separately.  This increases flexibility for configuring multiprocessor
dataflow systems.  A single hardware module performing all the functions has
been constructed and attached to the prototype Manchester Dataflow Machine.
The performance of this configuration is discussed.}
}

@inproceedings{kawa08,
title = {Analysis and Reduction of Memory Inefficiencies in {J}ava Strings},
author = {Kiyokuni Kawachiya and Kazunori Ogata and Tamiya Onodera},
crossref = {OOPSLA08},
abstract = {This paper describes a novel approach to reduce the memory
consumption of Java programs, by focusing on their "string memory
inefficiencies". In recent Java applications, string data occupies a large
amount of the heap area. For example, about 40\% of the live heap area is used
for string data when WebSphere Application Server with Trade6 is running. By
investigating the string data in the live heap, we identified two types of
memory inefficiencies --- "duplication" and "unused literals". In the heap,
there are many string objects that have the same values. There also exist many
string literals whose values are not actually used by the application. Since
these inefficiencies exist as live objects, they cannot be eliminated by
existing garbage collection techniques, which only remove dead objects.
Quantitative analysis of Java heaps in real applications revealed that more than
50\% of the string data in the live heap is wasted. To reduce the string memory
inefficiencies, this paper proposes two techniques at the Java virtual machine
level, "StringGC" for eliminating duplicated strings at the time of garbage
collection, and "Lazy Body Creation" for delaying part of the literal
instantiation until the literal's value is actually used. We also present an
interesting technique at the Java program level, which we call "BundleConverter"
for preventing unused message literals from being instantiated. Prototype
implementations on a production Java virtual machine have achieved about 18\%
reduction of the live heap in the production application server. The proposed
techniques could also reduce the live heap of standard Java benchmarks by 11.6\%
in average, without noticeable performance degradation.}
}

@inproceedings{kawa12,
title = {Distributed Garbage Collection for Managed {X}10},
author = {Kiyokuni Kawachiya and Mikio Takeuchi and Salikh Zakirov and Tamiya
Onodera},
booktitle = {Proceedings of the X10 2012 Workshop},
address = {Beijing, China},
month = jun,
year = 2012,
url = {http://dl.acm.org/citation.cfm?id=2246061&CFID=88387744&CFTOKEN=74139816}
}

@misc{kemp01,
title = {A Garbage Collection Framework for {C}++},
author = {William E. Kempf},
year = 2001,
month = jan,
howpublished = {The Vode Project website},
URL = {http://www.codeproject.com/KB/cpp/garbage_collect.aspx?print=true}
}

@inproceedings{kenn04,
author = {Andrew Kennedy and Don Syme},
title = {Combining Generics, Pre-Compilation and Sharing Between Software-Based Processes},
crossref = {SPACE04},
}

@article{kenn91,
author = "K. B. Kenny and K. Lin",
title = "Flexible Real-Time Systems Using the {F}lex Language",
journal = IEEETransComp,
publisher = IEEE,
pages = "70--78",
month = may,
year = 1991
}

@inproceedings{kenn91a,
title = "The Features of the Object Oriented Abstract Type Hierarchy
({OATH})",
author = "Brian Kennedy",
booktitle = "{U}senix {C++} Conference",
editor = "",
pages = "41--50",
year = 1991,
publisher = "Usenix Association",
month = apr,
comment = "Uses accessors rather than smart pointers in order to avoid the
dangers of raw pointers leaking out. But accessors still suffer from many
of the same problems as smart pointers."
}

@inproceedings{kerm95,
author = "A. M. Kermarrec and G. Cabillic and A. Gefflaut and C. Morin and Isabbelle Puaut",
title = "A Recoverable Distributed Shared Memory Integrating Coherence and
Recoverability",
booktitle = "25th Annual International Symposium on Fault-Tolerant Computing",
year = 1995
}

@inproceedings{kerm06,
  title =	 {The {C}ompressor: Concurrent, Incremental and Parallel
                  Compaction},
  author =	 {Haim Kermany and Erez Petrank},
  crossref =	 {PLDI06},
  pages =	 {354--363},
  doi =		 {10.1145/1133981.1134023}
}

@inproceedings{kero07,
title = {A Correct and Useful Incremental Copying Garbage Collector},
author = {Martin Kero and Johan Nordlander and Per Lundgren},
pages = {129--140},
crossref = {ISMM07},
}

@inproceedings{kess89,
author = "Kessler, Richard and Richard Jooss and Alvin Lebeck and Mark D.
Hill",
title = "Inexpensive Implementations of Set-Associativity",
crossref = {ISCA89},
pages = "131--139"
}

@inproceedings{kess89a,
author = "Richard E. Kessler and M. Livny",
title = "An Analysis of Distributed Shared Memory Algorithms",
booktitle = "9th International Conference on Distributed Computing Systems",
month = Jun,
year = 1989
}

@article{kess92,
author = "Kessler, Richard and H. Carr and L. Stoller and M. Swanson",
title = "Implementing {C}oncurrent {S}cheme for the {M}ayfly Distributed Parallel Processing System",
journal = LSC,
publisher = "Kluwer",
volume = 5,
number = 1,
pages = "73--93",
month = may,
year = 1992
}

@inproceedings{keyn01,
author = {Peter Keyngnaert},
title = {Conflict Graph Based Allocation of Static Objects to Memory Banks},
crossref = {SPACE01},
}

@misc{khed06,
author = {Uday Khedker and Amitabha Sanyal and Amey Karkare},
title = {Heap Reference Analysis Using Access Graphs},
howpublished = {ACM Computing Research Repository},
URL = {http://arxiv.org/abs/cs.PL/0608104},
month = aug,
year = 2006
}

@article{khed07,
  author =	 {Uday Khedker and Amitabha Sanyal and Amey Karkare},
  title =	 {Heap Reference Analysis Using Access Graphs},
  journal =	 TOPLAS,
  volume =	 30,
  number =	 1,
  year =	 2008,
  doi =		 {10.1145/1290520.1290521},
}

@inproceedings{kim98,
author = "Jin-Soo Kim and Xiaohan Qin and Yarsun Hsu",
title = "Memory Characterization of a Parallel Data Mining Workload",
booktitle = "Proc. Workload Characterization: Methodology and Case Studies",
publisher = IEEE,
year = 1998,
month = nov,
URL = "http://www.computer.org/proceedings/wwc/0450/04500060abs.htm",
abstract = {
This paper studies a representative of an important class of emerging
applications, a parallel data mining workload.  The application,
extracted from the {IBM} {I}ntelligent {M}iner, identifies groups of
records that are mathematically similar based on a neural network
model called self-organizing map.  We examine and compare in details
two implementations of the application: (1) temporal locality or
working set sizes; (2) spatial locality and memory block utilization;
(3) communication characteristics and scalability; and (4) TLB
performance.

First, we find that the working set hierarchy of the application is
governed by two parameters, namely the size of an input record and the
size of prototype array; it is independent of the number of input
records.  Second, the application shows good spatial locality, with
the implementation optimized for sparse data sets having slightly
worse spatial locality.  Third, due to the batch update scheme, the
application bears very low communication.  Finally, a 2-way set
associative TLB may result in severely skewed TLB performance in a
multiprocessor environment caused by the large discrepancy in the
amount of conflict misses.  Increasing the set associativity is more
effective in mitigating the problem than increasing the TLB size.
}
}

@inproceedings{kim00a,
author = "Jin-Soo Kim and Yarsun Hsu",
title = "Memory System Behavior of {J}ava Programs: Methodology and Analysis",
booktitle = SIGMETRICS,
pages = {264--274},
publisher = ACM,
year = 2000,
month = jul,
URL = "http://dev.acm.org/pubs/citations/proceedings/metrics/339331/p264-kim/"
}

@inproceedings{kim99,
  title =	 {Scheduling Garbage Collector for Embedded Real-Time Systems},
  author =	 {Taehyoun Kim and Naehyuck Chang and Namyun Kim and Heonshik
                  Shin},
  crossref =	 {LCTES99},
  pages =	 {55--64},
  doi =		 {10.1145/314403.314444}
}

@inproceedings{kim00,
title = {Bounding Worst Case Garbage Collection Time for Embedded Real-Time Systems},
author = {Taehyoun Kim and Naehyuck Chang and Heonshik Shin},
booktitle = {6th IEEE Real-Time Technology and Applications Symposium (RTAS)},
year = 2000,
address = {Washington, DC},
month = {May/June},
doi = {10.1109/RTTAS.2000.852450},
pages = {46--55},
abstract = {Execution of programs with various data structures often
requires dynamic memory management based on garbage collection for
better productivity, robustness, and program integrity. In spite of its
benefits, garbage collection has not been widely used in embedded
real-time systems partly because it often causes unpredictable
pause delay. Guaranteeing real-time operations with garbage
collection aims to bound and estimate the worst case computation
time of garbage collector as well as application tasks. We
introduce a new technique for bounding and estimating the worst
case garbage collection time in light of task scheduling. Since
the worst case live memory is the dominant factor to determine the
worst case garbage collection time, we quantify the worst case
live memory using the states of periodic tasks. We also present a
predictable real-time copying collection algorithm in order to
assess the effectiveness of the proposed approach. Performance
evaluation shows that the proposed approach provides a safe and
effective bound on the garbage collection time, thus reducing the
upper bound of live memory size by up to 35x \% compared with the
trivial bound. It also demonstrates that our algorithm can
accomplish 7-14\% reduction in the memory requirement.}
}

@article{kim01,
author = {Taehyoun Kim and Naehyuck Chang and Heonshik Shin},
title = {Joint Scheduling of Garbage Collector and Hard Real-time Tasks for
Embedded Applications},
journal = JSS,
pages = {247--260},
publisher = ES,
volume = 58,
number = 3,
month = sep,
year = 2001,
doi={10.1016/S0164-1212(01)00042-5}
}

@inproceedings{kim03,
author = {Taehyoun Kim and Heonshik Shin},
title = {Scheduling-Aware Real-Time Garbage Collection using Dual Aperiodic
Servers},
booktitle = {Real-Time and Embedded Computing Systems and Applications},
series = LNCS,
publisher = SV,
year =2004,
volume = 2968,
pages = {1--17},
doi = {10.1007/978-3-540-24686-2_1},
abstract = {Garbage collection has not been widely used in embedded real-time
applications since traditional real-time garbage collection algorithm can hardly
bound its worst-case responsiveness. To overcome this limitation, we have
proposed a scheduling-integrated real-time garbage collection algorithm based on
the single aperiodic server in our previous work. This paper introduces a new
scheduling-aware real-time garbage collection which employs two aperiodic
servers for garbage collection work. Our study aims at achieving similar
performance compared with the single server approach whilst relaxing the
limitation of the single server approach. In our scheme, garbage collection
requests are scheduled using the preset CPU bandwidth of aperiodic server such
as the sporadic server and the deferrable server. In the dual server scheme,
most garbage collection work is serviced by the secondary server at low priority
level. The effectiveness of our approach is verified by analytic results and
extensive simulation based on the trace-driven data. Performance analysis
demonstrates that the dual server scheme shows similar performance compared with
the single server approach while it allows flexible system design.}
}

@inproceedings{kimu87,
author = "Y. Kimura and K. Nishida and N. Miyauchi and T. Chikayama",
title = "Realtime {GC} by Multiple Reference Bit in {KL1}",
booktitle = "Data Flow Workshop",
pages = "215--222",
year = 1987,
month = oct,
note = "In Japanese"
}

@article{king91,
author = "H. Kingdon and David R. Lester and Geoffrey L. Burn",
title = "The {HDG}-Machine: A Highly Distributed Graph Reducer
for a transputer network",
journal = CompJ,
publisher = BCS,
volume = 34,
numbner = 4,
pages = "290--301",
month = Sep,
year = 1991
}

@inproceedings{king02,
title = {Removing {GC} Synchronisation},
author = {Andy C. King},
crossref = {OOPSLA02},
pages = {112--113 (Companion)}
}

@phdthesis{king04,
title = {Removing Garbage Collector Synchronisation},
author = {Andy C. King},
school = UKC,
year = 2004,
URL = {http://www.cs.kent.ac.uk/pubs/2004/1981/}
}

@techreport{kist99,
author = {Thomas Kistler and Michael Franz.},
title = {The Case for Dynamic Optimization: Improving Memory-Hierarchy
Performance by Continuously Adapting the Internal Storage Layout of Heap Objects at Run-Time},
institution = {University of California, Irvine},
number = {99--21},
month = may,
year = 1999,
URL = {http://caesar.ics.uci.edu/kistler/papers/ics-tr-99-21.ps}
}

@techreport{kist98,
author = {Thomas Kistler and Michael Franz},
title = {Automated Layout of Data Members for Type-Safe Languages},
institution = {University of California, Irvine},
number = {98--22},
month = may,
year = 1998,
URL = {http://caesar.ics.uci.edu/kistler/papers/ics-tr-98-22.ps}
}

@article{kist00,
author = {Thomas Kistler and Michael Franz},
title = {Automated Data-Member Layout of Heap Objects to Improve Memory-Hierarchy Performance},
journal = TOPLAS,
volume = 22,
number = 3,
pages = {490--505},
month = may,
year = 2000,
publisher = ACM
}

@inproceedings{kjel95,
title = "Memory Management in Flash-Memory Disks with Data Compression",
author = "Morten Kjels\/{o} and Simon Jones",
crossref = "IWMM95",
pages = {399-413},
doi = {10.1007/3-540-60368-9_36}
}

@inproceedings{klai91,
author = "Klaiber, Alexander C. and Henry M. Levy",
title = "An Architecture for Software-Controlled Data Prefetching",
crossref = {ISCA91},
pages = "43--53",
}

@inproceedings{klio09,
author = {Gabriel Kliot and Erez Petrank and Bjarne Steensgaard},
title = {A Lock-Free, Concurrent, and Incremental Stack Scanning for Garbage
Collectors},
crossref = {VEE09},
URL = {http://www.cs.technion.ac.il/~erez/Papers/sctack-scan-vee09.pdf}
}

@inproceedings{kloc1,
author = {Klock,II, Felix S. and Clinger, William D.},
title = {Bounded-Latency Regional Garbage Collection},
booktitle = {Proceedings of the 7th Symposium on Dynamic languages, DLS'11},
year = 2011,
address = {Portland, Oregon, USA},
pages = {73--84},
doi = {10.1145/2047849.2047859},
publisher = ACM,
abstract = {Regional garbage collection is scalable, with theoretical worst-case
bounds for gc latency, MMU, and throughput that are independent of mutator
behavior and the volume of reachable storage. Regional collection improves upon
the worst-case pause times and MMU seen in most other general-purpose
collectors, including garbage-first and concurrent mark/sweep collectors.}
} 

@mastersthesis{kluk89,
author = "Kluk, Mark G.",
title = "A Study of Garbage Collection Schemes for List Processors",
year = 1989,
school = "Lehigh University"
}

@inproceedings{kluz88,
author = {F. Klu\'{z}niak},
title = "Compile-Time Garbage Collection for Ground {P}rolog",
booktitle = "5th International Conference and Symposium on Logic Programming",
pages = "1490--1505",
year = 1988
}

@techreport{knig74,
author = "Tom Knight",
title = "{CONS}",
institution = MITAI,
type = "Working Paper",
number = 80,
month = nov,
year = 1974,
comment = "MIT Lisp machine"
}

@article{know65,
title = "A Fast Storage Allocator",
author = "Kenneth C. Knowlton",
journal = CACM,
publisher = ACM,
volume = 8,
number = 10,
month = oct,
year = 1965,
pages = "623--625",
doi={10.1145/365628.365655}
}

@inbook{knut73,
  author =	 "Donald E. Knuth",
  title =	 "Lists and Garbage Collection",
  crossref =     "knut73book",		   
  comment =	 {section 2.3.5 is the most comprehensive description and
                  analysis of algorithms that appeared prior to 1968. Standard
                  reference for these algorithms before cohe81},
  chapter =	 2,
  pages =	 "408-423",
}

@book{knut73book,
  key =          "Knuth Volume 1",
  author =	 "Donald E. Knuth",
  title =	 "The Art of Computer Programming",
  volume =	 "I: Fundamental Algorithms",
  publisher =	 AW,
  edition =	 "Second",
  year =	 1973,
}

@inproceedings{ko08,
author = {Sohyang Ko and Seonsoo Jun and Kiyong Kim and Yeonseung Ry},
title = {Study on Garbage Collection Schemes for Flash-Based Linux Swap System},
booktitle = {Advanced Software Engineering and Its Applications, ASEA 2008},
pages = {13--16},
month = dec,
year = 2008,
doi = {10.1109/ASEA.2008.55},
abstract = {NAND flash memory based SSDs (solid state disks) have become an
alternative storage device for future computer systems. Legacy operating system
functionalities like file system and virtual memory system should be carefully
re-designed since flash memory cannot be overwritten unless erased in advance.
In this paper, we study the performance of garbage collection schemes when flash
memory is used as the Linux swap storage. We have collected swap I/O traces from
Linux kernel and performed trace-driven simulation. We found that Linux swap
system must be re-designed in order to use flash memory as swap storage.}
}

@inproceedings{koch90,
title = "Cache Coherence and Storage Management in a Persistent Object System",
author = "B. Koch and T. Schunke and A. Dearle and F. Vaughan and C. Marlin and
R. Fazekerley and C. Barter",
crossref = "POS90",
pages = {99--109}
}

@inproceedings{koga97,
author = {Dmitry Kogan and Assaf Schuster},
title = {Remote Reference Counting: Distributed Garbage Collection with
Reduced Memory and Communication Overhead},
booktitle = {5th European Symposium on Algorithms},
address = {Graz},
pages = {308--325},
month = sep,
year = 1997,
URL = {http://www.cs.technion.ac.il/Labs/Millipede}
}

@inproceedings{koga97a,
author = {Dmitry Kogan and Assaf Schuster},
title = {Collecting Garbage Pages in a Distributed Shared Memory System},
booktitle = {5th European Symposium on Algorithms},
address = {Graz},
pages = {308--325},
month = sep,
year = 1997,
URL = {http://www.cs.technion.ac.il/Labs/Millipede}
}

@mastersthesis{koid93,
author = "Hiroshi Koide",
title = "Hybrid Garbage Collection",
school = "University of Electro-Communications, Tokyo",
year = 1993,
}

@article{koid93a,
author = "Hiroshi Koide and K. Noshita",
title = "On the Copying Garbage Collection which Preserves the Genetic Order",
journal = "Transaction of Information Processing (IPSJ)",
volume = 34,
number = 11,
pages = "2395--2400",
month = nov,
year = 1993,
note = "In Japanese"
}

@inproceedings{koll96,
title = "Blue --- A Language for Teaching Object-Oriented Programming",
author = {Michael K\"{o}lling and John Rosenberg},
booktitle = "27th SIGCSE Technical Symposium on Computer Science Education",
month = mar,
year = 1996,
pages = "190--194",
URL = "ftp://ftp.cs.su.oz.au/mik/papers/blue_paper.ps.Z",
abstract = "Teaching object-oriented programming has clearly become an
important part of computer science education. We agree with many others
that the best place to teach it is in the CS1 introductory course. Many
problems with this have been reported in the literature. These mainly
result from inadequate languages and environments. Blue is a new
language and integrated programming environment, currently under
development explicitly for object-oriented teaching. We expect clear
advantages from the use of Blue for first year teaching compared to
using other available languages. This paper describes the design
principles on which the language was based and the most important
aspects of the language itself.",
comment = "Uses GC"
}

@techreport{kolo87,
author = "Elliot K. Kolodner",
title = "Recovery Using Virtual Memory",
institution = "MIT Laboratory for Computer Science",
type = "Technical Memo",
number = "MIT/LCS/TM--404",
month = jul,
year = 1987,
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TM-404.html"
}

@inproceedings{kolo89,
title = "Atomic Garbage Collection:  Managing a Stable Heap",
author = "Elliot K. Kolodner and Barbara Liskov and  W. Weihl",
pages = "15--25",
booktitle = SIGMOD,
editor = "James Clifford and Bruce G. Lindsay and David Maier",
publisher = ACM,
month = jun,
year = 1989,
}

@inproceedings{kolo91,
title = "Atomic Incremental Garbage Collection and Recovery for Large Stable
Heap, Implementing Persistent Object Bases: Principles and Practice",
author = "Elliot K. Kolodner",
address = "IBM Science and Technology, Israel and MIT Lab. MA, USA",
crossref = "POS90"
}

@phdthesis{kolo92,
author = "Kolodner, Elliot K.",
title = "Atomic Incremental Garbage Collection and Recovery for a Large Stable Heap",
school = MIT,
year = 1992,
note = "MIT/LCS/TR  534"
}

@inproceedings{kolo92a,
title = "Atomic Incremental Garbage Collection",
author = "Elliot K. Kolodner and W. E. Weihl",
crossref = "IWMM92",
pages = {365--387},
doi = {10.1007/BFb0017202}
}

@inproceedings{kolo93,
title = "Atomic Incremental Garbage Collection and Recovery for Large Stable
Heap",
author = "Elliot K. Kolodner and William E. Weihl",
booktitle = SIGMOD,
address = "Washington, DC",
editor = "Peter Buneman and Sushil Jajodia",
pages = "177--186",
month = may,
year = 1993,
note = "Also MIT/LCS/TR-534, February, 1992",
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TM-534.html"
}

@techreport{kolo98,
author = {Elliot K. Kolodner and Erez Petrank},
title = {Parallel Copying Garbage Collection using Delayed Allocation},
institution = "IBM Haifa Research Lab.",
number = "88.384",
month = nov,
year = 1999,
URL = {http://www.cs.technion.ac.il/~erez/papers.html},
}

@inproceedings{koop90,
  title =	 "Cache Performance of Combinator Graph Reduction",
  author =	 "Koopman, Jr., Philip J. and Peter Lee and Daniel
                  P. Siewiorek",
  crossref =	 "PLDI89",
  pages =	 "110--119",
  doi =		 {10.1145/73141.74828}
}

@article{koop92,
title = "Cache Behavior of Combinator Graph Reduction",
author = "Philip J. Koopman and Peter Lee and Daniel P. Siewiorek",
pages = "265--297",
journal = TOPLAS,
publisher = ACM,
year = 1992,
month = apr,
volume = 14,
number = 2
}

@techreport{kord92,
author = "Kordale, R. and John Shilling and Mustaque Ahamad",
title = "Garbage Collection in Distributed Shared Memory Systems",
institution = "Georgia Institute of Technology",
number = "TR GIT-CC-92/45",
year = 1992
}

@inproceedings{kord93,
author = "R. Kordale and Mustaque Ahamad",
title = "A Scalable Cyclic Garbage Detection Algorithm for Distributed Systems",
crossref = "OOPSLA93-gc",
}

@inproceedings{kord93a,
author = "Kordale, R. and Mustaque Ahamad and John Shilling",
title = "Distributed/Concurrent Garbage Collection in Distributed Shared Memory Systems",
crossref = "IWOOOS93",
}

@inproceedings{korn85,
author = "David G. Korn and Kiem-Phong Vo",
title = "In Search of a Better Malloc",
booktitle = "USENIX Summer Conference",
address = {Portland, OR},
publisher = UA,
year = 1985,
pages = "489--506"
}

@article{kowa79,
author = "T. Kowaltowski",
title = "Data Structures and Correctness of Programs",
journal = JACM,
publisher = ACM,
volume = 26,
number = 2,
month = apr,
year = 1979,
pages = "283--301",
comment = {proves the correctness of the link reversal algorithm by Deutsch-Schorr-Waite},
}

@inproceedings{kral06,
title = {Static Verification of Global Heap References in {J}ava Native
Libraries},
author = {Andreas Krall},
pages = {98--100},
crossref = {SPACE06}
}

@inproceedings{kran86,
  author =	 "Kranz, David A. and Richard Kelsey and Jonathan Rees and
                  Paul Hudak and James Philbin and Norman Adams",
  title =	 "{ORBIT}: An Optimizing Compiler For {S}cheme",
  crossref =	 "PLDI86",
  pages =	 "219--233",
  doi =		 {10.1145/12276.13333}
}

@phdthesis{kran88,
author = "David A. Kranz",
title = "{ORBIT}:  An Optimizing Compiler For {S}cheme",
school = "Yale University",
year = 1988,
month = feb
}

@inproceedings{kran89,
  author =	 "David A. Kranz and Robert H. Halstead and Eric Mohr",
  title =	 "{Mul-T}: A High-Performance Parallel {Lisp}",
  crossref =	 "PLDI89",
  pages =	 "81--90",
  doi =		 {10.1145/73141.74825}
}

%book{Smalltalk-BHWA,
% in cross-references section

@inproceedings{krie93,
author = "E. Ulrich Kriegel",
title = "A Conservative Garbage Collector for an {EuLisp} to {ASM}/{C} Compiler",
crossref = "OOPSLA93-gc",
}

@inproceedings{krie90,
author = "O. Krieger and Michael Stumm",
title = "An Optimistic Approach for Consistent Replicated Data for Multicomputers",
booktitle = "Proc. HICCSS",
year = 1990
}

@inproceedings{kris06,
title = {Separation Logic for a Higher-Order Typed Language},
author = {Neelakantan Krishnaswami},
pages = {73--82},
crossref = {SPACE06}
}

@article{krog73,
author = "S. Krogdahl",
title = "A Dynamic Storage Allocation Problem",
journal = IPL,
publisher = NH,
volume = 2,
year = 1973,
pages = "96--99"
}

@incollection{krue89,
author = "Steven Krueger",
title = "VLSI-Appropriate Garbage Collection Support",
booktitle = "VLSI for artificial intelligence",
editor = "Delgado-Frias, Jose G and Moore, Will R.",
publisher = "Kluwer Academic Publishers",
year = 1989,
series = "The Kluwer international series in engineering and computer science"
}

@techreport{kuec91,
author = {K\"{u}chlin, Wolfgang and Nevin, Nicholas J.},
title = "On Multi-Threaded List-Processing and Garbage Collection",
institution = "Ohio State University",
year = 1991,
number = "OSU-CISRC-3/91-TR11",
month = Mar,
abstract = "We present the S-threads system for multi-threaded
list-processing in C, and we discuss its unique techniques of
parallel garbage collection.  The system is implemented on top of
C Threads on an Encore Multimax running Mach.  It was developed
for the parallelization of the SAC-2 Computer Algebra system, but
S-threads is general enough to support the parallelization of
other C based list-processing systems.  An S-thread is a C Thread
extended by a private heap segment with a private list of
available cells.  Private heaps are dynamically allocated by
claiming pages of cells from a global shared heap.  S-threads can
thus concurrently cons list cells and the application library can
build other parallel list-processing on top.
Our main discovery is that the exclusive use of the portable C
Threads system has profound implications for garbage collection.
We can no  longer efficiently stop all processing at a barrier,
which precludes us from using many popular parallel garbage
compaction algorithms. However, threads can now perform
preventive garbage collection upon exiting, where they free their
private heap segment at the small cost of copying their results.
This proves very effective in our experience, and appears
especially promising for real-time symbolic computation.  Under
some restrictions, threads can also run a sequential garbage
collection algorithm, such as mark-and-sweep, on their private
heaps.
On separate threads, multiple garbage collections and ordinary
processing can then occur concurrently.  Under a largely
functional style of programming, there is then no need for a new
parallel garbage collection algorithm, which is important for
full upward compatibility of sequential software.  We present
empirical results from testing our garbage collection techniques
on a parallel algorithm for polynomial g.c.d. calculation."
}

@inproceedings{kuec91a,
author = {K\"{u}chlin, Wolfgang and Nevin, Nicholas J.},
title = "On Multi-Threaded List-Processing and Garbage Collection",
booktitle = "3rd {IEEE} Symposium on Parallel and Distributed Processing",
pages = "894--897",
month = dec,
publisher = IEEE,
year = 1991
}

@inproceedings{kuec91b,
author = {K\"{u}chlin, Wolfgang},
title = "A Space-Efficient Parallel Garbage Collection Algorithm",
booktitle = "5th {ACM} International Conference on Supercomputing",
pages = "40--46",
publisher = ACM,
month = jun,
year = 1991
}

@inproceedings{kuma02,
title = {Dynamic Memory Management for Programmable Devices},
author = {Sanjeev Kumar and Kai Li},
crossref = {ISMM02},
pages = {139--149}
}

@inproceedings{kung77,
  author =	 "H. T. Kung and S. W. Song",
  title =	 "An Efficient Parallel Garbage Collection System and its
                  Correctness Proof",
  booktitle =	 "{IEEE} Symposium on Foundations of Computer Science",
  publisher =	 IEEE,
  year =	 "1977",
  pages =	 "120--131",
  doi =		 {10.1109/SFCS.1977.5},
  comment =	 {Presents a variant of the on-the-fly garbage collection
                  algorithm \cite{dijk78} that uses four colours and does not
                  trace the free-list.},
}

@techreport{kung77a,
author = "H. T. Kung and S. W. Song",
title = "Performance Analysis of a Parallel Garbage Collection System",
institution = CMU,
type = "Department of Computer Science Report",
year = 1977,
month = aug
}

@techreport{kung77b,
author = {Kung, H. T. and Song, S. W.},
title = {An Efficient Parallel Garbage Collection System and its Correctness Proof.},
institution = CMU,
type = "Department of Computer Science Report",
year = 1977,
month = sep
}

@mastersthesis{kung83,
author = "Kung, Delphine T. H",
title = "Garbage Collection of Linked Data Structures: An Example in a Network Oriented Database Management System",
year = 1983,
school = "Rochester Institute of Technology"
}

@inproceedings{kuri90,
author = "Satoshi Kurihara and Mikio Inari and Norihisa Doi and Kazuki Yasumatsu and Takemi Yamazaki",
title = "{SPiCE} Collector : The Run-Time Garbage Collector for
{S}malltalk-80 Programs Translated into {C}",
crossref = "OOPSLA90-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC90/Kurihara.ps.Z"
}

@inproceedings{kuro75,
author = "T. Kurokawa",
title = "New Marking Algorithms for Garbage Collection",
booktitle = "2nd USA--Japan Computer Conference",
year = 1975,
pages = "585--584",
comment = {marking algorithm which use a fixed-length stack and a tag bit to
deal with stack overflow},
}

@article{kuro81,
author = "T. Kurokawa",
title = "A New Fast and Safe Marking Algorithm",
journal = SPE,
publisher = Wiley,
volume = "11",
pages = "671--682",
year = 1981,
institution = "Toshiba R\&D Center, Kawasaki 210, Japan",
abstract = {A new marking algorithm for garbage collection is presented.
Although the method is a variation of the usual simple stacking algorithm,
in practice this algorithm has quite improved both in stack space and processing
time. One significant modification is to stack a node only when both the
sublists are unmarked.
The other innovation is a `stacked-node-checking' method invoked after each
stack-overflow...},
}

@inproceedings{kuse91,
title = "Generational Garbage Collection for {C}-Based Object-Oriented
Languages",
author = "Kazushi Kuse and Tsutomu Kamimura",
crossref = "OOPSLA91-gc",
comment = "Reference found in Detlefs92, but not in the archive?"
}

@inproceedings{kwon03,
author = {J. Kwon and A. Wellings and S. King},
title = {Predictable Memory Utilization in the {R}avenscar-{J}ava Profile},
crossref = {ISORC03},
pages = {267--274},
abstract = {In this paper, we present the Ravenscar-Java profile from the
perspective of memory utilization. This restricted programming model removes
language features with high overheads and complex semantics, on which it is hard
to perform various static analyses. Several classes in the RTSJ are refined, and
a few new classes are added, which all result in a compact, yet powerful and
predictable computational model for the development of software-intensive high
integrity real-time systems. We provide rationales behind the decisions we have
made on the use of memory areas and other language features that can have an
effect on the predictability of memory utilization. After that, some analysis
approaches are discussed in terms of how they can be developed and beneficially
used.},
URL={http://www.cs.york.ac.uk/rts/cgi-bin/bibtex/bibtex.pl?key=R:Kwon:2003}
}

@inproceedings{kwon04,
author = {J. Kwon and A. Wellings},
title = {Memory Management Based on Method Invocation in {RTSJ}},
crossref = {JTRES04},
pages = {333--345},
abstract = {In this paper, we present a memory management model for the
Ravenscar-Java profile. Because of the complexity and run-time overheads in
verifying the proper use of the RTSJs scoped memory, it is unfavourable in the
area of high integrity systems where any unpredictability must be cast out. Our
approach maps one anonymous memory area to a user-specifiable method by means of
our Java 1.5 annotation types. This straightforward model eliminates single
parent rule checks and simplifies other run-time checks that are the main cause
of unpredictability and overheads. In fact, it also makes the programmers job
easier since he/she does not have to worry about creating and maintaining memory
areas. All the annotated methods will be automatically converted by a
transformer into an RTSJ/Ravenscar-Java compliant version. The semantics of the
RTSJ remains the same, meaning that any program in our model when transformed is
also a legal RTSJ program. Our key contribution is the definition of a
predictable memory model and guidelines that will reduce/eliminate run-time
overheads. A bonus to this is a less complicated programming model.},
URL = {http://www.cs.york.ac.uk/rts/cgi-bin/bibtex/bibtex.pl?key=R:Kwon:2004}
}

@inproceedings{kwon07,
title = {Swap-Aware Garbage Collection for {NAND} Flash Memory Based Embedded Systems},
author = {Ohhoon Kwon and Koh, K},
booktitle = {7th IEEE International Conference on Computer and Information Technology, CIT 2007}, 
pages = {787--792},
year = 2007,
month = nov,
doi = {10.1109/CIT.2007.76},
absract = {Embedded systems use NAND flash memory as a secondary storage device
because it has many attractive features such as small size, fast access speeds,
shock resistance, and light weight. NAND flash memory based embedded systems
exploit a "demand paging" to run applications and also use a "swapping" to
extend a limited main memory space. Because the embedded systems use NAND flash
memory as swap space, it should perform garbage collection, which is a
time-consuming operation. Besides, the number of the erase operations allowed to
each block is also limited. In this paper, we propose a new garbage collection
policy for embedded systems with the swap system. The proposed garbage
collection policy focuses on minimizing the garbage collection time and even
wear-leveling. Trace-driven simulations show that the proposed policy performs
better than existing garbage collection policies in terms of the garbage
collection time and the endurance of flash memory.}
}

@inproceedings{kwon07a,
author = {Ohhoon Kwon and Jaewoo Lee and Kern Koh},
title = {{EF}-Greedy: A Novel Garbage Collection Policy for Flash Memory Based
Embedded Systems},
booktitle = {Computational Science, ICCS 2007},
series = LNCS,
publisher = SV,
year = 2007, 
volume = 4490,
pages = {913--920},
doi = {10.1007/978-3-540-72590-9_138},
abstract = {Flash memory is becoming increasingly important for embedded systems
because it has many attractive features such as small size, fast access speeds,
shock resistance, and light weight. Although flash memory has attractive
features, it should perform garbage collection, which includes erase operations.
The erase operations are very slow, and usually decrease the performance of the
system. Besides, the number of the erase operations allowed to each block is
also limited. To minimize the garbage collection time and evenly wear out, our
proposed garbage collection policy focuses on minimizing the garbage collection
time and wear-leveling. Trace-driven simulations show that the proposed policy
performs better than existing garbage collection policies in terms of the
garbage collection time and the endurance of flash memory. Specifically, we have
shown that the performance improvement of our proposed policy against the greedy
policy in terms of the endurance of flash memory is as much as 90.6\%.}
}

@inproceedings{kwon07b,
author = {Kwon, Ohhoon and Ryu, Yeonseung and Koh, Kern},
title = {An Efficient Garbage Collection Policy for Flash Memory Based Swap Systems},
booktitle = {2007 International Conference on Computational
Science and its Applications (ICCSA)},
year = 2007,
isbn = {3-540-74468-1, 978-3-540-74468-9},
address = {Kuala Lumpur, Malaysia},
pages = {213--223},
URL = {http://portal.acm.org/citation.cfm?id=1802834.1802853},
publisher = SV,
abstract = {Mobile computing devices use flash memory as a secondary storage
because it has many attractive features such as small size, fast access speeds,
shock resistance, and light weight. Mobile computing devices exploit a swap
system to extend a limited main memory space and use flash memory as a swap
system. Although flash memory has the attractive features, it should perform
garbage collection, which includes erase operations. The erase operations are
very slow, and usually decrease the performance of the system. Besides, the
number of the erase operations allowed to each block is also limited. To
minimize the garbage collection time and evenly wear out, our proposed garbage
collection policy focuses on minimizing the garbage collection time and
wear-leveling. Trace-driven simulations show that the proposed policy performs
better than existing garbage collection policies in terms of the number of erase
operation, the garbage collection time, total amount of energy consumption and
the endurance of flash memory.}
} 

@mastersthesis{kyry03,
author = {Sergiy Kyrylkov},
title = {Jikes {R}esearch {V}irtual {M}achine --- Design and Implementation of
a 64-bit {P}ower{PC} Port},
school = {University of New Mexico},
year = 2003
}

@inproceedings{kyry04,
author = {Sergiy Kyrylkov and Darko Stefanovi\'{c} and J. Eliot B. Moss},
title = {Design and Implementation of a 64-bit {P}ower{PC} Port of {J}ikes {RVM}
2.0.3},
booktitle = {2nd Workshop on Managed Runtime Environments (MRE)},
year = 2004
}

@techreport{kyry05,
author = {Sergiy Kyrylkov and Darko Stefanovi\'{c}},
title = {A Study of Garbage Collection with a Large Address Space for Server
Applications},
institution = {University of New Mexico},
number = {TR--CS--2005--1},
month = feb,
year = 2005
}

@article{kyry05a,
author = {Sergiy Kyrylkov},
title = {64-Bit Computing and {JVM} Performance},
journal = Dobbs,
volume = 30,
number = 370,
pages = {24--27},
month = mar,
year = 2005
}

@inproceedings{lai07,
author = {Chunrong Lai and Volosyuk Ivan and Xiao-Feng Li},
title = {Behavior Characterization and Performance Study on Compacting Garbage
Collectors with {A}pache {H}armony},
booktitle = {The 10th Workshop on Computer Architecture Evaluation using
Commercial Workloads (CAECW)},
note = {Held with HPCA-13},
address = {Phoenix, AZ},
month = feb,
year = 2007,
URL = {http://people.apache.org/~xli/papers/caecw07-compacting-GCs.pdf}
}

@inproceedings{lakh00,
author = {M.K. Lakhamraju and R. Rastoji and S. Seshadri and S. Sundarshan},
title = {On-line Reorganization in Object Databases},
year = 2000,
publisher = ACM,
booktitle = SIGMOD,
address = {Dallas, TX},
month = may,
comment = {includes IRA, an algorithm that can be applied to copying
collectors, online clustering and other contexts in which it is
necessary to move objects in presence of concurrent access to those
objects}
}

@phdthesis{ladi89,
author = "Ladin, Rivka",
title = "A Method for Constructing Highly Available Services and a
Technique for Distributed Garbage Collection",
year = 1989,
school = MIT
}

@inproceedings{ladi92,
title = "Garbage Collection of a Distributed Heap",
author = "Rivka Ladin and Barbara Liskov",
booktitle = "International Conference on Distributed Computing Systems",
address = "Yokohama",
month = jun,
year = 1992,
comment = "Simplifies and corrects \cite{lisk86}, adopting Hughes' algorithm."
}

@inproceedings{lam91,
  author =	 "Monica S. Lam and Edward E. Rothberg and Michael E. Wolf",
  title =	 "The Cache Performance and Optimizations of Blocked
                  Algorithms",
  crossref =	 "ASPLOS91",
  pages =	 "63--74",
  doi =		 {10.1145/106972.106981}
}

@inproceedings{lam92,
title = "Object Type Directed Garbage Collection to Improve Locality",
author = "Michael S. Lam and Paul R. Wilson and Thomas G. Moher",
crossref = "IWMM92",
pages={404--425},
doi={10.1007/BFb0017204},
}

@phdthesis{lam92a,
author = "Lam, Michael S.",
title = "Improving Locality via Garbage Collection",
year = 1992,
school = "University of Illinois at Chicago"
}

@article{lamb91,
author = "Charles Lamb and Gordon Landis and Jack Orenstein and Dan Weinreb",
title = "The {ObjectStore} Database System",
journal = cacm,
publisher = ACM,
year = 1991,
volume = 34,
number = 10,
month = oct,
pages = {50--63}
}

@techreport{lamp75,
author = "Lamport Leslie",
title = "On-The-Fly Garbage Collection: Once More with Rigor",
institution = "Computer Associates",
number = "CA-7508-1611",
year = 1975,
month = aug,
address = "Wakefield, MA",
}

@inproceedings{lamp76,
author = "Leslie Lamport",
title = "Garbage Collection With Multiple Processes: an Exercise in
Parallelism",
booktitle = "International Conference on Parallel Processing (ICPP)",
year = 1976,
pages = "50--54",
comment = "Generalisation of Dijkstra's algorithm to multiple processes."
}

@techreport{lamp76a,
author = "Leslie Lamport",
title = "Garbage Collection With Multiple Processes: an Exercise in Co-operation",
institution = "Computer Associates",
number = "CA-7602-2511",
year = 1976,
month = aug,
address = "Wakefield, MA",
}

@article{lamp77,
  author =	 {Leslie Lamport},
  title =	 {Concurrent Reading and Writing},
  journal =	 cacm,
  year =	 1977,
  volume =	 20,
  number =	 11,
  pages =	 {806-811},
  month =	 nov,
  doi =		 {10.1145/359863.359878}
}

@article{lamp79,
title = "A New Approach to Proving the Correctness of Multiprocess Programs",
author = "Leslie Lamport",
journal = TOPLAS,
publisher = ACM,
year = 1979,
month = jul,
volume = 1,
number = 1,
pages = "84--97"
}

@techreport{lamp91,
author = "Leslie Lamport",
title = "The Temporal Logic of Actions",
institution = DECSRC,
type = "Research Report",
number = 79,
year = 1991
}

@techreport{lamp83,
author = "Butler W. Lampson",
title = "A Description of the {C}edar Language: A {C}edar Language
Reference Manual",
institution = PARC,
number = "CLS--83--15",
year = 1983
}

@techreport{lang72,
author = "Bernard Lang and B. Wegbreit",
title = "Fast Compactification",
number = "25--72",
institution = "Harvard University",
address = "Cambridge, MA",
month = Nov,
year = 1972,
url = {http://www.datcha.net/papers/fast-compactification-Lang-Wegbreit-197211.pdf}
}

@inproceedings{lang87,
  title =	 "Incremental Incrementally Compacting Garbage Collection",
  author =	 "Bernard Lang and Francis Dupont",
  crossref =	 "PLDI87",
  pages =	 "253--263",
  doi =		 {10.1145/29650.29677},
  url = {http://www.datcha.net/papers/incremental-compacting-gc/incremental-compacting-gc-gipe.pdf}
}

@inproceedings{lang87a,
author = {Lang, Bernard and Dupont, B.}, 
title = {Incremental Incrementally Compacting Garbage Collection},
booktitle = {Programing Of Future Generation Computers II, Proceedings
of the Second Franco-Japanese Symposium},
month = nov,
year = 1987,
editors = {K. Fuchi and L. Kott},
pages = {163--182},
publisher = NH,
ISBN = {978-0444705266},
note = {Extended version of \cite{lang87}.}
}

@inproceedings{lang92a,
author = {Bernard Lang and Christian Quenniac and Jos\'{e} Piquer},
title = "Garbage Collecting the World",
pages = "39--50",
crossref = "POPL92",
URL = "ftp://ftp.inria.fr/INRIA/Projects/icsla/Papers/gc.ps.gz",
comment = "Local Mark-sweep, plus inter-node reference counting in a manner
similar to \cite{lins91c}. Fault tolerance by dynamic grouping of nodes",
abstract = "Distributed symbolic computations involve the existence of
{\em remote references} allowing an object, local to a processor, to
designate another object located on another processor. To reclaim
inaccessible objects is the non trivial task of a distributed Garbage
Collector (GC).  We present in this paper a new distributed GC algorithm
which
\begin{enumerate}
\item is fault-tolerant,
\item is largely independent of how a processor garbage collects its
      own data space,
\item does not need centralized control nor global stop-the-world
      synchronization,
\item allows for multiple concurrent active GCs,
\item does not require to migrate objects from processor to processor and
\item eventually reclaims all inaccessible objects including
      distributed cycles.
\end{enumerate}

These results are mainly obtained through the concept of a {\em group}
of processors (or processes).
Processors of a same group cooperate together to a GC inside this group;
this GC is conservative with respect to the outside of the group.
A processor contributes to the global GC of all groups to which it
belongs. Garbage collection on small groups reclaims quickly locally
distributed garbage clusters, while garbage collection on large groups
ultimately reclaims widely distributed garbage clusters, albeit more
slowly.
Groups can be reorganized dynamically, in particular to tolerate
failures of some member processors.
These properties make the algorithm usable on very large and evolving
networks of processors.
Other than distributed symbolic computations, possible applications
include for example distributed file or database systems."
}

@inproceedings{lang91,
title = "{FRATS}: A Parallel Reduction Strategy for Shared Memory",
author = "Koen G. Langendoen and Willem G. Vree",
booktitle = "3rd international Symposium on Programming Language Implementation ans Logic Programming, Passau, Germany",
editor = "M. Wirsing and J. Maluszynski",
publisher = SV,
series = LNCS,
volume = 528,
pages = "99--110",
month = aug,
year = 1991,
}

@inproceedings{lang92,
title = "Memory Management for Parallel Tasks in Shared Memory",
author = "Koen G. Langendoen and H. L. Muller and Willem G. Vree",
crossref = "IWMM92",
pages = {165--178},
doi = {10.1007/BFb0017189}
}

@inproceedings{laro98,
author = {Martin Larose and Marc Feeley},
title = {A Compacting Incremental Collector and its Performance in a Production Quality Compiler},
pages = {1--9},
crossref = {ISMM98},
doi = {10.1145/286860.286861},
URL = {http://citeseer.nj.nec.com/larose98compacting.html},
abstract = {We present a new near-real-time compacting collector and its
implementation in a production quality Scheme compiler (Gambit-C).
Our goal is to use this system as a base for an implementation of Erlang
for writing soft real-time telecommunication applications. We start
with a description of Gambit-C's memory organisation and its
blocking collector. The design and integration of the incremental
collector within Gambit-C are then explained. Finally we measure the
performance of the incremental collector and compare it to the original
blocking collector. We found that the overhead of the incremental
collector is high (a factor of 1.3 to 5) but nevertheless the collection
pauses and the compute power left for the mutator are compatible with
typical soft real-time requirements. }
}

@article{lars77,
author = "Richard G. Larson",
title = "Minimizing  Garbage Collection as A Function of Region Size",
journal = "{SIAM} Journal of Computing",
volume = 6,
number = 4,
month = Dec,
year = 1977,
pages = "663--668",
comment = {
Richard Larson's 1977 paper dealt with increasing the efficiency of a copy
collector by simply increasing the semispace ("region") sizes, and
therefore decreasing the frequency with which you must copy all of the
live objects from one region of memory to another.  This was 10 years
before Appel's much-better-known paper; not only that, but Larson's paper
gives a mathematical treatment of the tradeoff between basic efficiency
and locality issues.  (He overlooked the pathological behavior of LRU
replacement combined with a simple gc's cyclic memory reuse, though.)
}
}

@inproceedings{lars98,
author = {Paul {Per-\o{A}ke Larson} and Murali Krishnan},
title = {Memory Allocation for Long-Running Server Applications},
pages = {176--185},
crossref = {ISMM98},
abstract = {Prior work on dynamic memory allocation has largely neglected
long-running server applications, for example, web servers and mail
servers. Their requirements differ from those of one-shot applications
like compilers or text editors. We investigated how to build an allocator
that is not only fast and memory efficient but also scales well on SMP
machines. We found that it is not sufficient to focus on reducing lock
contention. Only limited improvement can be achieved this way; higher
speedups require a reduction in cache misses and cache invalidation
traffic. We then designed and prototyped a new allocator, called
Lkmalloc, targeted for both traditional applications and server
applications. LKmalloc uses several subheaps, each one with a
separate set of free lists and memory arena. A thread always allocates
from the same subheap but can free a block belonging to any subheap.
A thread is assigned to a subheap by hashing on its thread ID. We
compared its performance with several other allocators on a
server-like, simulated workload and found that it indeed scales well
and is quite fast but could use memory more efficiently.}
}

@inproceedings{laru88,
  author =	 "James R. Larus and Paul N. Hilfinger",
  title =	 "Detecting Conflicts Between Structure Accesses",
  crossref =	 "PLDI88",
  pages =	 "21--34",
  doi =		 {10.1145/53990.53993}
}

@inproceedings{latt02,
title = {Automatic Pool Allocation for Disjoint Data Structures},
author = {Chris Lattner and Vikram Adve},
crossref = {MSP02},
}

@inproceedings{latt05,
  title =	 {Automatic Pool Allocation: Improving Performance by
                  Controlling Data Structure Layout in the Heap},
  author =	 {Chris Lattner and Vikram S. Adve},
  crossref =	 {PLDI05},
  pages =	 {129-142},
  doi =		 {10.1145/1065010.1065027}
}

@article{laye91,
title = "Lisp Systems in the 1990s",
author = "D. K. Layer and C. Richardson",
address = "Franz Inc., 1995 University Avenue, Berkeley, Ca, 94704",
journal = CACM,
publisher = ACM,
year = 1991,
volume = 34,
number = 9,
pages = "48--57"
}

@article{lea93,
author = {Doug Lea},
title = {The {GNU} {C++} Library},
journal = {The {C++} Report},
publisher = {ACM SIGS Publications},
year = 1993,
URL = {http://gee.cs.oswego.edu/dl/libg++paper/libg++/libg++.html}
}

@misc{lea97,
author = {Doug Lea},
title = {A Memory Allocator},
URL = {http://gee.cs.oswego.edu/dl/html/malloc.html},
year = 1997,
comment = {Description of Doug Lea's excellent allocator, available from
ftp://gee.cs.oswego.edu/pub/misc/malloc.c}
}

@inproceedings{lebs05,
title = {Using Scratchpad to Exploit Object Locality in {J}ava},
author = {Carl S. Lebsack and J. Morris Chang},
booktitle = {International Conference on Computer Design},
address = {San Jose, CA},
month = oct,
year = 2005,
publisher = IEEEcomp,
doi = {10.1109/ICCD.2005.111},
abstract = {Performance of modern computers is tied closely to the effective use
of cache because of the continually increasing speed discrepancy between
processors and main memory. We demonstrate that generational garbage collection
employed by a system with cache and scratchpad memory can take advantage of the
locality of small short-lived objects in Java and reduce memory traffic by as
much as 20\% when compared to a cache-only configuration. Converting half of the
cache to scratchpad can be more effective at reducing memory traffic than
doubling or even quadrupling the size of the cache for several of the
applications in SPECjvm98.}
}

@phdthesis{lehu88,
author = "Serge {Le Huitouze}",
title = "Mise en Oeuvre de {P}rolog{II}/{MALI}",
school = {Universit\'{e} de Rennes I},
year = 1988,
comment = "MALI uses copying for lists of goals."
}

@inproceedings{lehu90,
author = "Serge {Le Huitouze}",
title = {A New Data Structure for Implementing Extensions to {P}rolog},
booktitle = "International Symposium on Programming Language Implementati
on and Logic Programming",
address = {Link\"{o}ping, Sweden},
pages = {136--150},
year = 1990
}

@inproceedings{lese92,
title = "Incremental Multi-Threaded Garbage Collection on Virtually Shared Memory Architectures",
author = "Thierry {Le Sergent} and Bernard Barthomieu",
crossref = "IWMM92",
pages = {179--199},
doi = {10.1007/BFb0017190},
URL = "ftp://laas.laas.fr/pub/lcs/reports/iwmm92.ps.Z",
}

@inproceedings{lee87,
author = "S. Lee and Heonshik Shin and Miroslaw Malek",
title = "Parallel Garbage Collection with Associative Tag",
booktitle = "International Conference on Computers and
Applications",
address = "Beijing",
month = jun,
year = 1987,
comment = {is this the same as \cite{shin85}?}
}

@mastersthesis{lee88,
author = "Lee, Elgin Hoe-Sing",
title = "Object Storage and Inheritance for {SELF}, a Prototype-Based
Object-Oriented Programming Language",
school = "Stanford University",
address = "Palo Alto, CA",
month = dec,
year = 1988,
type = "Engineer's thesis"
}

@inproceedings{lee97,
title = {Bytecode Instrumentation as an Aid in Understanding the Behaviour of {J}ava Persistent Stores},
author = {Han Bok Lee and Benjamin G. Zorn},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/zorn2.ps},
crossref = {OOPSLA97-gc}
}

@article{lee80,
author = "K. P. Lee",
title = "A Linear Algorithm for Copying Binary Trees Using Bounded Workspace",
journal = CACM,
publisher = ACM,
volume = 23,
number = 3,
month = mar,
year = 1980,
pages = "159--162",
comment = {algorithm for traversing trees without a stack or mark bits},
}

@article{lee89,
author = "T. Paul Lee and R. E. Barkley",
title = "Design and Evaluation of a Watermark-based Lazy Buddy System",
journal = "Performance Evaluation Review",
volume = 17,
number = 1,
month = may,
year = 1989
}

@inproceedings{lee79,
author = "S. Lee and W. P. {De Roever} and S. Gerhart",
title = "The Evolution of List Copying Algorithms",
booktitle = "6th ACM Symposium on Principles of Programming Languages",
address = "San Antonio, TX",
publisher = ACM,
month = jan,
year = 1979,
pages = "53--56",
comment = {proves the correctness of the link reversal algorithm by Deutsch-Schorr-Waite},
}

@inproceedings{lee00,
author = {Woo Hyong Lee and J. Morris Chang and Yusuf Hasan},
title = {Dynamic Memory Measuring Tool for {C++} Programs},
booktitle = {3rd IEEE Symposium on Application-Specific Systems and Software Engineering Technology (ASSET)},
address = {Richardson, TX},
month = mar,
year = 2000
}

@inproceedings{lee00a,
author = {Woo Hyong Lee and J. Morris Chang and Yusuf Hasan},
title = {Evaluation of a High-performance Object Reuse Dynamic Memory Allocation Policy for {C++} Programs},
booktitle = {4th IEEE International Conference on High Performance Computing in Asia-Pacific Region},
address = {Beijing, China},
month = may,
year = 2000,
pages = {386--391}
}

@article{lee02,
author = {Woo Hyong Lee and J. Morris Chang},
title = {A Study of Dynamic Memory Management in {C++} Programs},
journal = {International Journal of Computer Languages},
volume = 28,
publisher = {Elsevier Science},
year = 2002,
pages = {237--272}
}

@article{lee03,
author = {Woo Hyong Lee and J. Morris Chang},
title = {A Garbage Collection Policy Based on Empirical Behavior},
journal = {International Journal of Information Sciences},
publisher = {Elsevier Science},
year = 2003,
note = {To appear}
}

@article{lee03a,
author = {Woo Hyong Lee and J. Morris Chang},
title = {An Integrated Dynamic Memory Tracing Tool for {C++} Programs},
journal = {International Journal of Information Sciences},
volume = 151,
publisher = {Elsevier Science},
month = may,
year = 2003,
pages = {27--49}
}

@inproceedings{lee04,
title = {Experiments on the Effectiveness of an Automatic Insertion of Memory
Reuses into {ML}-like Programs},
author = {Oukseh Lee and Kwangkeun Yi},
crossref = {SPACE04},
}

@inproceedings{lee04a,
title = {Experiments on the Effectiveness of an Automatic Insertion of Memory
Reuses into {ML}-like Programs},
author = {Oukseh Lee and Kwangkeun Yi},
pages = {97--107},
crossref = {ISMM04}
}

@inproceedings{lerm86,
author = "C.-W. Lermen and Dieter Maurer",
title = "A Protocol for Distributed Reference Counting",
crossref = "LFP86",
pages = "343--350",
comment = "Avoids problem of premature deletion of objects at a cost of three
messages per operation.",
}

@inproceedings{lest89,
title = "An Efficient Distributed Garbage Collection Algorithm",
author = "David Lester",
crossref = "PARLE89",
volume = 365,
pages = {207--203},
doi = {10.1007/3540512845_41},
}

@inproceedings{lest92,
author = "David Lester",
title = "Distributed Garbage Collection of Cyclic Structures",
booktitle = "4th International Workshop on the Parallel Implementation of
Functional Languages",
address = "Aachen",
month = sep,
year = 1992,
note = "Available from Herbert Kuchen, Lehrstuhl Informatik II, RWTH Aachen,
Ahornstr. 55, W-51000 Aachen.
Also Glasgow Functional Programming Workshop 1993."
}

@article{leun97,
author = "Ho-Fung Leung and Hing-Fung Ting",
title = "An Optimal Algorithm for Global Termination Detection in Shared-Memory
Asynchronous Multiprocessor Systems",
journal = TPDS,
year = 1997,
month = may,
volume = 8,
number = 5,
pages = "538--543",
doi = "10.1109/71.598280"
}

@techreport{leva99,
author = {Yossi Levanoni and Erez Petrank},
title = {A Scalable Reference Counting Garbage Collector},
number = {CS--0967},
institution = {Technion --- Israel Institute of Technology},
address = {Haifa, Israel},
month = nov,
year = 1999,
URL = {http://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-info.cgi?1999/CS/CS0967},
}

@inproceedings{leva01,
author = {Yossi Levanoni and Erez Petrank},
title = {An On-the-Fly Reference Counting Garbage Collector for {J}ava},
URL = {http://www.cs.technion.ac.il/~erez/papers.html},
crossref = {OOPSLA01},
doi={10.1145/504282.504309},
pages={367--380}
}

@article{leva06,
author = {Yossi Levanoni and Erez Petrank},
title = {An On-the-Fly Reference Counting Garbage Collector for {J}ava},
journal = TOPLAS,
volume = 28,
number = 1,
month = jan,
year = 2006,
pages = {1--69},
doi = {10.1145/1111596.1111597}
}

@article{leve92,
author = "Willem G. Levelt and M. Frans Kaashoek and Henri E. Bal and Andrew Tanenbaum",
title = "A Comparison of Two Paradigms for Distributed Shared Memory",
journal = SPE,
publisher = Wiley,
volume = 22,
number = 11,
pages = "985--1010",
month = Nov,
year = 1992
}

@article{leve82,
author = "B. W. Leverett and P. G. Hibbard",
title = "An Adaptive System for Dynamic Storage Allocation",
journal = SPE,
publisher = Wiley,
volume = 12,
number = 6,
month = jun,
year = 1982,
pages = "543--556"
}

@inproceedings{lewi74,
author = "T. G. Lewis and B. J. Smith and M. Z. Smith",
title = "Dynamic Memory Allocation Systems for Minimizing Internal Fragmentation
",
booktitle = "{ACM} Annual Conference",
publisher = ACM,
month = nov,
year = 1974,
pages = "725--728"
}

@phdthesis{lext92,
title = "Generation de Serveurs de Vues",
author = "Vincent Lextrait",
school = "University of Nice",
month = dec,
year = 1992,
address = "lextrait@hotmail.com",
comment = "Claims to have a solution to the problem of reference counting cycles",
note = "(In french)"
}

@inproceedings{lhot02,
title = {Run-time Evaluation of Opportuniites for Object Inlining in {J}ava},
author = {Ondrej Lhot\'{a}k and Laurie Hendren},
booktitle = {Joint ACM Java Grande - ISCOPE Conference},
address = {Seattle, WA},
year = 2002,
pages = {175--184},
publisher = ACM,
doi = {10.1145/583810.583830}
}

@techreport{li85,
author = "Kai Li and Paul Hudak",
title = "A New List Compaction Method",
type = "Research Report",
number = 362,
institution = "Yale University",
month = feb,
year = 1985
}

@article{li86,
author = "Kai Li and Paul Hudak",
title = "A New List Compaction Method",
journal = SPE,
publisher = Wiley,
volume = 16,
number = 2,
pages = "145--163",
month = feb,
year = 1986
}

@phdthesis{li86a,
author = "Kai Li",
title = "Shared Virtual Memory on Loosely Coupled Multiprocessors",
school = "Yale University",
year = 1986
}

@article{li89,
author = "Kai Li and Paul Hudak",
title = "Memory Coherence in Shared Virtual Memory Systems",
journal = TransCompSys,
publisher = ACM,
volume = 7,
number = 4,
pages = "321--359",
month = Nov,
year = 1989
}

@inproceedings{li90,
author = "Kai Li",
title = "Real-Time Concurrent Collection in User Mode",
crossref = "OOPSLA90-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC90/Li.ps.Z",
abstract = "We previously presented a real-time, concurrent
garbage-collection algorithm that uses the virtual memory page
protection hardware to synchronize collector threads and mutator
threads.  The algorithm requires the mutator threads to access
protected pages that prevent collector threads from accessing.
This paper investigates three other alternatives to achieve such
a goal:  page-copying, multiple address mapping, and page sharing
in different address spaces.  We will present our  experiment
with the page-copying version and compare it with the kernel-
mode, simple stop-and-copy, and sequential real-time versions."
}

@inproceedings{li14,
title = {Modeling Heap Data Growth Using Average Liveness},
author = {Pengcheng Li and Chen Ding and Hao Luo},
pages = {71--82},
crossref = {ISMM14},
doi = {10.1145/2602988.2602997},
abstract = {Most of today's programs make use of a sizable heap to store dynamic
data. To characterize the heap dynamics, this paper presents a set of metrics to
measure the average amount of data live and dead in a period of execution. They
are collectively called average liveness. The paper defines these metrics of
average liveness, gives linear-time algorithms for measurement, and discusses
their use in finding the best heap size. The algorithms are implemented in a
Java tracing system called Elephant Tracks and evaluated using the Dacapo
benchmarks running on the Oracle HotSpot and IBM J9 Java virtual machines.}
}

@inproceedings{li08,
author = {Xiao-Feng Li and L. Wang and C. Yang},
title = {A Fully Parallel {LISP2} Compactor with Preservation of the Sliding Properties},
crossref = {LCPC08}
}

@misc{li09,
title = {Tick: Concurrent GC in {A}pache {H}armony},
author = {Xiao-Feng Li},
year = 2009,
URL =
{http://issues.apache.org/jira/secure/attachment/12416652/Harmony+Concurrent+GC+Design.ppt},
note = {Slides on Harmony's Tick GCs}
}

@techreport{lieb81,
title = "A Real-Time Garbage Collector Based on the Lifetimes of Objects",
author = "Henry Lieberman and Carl E. Hewitt",
type = "{AI} Memo",
number = "569a",
institution = "{MIT}",
month = apr,
year = 1981,
URL = "ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-569a.pdf",
comment = {Previously cited as "A Real-Time Garbage Collector That Can Recover Temporary Storage Quickly"},
}

@article{lieb83,
author = "Henry Lieberman and Carl E. Hewitt",
title = "A Real-Time Garbage Collector Based on the Lifetimes of Objects",
journal = CACM,
publisher = ACM,
volume = "26(6)",
pages = "419--429",
doi={10.1145/358141.358147},
year = 1983,
URL = {http://lieber.www.media.mit.edu/people/lieber/Lieberary/GC/Realtime/Realtime.html},
note = " Also report TM--184, Laboratory for Computer Science, MIT, Cambridge, MA, July 1980
and AI Lab Memo 569, 1981",
abstract = {The authors, motivated by the need for efficient management of short-lived
objects in object-oriented systems for AI applications, propose a new
garbage collection algorithm. The algorithm which is proposed has the
objective of differentiating the special case of garbage collection for
objects with short lives. Such differentiation, the paper argues, will also
improve the garbage collection for long-lived objects, since less effort is
made in considering these objects for reclamation.
The algorithm proposed is an extension of a garbage collection algorithm
proposed by Baker. The most important feature of Baker's algorithm is
that elementary object creation and object access time take a bounded
amount of time regardless of the memory size. It is a real-time algorithm.
As an enhancement to Baker's algorithm, the authors propose dividing the
address space into small regions, with each region being composed of a set
of pages. This division is different from the Baker algorithm, which
divides the address space into two regions. The second enhancement to Baker's
algorithm uses the finer divisions of the address space to vary the rate
of garbage collection for each region according to the age of the region.
The criteria for determining the rate are motivated by the observation that
newer regions contain a higher percentage of garbage.
The paper is excellently constructed. It was, however, disappointing not to
find comparative measurements for performance, region fragmentation, the
impact of locality, the impact of programming style, etc. Nevertheless, the
paper is recommended.}
}

@inproceedings{liec06,
title = {Compiler-Directed Automatic Memory Management},
author = {Florian Liekweg},
pages = {23--34},
crossref = {SPACE06}
}

@inproceedings{lim98,
author = {Tian F. Lim and Przemyslaw Pardyak and Brian N. Bershad},
title = {A Memory-Efficient Real-Time Non-Copying Garbage Collector},
pages = {118--129},
crossref = {ISMM98},
abstract = {Garbage collectors used in operating systems such as SPIN and
embedded systems such as Java and Inferno must operate with limited
resources and minimize their impact on application performance.
Consequently, they must maintain short real-time pauses, low
overhead, and a small memory footprint. Most garbage collectors are
not adequate because they are either not real-time or they require
larger heaps because they trade space for time. For example,
Treadmill uses segregated free lists to allocate and reclaim memory in
constant time but at the cost of under-utilizing memory. We have
implemented a new version of the Treadmill collector and used it in the
SPIN extensible operating system kernel. We chose Treadmill for its
excellent real-time latencies and low overhead. We improve its poor
memory utilization by using real- time page-level management
techniques that reduce the fragmentation caused by segregated free
lists. We use page-wise collection to locate pages of free memory,
which are dynamically reassigned between free lists as needed. We
use virtual memory to dynamically remap free pages into continuous
ranges. Our experiments demonstrate that we have substantially
improved memory utilization without compromising latency or
overhead, and that the new collector performs very well for SPIN's
workloads.}
}

@manual{limb97,
title = "The {L}imbo Programming Language ",
organization = "Lucent Technologies Inc",
year = 1997,
URL = "http://inferno.lucent.com/inferno/",
abstract = "Limbo is a programming language intended for applications
running distributed systems on small computers. It supports modular
programming, strong type checking at compile- and run-time,
interprocess communication over typed channels, automatic garbage
collection, and simple abstract data types. It is designed for safe
execution even on small machines without hardware memory protection.
In its initial implementation for the Inferno operating system, object
programs generated by the Limbo compiler run using an interpreter for a
fixed virtual machine. Inferno and its accompanying virtual machine run
either stand-alone on bare hardware or as an application under
conventional operating systems like Unix, Windows 95, Windows NT, and
Plan 9. For several architectures, including Intel x86 and MIPS, Limbo
object programs are transformed on-the-fly into instructions for the
underlying hardware. "
}

@inproceedings{lin12,
author = {Lin, Yi and Blackburn, Stephen M. and Frampton, Daniel},
title = {Unpicking the Knot: Teasing Apart {VM}/Application Interdependencies},
crossref = {VEE12},
pages = {181--190},
doi = {10.1145/2151024.2151048},
abstract = {Flexible and efficient runtime design requires an understanding of
the dependencies among the components internal to the runtime and those between
the application and the runtime. These dependencies are frequently unclear. This
problem exists in all runtime design, and is most vivid in a metacircular
runtime --- one that is implemented in terms of itself. Metacircularity blurs
boundaries between application and runtime implementation, making it harder to
understand and make guarantees about overall system behavior, affecting
isolation, security, and resource management, as well as reducing opportunities
for optimization. Our goal is to shed new light on VM interdependencies, helping
all VM designers understand these dependencies and thereby engineer better
runtimes. We explore these issues in the context of a high-performance
Java-in-Java virtual machine. Our approach is to identify and instrument
transition points into and within the runtime, which allows us to establish a
dynamic execution context. Our contributions are: 1) implementing and measuring
a system that dynamically maintains execution context with very low overhead, 2)
demonstrating that such a framework can be used to improve the software
engineering of an existing runtime, and 3) analyzing the behavior and runtime
characteristics of our runtime across a wide range of benchmarks. Our solution
provides clarity about execution state and allowable transitions, making it
easier to develop, debug, and understand managed runtimes.}
}

@misc{lin92,
author = "Lin, Sheng-Lien",
title = "Performance Evaluation of a Generation Scavenging Algorithm",
year = 1992
}

@inproceedings{lin00,
author = {Chi-Min Lin and Tien-Fu Chen},
title = {Dynamic Memory Management for Real-Time Embedded {J}ava Chips},
crossref = {RTCSA00},
doi = {10.1109/RTCSA.2000.896370},
}

@inproceedings{lin06,
title = {A Lightweight Cyclic Reference Counting Algorithm},
author = {Chin-Yang Lin and Ting-Wei Hou},
booktitle = {International Conference on Grid and Pervasive Computing},
publisher = SV,
series = LNCS,
number = 3947,
pages = {246--359},
year = 2006
}

@article{lin07,
  title =	 {A Simple and Efficient Algorithm for Cycle Collection},
  author =	 {Chin-Yang Lin and Ting-Wei Hou},
  journal =	 SIGPLAN,
  volume =	 42,
  number =	 3,
  month =	 mar,
  year =	 2007,
  pages =	 {7--13},
  doi =		 {10.1145/1273039.1273041}
}

@inproceedings{linc92,
title = "Operational Aspects of Linear Lambda Calculus",
author = "Patrick Lincoln and John Mitchell",
pages = "235--246",
booktitle = "7th Annual IEEE Symposium on Logic in Computer Science (LICS)",
year = 1992,
month = jun,
address = "Santa Cruz, CA",
publisher = IEEE
}

@Article{lin09,
  author =	 {Chunxiao Lin and Yiyun Chen and Bei Hua},
  title =	 {Verification of an Incremental Garbage Collector in
                  Hoare-Style Logic},
  journal =	 {International Journal of Software and Informatics},
  year =	 2009,
  volume =	 3,
  number =	 1,
  pages =	 {67--88},
  month =	 mar
}

@inproceedings{lind87,
author = "T. G. Lindholm and R. A. O'Keefe",
title = "Efficient Implementation of a Defensible Semantics for Dynamic {P}rolog Code",
crossref = "ICLP87",
}

@book{lind99,
author = {Tim Lindholm and Frank Yellin},
title = {{J}ava {V}irtual {M}achine Specification},
year = 1999,
isbn = 0201432943,
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
}

@book{lind12,
author = {Tim Lindholm and Frank Yellin and Gilad Bracha and Alex Buckley},
title = {Java Virtual Machine Specification},
publisher = {Oracle America, Inc.},
edition = {{J}ava 7~{SE}},
year = 2012
}

@article{lind73,
author = "Gary Lindstrom",
title = "Scaning List Structures Without Stacks or Tag Bits",
journal = IPL,
publisher = NH,
volume = 2,
number = 2,
month = jun,
year = 1973,
pages = "47--51",
comment = {algorithm for traversing trees without a stack or mark bits},
}

@article{lind74,
author = "Gary Lindstrom",
title = "Copying List Structures Using Bounded Workspace",
journal = CACM,
publisher = ACM,
volume = 17,
number = 4,
month = apr,
year = 1974,
pages = "199--202",
comment = {algorithm for copying lists without using a stack or mark bits.
It differs from the moving algorithms in that the altered contents of old lists
are later restored to their original values.},
}

@article{lind81,
title = "Referencing and Retention in Block-Structured Coroutines",
author = "Gary Lindstrom and Mary Lou Soffa",
journal = TOPLAS,
publisher = ACM,
year = 1981,
month = jul,
volume = 3,
number = 3,
pages = "263--292",
comment = "Don't know if this is useful or not"
}

@inproceedings{lind94,
author = {Anders Lindstrom and Alan Dearle and di Bona, Rex and J. Matthew Farrow and Frans Henskens and John Rosenberg and Francis Vaughan},
title = {A Model for User-Level Memory Management in a Persisitent Distributed Environment},
editor = {Gopal Gupta},
booktitle = {17th Annual Australasian Computer Science Conference (ACSC), Part {B}},
pages = {343--354},
address = {Christchurch, New Zealnad},
month = jan,
year = 1994,
URL = {http://docs.dcs.napier.ac.uk/DOCS/GET/linstrom94a/document.html}
}

@article{lins90a,
author = "Rafael D. Lins",
title = "Cyclic Reference Counting with Lazy Mark-Scan",
journal = IPL,
publisher = NH,
volume = 44,
number = 4,
pages = "215--220",
year = 1992,
doi={10.1016/0020-0190(92)90088-D},
URL = "ftp://unix.hensa.ac.uk/pub/misc/ukc.reports/comp.sci/reports/26-92.ps.Z",
note = "Also Computing Laboratory Technical Report 75, University of Kent,
July 1990",
comment = {Optimises \cite{mart90}}
}

@techreport{lins91a,
author = {Rafael D. Lins and M\'{a}rcio A. Vasques},
title = "A Comparative Study of Algorithms for Cyclic Reference Counting",
institution = UKC,
number = 92,
month = aug,
year = 1991,
URL = "ftp://unix.hensa.ac.uk/pub/misc/ukc.reports/comp.sci/reports/",
comment = {Compares the performance of \cite{mart90} and
several control strategies of \cite{lins90a}.
Also extends \cite{glas87} to work with cyclic structures.}
}

@article{lins91b,
author = "Rafael D. Lins",
title = "A Shared Memory Architecture for Parallel Cyclic Reference
Counting",
journal = "Microprocessing and Microprogramming",
volume = "32",
pages = "53--58",
publisher = "North-Holland",
month = sep,
year = 1991,
comment = "Describes a shared memory architecture based on
reference counting algorithms described in \cite{mart90} and
\cite{lins90}"
}

%do not change year
@inproceedings{lins91c,
author = "Rafael D. Lins and Richard E. Jones",
title = "Cyclic Weighted Reference Counting",
booktitle = "Procedings of {WP \& DP'93} Workshop on Parallel and
Distributed Processing",
address = {Sofia, Bulgaria},
editor = "K. Boyanov",
publisher = NH,
pages = {369--382},
month = may,
year = 1993,
institution = UKC,
note = "Also Computing Laboratory Technical Report 95, University of Kent,
December 1991",
comment = "Allows weighted reference counting
\cite{beva87,wats87} to work with cyclic structures.
Based on algorithms described in \cite{mart90,lins90a}"
}

@article{lins92,
author = "Rafael D. Lins",
title = "A Multi-processor Shared Memory Architecture for Parallel Cyclic Reference Counting",
journal = "Microprocessing and Microprogramming",
volume = "35",
pages = "563--568",
publisher = "North-Holland",
month = sep,
year = 1992,
comment = {Generalises the architecture presented in \cite{lins91a}.}
}

@techreport{lins92c,
author = "Lins, Rafael D ",
institution = "Computing Laboratory, University of Kent",
title = "Generational Cyclic Reference Counting",
year = 1992,
URL = "ftp://unix.hensa.ac.uk/pub/misc/ukc.reports/comp.sci/reports/22-92.ps.Z",
month = sep,
number = "22-92"
}

@inproceedings{lins94,
author = "Lins, Rafael D. and Frank Dehne",
title = "Distributed Reference Counting",
booktitle = "1994 Canada--France Conference on Parallel Computing",
year = 1994,
pages = "95--100",
month = may,
series = LNCS,
publisher = SV,
number = 805,
comment = "Based on Lins' tri-colour mark-scan but uses process spawning.
Despite alleged proof, the algorithm is fundamentally flawed. It is simple
to provide counter-examples and, we believe, impossible to correct (in the
spirit of the algorithm)."
}

@article{lins02,
author = {Lins, Rafael D.},
title = {An Efficient Algorithm for Cyclic Reference Counting},
journal = IPL,
volume = 83,
pages = {145--150},
year = 2002,
comment = {Unconvincing paper marred by careless(?) errors in the algorithm.}
}

@inproceedings{lins05,
author = {R. Lins},
title = {A New Multiprocessor Architecture for Parallel Lazy Cyclic Reference Counting},
booktitle = {17th International Symposium on Computer
Architecture and High Performance Computing (SBAC-PAD)},
publisher = IEEE,
year = 2005
}

@article{lins07,
author = {R.D. Lins and de Carvalho Junior, F. Heron and Z.D. Lins},
title = {Cyclic Reference Counting with Permanent Objects},
journal = {Journal of Universal Computer Science},
volume = 13,
number = 6,
pages = {830--838},
year = 2007
}

@inproceedings{lisk86,
title = "Highly Available Distributed Services and Fault-Tolerant Distributed
Garbage Collection",
author = "Barbara Liskov and Rivka Ladin",
pages = "29--39",
booktitle = "5th Annual ACM Symposium on the Principles on Distributed Computing",
address = "Calgary",
month = aug,
editor = "J. Halpern",
publisher = ACM,
year = 1986,
comment = "Local mark-sweep + highly available centralised service
which detects cycles."
}

@phdthesis{llam91,
author = "Llames, Rene Lim",
title = "Performance Analysis of Garbage Collection and Dynamic
Reordering in a {L}isp System",
year = 1991,
school = "University of Illinois at Urbana-Champaign",
abstract = {Generation-based garbage collection and dynamic reordering of
objects are two techniques for improving the efficiency of memory
management in Lisp and similar dynamic language systems.  An
analysis of the effect of generation configuration is presented,
focusing on the effect of the number of generations and generation
capacities.  Analytic timing and survival models are used to
represent garbage collection runtime and to derive structural results
on its behavior.  The survival model provides bounds on the age of
objects surviving a garbage collection at a particular level.
Empirical results show that execution time is most sensitive to the
capacity of the youngest generation.  The existence of a range of
optimum values demonstrates the potential for the tuning of garbage
collection.
A new memory management system integrating dynamic reordering with
garbage collection is described.  The system supports schemes for
preserving object order in virtual memory during garbage collection,
both approximately and exactly.
We present a technique, called scanning for transport statistics,
for evaluating the effectiveness of reordering, independent of main
memory size.  Reordering oldspace is scanned for the number of pages
containing the transported objects and statistics on their sizes,
from which is computed the reduction in working set size due to
reordering.  The relative reduction in working set size is a
measure of the density with which the actively used objects are
packed into pages.  Since the technique can be applied selectively
in space, the portions of memory which are suitable for reordering
can be identified.  The method can also be used to measure locality
improvement due to garbage collection.
Results from two experiments, one involving an extensive interactive
session and the other a large application, show overall reductions
in working set sizes of 48\% and 58\% due to reordering, with up to
93\% for individual memory areas.  Relative reduction in working set
size was found to be greater for list space than structure space, by
a factor of about three overall.  The large disparity between list
and structure object fragmentation in certain areas suggests that
the memory management system should be able to treat list and
structure space differently.}
}

@inproceedings{lo98,
author = {Chia-Tien Dan Lo and Witiwas Srisa-an and J. Morris Chang},
title = {Boundary Analysis for Buddy Systems},
booktitle = {International Computer Symposium (Computer Architecture Track)},
address = {Tainan, Taiwan},
month = dec,
year = 1998,
pages = {96--103}
}

@inproceedings{lo00,
author = {Chia-Tien Dan Lo and Witiwas Srisa-an and J. Morris Chang},
title = {Page Replacement Performance in Garbage Collection Systems},
booktitle = {13th International Conference on Parallel and Distributed Computing Systems},
address = {Las Vegas, NA},
month = aug,
year = 2000,
pages = {374--379}
}

@inproceedings{lo00a,
author = {Chia-Tien Dan Lo and Witiwas Srisa-an and J. Morris Chang},
title = {A Quantitative Simulator for Dynamic Memory Managers},
booktitle = {IEEE International Symposium on Performance Analysis of Systems and Software},
address = {Austin, TX},
publisher = IEEE,
month = apr,
year = 2000,
pages = {64--69},
URL = {http://ieeexplore.ieee.org/iel5/6790/18223/00842283.pdf}
}

@article{lo01,
author = {Chia-Tien Dan Lo and Witiwas Srisa-an and J. Morris Chang},
title = {A Study of Page Replacement Performance in Garbage Collection Heap},
journal = JSS,
pages = {235--245},
publisher = ES,
volume = 58,
number = 3,
month = sep,
year = 2001
}

@inproceedings{lo01a,
author = {Chia-Tien Dan Lo and J. Morris Chang},
title = {A Multithreaded Concurrent Generational Garbage Collector for {J}ava},
crossref = {OOPSLA01},
note = {Doctoral Symposium},
pages = {7--9}
}

@inproceedings{lo02,
author = {Chia-Tien Dan Lo and Witiwas Srisa-an and J. Morris Chang},
title = {A High Performance Garbage Collector for {J}ava},
booktitle = {Proceeding of the 2002 International Computer Symposium, ICS 2002},
address = {National Dong Hwa University, Hualien, Taiwan},
month = dec,
year = 2002
}

@inproceedings{lo02a,
author = {Chia-Tien Dan Lo and Witiwas Srisa-an and J. Morris Chang},
title = {A Multithreaded Concurrent Garbage Collector which Parallelizes the {new} Instruction in {J}ava},
booktitle = {International Parallel and Distributed Processing Symposium},
address = {Fort Lauderdale, FL},
month = apr,
year = 2002,
pages = {59--64}
}

@inproceedings{lo02b,
author = {Chia-Tien Dan Lo and Witiwas Srisa-an and J. Morris Chang},
title = {A Performance Comparison between Stop-the-World and Multithreaded Concurrent Garbage Collection for {J}ava},
booktitle = {21st IEEE International Performance, Computing, And Communications Conference (IPCCC 2002)},
address = {Phoenix, AZ},
month = apr,
year = 2002,
pages = {301--308}
}

@inproceedings{lo02c,
author = {Chia-Tien Dan Lo and J. Morris Chang and Ophir Frieder and David Grossman},
title = {The Object Behaviour of {J}ava Object-Oriented Database Management Systems},
booktitle = {International Conference on Information Technology: Coding and Computing (ITCC)},
publisher = IEEE,
year = 2002
}

@article{lo03,
author = {Chia-Tien Dan Lo and Witiwas Srisa-an and J. Morris Chang},
title = {Who Is Collecting Your {J}ava Garbage?},
journal = {IEEE IT Professional},
volume = 5,
number = 2,
month = apr,
year = 2003,
pages = {44--50}
}

@article{lo04,
title = {The Design and Analysis of a Quantitative Simulator for Dynamic
Memory Management},
author = {Chia-Tien Dan Lo and Witiwas Srisa-an and J. Morris Chang},
journal = JSS,
volume = 72,
number = 3,
month = aug,
year = 2004,
pages = {443--453},
doi = {10.1016/S0164-1212(03)00095-5}
}

@article{lo05,
title = {Security Issues in Garbage Collection},
author = {Chia-Tien Dan Lo and Witiwas Srisa-an and J. Morris Chang},
journal = {CrossTalk: The Journal of Defense Software Engineering},
month = oct,
year = 2005,
URL = {http://www.stsc.hill.af.mil/CrossTalk/2005/10/0510DanLo.html},
abstract = {This article examines Java security models, describing security
issues in garbage collection (GC), metrics used to predict program behaviors,
and their relations. Heap memory attacks are introduced and classified into both
slow death and fast death categories. These are potential scenarios if GC is
under attack. Experimental results show that a compromised system may result in
GC being invoked more times than its normal counterpart. Furthermore, presented
here is a runtime monitoring system that can detect anomalous program behaviors
using the collected memory metrics. This can be a runtime throttle to control
program behaviors, or a post-mortem diagnosis technique in case of heap memory
attacks.}
}

@inproceedings{loid00,
author = {H-W. Loidl},
title = {Investigating the Memory Management in a Parallel Graph Reducer},
pages = {185-200},
editor = {M. Mohnen and P. Koopman},
booktitle = {12th International Workshop on Implementation of Functional Languages},
organization = {RWTH Aachen},
year = 2000,
series = {{Aachener Informatik Berichte}},
number = {AIB-00-7},
}

@article{lome75,
author = "D. B. Lomet",
title = "Scheme for Invalidating References to Freed Storage",
journal = "IBM Journal of Research and Development",
pages = "26--35",
month = jan, year=1975,
comment = "No inter-area links though he maintains objects in regions"
}

@inproceedings{loub95,
author = {Sylvain Louboutin and Vinny Cahill},
title = {On Comprehensive Global Garbage Detection},
booktitle = {Proceeding of the European Research Seminar on Advances in
Distributed Systems (ERSADS '95)},
publisher = {INRIA/IMAG},
month = apr,
year = 1995,
pages = {208--213},
address = {Alpes d'Huez, France},
URL = {ftp://ftp.dsg.cs.tcd.ie/pub/doc/TCD-CS-95-11.ps.gz},
note = {Also technical report TCD-CS-95-11, Department of Computer Science, Trinity College Dublin},
abstract = {The experience gained with centralised garbage collection
(GC) techniques has left a legacy of assumptions, expectations
and tradeoffs, which may lead one to overlook some Global
Garbage Detection (GGD) approaches. We argue that it is not
necessary to give up on comprehensiveness in order to achieve
a high degree of concurrency and scalability, although this
may be at a price which is not palatable in a centralised
system. For instance, much higher detection latency or space
overhead, at least in terms of worst case scenarios, is
acceptable in a large distributed system. We are currently
implementing a variation of Schelvis' algorithm on Amadeus
(taking advantage of Amadeus' object clustering ability), to
conduct an empirical evaluation of the actual impact of such
tradeoffs.}
}

@techreport{loub95a,
author = "Sylvain Louboutin and Vinny Cahill",
title = "Lazy, per Cluster Log-Keeping Mechanism for Global Garbage Detection on {Amadeus}",
institution = "Department of Computer Science, Trinity College",
year = 1995,
number = "TCD-CS-95-13",
month = may,
URL = "ftp://ftp.dsg.cs.tcd.ie/pub/doc/TCD-CS-95-13.ps.gz",
abstract = "This document describes a log-keeping mechanism designed to
support Global Garbage Detection on Amadeus. This log-keeping
mechanism maintains, on a per site basis, a conservative
approximation of the actual root set for that site. Exchanges
of object references across site boundaries are logged on a
per cluster basis to cope with the dynamic nature of the
overall object graph. Clustering also determines the
granularity of the information logged. Furthermore, this
mechanism proceeds lazily, that is, is does not require either
any additional messages to be exchanged (and thus does not
cause any race condition), nor trigger any object fault which
would not otherwise have occurred. This mechanism makes it
possible to implement at a reasonable cost, a higher level
comprehensive, although scalable, Global Garbage Detection
algorithm.",
}

@inproceedings{loub95b,
author = "Sylvain Louboutin and Vinny Cahill",
title =  "A Lazy Log-Keeping Mechanism for Comprehensive Global Garbage Detection on {Amadeus}",
booktitle = {OOIS (Object-Oriented Information Systems) '95},
publisher = SV,
address = "London",
pages = {118--132},
year = 1995,
month = dec,
URL = "ftp://ftp.dsg.cs.tcd.ie/pub/doc/dsg-92.ps.gz",
note = {Technical report TCD--CS--95--11},
abstract = "Global Garbage Detection (GGD) in object-oriented distributed
systems requires that each application process maintains some
information in support of GGD. Maintaining this information is
known as log-keeping. In this paper we describe a
low-overhead, log-keeping mechanism which proceeds lazily and
avoids race conditions while nevertheless maintaining enough
information for comprehensive GGD to take place.",
}

@inproceedings{loub97,
title = {Comprehensive Distributed Garbage Collection by Tracking Causal Dependencies of Relevant Mutator Events},
author = {Sylvain R.Y. Louboutin and Vinny Cahill},
booktitle = {International Conference on Distributed Computing Systems (ICDCS)},
publisher = IEEE,
year = 1997,
URL = {ftp://ftp.dsg.cs.tcd.ie/pub/doc/dsg-106.ps.gz}
}

@phdthesis{loub98,
author = {Sylvain R.Y. Louboutin},
title = {A Reactive Approach to Comprehensive Global Garbage Detection},
school = {Trinity College, Dublin},
year = 1998,
ISBN = {1-58112-044-3},
URL = {http://www.dissertation.com/library/1120443a.htm},
comment = {Louboutin says that the algorithm as described in the dissertation is a bit
more complete than the one described in \cite{loub97}}
}

@inproceedings{lowr02,
author = {Lowry, M.C. and Munro, David S.},
title = {Safe and Complete Distributed Garbage with The {T}rain Algorithm},
booktitle = {International Conference on Parallel and Distributed Systems (ICPADS)},
address = {Taiwan},
month = dec,
year = 2002,
pages = {651--658}
}

@phdthesis{lowr04,
author = {Lowry, M.C.},
title = {A New Approach to the Train Algorithm for Distributed Garbage Collection},
school = {University of Adelaide},
month = dec,
year = 2004
}

@inproceedings{luk96,
  author =	 {Chi-Keung Luk and Todd C. Mowry},
  title =	 {Compiler-Based Prefetching for Recursive Data Structures},
  crossref =	 {ASPLOS96},
  pages =	 {222-233},
  doi =		 {10.1145/237090.237190}
}

@inproceedings{lyb12,
 author = {Lyberis, Spyros and Pratikakis, Polyvios and Nikolopoulos, Dimitrios S. and Schulz, Martin and Gamblin, Todd and de Supinski, Bronis R.},
 title = {The {M}yrmics Memory Allocator: Hierarchical, Message-passing Allocation for Global Address Spaces},
 crossref = {ISMM12},
 pages = {15--24},
 doi = {10.1145/2258996.2259001},
 abstract = {Constantly increasing hardware parallelism poses more and more
 challenges to programmers and language designers. One approach to harness the
 massive parallelism is to move to task-based programming models that rely on
 runtime systems for dependency analysis and scheduling. Such models generally
 benefit from the existence of a global address space. This paper presents the
 parallel memory allocator of the Myrmics runtime system, in which multiple
 allocator instances organized in a tree hierarchy cooperate to implement a
 global address space with dynamic region support on distributed memory
 machines. The Myrmics hierarchical memory allocator is step towards improved
 productivity and performance in parallel programming. Productivity is improved
 through the use of dynamic regions in a global address space, which provide a
 convenient shared memory abstraction for dynamic and irregular data structures.
 Performance is improved through scaling on manycore systems without system-wide
 cache coherency. We evaluate the stand-alone allocator on an MPI-based x86
 cluster and find that it scales well for up to 512 worker cores, while it can
 outperform Unified Parallel C by a factor of 3.7-10.7x.}
} 

@techreport{lync90,
author = "N. A. Lynch",
title = "Multivalued Possibilities Mappings",
institution = "MIT Laboratory for Computer Science",
type = "Technical Memo",
number = "MIT/LCS/TM--422",
month = aug,
year = 1990,
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TM-422.html"
}

@article{lyon88,
title = "Tagless Marking that is Linear over Subtrees",
author = "G. Lyon",
journal = IPL,
publisher = NH,
volume = 27,
number = 1,
pages = "23--28",
year = "1988",
abstract = {A new tagless marking algorithm traverses and marks nodes of a
directed binary graph, initiating tests for cycles only as need arises.
Because trees do not trigger any tests, the algorithm takes linear time on
any graph subtree.}
}

@inproceedings{maas12,
author = {Maas, Martin and Reames, Philip and Morlan, Jeffrey and Asanovi\'{c}, Krste and Joseph, Anthony D. and Kubiatowicz, John},
title = {{GPU}s as an Opportunity for Offloading Garbage Collection},
crossref = {ISMM12},
pages = {25--36},
doi = {10.1145/2258996.2259002},
abstract = {GPUs have become part of most commodity systems. Nonetheless, they
are often underutilized when not executing graphics-intensive or
special-purpose numerical computations, which are rare in consumer workloads.
Emerging architectures, such as integrated CPU/GPU combinations, may create an
opportunity to utilize these otherwise unused cycles for offloading traditional
systems tasks. Garbage collection appears to be a particularly promising
candidate for offloading, due to the popularity of managed languages on
consumer devices.
We investigate the challenges for offloading garbage collection to a GPU, by
examining the performance trade-offs for the mark phase of a mark \& sweep
garbage collector. We present a theoretical analysis and an algorithm that
demonstrates the feasibility of this approach. We also discuss a number of
algorithmic design trade-offs required to leverage the strengths and
capabilities of the GPU hardware. Our algorithm has been integrated into the
Jikes RVM and we present promising performance results.}
} 

@inproceedings{macl91,
author = "Robert A. MacLachlan",
title = "A System Model of Memory Management",
crossref = "OOPSLA91-gc",
}

@techreport{mada92,
author = "Peter W. Madany and Nayeem Islam and Panos Kougiouris and Roy H.
Campbell",
title = "Reification and Reflection in {C++}: An Operating Systems
Perspective",
institution = "Department of Computer Science, University of Illinois at
Urbana-Champaign",
number = "UIUCDCS--R--92--1736",
month = mar,
year = 1992,
abstract = "The paper discusses using reification (the
representation of an attribute of an object-oriented
program such as method dispatch, inheritance, or object
structure within the program) and reflection (the
ability to make attributes like method invocation,
interface, inheritance, object implementation the
subject of computation) in Choices. Reification is
used, for example, to modify the behaviour of pointers
so reference-counting can be done safely. The system
includes inheritance and classes as run-time entities,
allowing dynamic extension of the system functions."
}

@inproceedings{maeb04,
author= {Maebe, Jonas and  Ronsse, Michiel and  De Bosschere, Koen},
title= {The Missing Leak},
booktitle= {Program Acceleration through Application and Architecture driven Code Transformations: Symposium Proceedings},
year= {2004},
pages= {75-77},
address= {Edegem, Belgium},
URL = {http://escher.elis.ugent.be/publ/Edocs/DOC/P104_089.pdf}
}

@techreport{maed93,
author = "Munenori Maeda and Hiroki Konaka and Yutaka Ishikawa and Takashi Tomokiyo and Atsushi Hori",
title = "An Incremental, Weighted, Cyclic Reference Counting for Object-based Languages",
institution = "Tsukuba Research Center",
year = 1993,
type = "RWCP Technical Report",
number = "P--93--001",
comment = "WRONG. Based on Brownbridge! But gives each object an ordinal number
in order to copy pointer strengths correctly."
}

@inproceedings{maed95,
title = "On-The-Fly Global Garbage Collection Based on Partly Mark-Sweep",
author = {Munenori Maeda and Hiroki Konaka and Yutaka Ishikawa and Takashi Tomokiyo and Atsushi Hori and J\"{o}rg Nolte},
crossref = "IWMM95",
pages = {283--296},
doi = {10.1007/3-540-60368-9_29},
comment = "This is simply Cyclic Weighted Reference Counting
\cite{jone92,jone93} and comments in mail from REJ"
}

@inproceedings{maed97,
author = {Munenori Maeda and Yutaka Ishikawa},
title = {{GLEANER}-7: A Hybrid Distributed {GC} Algorithm},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/maeda.ps},
crossref = {OOPSLA97-gc}
}

@unpublished{maed92,
author = "Roman E. Maeder",
title = "A Provably Correct Reference Count Scheme for a Symbolic
Computation System",
note = "In unpublished form, cited by Edelson",
year = 1992
}

@inproceedings{maed06,
title = {Writing Practical Memory Management Code with a Strictly Typed Assembly
Language},
author = {Toshiyuki Maeda and Akinori Yonezawa},
pages = {35--46},
crossref = {SPACE06}
}

@techreport{maek87,
author = "Maekawa, Mamoru and Ohta, Masataka and Shimizu, Kentaro",
title = "Garbage Collection for Multimedia Processing",
institution = "University of Tokyo",
year = 1987,
number = "87-01"
}

@inproceedings{magn95,
title = "Garbage Collection for Control Systems",
author = "Boris Magnusson and Roger Henriksson",
crossref = "IWMM95",
pages={323--342},
doi={10.1007/3-540-60368-9_32},
URL = "ftp://mjolner.dna.lth.se/HD/ftp/pub/papers/LU-CS-TR.95-154.ps"
}

@inproceedings{magil06,
title = {Inferring Invariants in Separation Logic for Imperative
List-processing Programs},
author = {Stephen Magill and Aleksandar Nanevski and Edmund Clarke and Peter Lee},
pages = {47--60},
crossref = {SPACE06}
}

@techreport{magn95a,
title = "Garbage Collection for Hard Real-Time Systems",
author = "Boris Magnusson and Roger Henriksson",
institution = Lund,
number = "95--153",
URL = "ftp://mjolner.dna.lth.se/HD/ftp/pub/papers/LU-CS-TR.95-153.ps",
year = 1995
}

@article{mahe61,
author = "R. J. Maher",
title = "Problems of Storage Allocation in a Multiprocessor Multiprogrammed
System",
journal = CACM,
publisher = ACM,
volume = 4,
number = 10,
month = oct,
year = 1961,
pages = "421--422"
}

@mastersthesis{mahe92,
author = "Umesh Maheshwari",
title = "Distributed Garbage Collection in a Client--Server Transaction System",
school = "Department of Electrical Engineering and Computer Science, Massachusetts Institute of Technology",
year = 1992
}

@inproceedings{mahe93,
author = "Umesh Maheshwari",
title = "Distributed Garbage Collection in a Client--Server Persistent Object System",
crossref = "OOPSLA93-gc",
}

@techreport{mahe93a,
author = "Umesh Maheshwari",
title = "Distributed Garbage Collection in a Client--Server, Transactional, Persistent Object System",
institution = MIT,
number = "MIT/LCS/TR--574",
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TR-574.html",
year = 1993,
month = feb
}

@inproceedings{mahe94,
author = "Umesh Maheshwari",
title = " Fault-Tolerant Distributed Garbage Collection in a Client-Server
Object-Oriented Database",
booktitle = "3rd International Conference on Parallel and Distributed Information Systems, Austin",
URL = {ftp://pion.lcs.mit.edu/pub/thor/dgc.ps.gz},
month = sep,
year = 1994
}

@inproceedings{mahe95,
title = "Collecting Cyclic Distributed Garbage by Controlled Migration",
author = "Umesh Maheshwari and Barbara Liskov",
booktitle = "ACM Symposium on Principles of Distributed Computing (PODC) ",
URL = {http://www.pmg.lcs.mit.edu:80/~umesh/pubs/distance.ps.gz},
note = {Later appeared in Distributed Computing, Springer Verlag, 1996},
year = 1995
}

@inproceedings{mahe97,
title = "Collecting Cyclic Distributed Garbage by Back Tracing",
author = "Umesh Maheshwari and Barbara Liskov",
booktitle = "Principles of Distributed Computing (PODC)",
address = {Santa Barbara, CA},
publisher = ACM,
pages = {239--248},
URL = {http://www.pmg.lcs.mit.edu:80/~umesh/pubs/backtracing.ps.gz},
year = 1997
}

@techreport{mahe97a,
title = "Partitioned Garbage Collection of a Large Object Store",
author = "Umesh Maheshwari and Barbara Liskov",
institution = MIT,
number = {MIT/LCS/TR--699},
URL = {http://www.pmg.lcs.mit.edu:80/~umesh/pubs/gcor_tr.ps.gz},
year = 1997,
note = {This report contains an obsolete proposal. See \cite{mahe97b}}
}

@inproceedings{mahe97b,
title = "Partitioned Garbage Collection of a Large Object Store",
author = "Umesh Maheshwari and Barbara Liskov",
booktitle = SIGMOD,
URL = {http://www.pmg.lcs.mit.edu:80/~umesh/pubs/gcor_sigmod97.ps.gz},
year = 1997
}

@phdthesis{mahe97c,
title = {Garbage Collection in a Large, Distributed, Object Store},
author = "Umesh Maheshwari",
school = MITLCS,
month = sep,
year = 1997,
note = {Technical Report MIT/LCS/TR-727},
URL = {http://www.pmg.lcs.mit.edu:80/~umesh/pubs/phd_tr.ps.gz}
}

@inproceedings{mais92,
author = {Julien Maisonneuve and Marc Shapiro and Pierre Collet},
title = {Implementing References as Chains of Links},
crossref = "IWOOOS92"
}

@phdthesis{mais96,
author = {Julien Maisonneuve},
title = {Hobbes: un mod\`{e}le de liaison de r\'{e}f\'{e}rences r\'{e}parties},
school = {Universit\'{e} Paris 6, Pierre et Marie Curie},
month = oct,
year = 1996
}

@inproceedings{makh00,
author = {Henning Makholm},
title = {A Region-based Memory Manager for {P}rolog},
pages = {25--34},
crossref = {ISMM2000},
abstract = { We extend Tofte and Talpin's region-based model for memory
management to support backtracking and cuts, which makes it suitable for
use with Prolog and other logic programming languages. We describe how
the extended model can be implemented and report on the performance of a
prototype implementation. The prototype implementation performs well
when compared to a garbage-collecting Prolog implementation using
comparable technology for non-memory-management issues. }
}

@inproceedings{makh01,
author = {Henning Makholm and Henning Niss},
title = {Towards a More Flexible Region Type System},
crossref = {SPACE01},
}

@techreport{makp91,
title = "Structuring Distributed Applications as Fragmented Objects",
author = " Mesaac Makpangou and Yvon Gourhant and Jean-Pierre {Le Narzul} and Marc Shapiro",
number = "Rapport de Recherche INRIA 1404",
institution = INRIA,
month = feb,
year = 1992,
address = "nelly@sor.inria.fr, anonymous FTP nuri.inria.fr [128.93.1.26]"
}

@inproceedings{manc91,
author = "Luigi V. Mancini and Vittoria Rotella and Simonetta Venosa",
title = "Copying Garbage Collection for Distributed Object Stores",
booktitle = "10th Symposium on Reliable Distributed Systems",
address = "Pisa",
month = sep,
year = 1991,
comment = "Node-group collector"
}

@article{manc91a,
author = "Luigi V. Mancini and S. K. Shrivastava",
title = "Fault-Tolerant Reference Counting for Garbage Collection in
Distributed Systems",
journal = CompJ,
publisher = BCS,
volume = 34,
number = 6,
pages = "503--513",
month = dec,
year = 1991,
}

@inproceedings{mann05,
  author =	 {Tobias Mann and Morgan Deters and Rob Legrand and
                  Ron. K. Cytron},
  title =	 {Static Determination of Allocation Rates to Support
                  Real-Time Garbage Collection},
  crossref =	 {LCTES05},
  pages =	 {193--2002},
  doi =		 {10.1145/1065910.1065938}
}

@inproceedings{mans05,
  author =	 {Jeremy Manson and William Pugh and Sarita V. Adve},
  title =	 {The {Java} Memory Model},
  crossref =	 {POPL05},
  pages =	 {378-391},
  doi =		 {10.1145/1040305.1040336}
}

@inproceedings{mara91,
author = "L. Maranget",
title = "{GAML}: A Parallel Implementation of Lazy {ML}",
crossref = "FPCA91",
pages = "102--123",
}

@article{marg71,
author = "B. H. Margolin and R. P. Parmelee and M. Schatzoff",
title = "Analysis of Free-Storage Algorithms",
journal = ISJ,
publisher = IBM,
volume = 10,
number = 4,
pages = "283--304",
year = 1971
}

@inproceedings{mari07,
author = {Sebastien Marion and Richard Jones and Chris Ryder},
title = {Decrypting the {J}ava Gene Pool: Predicting Objects' Lifetimes with Micro-Patterns},
pages = {67--78},
crossref = {ISMM07},
doi={10.1145/1296907.1296918},
URL = {http://www.cs.kent.ac.uk/pubs/2007/2596/}
}

@inproceedings{mark94,
title = "The Use of Reference Counters in Update Based Coherent Memory",
author = "Evangelos P. Markatos and Catherine E. Chronaki",
crossref = "PARLE94",
pages = {805--808},
doi = {10.1007/3-540-58184-7_162}
}

@inproceedings{marl08,
title = {Parallel Generational-Copying Garbage Collection with a Block-Structured Heap},
author = {Simon Marlow and Tim Harris and Roshan James and Peyton Jones, Simon L.},
crossref = {ISMM08},
pages = {11--20},
doi = {10.1145/1375634.1375637},
abstract = {We present a parallel generational-copying garbage
collector implemented for the Glasgow Haskell Compiler. We use a
block-structured memory allocator, which provides a natural granularity
for dividing the work of GC between many threads, leading to a
simple yet effective method for parallelising copying GC. The results
are encouraging: we demonstrate wall-clock speedups of on average
a factor of 2 in GC time on a commodity 4-core machine with no
programmer intervention, compared to our best sequential GC.}
}

@inproceedings{marl09,
title = {Runtime Support for Multicore {H}askell},
author = {Simon Marlow and Peyton Jones, Simon L. and Satnam Singh},
booktitle = {14th } # ICFP,
pages = {65--78},
year = 2009,
doi = {10.1145/1596550.1596563}
}

@inproceedings{marl11,
title = {Multicore Garbage Collection with Local Heaps},
author = {Simon Marlow and Peyton Jones, Simon L.},
crossref = {ISMM11},
pages = {21--32},
do = {1993478.1993482},
abstract = {In a parallel, shared-memory, language with a garbage collected
heap, it is desirable for each processor to perform minor garbage collections
independently. Although obvious, it is difficult to make this idea pay off in
practice, especially in languages where mutation is common. We present several
techniques that substantially improve the state of the art. We describe these
techniques in the context of a full-scale implementation of Haskell, and
demonstrate that our local-heap collector substantially improves scaling, peak
performance, and robustness.}
}

@inproceedings{marq89,
title = "Extending the Operating System to Support an Object-Oriented Environment",
author = {Jos\'{e} Alves Marques and Paulo Guedes},
crossref = "OOPSLA89",
pages = "113--122"
}

@techreport{marq90,
author = {Jos\'{e} Alves Marques and Paulo Guedes and Pedro Sousa and Paulo
Ferreira and Jos\'{e} Monge and Andr\'{e} Z\'{u}quete and Manuel Sequeira},
title = "{IK} Implementation Report",
institution = "INESC, Portugal",
number = "INESC--TR--0013",
year = 1990,
month = jul,
note = "Extended description of system described in \cite{ferr90}."
}

@inproceedings{marq07,
  title =	 {A {DSL} Approach for Object Memory Management of Small
                  Devices},
  author =	 {Kevin Marquet and Gilles Grimaud},
  crossref =	 {PPPJ07},
  pages =	 {155-164},
  doi =		 {10.1145/1294325.1294346}
}

@article{marq00,
author = {Marquez, A. and Zigman, J. N. and Blackburn, S. M},
title = {Fast Portable Orthogonally Persistent {J}ava},
journal = SPE,
volume = 30,
number = 4,
pages = {449--479},
year = 2000
}

@inproceedings{marr09,
title = {Identification of Logically Related Heap Regions},
author = {Mark Marron and Deepak Kapur and Manuel Hermenegildo},
pages = {89--98},
doi = {10.1145/1542431.1542445},
crossref = {ISMM09}
}

@incollection{mars71,
author = "S. Marshall",
title = "An {A}lgol--68 Garbage Collector",
crossref = "Algol68",
pages = "239--243",
comment = {variant of Deutsch--Schorr--Waite algorithm for varisized cells.},
}

@inproceedings{mart06,
title = {Verification of the Heap Manager of an Operating System using
Separation Logic},
author = {Nicolas Marti and Reynald Affeldt and Akinori Yonezawa},
pages = {61--72},
crossref = {SPACE06}
}

@InProceedings{mart06b,
  author =	 {Nicolas Marti and Reynald Affeldt and Akinori Yonezawa},
  title =	 {Formal verification of the heap manager of an operating
                  system using separation logic},
  booktitle =	 {Formal Methods and Software Engineering},
  year =	 2006,
  editor =	 {Zhiming Liu and Jifeng He},
  volume =	 4260,
  series =	 lncs,
  pages =	 {400--419},
  month =	 nov,
  address =	 {Macao, China},
  publisher =	 {Springer},
  doi =		 {10.1007/11901433_22}
}

@article{mart82,
title = "An Efficient Garbage Compaction Algorithm",
author = "Johannes J. Martin",
journal = CACM,
publisher = ACM,
year = 1982,
month = Aug,
volume = 25,
number = 8,
pages = "571--581",
doi={10.1145/358589.358625}
}

@article{mart90,
author = "A. D. Martinez and R. Wachenchauzer and Rafael D. Lins",
title = "Cyclic Reference Counting with Local Mark-Scan",
journal = IPL,
publisher = NH,
volume = "34",
pages = "31--35",
year = 1990,
doi={10.1016/0020-0190(90)90226-N},
comment = {Presents a general garbage collection algorithm based on
reference counting, which deals with cyclic data structures, and proves its
correctness.}
}

@inproceedings{masm06,
author = {Miguel Masmano and Ismael Ripoll and Alfons Crespo},
title = {A Comparison of Memory Allocators for Real-time Applications},
booktitle = {4th International Workshop on Java
Technologies for Real-time and Embedded Systems},
pages = {68--76},
year = 2006
}

@inproceedings{mate92,
title = "Efficient Implementation for Coroutines",
author = "Luis Mateu",
crossref = "IWMM92",
pages = {230--247},
doi = {10.1007/BFb0017193}
}

@article{mato98,
title = {A Taxonomy of Distributed Termination Detection Algorithms},
author = {Jeff Matocha and Tracy Camp},
journal = JSS,
pages = {207--221},
volume = 43,
number = 3,
month = nov,
year = 1998,
URL = {http://www.elsevier.nl/locate/jnlnr/07735}
}

@article{mats87,
title = "{SYNAPSE} --- A Multi-Microprocessor {L}isp Machine With Parallel
Garbage Collector",
author = "Shogo Matsui and Yoshinobu Kato and Shinsuke Teramura and Tomoyuki Tanaka
and Nobuyuki Mohri and Atsushi Maeda and Masakazu Nakanishi",
institution = "Keio University, Department of Mathematics,
Japan,  Ricoh Ltd, Research and Development Lab,
Yokohama, Japan",
journal = LNCS,
publisher = SV,
year = 1987,
volume = 269,
pages = "131--137"
}

@inproceedings{mats95,
title = "Complementary Garbage Collector",
author = "Shogo Matsui and Yoshio Tanaka and Atsushi Maeda and Masakazu Nakanishi",
crossref = "IWMM95",
pages = {163--177},
doi = {10.1007/3-540-60368-9_23},
URL = {http://citeseer.nj.nec.com/84046.html},
}

@inproceedings{mats91,
author = {Satoshi Matsuoka and Shin'ichi Furuso and Akinori Yonezawa},
title = {A Fast Parallel Conservative Garbage Collector for Concurrent Object-oriented Systems},
crossref = {IWOOOS91},
pages = {87--93},
URL = {http://ftp.yl.is.s.u-tokyo.ac.jp/pub/papers/woos91-gc-a4.ps.Z}
}

@article{matt87,
author = {Friedmann Mattern},
title = {Algorithms for Distributed Termination Detection},
journal = {Distributed Computing},
volume = 2,
pages = {161--175},
year = 1987
}

@article{matt89,
author = {Friedmann Mattern},
title = {Global Quiescence Detection based on Credit distribution and Recovery},
journal = IPL,
volume = 30,
number = 4,
pages = {195--200},
year = 1989
}

@inproceedings{matt89a,
author = {Friedmann Mattern},
title = {Virtual Time and Global States of Distributed Systems},
booktitle = {International Workshop on Parallel and Distributed Algorithms},
editor = {M. Cosnard and others},
address = {Amsterdam},
pages = {215--226},
publisher = ES,
year = 1989
}

@inproceedings{matt95,
title = "{LEMMA}: A Distributed Shared Memory with Global and Local Garbage Coll
ection",
author = "David C. J. Matthews and Thierry {Le Sergent}",
crossref = "IWMM95",
pages = {297--311},
doi = {10.1007/3-540-60368-9_30}
}

@article{matt70,
author = "R. L. Mattson and J. Gecsei and D. R. Slutz and I. L. Traiger",
title = "Evaluation Techniques for Storage Hierarchies",
journal = ISJ,
publisher = IBM,
volume = 9,
year = 1970,
pages = "78--117"
}

@inproceedings{mazu00,
author = "Nancy Mazur and Gerda Janssens and Maurice Bruynooghe",
title = "A Module Based Analysis for Memory Reuse in {M}ercury",
booktitle = "Computational Logic",
pages = "1255-1269",
year = "2000",
url = "http://citeseer.nj.nec.com/379252.html"
}

@inproceedings{mazu01,
author = {Nancy Mazur and Peter Ross and Gerda Janssens and Maurice Bruynooghe},
title = {Practical Aspects for a Working Compile Time Garbage Collection System for {M}ercury},
booktitle = {International Conference on Logic Programming},
pages = {105--119},
year = 2001,
url = {http://citeseer.nj.nec.com/mazur01practical.html}
}

@inproceedings{mazu02,
author = {Nancy Mazur},
title = {Practical Structure Reuse for {M}ercury},
crossref = {SPACE01},
}

@article{mcbe63,
author = "J. Harold McBeth",
title = "On the Reference Counter Method",
journal = CACM,
publisher = ACM,
volume = 6,
number = 9,
month = Sep,
pages = 575,
year = 1963,
comment = {First paper to report the inadequacy of reference counting \cite{coll60}
for cyclic structures.  }
}

@techreport{mcca59,
title = {Artificial Intelligence, Quarterly Progress Report no. 53},
author = {John McCarthy and Marvin Minsky},
institution = {Research Laboratory of Electronics at MIT},
month = apr,
year = 1959
}

@article{mcca60,
  author =	 "John McCarthy",
  title =	 "Recursive Functions of Symbolic Expressions and their
                  Computation by Machine, {Part I}",
  journal =	 CACM,
  publisher =	 ACM,
  volume =	 3,
  number =	 4,
  year =	 1960,
  month =	 apr,
  pages =	 "184--195",
  doi =		 {10.1145/367177.367199},
  comment =	 {The classical Mark-Sweep algorithm.}
}


@manual{mcca62,
author = "John McCarthy and others",
title = "{L}isp 1.5 Programmer's Manual",
publisher = MIT,
year = 1962,
}

@incollection{mcca78,
  author =	 "John McCarthy",
  title =	 "History of {LISP}",
  booktitle =	 "History of Programming Languages {I}",
  editor =	 "Richard L. Wexelblat",
  pages =	 "173--185",
  publisher =	 ACM,
  doi =		 {10.1145/800025.1198360},
  year =	 1978
}

@inproceedings{mccr07,
  title =	 {A General Framework for Certifying Garbage Collectors and
                  Their Mutators},
  author =	 {Andrew McCreight and Zhong Shao and Chunxiao Lin and Long
                  Li},
  crossref =	 {PLDI07},
  pages =	 {468-479},
  doi =		 {10.1145/1250734.1250788}
}

@inproceedings{mccr10,
title = {A Certified Framework for Compiling and Executing Garbage-Collected
languages},
author = {Andrew McCreight and Tim Chevalier and Andrew Tolmach},
crossref = {ICFP10},
pages = {273--284},
doi = {10.1145/1863543.1863584},
abstract = {We describe the design, implementation, and use of a
machine-certified framework for correct compilation and execution of programs in
garbage-collected languages. Our framework extends Leroy's Coq-certified
Compcert compiler and Cminor intermediate language. We add: (i) a new
intermediate language, GCminor, that includes primitives for allocating memory
in a garbage-collected heap and for specifying GC roots; (ii) a precise,
low-level specification for a Cminor library for garbage collection; and (iii) a
proven semantics-preserving translation from GCminor to Cminor plus the GC
library. GCminor neatly encapsulates the interface between mutator and collector
code, while remaining simple and flexible enough to be used with a wide variety
of source languages and collector styles. Front ends targeting GCminor can be
implemented using any compiler technology and any desired degree of
verification, including full semantics preservation, type preservation, or
informal trust.
As an example application of our framework, we describe a compiler for Haskell
that translates the Glasgow Haskell Compiler's Core intermediate language to
GCminor. To support a simple but useful memory safety argument for this
compiler, the front end uses a novel combination of type preservation and
runtime checks, which is of independent interest.}
}

@incollection{mccu83,
author = "P. L. McCullough",
title = "Implementing the {S}malltalk-80 System: the {T}ektronix Experience",
crossref = "Smalltalk-BHWA",
pages = "59--78",
}

@article{mcdo98,
  title =	 {Reducing Garbage in {J}ava},
  author =	 {Charles E. McDowell},
  journal =	 SIGPLAN,
  volume =	 33,
  number =	 9,
  month =	 sep,
  pages =	 {84--86},
  year =	 1998,
  URL =		 {http://www.cse.ucsc.edu/research/embedded/pubs/gc/},
  comment =	 {Obtains small improvement by observing that some objects do
                  not need to be stack allocated.}
}

@article{mcen87,
author = "T. J. McEntee",
title = "Overview of Garbage Collection in Symbolic Computing",
journal = "{LISP} Pointers",
publisher = ACM,
volume = 1,
number = 3,
pages = "8--16",
month = "August--September",
year = 1987
}

@inproceedings{mcga85,
author = "Mike McGaughey",
title = "Bounded-Space Tagless Garbage Collection for First Order Polymorphic Languages",
booktitle = "18th Australian Computer Science Conference (ACSC)",
series = "Australian Computer Science Communications 17(1)",
pages = "380--388",
address = "Glenelg, South Australia",
month = jan,
year = 1995,
URL = "http://www.cs.monash.edu.au/~mmcg/papers/mmcg-bounded-tagless-acsc95.ps.Z",
note = "Also appears as: Technical report 94/208, Department of Computer Science, Monash University",
abstract = "By compile-time type analysis of a program written in a statically typed first-order
polymorphic language, it is possible to generate a mark-sweep or copying garbage collector for that program
which does not require runtime tags on the data, which operates in linear time in the size of the data and stack,
and, excepting the use of a per-pointer mark bit, within a small, bounded workspace---desirable in an
algorithm which is only invoked when space is exhausted. The basis for the new graph marking algorithm, the
compile time type analysis required, and safety in the presence of sharing is described for languages employing a
first-order subset of the Hindley-Milner typing discipline; it is also immediately applicable to monomorphic,
type-safe programming languages, such as PASCAL. The algorithm is the first tag-free marking algorithm for
values of arbitrary algebraic type requiring less than linear space in the worst case."
}

@inproceedings{mcga06,
  title =	 {Reducing Generational Copy Reserve Overhead with Fallback
                  Compaction},
  author =	 {Phil McGachey and Antony L Hosking},
  pages =	 {17--28},
  crossref =	 {ISMM06},
  doi =		 {10.1145/1133956.1133960}
}

@inproceedings{mcga08,
  author =	 {Phil McGachey and Ali-Reza Adl-Tabatabi and Richard
                  L. Hudson and Vijay Menon and Bratin Saha and Tatiana
                  Shpeisman},
  title =	 {Concurrent {GC} Leveraging Transactional Memory},
  crossref =	 {PPoPP08},
  pages =	 {217--226},
  doi =		 {10.1145/1345206.1345238}
}

@inproceedings{mcil76,
author = "M. Douglas McIlroy",
title = "Mass-Produced Software Components",
booktitle = "Software Engineering Concepts and Techniques (1968 {NATO}
Conference of {S}oftware Engineering)",
editor = "J. M. Buxton and Peter Naur and Brian Randell",
pages = "88--98",
year = 1976
}

@article{mcil82,
author = "M. Douglas McIlroy",
title = "The Number of States of a Dynamic Storage Allocation System",
journal = COMPJ,
volume = 25,
number = 3,
month = aug,
year = 1982,
pages = "388--392"
}

@inproceedings{mcil08,
title = {Efficient Dynamic Heap Allocation of Scratch-Pad Memory},
author = {Ross McIlroy and Peter Dickman and Joe Sventek},
crossref = {ISMM08},
pages = {31--40},
doi = {10.1145/1375634.1375640},
abstract = {An increasing number of processor architectures support
scratch-pad memory - software managed on-chip memory. Scratch-pad
memory provides low latency data storage, like on-chip caches, but
under explicit software control. The simple design and predictable
nature of scratchpad memories has seen them incorporated into a
number of embedded and real-time system processors. They are also
employed by multi-core architectures to isolate processor core local
data and act as low latency inter-core shared memory.  Managing
scratch-pad memory by hand is time consuming, error prone and
potentially wasteful; tools that automatically manage this memory
are essential for its use by general purpose software. While there
has been promising work in compile time allocation of scratch-pad
memory, there will always be applications which require run-time
allocation. Modern dynamic memory management techniques are too
heavy-weight for scratch-pad management.  This paper presents the
Scratch-Pad Memory Allocator, a light-weight memory management
algorithm, specifically designed to manage small on-chip memories.
This algorithm uses a variety of techniques to reduce its memory
footprint while still remaining effective, including: representing
memory both as fixed-sized blocks and variable-sized regions within
these blocks; coding of memory state in bitmap structures; and
exploiting the layout of adjacent regions to dispense with boundary
tags for split and coalesce operations. We compare the performance
of this allocator against Doug Lea's malloc implementation for the
management of core-local and inter-core shared scratchpad memories
under real world memory traces. This algorithm manages small memories
efficiently and scales well under load when multiple competing cores
access shared memory.}
}

@inproceedings{mcil10,
author = {McIlroy, Ross and Sventek, Joe},
title = {Hera-JVM: a runtime system for heterogeneous multi-core architectures},
crossref = {OOPSLA10},
pages = {205--222},
doi = {1869459.1869478},
abstract = {Heterogeneous multi-core processors, such as the IBM Cell processor,
can deliver high performance. However, these processors are notoriously
difficult to program: different cores support different instruction set
architectures, and the processor as a whole does not provide coherence between
the different cores' local memories.
We present Hera-JVM, an implementation of the Java Virtual Machine which
operates over the Cell processor, thereby making this platforms more readily
accessible to mainstream developers. Hera-JVM supports the full Java language;
threads from an unmodified Java application can be simultaneously executed on
both the main PowerPC-based core and on the additional SPE accelerator cores.
Migration of threads between these cores is transparent from the point of view
of the application, requiring no modification to Java source code or bytecode.
Hera-JVM supports the existing Java Memory Model, even though the underlying
hardware does not provide cache coherence between the different core types.
We examine Hera-JVM's performance under a series of real-world Java benchmarks
from the SpecJVM, Java Grande and Dacapo benchmark suites. These benchmarks show
a wide variation in relative performance on the different core types of the Cell
processor, depending upon the nature of their workload. Execution of these
benchmarks on Hera-JVM can achieve speedups of up to 2.25x by using one of the
Cell processor's SPE accelerator cores, compared to execution on the main
PowerPC-based core. When all six SPE cores are exploited, parallel workloads can
achieve speedups of up to 13x compared to execution on the single PowerPC core.}
}

@inproceedings{mciv94,
author = "William J. McIver and Roger King",
title = "Self-Adaptive, On-Line Reclustering of Complex Object Data",
booktitle = "SIGMOD94",
pages = "407--418",
year = 1994
}

@inproceedings{mcke93,
author = "Paul E. McKenney and Jack Slingwine",
title = "Efficient Kernel Memory Allocation on Shared-Memory Multiprocessors",
booktitle = "USENIX Winter Technical Conference",
address = {San Diego, CA},
month = jan,
publisher = UA,
pages = {295--306},
year = 1993
}

@inproceedings{mcke98,
author = "Paul E. McKenney and Jack Slingwine",
title = {Read-Copy Update: Using Execution History to Solve Concurrency Problems},
booktitle = {10th IASTED International Conference on Parallel and Distributed Computing and Systems},
month = oct,
year = 1998
}

@inproceedings{mcku88,
author = "Marshall K. McKusick and Michael J. Karels",
title = "Design of a General-Purpose Memory Allocator for the {4.3BSD} {UNIX} Kernel",
booktitle = "Summer {USENIX} Conference",
publisher = UA,
month = jun,
year = 1988
}

@techreport{mccl08,
  title =	 {Staccato: A Parallel and Concurrent Real-time Compacting
                  Garbage Collector for Multiprocessors},
  author =	 {Bill McCloskey and David F. Bacon and Perry Cheng and David
                  Grove},
  type =	 {IBM Research Report},
  number =	 {RC24505},
  institution =	 {IBM Research},
  year =	 2008,
  URL =
                  {http://domino.watson.ibm.com/comm/research_people.nsf/pages/dgrove.rc24504.html},
  abstract =	 {Existing real-time garbage collectors are either unable to
                  scale to large multiprocessors, or unable to meet hard
                  real-time requirements even with specialized hardware
                  support.  These limitations are rapidly becoming
                  unacceptable: hardware improvements have brought
                  multi-gigabyte heaps and ubiquitous multi-core parallelism;
                  applications have increasingly stringent real-time
                  requirements; and non-embedded, highly parallel server
                  applications form an increasing percentage of real-time
                  workloads.  We present Staccato, an algorithm that supports
                  both hard- and soft-real-time garbage collection on stock
                  hardware and both real-time and stock operating systems. The
                  algorithm is incremental, concurrent, and
                  parallel. Defragmentation can be performed on a per-object
                  basis using a lock-free algorithm which requires no atomic
                  mutator operations in the common case. On a real-time
                  operating system it is capable of meeting hard real-time
                  bounds.  We have implemented Staccato in IBM's J9 virtual
                  machine and present an evaluation on IBM's real-time variant
                  of Linux. Staccato is able to achieve maximum pause times of
                  753us and an MMU of 85\% over a 5ms time window,
                  out-performing both IBM's Metronome-based product and Azul's
                  soft real-time, hardware-assisted collector.}
}

@article{mcna91,
title = "2 Models For Integrating Persistence And Lazy Functional
Languages",
author = "D. J. McNally and Anthony J. T. Davie",
address = "University of  St Andrews, Department of Computational Science, St Andrews KY16 9ST,
Fife, Scotland",
journal = Sigplan,
publisher = ACM,
year = 1991,
volume = 26,
number = 5,
pages = "43--52"
}

@phdthesis{meir85,
author = "Meira, Silvio R. de L.",
title = "On the Efficiency of Applicative Algorithms",
school = UKC,
month = mar,
year = 1985,
comment = "Chapter 4 considers limited-field reference counts"
}

@inproceedings{mell80,
author = "C. S. Mellish",
title = "An Alternative to Structure-Sharing in the Implementation of a
{P}rolog Interpreter",
booktitle = "Workshop on Logic Programming, Debrecen, Hungary",
year = 1980,
comment = "Structure copying:simplifies gc algorithms (bruy82)." ,
}

@misc{melo99,
title = {The {J}ava {H}ot{S}pot Performance Engine: An In-Depth Look},
author = {Steve Meloan},
year = 1999,
URL = {http://developer.java.sun.com/developer/technicalArticles/Networking/HotSpot/},
comment = {Contains some discussion of object layout and GC in HotSpot.
Whether it is in-depth or not....},
howpublished = {Article on Sun's Java Developer Connection site}
}

@article{mend93,
author = "Abraham Mendelson and Dominique Thiebaut and Dhiraj K. Pradhan",
title = "Modeling Live and Dead Lines in Cache Memory Systems",
journal = IEEETransComp,
publisher = IEEE,
volume = 42,
number = 1,
year = 1993,
month = jan,
pages = {1--14}
}

@inproceedings{mene97,
title = {Garbage Collection in Open Distributed Tuple Space Systems},
author = {Ronaldo Menezes and Alan Wood},
booktitle = {15th Brazilian Computer Networks Symposium --- SBRC '97},
pages = {525--543},
month = may,
year = 1997,
abstract = {This paper demonstrates the need for garbage collection in
multiple tuple space distributed open systems, which has Linda as a
major icon, and identifies problems involved in incorporating garbage
collection into such systems.  We concern ourselves with open
implementations as the existence of a garbage collector is essential in
this environment.
The extension of Linda to include multiple tuple spaces has introduced
this new problem as processes are now able to create tuple spaces,
spawn other processes into these tuple spaces, and store tuples (data)
into these tuple spaces, but are unable to delete any of the objects
(tuples, tuple spaces and processes) or even decide about their
usefulness.
In this paper we begin by showing that the main problem in introducing
garbage collection into Linda is the lack of sufficient information
about the effectiveness of Linda objects. We then describe techniques
for maintaining a structure to be used by a garbage collection
algorithm of tuple spaces.},
URL = {http://www.cs.york.ac.uk/linda/ps/sbrc97.ps}
}

@inproceedings{mene98,
title = {Ligia: Incorporating Garbage Collection in a {J}ava based {L}inda-like Run-Time System},
author = {Ronaldo Menezes},
booktitle = {2nd Workshop on Distributed Systems (WOSID)},
address = {Curitiba, Parana, Brazil},
pages = {81--88},
year = 1998,
abstract = {Generative distributed open coordination systems have been
so far implemented in a variety of ways. Surprisingly, no published
implementation appears to address one particularly important issue for
any general purpose open system | garbage collection.
This paper describes an open Linda-like implementation called Ligia
using Java, based on communication via sockets and which includes
garbage collection of tuple spaces and agents. It is also demonstrated
how the garbage collection described in [MW97] is implemented and that
it adds little overhead to the overall performance of the system.},
URL = {http://www.cs.york.ac.uk/linda/ps/wosid98.ps}
}

@inproceedings{mene98a,
title = {Using Tuple Monitoring and Process Registration on the Implementation of Garbage Collection in open {L}inda-like Systems},
author = {Ronaldo Menezes and Alan Wood},
booktitle = {10th IASTED International Conference on Parallel and Distributed Computing System (PDCS)},
address = {Las Vegas},
pages = {490--495},
month = oct,
year = 1998,
publisher = {ASTED/Acta Press},
abstract = {This paper demonstrates the importance of garbage
collection in open distributed tuple space systems based on Linda, and
how it should be implemented without adding a big overhead to the
system.
The extension of Linda to include multiple tuple spaces introduced this
new problem as processes are able to create tuple spaces but are unable
to delete them  or even decide whether a given tuple space is still
required in the system or not (garbage).
Techniques for maintaining a structure to be used by a garbage
collection algorithm of tuple spaces are described, implemented and the
results analysed. Two new concepts are introduced in the model in order
to provide the collector with the information required: tuple
monitoring and process registration.}
}

@techreport{mene98b,
title = {Ligia: A {J}ava based {L}inda-like Run-time System with Garbage Collection of Tuple Spaces},
author = {Ronaldo Menezes and Alan Wood},
institution = {University of York},
number = {YCS 304 (1998)},
year = 1998,
abstract = {Generative distributed open coordination systems have been
so far implemented in a variety of ways.  Surprisingly, no published
implementation appears to address one particularly important issue for
any general purpose open system | garbage collection.
This paper describes an open Linda-like implementation called Ligia
using Java, based on communication via sockets and which includes
garbage collection of tuple spaces and agents. It is demonstrated how
to do garbage collection efficiently, showing that little overhead is
added to the overall performance of the system.},
URL = {ftp://ftp.cs.york.ac.uk/reports/YCS-98-304.ps.Z}
}

@inproceedings{merr92,
title = "Collections and Garbage Collection",
author = "Simon C. Merrall and Julian A. Padget",
crossref = "IWMM92",
pages = {473--489},
doi = {10.1007/BFb0017208}
}

@misc{mery95,
title = {Refining Solutions of the On The Fly Garbage Collection from Formal Specifications},
author = {Dominique M\'{e}ry},
address = {Universit\'{e} henri Poincar\'{e}},
email = {mery@loria.fr},
month = nov,
year = 1995
}

@book{metr80,
title = "A History of Computing in the Twentieth Century",
editor = "N. Metropolis and J. Howlett and Gian-Carlo Rota",
publisher = AP,
year = 1980
}

@book{meye88,
author = "Bertrand Meyer",
title = "Object-oriented Software Construction",
publisher = PH,
year = 1988,
comment = "Introduces the Eiffel object-oriented programming language."
}

@techreport{meye96,
author = "Bertrand Meyer",
title = "The {ISE} {E}iffel Garbage Collection mechanism: An overview",
institution = "ISE Inc.",
URL = {http://www.eiffel.com/doc/manuals/technology/internal/gc/page.html},
mon= feb,
year = 1996
}

@inproceedings{meye12,
author = {Meyer, Bertrand and Kogtenkov, Alexander and Akhi, Anton},
title = {Processors and their Collection},
booktitle = {Proceedings of the 2012 International Conference on Multicore
Software Engineering, Performance and Tools, MSEPT'12},
year = {2012},
address = {Prague, Czech Republic},
pages = {1--15},
doi = {10.1007/978-3-642-31202-1_1},
publisher = SV,
} 

@inproceedings{meye03,
title = {A Novel Processor Architecture with Exact Tag-free Pointers},
author = {Matthias Meyer},
booktitle = {2nd Workshop on Application Specific Processors},
address = {San Diego, CA},
pages = {96--103},
year = 2003,
URL = {http://www.ikr.uni-stuttgart.de/~meyer/wasp03.pdf}
}

@article{meye04,
title = {A Novel Processor Architecture with Exact Tag-free Pointers},
author = {Matthias Meyer},
journal = {IEEE Micro},
volume = 24,
number = 3,
month = {May--June},
year = 2004,
pages = {46--55},
URL = {http://ieeexplore.ieee.org/xpl/tocresult.jsp?isNumber=29085}
}

@inproceedings{meye05,
author = {Matthias Meyer},
title = {An On-chip Garbage Collection Coprocessor for Embedded
Real-time Systems},
booktitle = {11th {IEEE} International Conference on Embedded
and Real-Time Computing Systems and Applications},
address = {Hong Kong, China},
month = aug,
year = 2005,
pages = {517--524},
URL = {http://www.ikr.uni-stuttgart.de/~meyer/rtcsa05.pdf}
}

@inproceedings{meye06,
title = {A True Hardware Read Barrier},
author = {Matthias Meyer},
pages = {3--16},
crossref = {ISMM06},
}

@incollection{meye83,
author = "R. Meyers and D. Casseres",
title = "An {MC68000}-Based {S}malltalk-80 System",
crossref = "Smalltalk-BHWA",
pages = "175--188",
}

@techreport{mich95,
author = {Maged M. Michael and M.L. Scott},
title = {Correction of a Memory Management Method for Lock-Free Data Structures},
institution = {University of Rochester},
number = {UR CSD / TR59},
month = dec,
year = 1995,
doi = {1802/503}
}

@techreport{mich02,
author = {Maged M. Michael},
title = {Safe Memory Reclamation for Dynamic Lock-Free Objects Using Atomic Reads and Writes},
type = {Research Report},
number = {RC22317},
institution = "{IBM} Corp., Thomas J Watson Research Center, Yorktown Heights, NY",
month = jan,
year = 2002,
URL = {http://www.research.ibm.com/people/m/michael/RC22317.pdf}
}

@inproceedings{mich02a,
author = {Maged M. Michael},
title = {Safe Memory Reclamation for Dynamic Lock-Free Objects Using Atomic Reads and Writes},
booktitle = {The 21st Annual ACM Symposium on Principles of Distributed
Computing (PODC)},
pages = {21--30},
month = jul,
year = 2002,
URL = {http://www.research.ibm.com/people/m/michael/podc-2002.pdf},
doi = {10.1145/571825.571829}
}

@inproceedings{mich04,
  title =	 {Scalable Lock-Free Dynamic Memory Allocation},
  author =	 {Maged M. Michael},
  crossref =	 {PLDI04},
  pages =	 {35-46},
  doi =		 {10.1145/996841.996848}
}

@article{mich04a,
title =	 {Hazard Pointers: Safe Memory Reclamation for Lock-Free Objects},
author = {Maged M. Michael},
journal = {IEEE Transactions on Parallel and Distributed Systems},
volume = 15,
number = 6,
pages = {491--504},
month = jun,
year = 2004,
URL = {http://www.research.ibm.com/people/m/michael/ieeetpds-2004.pdf},
doi = {10.1109/TPDS.2004.8}
}

@inproceedings{mija04,
author = {Ivana Mijajlovic and Noah Torp-Smith},
title = {Refinement in Separation Context},
crossref = {SPACE04},
}

@inproceedings{mikh01,
author = {V.V. Mikheev and S.A. Fedoseev},
title = {Compiler-Cooperative Memory Management in {J}ava},
booktitle = {Andrei Ershov 4th International Conference "Perspectives of System Informatics"},
series = LNCS,
volume = 2244,
publisher = SV,
year = 2001,
URL = {http://www.excelsior-usa.com/pdf/StackAlloc.pdf}
}

@techreport{mill88a,
author = "B. P. Miller",
title = "The Frequency of Dynamic Pointer References in {'C'} Programs",
institution = "University of Wisconsin, Madison",
number = "TR 759",
year = 1988
}

@phdthesis{mill87,
author = "James S. Miller",
title = "Multi{S}cheme: A Parallel Processing System Based on {MIT} {S}cheme",
school = MIT,
year = 1987,
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TR-402.html",
note = "Also Technical Report MIT/LCS/402"
}

@inproceedings{mill90,
author = "James S. Miller and B. Epstein",
title = "Garbage Collection in {M}ulti{S}cheme",
booktitle = "US/Japan Workshop on Parallel Lisp",
series = LNCS,
volume = 441,
publisher = SV,
pages = "138--160",
month = jun,
year = 1990
}

@techreport{mill94,
author = "Miller, James S.  and Rozas, Guillermo J. ",
institution = MITAI,
title = "Garbage Collection is Fast, but a Stack is Faster",
year = 1994,
URL = "ftp://publications.ai.mit.edu/ai-publications/1000-1499/AIM-1462.ps.Z",
month = mar,
number = "{AIM}-1462",
doi = {1721.1/6622}
}

@article{mill96,
author = "Justin Miller",
title = "Clean Up: {C++} Garbage Collection",
journal = "BYTE",
month = jan,
year = 1996,
pages = "157--158",
comment= "Reference counting library for C++."
}

@book{miln90,
author = "Robin Milner and Mads Tofte and Robert Harper",
title = "The Definition of Standard {ML}",
publisher = MIT,
year = 1990
}

@techreport{mins63,
author = "Marvin L. Minsky",
title = "A {L}isp Garbage Collector Algorithm Using Serial Secondary Storage",
number = "Memo 58 (rev.)",
institution = "Project MAC",
address = "MIT, Cambridge, MA",
month = dec,
year = 1963,
comment = {Presents an algorithm which eliminates the difficulties of having
a shared cell being output more than once to secondary storage.
Does not use a stack, but requires one mark-bit per lisp cell.
Live data is copied out to a file and then read back in.
This algorithm is linearizing.
Lisp 1.5. Would be unbearably slow on a modern machine.  }
}

@article{mira77,
  author =	 "Miranda, Eliot E.",
  title =	 "BrouHaHa --- a Portable {S}malltalk Interpreter",
  journal =	 SIGPLAN,
  volume =	 22,
  number =	 12,
  publisher =	 ACM,
  pages =	 "354--365",
  year =	 1977,
  comment =	 "``also describes Peter Deutsch's add/subtract two reference
                  counting hack that has to be one of the all-time greats.''"
}

@inproceedings{mira87,
author = "Eliot Miranda",
title = "Brou{H}a{H}a --- a Portable {S}malltalk Interpreter",
crossref = "OOPSLA87",
pages = "354-365",
comment = "Hybrid: reference count + mark-sweep"
}

@article{misr82,
title = "Termination Detection of Diffusing Computations in Communicating Sequential Processes",
author = "Jayadev Misra and K. M. Chandy",
pages = "37--43",
journal = TOPLAS,
publisher = ACM,
year = 1982,
month = jan,
volume = 4,
number = 1
}

@article{misr86,
title = "Axioms for Memory Access in Asynchronous Hardware Systems",
author = "Jayadev Misra",
pages = "142--153",
journal = TOPLAS,
publisher = ACM,
year = 1986,
month = jan,
volume = 8,
number = 1
}

@inproceedings{mitc03,
title = {{L}eak{B}ot: An Automated and Lightweight Tool for Diagnosing Memory Leaks in Large Java Applications},
author = {Nick Mitchell and Gary Sevitsky},
crossref = {ECOOP03},
pages = {351--377},
abstract = {Despite Java's automatic reclamation of memory, memory
leaks remain an important problem. For example, we frequently encounter
memory leaks that cause production servers to crash. These servers
represent an increasingly common class of Java applications: they are
large scale and they make heavy use of frameworks. For these
applications, existing tools require too much expertise, and, even for
experts, require many hours interpreting low-level details. In
addition, they are often too expensive to use in practice. We present
an automated, adaptive, and scalable tool for diagnosing memory leaks,
called LeakBot.
LeakBot incorporates three new techniques. First, it automatically
ranks data structures by their likelihood of containing leaks. This
process dramatically prunes the set of candidate structures, using
object reference graph properties and knowledge of how leaks occur.
Second, it uses Co-Evolving Regions to identify suspicious regions
within a data structure and characterize their expected evolution.
Third, it uses the first two methods to derive a lightweight way to
track those regions' actual evolution as the program runs. These
techniques are mutually beneficial: we need only monitor what is highly
ranked, and, because the tracking is so cheap, a region's rank can be
continually updated with information from production machines. Finally,
this whole process can be done without user assistance.
We demonstrate LeakBot's effectiveness on a number of large-scale
applications that we have analyzed as part of the ongoing consulting
practice our group maintains. We have found that the ranking analysis
scales (e.g. written in Java, it analyzes 10^6 objects in 30 seconds
with a 300M heap), is selective (e.g. it prunes that set to three
candidate leak roots), and is accurate (it discounts non-leakingroots).
The CER generation completes in tens of seconds. The lightweight
tracking refines the rankings, while lowering throughput by less than
5\%.}
}

@inproceedings{mitc09,
title = {Making Sense of Large Heaps},
author = {Nick Mitchell and Edith Schonberg and Gary Sevitsky},
crossref = {ECOOP09},
}

@inproceedings{mitt86,
author = "Mittal, S. and Bobrow, Daniel and Kahn, K.",
title = "Virtual Copies: At the Boundary Between Classes and Instances",
crossref = "OOPSLA86",
pages = "159--166"
}

@inproceedings{miya87,
author = "Miyauchi, Nobuhito and A. Matsumoto and Y. Kimura and A. Goto",
title = "Multiple Reference Management by {MRB} --- {GC} Characteristics on
{KL1} Emulator",
booktitle = "35th Meeting of Information Processing Society",
year = 1987,
month = sep,
note = "In Japanese"
}

@techreport{miya89,
author = "Miyauchi, Nobuhito and Kawada, Yasuharu and Nakajima, Katsuto",
title = "Tracing Garbage Collection for {KL1} on the {M}ulti-{PSI}/{V2}
System",
institution = "Institute for New Generation Computer Technology",
year = 1989,
type = "ICOT technical report",
number = "TR-469",
month = Mar,
abstract = "This paper describes the implementation and evaluation
of tracing garbage collection for KL1 on the Multi-PSI/V2.  It is
important for committed choice language systems to implement
effective memory management mechanisms, because the memory
consumption speed is quite high.  The incremental garbage
collector by Multiple Reference Bit (MRB) reclaims single-
referenced data in order to keep locality and avoid frequent
tracing garbage collection on the Multi-PSI/V2, but cannot
collect multiple-referenced garbages.  Thus, the tracing garbage
collector is indispensable to collect multiple-referenced
garbages.  The MRB information is maintained by counting
reference paths in the tracing garbage collection, so the
incremental garbage collector can collect all of single-
referenced garbages after that.  We evaluated the performance of
the tracing garbage collection and the statistics of memory
consumption on the Multi-PSI/V2, and confirmed that all of
processors can work away without the disturbance of the tracing
garbage collection."
}

@inproceedings{mogu91,
  author =	 "Jeffrey C. Mogul and Anita Borg",
  title =	 "The Effect of Context Switches on Cache Performance",
  crossref =	 "ASPLOS91",
  pages =	 "75--84",
  doi =		 {10.1145/106972.106982},
  comment =	 "Cost of second level cache miss may rise to 200 cycles"
}

@phdthesis{moha84,
author = "Khayri A. Mohamed-Ali",
title = "Object Oriented Storage Management and Garbage Collection in
Distributed Processing Systems",
school = "Royal Institute of Technology, Stockholm",
month = dec,
number = "TRITA--CS--8406",
year = 1984,
comment = "Cannot deal with cycles"
}

@article{moha86,
title = "Global Garbage Collection for Distributed Heap Storage-Systems",
author = "Kharyi A. Mohamed-Ali and Seif Haridi",
address = "Swedish Inst. Computer Science, S--16313 Spanga, Sweden",
journal = "International Journal Of Parallel Programming",
year = 1986,
volume = 15,
number = 5,
pages = "339--387"
}

%Check author
@inproceedings{moha89,
author = "Kharyi A. Mohamed-Ali",
title = "Garbage Collection for {O}r-parallel {P}rolog Based on {WAM}",
booktitle = "Gigalips Workshop",
address = "Stockholm",
month = apr,
year = 1989,
publisher = "SICS"
}

@techreport{mohn95,
title = "Efficient Compile-Time Garbage Collection for Arbitrary Data Structures",
author = "Markus Mohnen",
institution = "University of Aachen",
number = "95--08",
URL = "ftp://ftp.informatik.rwth-aachen.de/pub/reports/1995/95-08.ps.gz",
month = may,
year = 1995,
abstract = "This paper describes a \emph{compile-time garbage collection} (ctgc)
           method in the setting of a first-order functional language with data
           structures. The aim is to obtain information on positions in a
           program where certain heap cells will become obsolete during
           execution. Therefore we develop an abstract interpretation for the
           detection of {\em inheritance information\/} which allows us to
           detect whether the heap cells of an argument will be propagated to
           the result of a function call. The abstract interpretation itself is
           independent of the evaluation strategy of the underlying language.
           However, since the actual deallocations take place after on
           termination of functions, the information obtained by the abstract
           interpretation can be only be applied in an eager context, which may
           be detected using strictness analysis in a lazy language. In order to
           increase efficiency we show how the number of recomputations can be
           decreased by using only parts of the abstract domains. The worst case
           time complexity is essentially quadratic in the size of the program.
           We illustrate the method developed in this paper with several
           examples and we demonstrate how to use the results in an eager
           implementation.  Correctness of the analysis is considered, using a
           modified denotational semantics as reference point. A main goal of
           our work is to keep both the run-time and the compile-time overhead
           as small as possible.",
note = "Also in 7th International Symposium on Programming Languages, Implementations, Logics and Programs, PLILP95"
}

@inproceedings{mohn95a,
title = "Efficient Compile-Time Garbage Collection for Arbitrary Data Structures",
booktitle = {7th International Symposium on Programming Languages,
Implementations, Logics and Programs (PLILP)},
author = "Markus Mohnen",
pages = {241--258},
year = 1995,
abstract = "This paper describes a \emph{compile-time garbage collection} (ctgc)
           method in the setting of a first-order functional language with data
           structures. The aim is to obtain information on positions in a
           program where certain heap cells will become obsolete during
           execution. Therefore we develop an abstract interpretation for the
           detection of {\em inheritance information\/} which allows us to
           detect whether the heap cells of an argument will be propagated to
           the result of a function call. The abstract interpretation itself is
           independent of the evaluation strategy of the underlying language.
           However, since the actual deallocations take place after on
           termination of functions, the information obtained by the abstract
           interpretation can be only be applied in an eager context, which may
           be detected using strictness analysis in a lazy language. In order to
           increase efficiency we show how the number of recomputations can be
           decreased by using only parts of the abstract domains. The worst case
           time complexity is essentially quadratic in the size of the program.
           We illustrate the method developed in this paper with several
           examples and we demonstrate how to use the results in an eager
           implementation.  Correctness of the analysis is considered, using a
           modified denotational semantics as reference point. A main goal of
           our work is to keep both the run-time and the compile-time overhead
           as small as possible.",
note = "Also see \cite{mohn95}."
}

@inproceedings{moll01,
author = {Anders M\/{o}ller},
title = {Verification of Data Type Implementations using Graph Types and Monadic Second-order Logic},
crossref = {SPACE01},
}

@inproceedings{monn01,
  title =	 {Principled Scavenging},
  author =	 {Stefan Monnier and Bratin Saha and Zhong Shao},
  crossref =	 {PLDI01},
  pages =	 {81-91},
  doi =		 {10.1145/378795.378817}
}

@inproceedings{monn01a,
author = {Stefan Monnier},
title = {Principled Scavenging},
crossref = {SPACE01},
}

@inproceedings{monn04,
author = {Stefan Monnier},
title = {Typed Regions},
crossref = {SPACE04},
}

@manual{moon74,
author = "David A. Moon",
title = "{MACLisp} reference manual",
organization = "Project MAC",
address = "MIT, Cambridge, MA",
month = apr,
year = 1974,
}

@inproceedings{moon84,
title = "Garbage Collection in a Large {LISP} System",
author = "David A. Moon",
crossref = "LFP84",
pages = "235--245",
doi={10.1145/800055.802040},
comment = "Improve performance by using the garbage collector.
Lisp Machines have special purpose hardware to detect pointers
into fromspace and trap to a handler.
The cost of this checking on a conventional machine is in the tens of percent
for a high performance system."
}

@inproceedings{moon85,
author = "David A. Moon",
title = "Architecture of the {S}ymbolics 3600",
booktitle = "12th Annual International Symposium on Computer
Architecture",
address = "Boston, MA",
month = jun,
year = 1985,
pages = "76--83",
comment = {Multiple generations are reclaimed incrementally.}
}

@inbook{moon90,
  author =	 "David A. Moon",
  title =	 {Symbolics Architecture},
  chapter =	 3,
  booktitle =	 "Computers for Artificial Intelligence Processing",
  publisher =	 Wiley,
  year =	 1990
}

@inproceedings{moon91,
title = {Genera Retrospective},
crossref = {IWOOOS91},
author = "David A. Moon",
note = {Order Number 2265}
}

@inproceedings{moon92,
title = "Copying Garbage Collection is Harmful",
author = "David A. Moon",
crossref = "IWMM92",
note = {Discussion Session}
}

@inproceedings{moor97,
title = {Oscar: A {GC} Testbed},
author = {Jonathan Moore and Mike Hicks and Scott Nettles},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/nettles-oscar.ps},
crossref = {OOPSLA97-gc}
}

@techreport{mora09,
  title =	 {Efficient Memory Management for Long-Lived Objects},
  author =	 {Ronny Morad and Martin Hirzel and Elliot K. Kolodner and
                  Mooly Sagiv},
  institution =	 {IBM T.J. Watson Research Center},
  type =	 {IBM Research Report},
  number =	 {RC24794},
  month =	 may,
  year =	 2009,
  URL = {https://researcher.ibm.com/researcher/files/us-hirzel/tr09-rc24794-regions.pdf}
}
%  URL = {http://domino.watson.ibm.com/comm/research_people.nsf/pages/hirzel.index.html/$FILE/tr09-rc24794-regions.pdf}

@techreport{more97,
author = {Luc Moreau},
title = {A Distributed Garbage Collector with Diffusion Tree Reorganisation and Object Mobility},
number = {M97/2},
month = oct,
institution = {University of Southampton},
year = 1997
}

@inproceedings{more97a,
author = {Luc Moreau and David DeRoure and Ian Foster},
title = {{N}e{X}eme: a Distributed {S}cheme Based on {N}exus},
booktitle = {3rd International Europar Conference (EuroPar)},
series = LNCS,
volume = 1300,
pages = {581--590},
address = {Passau, Germany},
month = aug,
publisher = SV,
year = 1997
}

@inproceedings{more98,
author = {Luc Moreau},
title = {Hierarchical Distributed Reference Counting},
pages = {57--67},
crossref = {ISMM98},
abstract = {Massively distributed computing is a challenging problem
for garbage collection algorithm designers
as it raises the issue of scalability. The high number of hosts
involved in a computation can require large tables for reference
listing, whereas the lack of information sharing between hosts in
a same locality can entail redundant GC traffic. In this paper,
we argue that a conceptual hierarchical organisation of massive
distributed computations can solve this problem. By conceptual
hierarchical organisation, we mean that processors are still able
to communicate in a peer to peer manner using their usual
communication mechanism, but GC messages will be routed as if
processors were organised in hierarchy. We present an extension
of a distributed reference counting algorithm that uses such a
hierarchical organisation. It allows us to bound table sizes by
the number of hosts in a domain, and it allows us to share GC
information between hosts in a same locality in order to reduce
cross-network GC traffic. }
}

@inproceedings{more98a,
author = {Luc Moreau},
title = {A Distributed Garbage Collector with Diffusion Tree Reorganisation and Mobile Objects},
pages = {204--215},
crossref = {ICFP98},
URL = {http://www.acm.org/pubs/articles/proceedings/fp/289423/p204-moreau/p204-moreau.pdf}
}

@misc{more99,
author = {Luc Moreau and Jean Duprat},
title = {A Construction of Distributed Reference Counting: the Constructive Proof in {C}oq},
month = feb,
year = 1999,
URL = {http://www.ecs.soton.ac.uk/~lavm/coq/drc/}
}

@inproceedings{more99a,
author = {Luc Moreau},
title = {Implementation and Performance Evaluation of a Distributed Garbage
Collection Algorithm},
booktitle = {Parallel and Distributed Computing for Symbolic and Irregular Applications, PDCSIA'99},
editor = {Takayasu Ito and Taiichi Yuasa},
year = 1999,
URL = {http://www.ecs.soton.ac.uk/~lavm/papers/pdcsia99.ps.gz},
publisher = {World Scientific Publishing},
address = {Sendai, Japan},
month = jul,
pages = {221--241},
abstract = {We have recently described an algorithm for distributed garbage
collection based on reference-counting; the algorithm describes a
spectrum of algorithms according to the policy used to manage
messages. In this paper, we describe the implementation of the
algorithm and evaluate its performance.  We have implemented two
policies, which are extremes of the spectrum.  The first one uses
incdec messages, whose effect is to reorganise the diffusion tree,
whereas the other one does not use such messages, which in effect
results in Piquer's indirect reference counting.  In addition, two
different strategies for managing action queues have been
implemented.  The conclusions of our experimentations are the
following. Using incdec messages potentially offers more
parallelism in the DGC activity; this phenomenon can be measured by
shorter causality chains than with indirect reference counting.
Grouping messages per destination dramatically reduces the number
of messages to be sent, though requires a more complex
implementation as messages have to be sorted per destination.}
}

@article{more01,
author = {Luc Moreau and Jean Duprat},
title = {A Construction of Distributed Reference Counting},
journal = {Acta Informatica},
colume = 37,
pages = {563--595},
year = 2001,
URL = {http://eprints.ecs.soton.ac.uk/8935/}
}

@article{more01a,
author = {Luc Moreau},
title = {Tree Rerooting in Distributed Garbage Collection: Implementation and Performance Evaluation},
journal = {Higher-Order and Symbolic Computation},
volume = 14,
number = 4,
year = 2001,
URL = {http://eprints.ecs.soton.ac.uk/6397/}
}

@techreport{more03,
author = {Luc Moreau and Peter Dickman and Richard Jones},
title = {Birrell's Distributed Reference Listing Revisited},
month = jul,
year = 2003,
pages = {50},
url = {http://www.cs.kent.ac.uk/pubs/2003/1650},
institution = {University of Kent},
number = {8--03},
}

@article{more05,
author = {Luc Moreau and Peter Dickman and Richard Jones},
title = {Birrell's Distributed Reference Listing Revisited},
url = {http://www.cs.kent.ac.uk/pubs/2005/1993},
pages = {1344--1395},
journal = TOPLAS,
volume = 27,
number = 6,
year = {2005},
publisher = ACM,
issn = {0164-0925}
}

@techreport{more02,
author = {P.-E. Moreau and Olivier Zendra},
title = {$\textnormal{GC}^2$: A Generational Conservative Garbage Collector for the {AT}erm Library},
institution = {INRIA Lorraine},
type = "Rapport de Recherche",
number = {RR--4547},
month = sep,
year = 2002,
URL = {http://www.loria.fr/~zendra/publications/rr2002c.pdf}
}

@article{more04,
author = {P.-E. Moreau and Olivier Zendra},
title = {$\textnormal{GC}^2$: A Generational Conservative Garbage Collector for the {AT}erm Library},
journal = {Journal of Logic and Algebraic Programming (JLAP)},
volume = 59,
number = {1--2},
month = apr,
year = 2004,
publisher = {Elsevier},
URL = {http://www.loria.fr/~zendra/publications/jlap-gc-aterms-2004.pdf}
}

@inproceedings{mori13,
author = {Morikawa, Kazuya and Ugawa, Tomoharu and Iwasaki, Hideya},
title = {Adaptive Scanning Reduces Sweep Time for The {L}isp2 Mark-Compact Garbage Collector},
crossref = {ISMM13},
doi = {10.1145/2464157.2466480},
abtract = {Mark-compact garbage collection helps long-running programs avoid
fragmentation. The Lisp2 mark-compact collector is a classic but still
widely-used compaction algorithm. It sequentially scans the entire heap to
compact all live objects at one end of the heap while preserving their order of
addresses. Since the heap is generally large, this scanning takes a long time.
Although some collectors adopt a separate bitmap into which mark bits of objects
are stored to reduce the scanning time, we observed that scanning the bitmap can
take longer than scanning the heap if objects are densely located. We propose a
new scanning method from this observation, which adaptively alternates methods
of scanning depending on heap usage; it scans those parts of the heap where live
objects are densely located whereas it scans the bitmap for the remaining parts.
We implemented this scanning method in the Lisp2 collector of Jikes RVM.
The experimental results revealed that the adaptive scanner scanned faster than
the method that only scanned the heap and the method that only scanned the
bitmap.}
} 


@article{morr78,
author = "F. Lockwood Morris",
title = "A Time- and Space-Efficient Garbage Compaction Algorithm",
journal = CACM,
publisher = ACM,
volume = 21,
number = 8,
pages = "662--5",
year = "1978",
doi={10.1145/359576.359583},
abstract = {Compacting GC for vari-sized cells. O(n) and requires only 1 extra bit per
pointer.
No break tables. Sliding. Cf. also Jonkers79. Apparently slow --- see cohen-
nicolau.}
}

@article{morr79,
author = "F. Lockwood Morris",
title = "On a Comparison of Garbage Collection Techniques",
journal = CACM,
publisher = ACM,
volume = 22,
number = "10",
month = Oct,
year = 1979,
pages = 571,
}

@article{morr82,
title = "Another Compacting Garbage Collector",
author = "F. Lockwood Morris",
journal = IPL,
publisher = NH,
series = "Data compaction",
year = 1982,
month = oct,
volume = 15,
number = 4,
pages = "139--142",
doi={10.1016/0020-0190(82)90094-1}
}

@techreport{morr95,
title = "Abstract Models of Memory Management",
author = "J. Gregory Morrisett and Mattias Felleisen and Robert Harper",
institution = CMU,
URL = "http://www.cs.cmu.edu:8001/afs/cs.cmu.edu/user/jgmorris/web/jgmorris-home.html",
month = jan,
number = "CMU--CS--95--110",
year = 1995,
note = "Also published as Fox memorandum CMU--CS--FOX--95--01"
}

@inproceedings{morr95a,
title = "Abstract Models of Memory Management",
author = "J. Gregory Morrisett and Mattias Felleisen and Robert Harper",
URL = "http://www.cs.cornell.edu/Info/People/jgm/papers/fpca_gc.ps",
crossref = "FPCA95",
}

@phdthesis{morr95b,
title = "Compiling with Types",
author = "J. Gregory Morrisett",
school = CMU,
URL = "http://www.cs.cornell.edu/Info/People/jgm/papers/thesis.ps",
month = dec,
year = 1995,
note = "Published as CMU Technical Report CMU-CS-95-226",
}

@incollection{morr97,
title = {Semantics of Memory Management for Polymorphic Languages},
author = {Greg Morrisett and Robert Harper},
booktitle = {Higher Order Operational Techniques in Semantics},
editor = {A. Gordon and A. Pitts},
publisher = {Newton Institute, } # CUP,
pages = {175--226},
year = 1997
}

@inproceedings{morr01,
author = {Greg Morrisett},
title = {Next Generation Low-Level Languages},
crossref = {SPACE01},
note = {Invited talk}
}

@techreport{moss78,
author = "Moss, J. Eliot B.",
title = "Abstract Data Types in Stack Based Languages",
institution = "MIT Laboratory for Computer Science",
type = "Technical Memo",
number = "MIT/LCS/TR--190",
month = aug,
year = 1990,
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TR-190.html"
}

@incollection{moss88,
author = "J. Eliot B. Moss and S. Sinofsky",
title = "Managing Persistent Data with {M}neme: Designing a Reliable,
Shared Object Interface",
booktitle = "Advances in Object-oriented Database Systems",
series = LNCS,
volume = 334,
pages = "298--316",
publisher = SV,
year = 1988
}

@inproceedings{moss89,
author = "Moss, J. Eliot B.",
title = "Addressing Large Distributed Collections of Persistent
Objects:  The {M}neme Project's Approach",
booktitle = "2nd International Workshop on Database Programming
Languages",
pages = "269--285",
month = jun,
year = 1989,
address = "Glenedon Beach, OR",
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/dbpl89.ps.Z},
note = "Also available as Technical Report 89-68, " # UMass,
}

@techreport{moss89b,
author = "J. Eliot B. Moss",
title = "The {M}neme Persistent Object Store",
type = "COINS Technical Report",
number = "89--107",
institution = UMass,
year = 1989
}

@inproceedings{moss90,
author = "J. Eliot B. Moss",
title = "Garbage Collecting Persistent Object Stores",
crossref = "OOPSLA90-gc",
URL = "ftp://ibis.cs.umass.edu/pub/papers/oopsla90gc.ps.Z",
note = "Also in SIGPLAN Notices 23(1):45--52, January 1991.",
}

@techreport{moss90a,
author = "Moss, J. Eliot B.",
title = "Working With Objects: To Swizzle or Not to Swizzle?",
number = "90--38",
institution = UMass,
address = "Amherst, MA",
month = may,
year = 1990
}

@inproceedings{moss91,
author = "Maurice P. Herlihy and J. Eliot B. Moss",
title = "Lock-Free Garbage Collection for Multiprocessors",
booktitle = "Parallel Algorithms and Architectures",
publisher = ACM,
pages = "229--236",
month = jul,
year = 1991
}

@inproceedings{moss91a,
title = "The {UM}ass Language Independent Garbage Collector Toolkit",
author = "J. Eliot B. Moss",
crossref = "OOPSLA91-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/moss.ps"
}

@article{moss92,
author = "Moss, J. Eliot B.",
title = "Working With Persistent Objects: To Swizzle or Not to Swizzle?",
journal = IEEETransSWE,
publisher = IEEE,
volume = 18,
number = 8,
month = aug,
year = 1992,
pages = "657-673",
doi={10.1109/32.153378}
}

@inproceedings{moss96,
author = {J. Eliot B. Moss and David S. Munro and Richard L. Hudson},
title = {{PMOS}: A Complete and Coarse-grained Incremental Garbage
                  Collector for Persistent Object Stores},
crossref = "POS96",
pages = {140--150},
URL = {http://www.dcs.st-and.ac.uk/research/publications/download/MMH96.pdf},
abstract = {Traditional garbage collection techniques designed for
                  language systems operating over transient data do not
                  readily migrate to a persistent context. The size,
                  complexity, and permanence characteristics of a persistent
                  object store mean that an automatic storage reclamation
                  system, in addition to ensuring that all unreachable and
                  only unreachable data is reclaimed, must also maintain store
                  consistency while limiting I/O overhead when collecting
                  secondary-memory data. Research has shown that careful
                  selection of which area of a store to collect can
                  significantly increase the amount of reclaimed storage while
                  reducing the I/O costs.  Many garbage collectors for
                  existing stores, however, either are off-line or rely on
                  reclaiming space in a predefined order. This paper presents
                  a new incremental garbage collection algorithm specifically
                  designed for reclaiming persistent object storage. The
                  collector extends the Mature Object Space algorithm to
                  ensure incrementality in a persistent context, to achieve
                  recoverability, and to impose minimum constraints on the
                  order of collection of areas of the persistent address
                  space.}
}

@inproceedings{mowr92,
  author =	 "Todd C. Mowry and Monica S. Lam and Anoop Gupta",
  title =	 "Design and Evaluation of a Compiler Algorithm for
                  Prefetching",
  crossref =	 "ASPLOS92",
  pages =	 "62--73",
  doi =		 {10.1145/143365.143488}
}

@inproceedings{mulk90,
author = "Anne Mulkers and William Winsborough and Maurice Bruynooghe",
title = "Analysis of Shared Data Structures for Compile-Time Garbage Collection in Logic Programs",
booktitle = "7th International Conference on Logic Programming",
publisher = MIT,
pages = "747--762",
year = 1990
}

@techreport{mulk90a,
author = "Anne Mulkers and William Winsborough and Maurice Bruynooghe",
title = "Analysis of Shared Data Structures for Compile-Time Garbage Collection in
 Logic Programs",
institution = "Katholieke Universitiet of Leuven, Belgium",
type = "Report",
number = "CW117",
note = "Extended version",
year = 1990
}

@phdthesis{mulk91,
author = "Anne Mulkers",
title = "Deriving Live Data Structures in Logic Programs by Means of Abstract
Interpretation",
school = "Katholieke Universitiet of Leuven, Belgium",
year = 1991
}

@inproceedings{mulk92,
author = "Anne Mulkers and William Winsborough and Maurice Bruynooghe",
title = "Static Analysis of Logic Programs to Detect Run-Time Garbage Cells",
booktitle = "International Conference on Computer Systems and Software
Engineering",
publisher = IEEE,
pages = "526--531",
year = 1992
}

@book{mulk93,
author = "Anne Mulkers",
title = "Live Data Structures in Logic Programs",
publisher = SV,
series = LNCS,
number = 675,
year = 1993,
comment = "Abstract interpretation for compile-time gc"
}

@techreport{mulk93a,
author = "Anne Mulkers and William Winsborough and Maurice Bruynooghe",
title = "A Live-Structure Data-Flow Analysis for {P}rolog",
institution = "Katholieke Universitiet of Leuven, Belgium",
type = "Theory Reort",
number = "CW167",
year = 1993
}

@article{mulk94,
author = "Anne Mulkers and William Winsborough and Maurice Bruynooghe",
title = "Live-Structure Dataflow Analysis for {P}rolog",
journal = TOPLAS,
publisher = ACM,
volume = 16,
number = 2,
month = mar,
year = 1994,
URL = {http://www.acm.org/pubs/citations/journals/toplas/1994-16-2/p205-mulkers/}
}

@techreport{mull92,
author = "H. L. Muller and K. G. Langendoen and L. O. Hertzberger",
title = "{MiG}: Simulating Parallel Functional Programs on Hierarchical
Cache Architectures",
institution = "Department of Computer Science, University of Amsterdam",
year = 1992,
month = jun,
number = "CS--92--04",
}

@phdthesis{mull76,
author = {Klaus A. G. M\"{u}ller},
title = "On the Feasibility of Concurrent Garbage Collection",
school = "Tech. Hogeschool Delft",
month = Mar,
year = 1976,
}

@inproceedings{munr99,
author = {David Munro and Alfred Brown and Ron Morrison and J. Eliot B. Moss},
title = {Incremental Garbage Collection of a Persistent Object Store using {PMOS}},
booktitle = {Advances in Persistent Object Systems},
editor = {Ron Morrison and Mick Jordan and Malcolm Atkinson},
publisher = MK,
pages = {78--91},
year = 1999,
URL = {http://www.dcs.st-and.ac.uk/research/publications/download/MBM+99.pdf}
}

@inproceedings{munr00,
author = {David S. Munro and Alfred L. Brown},
title = {Evaluating Partition Selection Policies using the {PMOS} Garbage Collector},
pages = {104--115},
crossref = {POS00}
}

@inproceedings{munsi02,
author = {Henrik Munsin and Johan Lilius},
title = {Compile-Time Garbage Collection Using Escape Analysis},
booktitle = {Nordic Workshop on Software Development Tools
and Techniques (NWPER)},
year = 2002,
URL = {http://crest.abo.fi/index.php?format_in=bibtex\&key_in=inpMuLi02a\&submit=Search\&page=search\&standalone=no}
}

@inproceedings{murt84,
author = "Thomas P. Murtagh",
title = "A Less Dynamic Memory Allocation Scheme for {A}lgol-like Languages",
crossref = "POPL84",
pages = {283--289},
}

@article{murt91,
title = "An Improved Storage Management Scheme for Block Structured Languages",
author = "Thomas P. Murtagh",
pages = "372--398",
journal = TOPLAS,
publisher = ACM,
year = 1991,
month = jul,
volume = 13,
number = 3
}

@techreport{muth04,
author = {Muthukumar, R.M. and D. Janakiram},
title = {Yama: a Scalable Generational Garbage Collector for {J}ava in
Multiprocessor Systems},
institution = {Distributed and Object Systems Lab, Indian Institute of
Technology, Madras},
number = {DOS-CSE-2004-14},
year = 2004,
comment = {Extended version of \cite{muth06}}
}

@article{muth06,
author = {Muthu Kumar, R.M. and D. Janakiram},
title = {Yama: a Scalable Generational Garbage Collector for {J}ava in
Multiprocessor Systems},
journal = {IEEE Transactions on Parallel and Distributed Systems},
volume = 17,
number = 2,
pages = {148--159},
year = 2006,
URL = {http://dos.iitm.ac.in/LabPapers/TPDS_Yama_Final_Version.pdf}
}

@inproceedings{mycr01,
author = {Alan Mycroft},
title = {Statically Allocated Systems},
crossref = {SPACE01},
URL = {http://www.cl.cam.ac.uk/users/am/research/sa}
}

@inproceedings{mytk09,
  title =	 {Producing Wrong Data Without Doing Anything Obviously
                  Wrong!},
  author =	 {Todd Mytkowicz and Amer Diwan and Matthias Hauswirth and
                  Peter F. Sweeney},
  crossref =	 {ASPLOS09},
  pages =	 {265-276},
  doi =		 {10.1145/1508244.1508275}
}

@inproceedings{naeem09,
title = {Efficient Alias Set Analysis Using {SSA} Form},
author = {Nomair A. Naeem and Ondrej Lhot\'{a}k},
pages = {79--88},
doi = {10.1145/1542431.1542443},
crossref = {ISMM09}
}

@article{naga88,
author = "Naganuma, Jiro and Ogura, Takeshi and Yamada, Shin-ichiro and Kimura, Takashi",
address = "NTT, Kanagawa, Jpn",
title = "High-Speed {CAM}-Based Architecture for a {P}rolog Machine ({ASCA})",
year = 1988,
journal = IEEETransComp,
publisher = IEEE,
volume = 37,
number = 11,
month = 11,
pages = "1375--1383",
abstract = {A content-addressable-memory (CAM)-based machine is proposed
for a high-speed Prolog machine. This Prolog machine
attempts to speed up the total Prolog execution performance
by using a hierarchical pipelined scheme and CAM-based
backtracking scheme. The hierarchical pipelined scheme
reduces the total number of Prolog execution steps to half
of that using the conventional method. The CAM-based
backtracking is efficiently and quickly achieved by using a
sophisticated garbage collection function, which eliminates
the need for stacks and additional operation cycles. In this
machine, all Prolog execution can be simply controlled by a
semantic information 'inference depth' without any address
handling by sorting all working information, binding, and
control information in CAMs. This machine attains a
performance of 100 KLIPS (kilo logical inferences per
second) on the deterministic append program in the
interpretive mode and also attains high performance on the
interministic program. All Prolog programs in artificial-
intelligence application areas can run at high performance
on this machine.}
}

@inproceedings{naga09,
title = {Self-Recovery in Server Programs},
author = {Vijay Nagarajan and Dennis Jeffrey and Rajiv Gupta},
pages = {49--58},
doi = {10.1145/1542431.1542439},
crossref = {ISMM09}
}

@techreport{naka88,
author = "Nakajima, Katsuto",
title = "Piling {GC}: Efficient Garbage Collection for {Al} Languages",
institution = "Institute for New Generation Computer Technology",
year = 1988,
type = "ICOT technical report",
number = "TR-354"
}

@inproceedings{naka88a,
author = "Nakajima, Katsuto",
title = "Piling {GC}: Efficient Garbage Collection for {Al} Languages",
booktitle = "IFIP WG 10.3 Working Conference on Parallel Processing",
year = 1988,
pages = "210--204",
publisher = NH
}

@inproceedings{nakl06,
author = {C. Nakhli and C. Rippert and G. Salagnac and S. Yovine},
title = {Efficient Region-Based Memory Management for Resource-limited Real-Time
Embedded Systems},
editor ={Olivier Zendra},
booktitle ={Implementation, Compilation, Optimization of Object-Oriented
Languages, Programs and Systems ({ICOOOLPS}'2006)},
pages = 8,
address = {Nantes, France},
month = jul,
year = 2006,
URL = {http://www-verimag.imag.fr/~salagnac/recherche/articles/NRSY-icooolps06.pdf}
}

@inproceedings{nand05,
  author =	 {V. Krishna Nandivada and David Detlefs},
  title =	 {Compile-Time Concurrent Marking Write Barrier Removal},
  crossref =	 {CGO05},
  pages =	 {37--48},
  doi =		 {10.1109/CGO.2005.12}
}
 
@book{naru10,
title = {Garbage Collection Algorithms and Implementations},
author = {Narihiro Nakamura and Hikari Aikawa},
publisher = {Hidekazu},
year = 2010,
ISBN = {978-4798025629},
note = {In Japanese}
}

@mastersthesis{neel96,
title = "An Analysis of the Effects of Memory Allocation Policy on Storage Fragmentation",
author = "Michael S. Neely",
school = "University of Texas at Austin",
year = 1996,
URL = "http://www.cs.utexas.edu/users/oops/papers.html#neely-thesis"
}

@inproceedings{neir87,
author = "Anne Neirynck and Prakash Panangaden and Alan J. Demers",
title = "Computation of Aliases and Support Sets",
crossref = "POPL87",
pages = {274--283},
}

@phdthesis{neir88,
author = "Anne Neirynck",
title = "Static Analysis of Aliasing and Side Effects in Higher-Order Languages",
school = Cornell,
year = 1988,
month = jan
}

@inproceedings{nels83,
title = "Verifying Reachability Invariants of Linked Structures",
author = "Greg Nelson",
pages = "38--47",
crossref = "POPL83",
doi = {10.1145/567067.567073}
}

@mastersthesis{nels89,
author = "Nelson, Jeffrey E.",
title = "Automatic, Incremental, On-The-Fly Garbage Collection of Actors",
year = 1989,
school = "Virginia Polytechnic Institute and State University"
}

@inproceedings{neth04,
author = {Nicholas Nethercote and Jeremy Fitzhardinge},
title = {Bounds-Checking Entire Programs without Recompiling},
crossref = {SPACE04},
}

@inproceedings{nett92,
title = "Replication-Based Incremental Copying Collection",
author = "Scott M. Nettles and James W. O'Toole and David Pierce and Nicholas Haines",
crossref = "IWMM92",
pages={357--364},
doi={10.1007/BFb0017201},
URL = "ftp://reports.adm.cs.cmu.edu/usr/anon/1993/CMU-CS-93-138.ps",
}

@techreport{nett92a,
author = "Nettles, Scott M.",
title = "A {L}arch Specification of Copying Garbage Collection",
institution = CMU,
year = 1992,
type = "Research paper",
number = "CMU-CS-92-219",
URL = "http://rose.mercury.acs.cmu.edu:1082/TR/CMU:CS-92-219",
month = Dec,
abstract = "Garbage collection (GC) is an important part of many
language implementations.  One of the most important garbage
collection techniques is copying GC.  This paper consists of an
informal but abstract description of copying collection, a formal
specification of copying collection written in the Larch Shared
Language and the Larch/C Interface Language, a simple
implementation of a copying collector written in C, an informal
proof that the implementation satisfies the specification, and a
discussion of how the specification applies to other types of
copying GC such as generational copying collectors.  Limited
familiarity with copying GC or Larch is needed to read the
specification."
}

@inproceedings{nett93,
  title =	 "Real-Time Replication-Based Garbage Collection",
  author =	 "Scott Nettles and James O'Toole",
  crossref =	 "PLDI93",
  pages =	 {217--226},
  doi =		 {10.1145/155090.155111},
  URL =		 "http://www.psrg.lcs.mit.edu/ftpdir/james/papers/pldi93.ps",
  comment =	 "Copying GC that permits continuous unimpeded mutator access
                  to the original object during copying. GC incrementally
                  replicates accessible objects and uses a mutation log to
                  bring replicas up-to-date"
}

@techreport{nett93b,
title = "Concurrent Garbage Collection of Persistent Heaps",
author = "Scott M. Nettles and James W. O'Toole and David Gifford",
number = "MIT/LCS/TR--569 and CMU--CS--93--137",
institution = CMU,
URL = "ftp://reports.adm.cs.cmu.edu/usr/anon/1993/CMU-CS-93-137.ps",
month = apr,
year = 1993,
note = "The same paper as \cite{otoo93a}"
}

@inproceedings{nett93c,
author = "Scott M. Nettles and James W. O'Toole",
title = "Implementing Orthogonal Persistence: A Simple Optimization Based on Replicating Collection",
crossref = "IWOOOS93",
}

@inproceedings{nett96,
title = {A Rollback Technique for Implementing Persistence by Reachability},
author = {Scott M. Nettles and James W. O'Toole},
crossref = "POS96"
}

@inproceedings{newe57,
author = "A. Newell and J. C. Shaw",
title = "Programming the Logic Theory Machine",
booktitle = "Western Joint Computing Conference",
pages = "230--240",
year = 1957
}

@article{newe60,
author = "A. Newell and F. M. Tonge",
title = "An Introduction to Information Processing Language {V}",
journal = CACM,
publisher = ACM,
volume = 3,
number = 4,
month = Apr,
pages = "205--211",
year = 1960,
comment = {
An early list processing language. IPL--V programmers were responsible for
returning list cells to the pool of free storage.  }
}

@article{newm82,
author = "I. A. Newman and R. P. Stallard and M. C. Woodward",
title = "Performance of Parallel Garbage Collection Algorithms",
journal = "Computer Studies",
volume = 166,
month = sep,
year = 1982
}

@inproceedings{newm82a,
author = "I. A. Newman and R. P. Stallard and M. C. Woodward",
title = "Alternative Approaches to Multiprocessor Garbage Collection",
booktitle = "International Conference on Parallel Processing",
pages = "205--210",
publisher = IEEE,
month = aug,
year = 1982,
comment = "Modification of Lamport's multiprocessor on-the-fly algorithm"
}

@inproceedings{newm83,
author = "I. A. Newman and R. P. Stallard and M. C. Woodward",
title = "Improved Multiprocessor Garbage Collection Algorithms",
booktitle = "International Conference on Parallel Processing",
pages = "367-368",
publisher = IEEE,
month = aug,
year = 1983,
comment = "Modification of Lamport's multiprocessor on-the-fly algorithm"
}

@inproceedings{newm84,
author = "I. A. Newman and R. P. Stallard and M. C. Woodward",
title = "A Parallel Compaction Algorithm for Multiprocessor Garbage
Collection",
booktitle = "Parallel Computing 83 Conference",
editor = "M. Feilmeier and J. Joubert and U. Schendel",
pages = "450--462",
year = 1984
}

@article{newm87,
title = "A Hybrid Multiple Processor Garbage Collection Algorithm",
author = "I. A. Newman and R. P. Stallard and M. C. Woodward",
address = "Loughborough University of Technology, Department of Computer Studies,
Loughborough LE11 3TU,  Leics,  England",
journal = CompJ,
publisher = BCS,
year = 1987,
volume = 30,
number = 2,
pages = "119--127",
abstract = {Dynamic storage allocation schemes continue to grow in popularity.
The problem of automatically reclaiming space that is no longer used is the
principal drawback of such memory management schemes.  This paper gives an
overview of existing algorithms and proposes a new combined approach that
overcomes some of the problems with previous algorithms.  Results are presented
for several algorithms executed on a four-processor system that suggest that
the proposed combined approach offers an improved performance when
executed on shared-memory multiprocessors.}
}

@inproceedings{ng87,
title = "Basic Memory Support for Functional Languages",
author = "Y. H. Ng and R. J. Glover",
booktitle = "4th International {IEEE} {VLSI} Multilevel Interconnection Conference",
address = {Santa Clara, CA},
month = jun,
publisher = IEEE,
pages = "35--40",
year = 1987,
abstract = {A symbolic associative processor (SAP) is described that is capable
of supporting complex dynamic data structures commonly found in functional
programming.  The overheads imposed by the need for garbage collection, which
are a limiting factor in conventional Von Neumann and random access memory
implementations, are minimized by the use of a modified content-addressable
memory.  The suitability of the proposed SAP for VLSI implementation is
discussed, and a test chip containing some SAP structures is described.}
}

@mastersthesis{ng96,
author = {T.C.T. Ng},
title = {Efficient Garbage Collection for Large Object-Oriented Databases},
school = MITLCS,
year = 1996
}

@inproceedings{nguy07,
title = {Detecting and Eliminating Memory Leaks Using Cyclic memory Allocation},
author = {Huu Hai Nguyen and Martin Rinard},
pages = {15--30},
crossref = {ISMM07},
doi = {10.1145/1296907.1296912},
URL = {http://cag.csail.mit.edu/~rinard/paper/ismm07.ps}
}

@inproceedings{nguy07a,
author = {N. Nguyen and A. Dominguez and R. Barua},
title = {Scratch-pad Memory Allocation without Compiler Support for {J}ava
Applications},
booktitle = {International Conference on Compilers, Architecture and Synthesis
for Embedded Systems (CASES)},
year = 2007
}

@inproceedings{ni07,
author = {Yang Ni and Vijay Menon and Ali-Reza Adl-Tabatabai and Antony L. Hosking and
          Richard L. Hudson and J. Eliot B. Moss and Bratin Saha and Tatiana Shpeisman},
title = {Open Nesting in Software Transactional Memory},
crossref = {PPoPP07},
pages = {68-78},
doi = {10.1145/1229428.1229442}
}

@article{niel77,
author = "Norman R. Nielsen",
title = "Dynamic Memory Allocation in Computer Simulation",
journal = cacm,
publisher = ACM,
year = 1977,
volume = 20,
number = 11,
month = nov,
pages = {864--873}
}

@inproceedings{nikh00,
author = {R.S. Nikhil and U. Ramachandran},
title = {Garbage Collection of Timestamped Data in {S}tampede},
booktitle = {19th Annual Symposium on Principles of Distributed Computing (PODC)},
month = jul,
year = 2000
}


@techreport{nils87,
author = "Nilsen, Kelvin D.",
title = "Real-Time Garbage Collection of Strings and Linked Data Structures",
institution = "University of Arizona, Department of Computer Science",
year = 1987,
month = Jan,
number = "TR 87-5"
}

@article{nils88,
title = "Garbage Collection of Strings and Linked Data-Structures in Real-Time",
author = "Kelvin D. Nilsen",
institution = "Univ Arizona, Department of Computer Science, Tucson, AZ, 85721",
journal = SPE,
publisher = Wiley,
year = 1988,
volume = 18,
number = 7,
pages = "613--640",
comment = {Variant of Baker's algorithm, with lazy copying.
This paper describes the addition of certain information to a
string descriptor and enhancements to existing copying garbage collection
algorithms that permit linked data structures and strings to be allocated
and garbage collected from a shared region of memory in real time.  This
algorithm is real-time in the sense that the time required for allocation
of each basic unit of memory is bounded by a constant.
An analysis of performance is
reported, and comparisons are made with traditional garbage collection.}
}

@inproceedings{nils90,
author = "Kelvin D. Nilsen and William J. Schmidt",
title = "Hardware Support for Garbage Collection of Linked Objects and Arrays in Real-Time",
crossref = "OOPSLA90-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/nilsen.ps"
}

@techreport{nils90a,
author = "Nilsen, Kelvin D. and  Schmidt, William J.",
title = "A High-Level Overview of Hardware Assisted Real-Time Garbage Collection",
institution = "Iowa State University, Department of Computer Science",
year = 1990,
number = "TR90-18a",
month = Oct,
abstract = "The costs of executing traditional garbage collection
algorithms most generally include not only the costs of
allocating and reclaiming memory, but also the overhead costs
imposed by the garbage collection system on standard memory read
and write operations.  This paper  outlines the design of a
general purpose garbage collection system that uses specialized
hardware to allow standard memory access and modification
operations to perform nearly as well as traditional memory.
Allocation and  garbage collection are as efficient as more
traditional stop-and-wait garbage collection systems.  The cost
of the specialized hardware is relatively small in comparison to
the cost of the memory it manages.
The specialized hardware is located entirely within an
intelligent memory module whose interface to the system bus is
identical to  traditional memory.  This paper describes the data
types supported by the general purpose garbage collection
algorithm and outlines the hardware organization of the proposed
architecture."
}

@inproceedings{nils91,
author = "Kelvin D. Nilsen",
title = "A High-Performance Architecture for Real-Time Garbage Collection ",
crossref = "OOPSLA91-gc",
}

@techreport{nils92,
author = "Nilsen, Kelvin D. and  Schmidt, William J.",
title = "Hardware-Assisted General-Purpose Garbage Collection for
Hard Real-Time Systems",
institution = "Iowa State University, Department of Computer Science",
year = 1992,
number = "ISU TR92-15",
month = oct,
URL = "http://www.cs.iastate.edu/tech-reports/TR92-15.ps"
}

@techreport{nils92a,
author = "Nilsen, Kelvin D. and  Schmidt, William J.",
title = "Preferred Embodiment of a Hardware-Assisted Garbage Collection System",
institution = "Iowa State University, Department of Computer Science",
year = 1992,
number = "ISU TR92-17",
month = nov,
URL = "http://www.cs.iastate.edu/tech-reports/TR92-17a.ps"
}

@techreport{nils92b,
author = "Kelvin D. Nilsen",
title = "Memory Cycle Accountings for Hardware-Assisted Real-Time Garbage Collection",
institution = "Iowa State University",
number = "91-21(c)",
address = "Computer Science Department",
year = 1992,
URL = "http://www.cs.iastate.edu/tech-reports/TR91-21c.ps"
}

@article{nils92c,
title = "Cost-Effective Object-Space Management for Hardware-Assisted
Real-Time Garbage Collection",
author = "Nilsen, Kelvin D. and  Schmidt, William J.",
journal = "Letters on Programming Language and Systems",
publisher = ACM,
volume = 1,
number = 4,
pages = "338--354",
month = dec,
year = 1992,
URL = {http://www.newmonics.com/webroot/technologies/gc/loplas.ps}
}

@inproceedings{nils93,
author = "Kelvin D. Nilsen",
title = "Reliable Real-Time Garbage Collection of {C++}",
crossref = "OOPSLA93-gc",
}

@article{nils93a,
title = "Cost-Effective Object-Space Management for Hardware-Assisted Real-Time Garbage Collection",
author = "Kelvin D. Nilsen and William J. Schmidt",
journal = "Letters on Programming Languages and Systems",
publisher = ACM,
year = 1993,
volume = 1,
number = 4,
pages = "338--354",
month = dec
}

@inproceedings{nils94,
  title =	 "Cost-Effective Hardware-Assisted Real-Time Garbage
                  Collection",
  author =	 "Kelvin D. Nilsen",
  crossref =	 {LCTES94},
  URL =		 "ftp://ftp.cs.iastate.edu:/pub/kelvin",
  abstract =	 {Hardware-assisted real-time garbage collection offers more
                  reliable operation and higher performance than software-only
                  real-time garbage collection systems. Completed simulation
                  studies have analyzed the behavior of a hardware-assisted
                  garbage collection system tuned primarily to achieve high
                  throughput. Based on these studies, we conclude that system
                  designers can trade small amounts of performance loss for
                  significant cost reductions. This paper provides an overview
                  of an alternative design for hardware-assisted real-time
                  garbage collection that has been configured with the primary
                  goal of maximizing performance per unit cost. Work is under
                  way to build and analyze a hardware prototype.}
}

@article{nils94a,
title = "A High-Performance Hardware-Assisted Real Time Garbage Collection System",
author = "Kelvin D. Nilsen and William J. Schmidt",
journal = "Journal of Programming Languages",
year = 1994,
volume = 2,
number = 1,
URL = "ftp://ftp.cs.iastate.edu:/pub/kelvin"
}

@article{nils94b,
title = "Reliable Real-Time Garbage Collection of {C++}",
author = "Kelvin D. Nilsen",
journal = "Computing Systems",
year = 1994,
volume = 7,
number = 4,
URL = "ftp://ftp.cs.iastate.edu:/pub/kelvin",
abstract = {Garbage collection of C++ offers the potential of improving
programmer productivity, reducing the occurrence of dynamic memory
management errors in both prototype and production software, and
increasing the levelof abstraction provided by many reusable software
components. The hardware-assisted real-time garbage collection system
described in this paper offers the additional benefits of providing
more predictable memory utilization and response times than are
available from traditional dynamic memory management techniques for
C++. This paper describes a C++ dialect that allows real-time garbage
collection of heap-allocated objects in a manner that is compatible
with traditional real-time development methodologies. This paper also
provides a brief overview of established methodologies for development
of reliable real-time software, with emphasis on issues that are
relevant to garbage collection, and summarizes the shortcomings of
existing real-time garbage collection techniques.}
}

@inproceedings{nils95,
title = "Progress in Hardware-Assisted Real-Time Garbage Collection",
author = "Kelvin Nilsen",
crossref = "IWMM95",
pages = {355-379},
doi = {10.1007/3-540-60368-9_34},
abstract = {Hardware-assisted real-time garbage collection offers more
reliable operation and higher
performance than software-only real-time garbage collection
systems. Completed simulation studies have analyzed the behavior
of a hardware-assisted garbage collection system tuned primarily
to achieve high throughput. Based on these studies, we conclude
that system designers can trade small amounts of performance
loss for significant cost reductions. This paper provides an
overview of an alternative design for hardware-assisted
real-time garbage collection that has been configured with the
primary goal of maximizing performance per unit cost. Improved
functionality is achieved by providing support for a variety of
garbage collection algorithms, including fully copying,
incremental mark and sweep, mostly stationary, and generational
techniques. }
}

@inproceedings{nils95a,
author = "Kelvin Nilsen and H. Gao",
title = "The Real-Time Behaviour of Dynamic Memory Management in {C++}",
booktitle = "IEEE Real-Time Technologies and Applications Symposium",
publisher = IEEE,
address = "Chicago",
pages = "142--153",
month = may,
year = 1995,
URL = {http://www.newmonics.com/webroot/technologies/gc/rtas.ps},
abstract = {Dynamic memory management is an important aspect of modern
software engineering techniques based on object-oriented methodologies.
Additionally, dynamic management of memory serves important roles in
improving the flexibility and functionality of large software systems.
However, developers of current real-time systems avoid the use of
dynamic memory because they fear that the worst-case time and space
requirements of typical memory managers are insufficiently bounded. The
degree to which these concerns are valid is quantified by detailed
measurements of several real-world workloads. A special
hardware-assisted real-time garbage collection system has been designed
to facilitate reliable use of dynamic memory in hard-real-time systems.
By analyzing the dynamic memory use of application software, the
real-time developer can prove compliance with time and space
constraints.  Analysis techniques are presented and the real-time
performance of the hardware-assisted garbage collection system are
compared to that of the traditional allocators.}
}

@inproceedings{nils95b,
author = "Kelvin Nilsen",
title = {High-Level Dynamic Memory Management for Object Oriented Real-Time Systems},
booktitle = {Workshop on Object-Oriented Real-Time Systems},
address = {San Antonio, Tx.},
month = oct,
year = 1995,
URL = {http://www.newmonics.com/webroot/technologies/gc/oops.ps},
abstract = {On-the-fly memory allocation and deallocation is required
for the cost-effective implementation of systems with workloads that
vary over time and for systems that deal with problems of unpredictable
size or complexity. Furthermore, many of the easily programmed data
structures that are most efficient for data access and manipulation are
constructed from large numbers of independently allocated memory
objects. But dynamic memory management in real-time systems is
difficult because most traditional allocation and deallocation
algorithms are unpredictable in terms of their worst-case memory
utilization and execution times. This paper describes recent work on a
new memory management system designed specifically to support
hard-real-time allocation, automatic garbage collection, and
defragmentation of the free pool. The memory management system, which
consists of special hardware circuits placed between the CPU's
level-two caches and its memory subsystem, offers worst-case allocation
delays of two microseconds and typical memory utilizations that exceed
binary-buddy allocators by over 30\%. Commercial implementations of this
technology are currently under development.}
}

@article{nils96,
title = {Issues in the Design and Implementation of Real-Time {J}ava},
author = "Kelvin Nilsen",
journal = {Java Developer's Journal},
month = jun,
year = 1996,
volume = 1,
number = 1,
pages = 44,
URL = {http://www.sys-con.com/java/iss1/real.htm}
}

@article{nils96a,
title = {Starting to {PERC}},
author = "Kelvin Nilsen",
journal = {Java Developer's Journal},
month = jul,
year = 1996,
volume = 1,
number = 2,
pages = 11,
URL = {http://www.sys-con.com/java/iss2/perc.htm}
}

@article{nils96b,
title = {Invited Note: {J}ava for Real-Time},
author = "Kelvin Nilsen",
journal = {Real-Time Systems Journal},
month = sep,
year = 1996,
pages = {197--205},
URL = {http://www.newmonics.com/WebRoot/technologies/java.html#rtsj}
}

@article{nils98,
author = "Kelvin Nilsen",
title = {Adding Real-Time Capabilities to the {J}ava Programming Language},
journal = CACM,
publisher = ACM,
year = 1998,
note = {To appear},
comment = {NewMonics Inc real-time Java}
}

@techreport{nils09,
author = "Kelvin Nilsen",
title = {Differentiating Features of the {PERC} Virtual Machine},
type = {White Paper},
institution = {Aonix},
URL = {http://www.aonix.com/pdf/PERCWhitePaper_e.pdf},
year = 2009
}

@article{ning06,
  title =	 {Minimizing {GC} Work by Analysis of Live Objects},
  author =	 {Zhang Ning and Guangze Xiong},
  journal =	 SIGPLAN,
  volume =	 41,
  number =	 3,
  month =	 mar,
  year =	 2006,
  pages =	 {20--29},
  doi = {10.1145/1140543.1140548}
}

@inproceedings{nish98,
author = {Gor Nishanov and Sibylle Schupp},
title = {Garbage Collection in Generic Libraries},
pages = {86--96},
crossref = {ISMM98},
abstract = {This paper demonstrates a unified and garbage-collector independent
way to describe the information required for precise collection.
Thereby it is possible to construct a library that can be used with
different mostly-copying collectors, without modifying the code of the
library or the garbage collector. The library design presented applies
the adaptor idiom of generic programming which guarantees that no
overhead, in time or space, incurs if the library is used with manual
allocators or with garbage collectors that do not require programmer
cooperation. We illustrate the approach with adaptors to Bartlett's and
to the CMM primary collector. We also show that the Standard
Template Library (STL) can be easily modified to become
garbage-collector aware. }
}

@techreport{nish98a,
author = {Gor Nishanov and Sibylle Schupp},
title = {Design and Implementation of the fgc Garbage Collector},
number = {98--7},
institution = {Rensselaer Polytechnic Institute, NY},
year = 1998,
note = {Extended version (1 December 1999) available},
URL = {http://www.cs.rpi.edu/research/gpg/fgc.html}
}

@techreport{nish88,
author = "Nishida, Kenji and Kimura, Yasunori and Matsumoto, A.",
title = "Evaluation of the Effect of Incremental Garbage Collection by
{MRB} on {FGHC} Parallel Execution Performance",
institution = "Institute for New Generation Computer Technology",
year = 1988,
type = "ICOT technical report",
number = "TR-394",
month = Jun,
abstract = "The reduction of bus traffic is the key issue to
improve the performance of shared memory multiprocessors based on
coherent cache mechanism.  Committed choice logic programming
lanagues, such as Flat GHC (FGHC), consume memory area very
rapidly, and require large storage size.  Such large storage size
requirement affects the total system performance not only by
frequent global GC, but also by increasing bus traffic especially
for memory allocation.  Incremental GC reduces the bus traffic
for memory allocation by decreasing the required storage size.
It also reduces other bus traffic by decreasing cache misses,
since the locality of memory references can be enhanced by
reclamation and reuse of memory cells.
Therefore, incremental GC is the key issue to improve the total
system performance of committed choice logic programming
language.  Incremental GC by Multiple Reference Bit (MRB-GC) has
been proposed as an efficient incremental GC scheme for FGHC.
The required staorge size is reduced to 30 percent by MRB-GC.  The
overheads of incremental GC, such as extra memory references for
management of reference count, is reduced not to affect the
performance of FGHC execution.  The paper evaluates the effect of
MRB-GC on the bus traffic of FGHC execution on the shared memory
multiprocessor.
The evaluation result shows that memory-cache traffic is reduced
more than expected from decrement of the required storage size.
Yet the problem on the increase of cache-cache traffic by mutual
invalidation of cache blocks is revealed."
}

@inproceedings{nish88a,
author = "Nishida, Kenji and Kimura, Yasunori and Matsumoto, A. and A. Goto",
title = "Evaluation of {MRB} Garbage Collection on Parallel Logic
Programming Architectures",
booktitle = "7th International Conference on Logic Programming, Jerusalem",
pages = "83--95",
publisher = MIT,
month = jun,
year = 1988
}

@inproceedings{nish06,
title = {Verifying Data-Parallel Programs with Separation Logic},
author = {Susumu Nishimura},
pages = {101--104},
crossref = {SPACE06}
}

@article{nitz91,
author = {B. Nitzberg and V. Lo},
title = {Distributed Shared Memory: A Survey of Issues and Algorithms},
journal = {IEEE Computer},
pages = {52--60},
year = 1991
}

@inproceedings{niwa86,
title = "Garbage Collector with Area Optimization for {FACOM} {ALPHA}.",
author = "M. Niwa and M. Yuhara and K. Hayashi and A. Hattori",
booktitle = "{COMPCON} Spring 86: 31st {IEEE} Computer Society
International Conference. {S}an {F}rancisco, 1986 {M}arch 3--6",
publisher = IEEE,
year = 1986,
abstract = {The FACOM ALPHA is a high-speed list processing machine that can
execute LISP and PROLOG programs.  It is a back-end processor connected to
a Fujitsu M series mainframe computer or S series superminicomputer.  The
garbage collector and memory management of the FACOM ALPHA are discussed.  A
feature of the FACOM ALPHA garbage collector is that the sizes of the memory
areas for different types of data are dynamically adjusted to optimize the
configuration
for each user program.  The algorithm used by this memory size adjustment
function is presented and its effectiveness is evaluated.  Measurements
indicate that the algorithm reduces the number of garbage collection calls
while improving memory-use efficiency.}
}

@book{nobl00,
title = {Small Memory Software: Patterns for Systems with Limited Memory},
author = {James Noble and Charles Weir and Duane Bibby},
publisher = AW,
year = 2000,
ISBN = {201596075},
pages = 288
}

@inproceedings{norc03,
author = {Norcross, Stuart and Morrison, Ron and Munro, David S. and Detmold, Henry},
title = {Implementing a Family of Distributed Garbage Collectors},
booktitle = {Australasian Computer Science Conference, (ACSC)},
address = {Adelaide},
month = jan,
year = 2003,
pages = {161--170}
}

@phdthesis{norc03a,
author = {Norcross, Stuart},
title = {Deriving Distributed Garbage Collectors for Distributed Termination
Algorithms},
school = {St Andrews University},
year = 2003
}

@mastersthesis{nori79,
title = "A Storage Reclamation System for an Applicative Multiprocessor System",
author = "A. K. Nori",
school = "University of Utah",
address = "Salt Lake City, Utah",
year = 1979
}

@inproceedings{nort87,
author = "S. C. North and John H. Reppy",
title = "Concurrent Garbage Collection on Stock Hardware",
crossref = "FPCA87",
pages = "113--133",
abstract = "the design and implementation of a memory
management system for Pegasus, a system that supports the
implementation of programming environments and other interactive applications
on single-user workstations.
Variation of (broo84), itself a variation of Baker."
}

@techreport{nova06,
title = {Custom Object Layout for Garbage-Collected Languages},
author = {Gene Novark and Trevor Strohman and Emery D. Berger},
institution = UMass,
URL = {http://www.cs.umass.edu/~emery/pubs/06-06.pdf},
type = {},
year = 2006,
abstract = {Modern architectures require data locality to achieve
performance. However, garbage-collected languages like Java limit the
ability of programmers to influence object locality, and so impose a
significant performance penalty. We present custom object layout, an
approach that allows programmers to control object layout in
garbage-collected languages. Custom object layout cooperates with
copying garbage collection. At collection time, the garbage collector
invokes programmer-supplied methods that direct object
placement. Custom object layout is particularly effective at improving
the locality of classes with well-known traversal patterns, such as
dictionary data structures. We show that using custom object layout
can reduce cache misses by 50\%-77\% and thus improves the query
performance of dictionary data structures by 20\%.},
note = {New England Programming Languages and Systems Symposium, March, 2006}
}

@inproceedings{nova09,
  title =	 {Efficiently and Precisely Locating Memory Leaks and Bloat},
  author =	 {Gene Novark and Emery Berger and Benjamin Zorn},
  crossref =	 {PLDI09}
}

@techreport{nuth87,
author = "Peter R. Nuth",
title = "Communication Patterns in a Symbolic Multiprocessor",
institution = MITLCS,
number = "MIT/LCS/TR--395",
month = jun,
year = 1987
}

@article{nuth89,
author = "Peter R. Nuth and Robert H. Halstead",
title = "A Study of {LISP} on a Multiprocessor (Preliminary Version)",
journal = "Lisp Pointers",
publisher = ACM,
volume = 2,
number = "3--4",
pages = "15--32",
year = 1989
}

@inproceedings{oanc09,
title = {A New Approach to Parallelising Tracing Algorithms},
author = {Cosmin E. Oancea and Alan Mycroft and Stephen M. Watt},
pages = {10--19},
doi = {10.1145/1542431.1542434},
crossref = {ISMM09}
}

@book{occa88,
title = "The occam 2 Reference Manual",
author = "inmos",
publisher = PH,
year = 1988
}

@inproceedings{odei10,
title = {Efficient Runtime Tracking of Allocation Sites in {J}ava},
author = {Rei Odaira and Kazunori Ogata and Kiyokuni Kawachiya and Tamiya
Onodera and Toshio Nakatani},
crossref = {VEE10},
pages = {109--120},
doi = {10.1145/1735997.1736014}, 
abstract = {Tracking the allocation site of every object at runtime is useful
for reliable, optimized Java. To be used in production environments, the
tracking must be accurate with minimal speed loss. Previous approaches suffer
from performance degradation due to the additional field added to each object or
track the allocation sites only probabilistically. We propose two novel
approaches to track the allocation sites of every object in Java with only a
1.0\% slow-down on average. Our first approach, the
Allocation-Site-as-a-Hash-code (ASH) Tracker, encodes the allocation site ID of
an object into the hash code field of its header by regarding the ID as part of
the hash code. ASH Tracker avoids an excessive increase in hash code collisions
by dynamically shrinking the bit-length of the ID as more and more objects are
allocated at that site. For those Java VMs without the hash code field, our
second approach, the Allocation-Site-via-a-Class-pointer (ASC) Tracker, makes
the class pointer field in an object header refer to the allocation site
structure of the object, which in turn points to the actual class structure. ASC
Tracker mitigates the indirection overhead by constant-class-field duplication
and allocation-site equality checks. While a previous approach of adding a
4-byte field caused up to 14.4\% and an average 5\% slowdown, both ASH and ASC
Trackers incur at most a 2.0\% and an average 1.0\% loss. We demonstrate the
usefulness of our low-overhead trackers by an allocation-site-aware memory leak
detector and allocation-site-based pretenuring in generational GC. Our
pretenuring achieved on average 1.8\% and up to 11.8\% speedups in SPECjvm2008.}
}

@phdthesis{ofar92,
author = "O'Farrell, William Gerald",
title = "Garbage Collection Algorithms for the Connection Machine",
year = 1991,
school = "Syracuse University"
}

@inproceedings{ogas09,
author = {Takeshi Ogasawara},
title = {{NUMA}-Aware Memory Manager with Dominant-Thread-Based Copying {GC}},
pages = {377--390},
crossref = {OOPSLA09},
doi = {10.1145/1640089.1640117}
}

@inproceedings{ogat10,
author = {Ogata, Kazunori and Mikurube, Dai and Kawachiya, Kiyokuni and Trent, Scott and Onodera, Tamiya},
title = {A Study of Java's Non-Java Memory},
crossref = {OOPSLA10},
pages = {191--204},
doi = {10.1145/1869459.1869477},
abstract = {A Java application sometimes raises an out-of-memory exception.
This is usually because it has exhausted the Java heap. However, a Java
application can raise an out-of-memory exception when it exhausts the memory
used by Java that is not in the Java heap. We call this area non-Java memory.
For example, an out-of-memory exception in the non-Java memory can happen when
the JVM attempts to load too many classes. Although it is relatively rare to
exhaust the non-Java memory compared to exhausting the Java heap, a Java
application can consume a considerable amount of non-Java memory.
This paper presents a quantitative analysis of non-Java memory. To the best of
our knowledge, this is the first in-depth analysis of the non-Java memory. To do
this we created a tool called Memory Analyzer for Redundant, Unused, and String
Areas (MARUSA), which gathers memory statistics from both the OS and the Java
virtual machine, break-ing down and visualizing the non-Java memory usage.
We studied the use of non-Java memory for a wide range of Java applications,
including the DaCapo benchmarks and Apache DayTrader. Our study is based on the
IBM J9 Java Virtual Machine for Linux. Although some of our results may be
specific to this combination, we believe that most of our observations are
applicable to other platforms as well.}
}

@article{ogur89,
author = "Ogura, Takeshi and Yamada, Junzo and Yamada, Shin-Ichiro and Tan-No, Masa-Aki",
address = "NTT LSI Lab, Atsugi, Japan",
title = "20-kbit Associative Memory {LSI} for Artificial Intelligence Machines",
year = 1989,
journal = "IEEE Journal of Solid-State Circuits",
publisher = IEEE,
volume = 24,
number = 4,
month = aug,
abstract = {A 20-kb (512 words multiplied by 40 b) CMOS associative-
memory LSI is described. This LSI performs large-scale
parallelism for highly efficient associative operations in
artificial intelligence machines. Relational search, large-
bit-length data treatment, and quick garbage collection are
realized on the single-chip associative-memory LSI. A cell
array structure has been designed in order to reduce the
chip area. A newly designed simple accelerator circuit
allows for high-speed search operations. The LSI is
fabricated using 1.2- mu m double-aluminum-layer CMOS
process technology. 284,000 devices have been integrated on
a 5.3 multiplied by 7.9-mm**2 chip. The measured minimum
cycle time and power dissipation at 10-MHz operation are 85
ns and 250 mW, respectively. The associative memory, with
its highly efficient associative operation capabilities,
promises to be a large step toward the development of high-
performance artificial intelligence machines. }
}

@inproceedings{oiwa09,
title = {Implementation of the Memory-Safe Full {ANSI-C} Compiler},
author = {Yutaka Oiwa},
pages = {259--269},
doi = {10.1145/1542476.1542505},
crossref = {PLDI09}
}

@article{olde85,
author = "Rod R. Oldehoeft and S. J. Allan",
title = "Adaptive Exact-Fit Storage Management",
journal = CACM,
publisher = ACM,
volume = 28,
number = 5,
pages = "506-511",
month = may,
year = 1985
}

@inproceedings{olde92,
author = {William J. Older and John A. Rummell},
title = {An Incremental Garbage Collector for {WAM}-Based {P}rolog},
booktitle = ICLP,
address = {Washington, DC},
pages = {369--383},
year = 1992
}


@manual{OMG97,
organization = {Object Management Group},
key = {OMG},
title = {Garbage Collection of {CORBA} Objects},
note = {Draft {RFP}},
year = 1997,
URL = {http://www.omg.org/docs/orbos/orbos/1997/97-08-08.pdf}
}

@manual{omoh91,
title = "The {S}ather Language",
author = "Stephen M. Omohundro",
organization = "ICSI, Berkeley",
year = 1991,
comment = "Sather is an object oriented language designed to be simple,
     efficient, safe, and non-proprietary. It was originally
     envisioned as a ``cleaned-up'' version of Eiffel, addressing
     perceived failures in simplicity and efficiency. The first public
     implementation (Sather 0) was first released to the public by ICSI
     in 1991. Shortly after, a compiler group at the University of
     Karlsruhe created the first native code compiler.

     A major effort then began to redesign the language to correct shortcomings
     in Sather 0 and to make Sather suitable for
     general-purpose, large scale programming. In part because each compiler
     group was building a compiler for a moving
     design target, the two parallel efforts resulted in two dialects, Sather 1
      and Sather K. This report analyzes the essential
     causes of the differences, which result from differences in each group's
     goals. <http://www.icsi.berkeley.edu/~davids/tr-96-037.ps.gz>"
}

@article{onod93,
title = "A Generational and Conservative Copying Collector for Hybrid Object-oriented Languages",
author = "Tamiya Onodera",
institution = "IBM Tokyo Research Laboratory",
journal = SPE,
publisher = Wiley,
volume = 23,
number = 10,
pages = "1077--1093",
month = oct,
year = 1993
}

@phdthesis{oper89,
title = "Optimization and Garbage Collection in {A}da Programs on Shared
Memory Computers",
author = "H. L. Operowsky",
school = "New York Academy of Sciences",
address = "New York",
year = "1989",
other = "UMI order no:  GAX89-16082"
}

@manual{optimizeit,
title = "OptimizeIt",
key = "OptimizeIt",
organization = {Borland},
note = {http://www.optimizeit.com},
URL = {http://www.optimizeit.com},
comment = {Profiling and debugging tools for {J}ava (formerly published by VMGEAR)}
}

@techreport{orac08,
title = {Mission-Critical {J}ava},
key = {Oracle Corporation},
institution = {Oracle Corporation},
type = {Oracle White Paper},
month = oct,
year = 2008,
URL = {http://www.oracle.com/appserver/docs/mission-critical-java-whitepaper.pdf},
note = {Describes Oracle JRockit Real Time}
}

@book{orga83,
title = "A Programmer's View of the {I}ntel 432 System",
author = "E. I. Organick",
publisher = MGH,
year = 1983,
pages = "418",
isbn = "0--07--047719--1",
abstract = {Chapter 9 describes the extensive memory
management facilities of iMAX and the supporting hardware. These include
facilities to support the stack and heap memory resources required, for
example, by executing ADA programs. In addition, memory management supports
an on-the-fly garbage collector, dynamic memory compaction, and, where
configured, a virtual memory management subsystem.
Almost all references are numbered wrongly; the reference numbers should
be increased by a number from 0 to 4.
Sometimes the text looks like a eulogy of Intel.
It is difficult to discern whether the description of
the design of the Intel 432 system coincides with reality; it could be
viewed also as a subsequent interpretation by the author.
As mentioned above, the chapters on ADA consume too much space.
The book is written in a lucid manner. It should be of interest to
different clienteles: designers of operating systems, designers of
programming languages, computer architects, and programmers; they all
could learn more about the dependencies between programming languages and
computer systems.}
}

@inproceedings{orlo06,
title = {Memory Leak Analysis by Contradiction},
author = {M. Orlovich and R. Rugina},
booktitle = {International Static Analysis Symposium (SAS)},
address = {Seoul, South Korea},
month = aug,
year = 2006,
url = {http://www.cs.cornell.edu/~rugina/papers/sas06.pdf}
}

@inproceedings{ossi02,
  title =	 {A Parallel, Incremental and Concurrent {GC} for Servers},
  author =	 {Yoav Ossia and Ori Ben-Yitzhak and Irit Goft and Elliot
                  K. Kolodner and Victor Leikehman and Avi Owshanko},
  crossref =	 {PLDI02},
  pages =	 {129--140},
  doi =		 {10.1145/512529.512546},
  abstract =	 {Multithreaded applications with multi-gigabyte heaps running
                  on modern servers provide new challenges for garbage
                  collection (GC).  The challenges for "server-oriented" GC
                  include: ensuring short pause times on a multi-gigabyte
                  heap, while minimizing throughput penalty, good scaling on
                  multiprocessor hardware, and keeping the number of expensive
                  multi-cycle fence instructions required by weak-ordering to
                  a minimum. We designed and implemented a fully parallel,
                  incremental, mostly concurrent collector, which employs
                  several novel techniques to meet these challenges. First, it
                  combines incremental GC to ensure short pause times with
                  concurent low-priority background GC threads to take
                  advantage of processor idle time. Second, it employs a
                  low-overhead work packet mechanism to enable full
                  parallelism among the incremental and concurrent collecting
                  threads and ensure load balancing. Third, it reduces memory
                  fence instructions by using batching techniques: one fence
                  for each block of small objects allocated, one fence for
                  each group of objects marked, and no fence at all in the
                  write barrier. When compared to the mature well-optimized
                  parallel stop-the-world mark-sweep collector already in the
                  IBM Jvm, our collector prototype reduces the maximum pause
                  time from 284 ms to 101 ms, and the average pause time from
                  266 ms to 66 ms while only losing 10\% throughput when
                  running the SPECjbb2000 benchmark on a 256 MB heap on a
                  4-way 550 MHz Pentium multiprocessor.}
}

@inproceedings{ossi04,
title = {Mostly Concurrent Compaction for Mark-Sweep {GC}},
author = {Yoav Ossia and Ori Ben-Yitzhak and Marc Segal},
pages = {25--36},
crossref = {ISMM04},
doi={10.1145/1029873.1029877}
}

@inproceedings{oste12,
title = {Analysis of Pure Methods using Garbage Collection},
author = {Erik \"{O}sterlund and Welf L\"{o}we},
crossref = {MSPC12},
 doi = {10.1145/2247684.2247694},
 pages = {48--57},
abstract = {Parallelization and other optimizations often depend on static
dependence analysis. This approach requires methods to be independent regardless
of the input data, which is not always the case.
Our contribution is a dynamic analysis "guessing" if methods are pure, i.e., if
they do not change state. The analysis is piggybacking on a garbage collector,
more specifically, a concurrent, replicating garbage collector. It guesses
whether objects are immutable by looking at actual mutations observed by the
garbage collector. The analysis is essentially for free. In fact, our concurrent
garbage collector including analysis outperforms Boehm's stop-the-world
collector (without any analysis), as we show in experiments. Moreover, false
guesses can be rolled back efficiently.
The results can be used for just-in-time parallelization allowing an automatic
parallelization of methods that are pure over certain periods of time. Hence,
compared to parallelization based on static dependence analysis, more programs
potentially benefit from parallelization.}
}

@misc{otoo90,
author = "James W. O'Toole",
title = "Garbage Collecting Locally",
note = "Area Exam, Department of Electrical Engineering and Computer Science, MIT",
month = dec,
year = 1990,
URL = "http://www.psrg.lcs.mit.edu/ftpdir/james/papers/RevisedGcl.txt"
}

@techreport{otoo93,
title = "Concurrent Replicating Garbage Collection",
author = "James W. O'Toole and Scott M. Nettles",
type = "Technical Report",
number = "MIT--LCS--TR--570 and CMU--CS--93--138",
institution = "MIT and CMU",
year = 1993,
URL = "ftp://reports.adm.cs.cmu.edu/usr/anon/1993/CMU-CS-93-138.ps",
note = "Also LFP94 and OOPSLA93 Workshop on Memory Management and Garbage Collection",
}

@inproceedings{otoo93a,
  title =	 "Concurrent Compacting Garbage Collection of a Persistent
                  Heap",
  author =	 "James W. O'Toole and Scott M. Nettles and David Gifford",
  crossref =	 "SOSP93",
  pages =	 "161--174",
  doi =		 {10.1145/168619.168632},
  URL =		 "http://www-psrg.lcs.mit.edu/ftpdir/pub/james/sosp93.ps",
  note =	 "Also MIT/CMU Technical report MIT--LCS--TR--569. The same
                  paper as \cite{nett93b}",
  comment =	 "Client threads read and write the heap in primary memory and
                  can independently commit or abort writes; when committed
                  they are preserved in stable storage. Clients can freely
                  access the heap during GC because a replica is created."
}

@techreport{otoo93b,
title = "Real-Time Replication {GC}: An Implementation Report",
author = "James W. O'Toole and Scott M. Nettles",
number = "MIT--LCS--TR--568 and CMU--CS--93--136",
institution = "MIT and CMU",
year = 1993,
note = "WWW page says this is unpublished."
}

@techreport{otoo93c,
title = "Garbage Collecting an Object Cache",
author = "James W. O'Toole",
number = "MIT/LCS/TM--485",
institution = MIT,
URL = "http://www.psrg.lcs.mit.edu/ftpdir/james/papers/replgc-cache.txt",
month = apr,
year = 1993,
}

@misc{ovm,
key = {Ovm},
title = {The {O}vm Virtual machine},
institution = Purdue,
URL = {http://www.ovmj.net}
}

@article{owic76,
author = "Susan Owicki and David Gries",
title = "Verifying Properties of Parallel Programs: An Axiomatic Approach",
journal = CACM,
publisher = ACM,
volume = 19,
number = 5,
month = May,
year = 1976,
pages = "279--285",
abstract = {An axiomatic method for proving a number of properties
of parallel programs is presented. Hoare has given a set of axioms for
partial correctness, but they are not strong enough in most cases.
This paper defines a more powerful deductive system which is in some
sense complete for partial correctness. A crucial axiom provides
for the use of auxiliary variables, which are added to a parallel
program as an aid to proving it correct.
The information in a partial correctness proof can be used to prove
such properties as mutual exclusion, freedom from deadlock, and
program termination.
Techniques for verifying these properties are presented and illustrated
by application to the dining philosophers problem.},
comment = {Used in \cite{grie77} to prove the correctness of the on-the-fly algotithm in \cite{dijk76b}}
}

@inproceedings{owic81,
title = "Making the World Safe for Garbage Collection",
author = "Susan Owicki",
crossref = "POPL81",
pages = "77--86",
}

@article{owic82,
title = "Proving Liveness Properties of Concurrent Programs",
author = "Susan Owicki and Leslie Lamport",
pages = "455--495",
journal = TOPLAS,
publisher = ACM,
year = 1982,
month = jul,
volume = 4,
number = 3,
comment = {see \cite{rame83}},
}

@techreport{ozaw89,
author = "Ozawa, Toshihiro and Hosoi, Akira and Hattori, Akira.",
title = "Generation Type Garbage Collection for Parallel Logic Languages",
institution = "Institute for New Generation Computer Technology",
year = 1989,
type = "ICOT technical report",
number = "TR-512",
month = Oct,
abstract = {This paper presents a garbage collection (GC) method
for parallel logic programming languages.  Paralle logic
languages require large amounts of data since logic variables can
have only one value.  Efficient memory management is important
for an efficient language processor.  In the parallel loge
language Flat Guarded Horn Clauses (FGHC), the amount of live
data is always small compared to the total amount of data
allocated.  These are two kinds of data: short-term and long-
term.  We concluded that garbage collection using only 2
generations best suits this kind of language.  We call our
garbage collection method "2-generation garbage collection".
Short-term data is garbage collected back into the 1st generation
garbage collection and long-term data is collected into the 2nd
generation garbage collection.  This method is efficient
independent of the ratio of the amount of live data to heap size.
When this ratio is high, our method is especially good, reducing
the amount of data copied by a factor of 10, compared to simple
copying garbage collection.}
}

@article{page82,
author = "Ivor P. Page",
title = "Optimal Fit of Arbitrary Sized Segments",
journal = CompJ,
publisher = BCS,
volume = 25,
number = 1,
month = jan,
year = 1982
}

@article{page84,
author = "Ivor P. Page",
title = "Analysis of a Cyclic Placement Scheme",
journal = CompJ,
publisher = BCS,
volume = 27,
number = 1,
month = jan,
year = 1984,
pages = "18--25"
}

@article{page86,
author = "Ivor P. Page and Jeff Hagins",
title = "Improving the Performance of Buddy Systems",
journal = IEEETransComp,
publisher = IEEE,
volume = "C-35",
number = 5,
month = may,
year = 1986,
pages = "441--447",
doi={10.1109/TC.1986.1676786}
}

@inproceedings{pala94,
title = "Evaluating Stream Buffers as a Secondary Cache Replacement",
author = "S. Palacharla and R. E. Kessler",
crossref = "ISCA94",
pages = {24--33}
}

@inproceedings{pala02,
  author =	 {Krzysztof Palacz and Jan Vitek and Grzegorz Czajkowski and
                  Laurent Dayn{\`e}s},
  title =	 {Incommunicado: efficient communication for isolates},
  crossref =	 {OOPSLA94},
  pages =	 {262-274},
  doi =		 {10.1145/582419.582444}
}

@inproceedings{pall88,
  title =	 "Multiprocessor {Smalltalk}: A Case Study of a
                  Multiprocessor-Based Programming Environment",
  author =	 "Joseph Pallas and David Ungar",
  crossref =	 "PLDI88",
  pages =	 {268-277},
  doi =		 {10.1145/53990.54017}
}

@techreport{pan86,
author = "Pan, Wilson",
title = "Designing an Operating System Kernal Based on Concurrent Garbage
Collection",
institution = "University of Iowa, Department of Computer Science",
year = 1986,
number = "86-04"
}

@mastersthesis{panz86,
author = "Panzer, Edward J.",
title = "Execution Time of Marking Algorithms During Garbage Collection
in {LISP}",
year = 1986,
school = "California State Polytechnic University",
}

@incollection{pare68,
author = "R. J. Parents",
title = "A Simulation Oriented Memory Allocation Algorithm",
booktitle = "Simulation Programming Languages",
editor = "J. M. Buxton",
publisher = "North-Holland",
address = "Amsterdam",
year = 1968,
pages = "199--209",
}

@inproceedings{pare01,
author = {Lars Pareto},
title = {Sized Region Types},
crossref = {SPACE01},
}

@phdthesis{park91,
author = "Young G. Park",
title = "Semantic Analyses for Storage Management Optimizations in Functional Language Implementations",
school = "New York University",
year = 1991
}

@inproceedings{park91a,
author = "Young Gil Park and Benjamin Goldberg",
title = "Reference Escape Analysis: Optimizing Reference Counting
based on the Lifetime of References",
booktitle = "Symposium on Partial Evaluation and Semantics-Based Program Manipul
ation",
address = "New Haven, CT",
month = jun,
year = 1991,
pages = "178--189"
}

@article{park92,
  title =	 "Escape Analysis on Lists",
  author =	 "Young G. Park and Benjamin Goldberg",
  pages =	 "116--127",
  journal =	 SIGPLAN,
  month =	 Jun,
  volume =	 27,
  number =	 7,
  address =	 "San Francisco, {U.S.A.}",
  publisher =	 ACM,
  year =	 1992,
  comment =	 "Higher order programming languages tend to allocate objects
                  at a very high rate.  Many of the objects are included in
                  lists and this paper shows how an analysis can be done to
                  see how far from the spine of a list a function gets, and
                  this what part of a list may escape (and hence be required
                  on the heap rather than the stack).  Other optimizations
                  include reuse of lists."
}

@article{park95,
author = "Young G. Park and Benjamin Goldberg",
title = {Static Analysis for Optimising Reference Counting},
journal = IPL,
volume = 55,
number = 4,
month = aug,
year = 1995,
pages = {229-234}
}

@article{pati97,
author = {Harish G. Patil and Charles N. Fischer},
title = {Low-cost, Concurrent Checking of Pointer and Array Accesses in {C} Programs},
journal = SPE,
volume = 27,
number = 12,
pages = {87--110},
month = dec,
year = 1997
}

@techreport{patt83,
author = "David A. Patterson",
title = "Smalltalk on a {RISC}: Architectural Investigations",
institution = "Computer Science Division, " # UCB,
number = "CS292R",
year = 1983,
month = apr
}

@inproceedings{pauw93,
author = {de Pauw, W. and R. Helm and D. Kimelman and J. Vlissides},
title = {Visualizing the Behaviour of Object-Oriented Systems},
crossref = {OOPSLA93},
pages = {326--337},
URL = {http://www.research.ibm.com/jinsight/papers/oopsla93.ps}
}

@incollection{pauw97,
author = {de Pauw, W. and D. Kimelman and J. Vlissides},
title = {Visualizing Object-Oriented Software Execution},
booktitle = {Software Visualization},
publisher = MIT,
editor = {John T. Stasko and John B. Domingue and Marc H. Brown and Blaine A. Price},
year = {1997},
URL = {http://www.research.ibm.com/jinsight/papers/coots98.pdf}
}

@inproceedings{pauw99,
author = {de Pauw, W. and G. Sevitski},
title = {Visualizing Reference Patterns for Solving Memory Leaks in {J}ava},
crossref = {ECOOP99},
pages = {116--134},
URL = {http://www.research.ibm.com/jinsight/papers/refpat.pdf}
}

@article{pauw00,
author = {de Pauw, W. and G. Sevitski},
title = {Visualizing Reference Patterns for Solving Memory Leaks in {J}ava},
journal = CPE,
publisher = Wiley,
year = 2000,
volume = 12,
pages = {1431-1454},
URL = {http://www.research.ibm.com/jinsight/papers/CPE2000.pdf}
}

@inproceedings{pauw01,
author = {de Pauw, W. and N. Mitchell and M. Robillard and G. Sevitski and H. Srinivasan},
title = {Drive-by Analysis of Running Programs},
booktitle = {Workshop on Software Visualization, International
Conference on Software Engineering},
address = {Toronto},
month = may,
year = 2001,
URL = {http://www.research.ibm.com/jinsight/papers/ICSE2001.pdf}
}

@incollection{pavl03,
author = {Dusko Pavlovic and Peter Pepper and Doug Smith},
title = {Colimits for Concurrent Collectors},
booktitle = {Verification: Theory and Practice, essays dedicated to Zohar Manna
on the occasion of his 64th birthday},
editor = {Nachum Dershowitz},
volume = 2772,
series = LNCS,
pages = {568--597},
publisher = SV,
year = 2003,
url = {http://www.kestrel.edu/home/people/smith/pub/gc.pdf}
}

@inproceedings{pavl10,
title = {Formal Derivation of Concurrent Garbage Collectors},
author = {Dusko Pavlovic and Peter Pepper and Douglas R. Smith},
booktitle = {10th International Conference on Mathematics of Program Construction (MPC)},
address = {Qu\'{e}bec City, Canada},
year = 2010,
publisher = SV,
series = LNCS,
number = 6120,
month = jun,
pages = {353--376},
doi = {10.1007/978-3-642-13321-3_20},
url = {http://www.isg.rhul.ac.uk/dusko/papers/2010-garbage-full.pdf}
}

@techreport{pavl10a,
title = {Formal Derivation of Concurrent Garbage Collectors},
author = {Dusko Pavlovic and Peter Pepper and Douglas R. Smith},
note = {The short version of this paper appeared in MPC 2010},
abstract = {Concurrent garbage collectors are notoriously difficult to implement
correctly. Previous approaches to the issue of producing correct collectors
have mainly been based on posit-and-prove verification or on the application of
domain-specific templates and transformations. We show how to derive the upper
reaches of a family of concurrent garbage collectors by refinement from a
formal specification, emphasizing the application of domain-independent design
theories and transformations. A key contribution is an extension to the
classical lattice-theoretic fixpoint theorems to account for the dynamics of
concurrent mutation and collection.},
year = 2010,
URL = {http://arxiv.org/abs/1006.4342}
}

@misc{pawl99,
title = {Reference Objects and Garbage Collection},
author = {Monica Pawlam},
year = 1999,
URL = {http://developer.java.sun.com/developer/technicalArticles//ALT/RefObj/index.html},
comment = {Whether it is in-depth or not....},
howpublished = {Article on Sun's Java Developer Connection site}
}

@mastersthesis{crac07,
title = {A Compacting Real-Time Memory Management System},
author = {Hannes Payer and Ana},
school = {University of Salzburg},
year = 2007,
URL = {http://cs.uni-salzburg.at/~hpayer/thesis.pdf},
}

@techreport{paz03,
author = {Harel Paz and David F. Bacon and Elliot K. Kolodner and Erez Petrank and V.T. Rajan},
title = {Efficient On-the-Fly Cycle Collection},
number = {CS--2003--10},
institution = {Technion University},
year = 2003,
URL = {http://www.cs.technion.ac.il/~erez/Papers/CycleCollection.ps}
}

@inproceedings{paz05,
title = {Age-Oriented Concurrent Garbage Collection},
author = {Harel Paz and Erez Petrank and Stephen M. Blackburn},
doi={10.1007/978-3-540-31985-6_9},
pages={121--136},
crossref = {CC05}
}

@inproceedings{paz05a,
title = {An Efficient On-the-Fly Cycle Collection},
author = {Harel Paz and Erez Petrank and David F. Bacon and Elliot K. Kolodner and V.T. Rajan},
doi={10.1007/978-3-540-31985-6_11},
pages={156--171},
crossref = {CC05}
}

@phdthesis{paz06,
  author =	 {Harel Paz},
  title =	 {Efficient Memory Management for Servers},
  school =	 {Technion, Israel Institute of Technology},
  year =	 2006
}

@inproceedings{paz07,
title = {Using Prefetching to Improve Reference-Counting Garbage Collectors},
author = {Harel Paz and Erez Petrank},
doi={10.1007/978-3-540-71229-9_4},
pages={48--63},
crossref = {CC07}
}

@article{paz07a,
  title =	 {An Efficient On-the-Fly Cycle Collection},
  author =	 {Harel Paz and David F. Bacon and Elliot K. Kolodner and Erez
                  Petrank and V. T. Rajan},
  journal =	 TOPLAS,
  volume =	 29,
  number =	 4,
  month =	 aug,
  year =	 2007,
  pages =	 {1--43},
  doi =		 {10.1145/1255450.1255453}
}

@article{pear96,
title = {Garbage collection with pointers to individuals cells},
author = {B. Pearlmutter},
journal = CACM,
volume = 39,
number = 12,
month = dec,
year = 1996
}

@inproceedings{pede06,
author = {Rasmus Pedersen and Martin Schoeberl},
title = {Exact Roots for a Real-time Garbage Collector},
booktitle = {4th International Workshop on Java Technologies for Real-time and Embedded Systems},
pages = {77--84},
year = 2006
}

@inproceedings{peir98,
  title =	 {Capturing Dynamic Memory Reference Behavior with Adaptive
                  Cache Topology},
  author =	 {Jih-Kwon Peir and Yongjoon Lee and Windsor W. Hsu},
  crossref =	 {ASPLOS98},
  pages =	 {250-250},
  doi =		 {10.1145/291069.291053}
}

@techreport{peng89,
author = "Peng, Chih-Jui and Gurindar S. Sohi",
title = "Cache Memory Design Considerations to Support Languages with
Dynamic Heap Allocation",
number = 860,
institution = {Computer Sciences Department, University of Wisconsin-Madison},
month = jul,
comment = {cache performance of heap-intensive programs is bad w/conventional
caches (assumes eden > cache); computes improvements with "allocate in
cache" operation and in-cache GC; nice systematic treatment,
interesting arguments},
year = 1989
}

@techreport{pepe88,
author = "E. J. H. Pepels and van Eekelen, M. C. J. D. and M. J. Plasmeijer",
title = "A Cyclic Reference Counting Algorithm and its Proof",
institution = "Computing Science Department",
address = "University of Nijmegen",
year = "1988",
number = "88--10",
comment = {A correct and terminating version of the algorithm in
\cite{brow85} and its proof. Based on \cite{salk87}.
Complexity is at least exponential.},
}

@techreport{pere02,
author = {D. Pereira and J. Aycock},
title = {Dynamic Region Inference},
number = {2002 709 12},
institution = {University of Calgary},
year = 2002
}

@inproceedings{pers99,
  title =	 {Live Memory Analysis for Garbage Collection in Embedded
                  Systems},
  author =	 {Patrik Persson},
  crossref =	 {LCTES99},
  pages =	 {45--54},
  doi =		 {10.1145/314403.314440}
}

@article{pers06,
author = {Mattias Persson},
title = {{J}ava technology, {IBM} style: Garbage collection policies, part 1},
journal = {IBM developerWorks},
URL = {http://http://www.ibm.com/developerworks//library/j-ibmjava2/},
year = 2006
}

@article{pete77,
author = "James L. Peterson and Theodore A. Norman",
title = "Buddy Systems",
journal = CACM,
publisher = ACM,
volume = 20,
number = 6,
pages = "421--431",
year = 1977,
doi={10.1145/359605.359626}
}

@inproceedings{pete03,
title = {A Type Theory for Memory Allocation and Data Abstraction},
author = {Leaf Peterson and Robert Harper and Karl Crary and Frank Pfenning},
crossref = {POPL03}
}

@article{peti98,
author = {Alexandre Petit-Bianco},
title = {Java Garbage Collection for Real-Time Systems},
journal = Dobbs,
month = oct,
year = 1998,
URL = {http://www.ddj.com/ddj/1998/1998_10/LEAD/LEAD.htm}
}

@inproceedings{petr02a,
author = {Petrank, Erez and Rawitz, Dror},
title = {The Hardness of Cache Conscious Data Placement},
crossref = {POPL02},
pages = {101--112},
doi = {10.1145/503272.503283},
}

@inproceedings{petr03,
author = {Erez Petrank and Dror Rawitz},
title = {The Hardness of Cache Conscious Data Placement},
crossref = {POPL02},
note = {Extended Abstract},
URL = {http://www.cs.technion.ac.il/~erez/Papers/PetRaw-POPL.ps}
}

@techreport{petr03a,
author = {Erez Petrank and Dror Rawitz},
title = {The Hardness of Cache Conscious Data Placement},
institution = {Technion --- Israel Institute of Technology, Haifa, Israel},
year = 2003,
URL = {http://www.cs.technion.ac.il/~erez/Papers/PetRaw.ps}
}

@article{petr04,
author = {Erez Petrank and Elliot K. Kolodner},
title = {Parallel Copying Garbage Collection using Delayed Allocation},
journal = {Parallel Processing Letters},
volume = 14,
number = 2,
month = jun,
year = 2004,
pages = {271--286},
doi={10.1142/S0129626404001878},
URL = {http://www.cs.technion.ac.il/~erez/Papers/parallel_copy.ps}
}

@inproceedings{petr02,
title = {Embedded {JVM} Concurrent Garbage Collector Internals},
author = {Peter D. Petrov and Martin T. Vechev},
booktitle = {{IASTED} Networks, Parallel and Distributed Processing, and
Applications ({NPDPA'02})},
year = 2002
}

@inproceedings{petr10,
author = {Petricek, Tomas and Syme, Don},
title = {Collecting {H}ollywood's Garbage: Avoiding Space-Leaks in Composite Events},
crossref = {ISMM10},
pages = {53--62},
doi = {10.1145/1806651.1806662},
abstract = {The reactive programming model is largely different to what we're
used to as we don't have full control over the application's control flow. If we
mix the declarative and imperative programming style, which is usual in the ML
family of languages, the situation is even more complex. It becomes easy to
introduce patterns where the usual garbage collector for objects cannot
automatically dispose all components that we intuitively consider garbage.
In this paper we discuss a duality between the definitions of garbage for
objects and events. We combine them into a single one, to specify the notion of
garbage for reactive programming model in a mixed functional/imperative language
and we present a formal algorithm for collecting garbage in this environment.
Building on top of the theoretical model, we implement a library for reactive
programming that does not cause leaks when used in the mixed
declarative/imperative model. The library allows us to safely combine both of
the reactive programming patterns. As a result, we can take advantage of the
clarity and simplicity of the declarative approach as well as the expressivity
of the imperative model.}
}

@article{peyt92,
author = "Peyton Jones, Simon L.",
title = "Implementing Lazy Functional Languages on Stock Hardware: The
{S}pineless {T}agless {G}-Machine",
journal = JFP,
publisher = CUP,
volume = 2,
number = 2,
month = apr,
year = 1992,
pages = "127--202"
}

@techreport{peyt98,
author = {Peyton Jones, Simon L. and Norman Ramsey},
title = {Machine-Independent Support for Garbage Collection, Debugging, Exception Handling and Concurrency},
number = {CS--98--19},
institution = {University of Virginia},
URL = {http://www.eecs.harvard.edu/~nr/pubs/c--rti-abstract.html},
month = aug,
year = 1998,
abstract = {For a compiler writer, generating good machine code for a
variety of platforms is hard work. One might try to reuse a
retargetable code generator from another compiler, but code generators
are complex and difficult to use, and they limit one's choice of
implementation language. One might try to use C as a portable assembly
language, but C limits the compiler writer's flexibility and the
performance of the resulting code. The wide use of C, despite these
drawbacks, argues for a portable assembly language.

C{-}{-} is a new language designed expressly as a portable assembly
language. C{-}{-} eliminates some of the performance problems associated
with C, but in its originally-proposed form it does not provide
adequate support for garbage collection, exception handling, and
debugging. The problem is that neither the high-level compiler nor the
C{-}{-} compiler has all of the information needed to support these
run-time features. This paper proposes a three-part solution: new
language constructs for C{-}{-}, run-time support for C--, and restrictions
on optimization of C{-}{-} programs.

The new C{-}{-} language constructs enable a high-level compiler to
associate initialized data with spans of C{-}{-} source ranges and to
specify ``alternate continuations'' for calls to procedures that might
raise exceptions. The run-time support is an interface (specified in C)
that the garbage collector, exception mechanism, and debugger can use
to get access to both high-level and low-level information, provided
that the C{-}{-} program is suspended at a safe point. High- and low-level
information is coordinated by means of the C{-}{-} spans and a common
numbering for variables. Finally, the C{-}{-} optimizer operates under the
constraints that the debugger or garbage collector can change the
values of local variables while execution is suspended, and that a
procedure call with alternate continuations can return to more than one
location.

This three-part solution also provides adequate support for
concurrency, so the paper illustrates the problem and the proposed
solution with examples from garbage collection, exception handling,
debugging, and threads. The paper also includes a model of the dataflow
behavior of C{-}{-} calls.

A number of open problems remain. The most serious have to do with
apparent redundancies among spans and safe points, and with the
interaction of debugging support with optimization.

This paper is very much work in progress. We are not yet satisfied with
the solutions we've come up with. Perhaps you can help improve it. }
}

@inproceedings{peyt99,
author = {Peyton Jones, Simon L. and Norman Ramsey and Fermin Reig},
title = {C--: a Portable Assembly Language that Supports Garbage Collection},
booktitle = {International Conference on Principles and Practice of Declarative Programming},
month = sep,
year = 1999,
URL = {http://www.eecs.harvard.edu/~nr/pubs/c--gc-abstract.html},
abstract = {For a compiler writer, generating good machine code for a
variety of platforms is hard work. One might try to reuse a
retargetable code generator, but code generators are complex and
difficult to use, and they limit one's choice of implementation
language. One might try to use C as a portable assembly language, but C
limits the compiler writer's flexibility and the performance of the
resulting code. The wide use of C, despite these drawbacks, argues for
a portable assembly language. C{-}{-} is a new language designed expressly
for this purpose. The use of a portable assembly language introduces
new problems in the support of such high-level run-time services as
garbage collection, exception handling, concurrency, profiling, and
debugging. We address these problems by combining the C{-}{-} language with
a C{-}{-} run-time interface. The combination is designed to allow the
compiler writer a choice of source-language semantics and
implementation techniques, while still providing good performance. }
}

@inproceedings{peyt00,
author = {Peyton Jones, Simon L. and Simon Marlow and Conal Elliott},
title = {Stretching the Storage Manager: Weak Pointers and Stable Names in
{H}askell},
booktitle = {11th International Workshop on the Implementation of Functional
Languages},
publisher = SV,
series = LNCS,
volume = 1868,
pages = {37--58},
year = 2000
}

@book{pfal77,
author = "J. L. Pfalz",
title = "Computer Data Structures",
publisher = MGH,
year = 1977,
comment = {book with sections on garbage collection},
}

@inproceedings{phal95,
title = "A Miss History-based Architecture for Cache Prefetching",
author = "Vidyadhar Phalke and B. Gopinath",
crossref = "IWMM95",
pages = {381--398},
doi = {10.1007/3-540-60368-9_35}
}

@inproceedings{phan08,
title = {Runtime Support for Region-Based Memory Management in {M}ercury},
author = {Quan Phan and Gerda Janssens and Zoltan Somogyi},
crossref = {ISMM08},
pages = {61--70},
doi = {10.1145/1375634.1375644},
abstract = {Applying region-based memory management (RBMM) to logic
programming languages poses a special challenge: backtracking can
require regions removed during forward execution to be ``resurrected'',
and any memory allocated during a computation that has been backtracked
over must be recovered promptly, without waiting for the regions
involved to come to the end of their life.  In this paper, we
describe how we implemented runtime support for RBMM in the logic
programming language Mercury, whose specialized implementation of
the language constructs involved in backtracking required equally
specialized support.  Our benchmark Mercury programs run about 25\%
faster on average with RBMM than with the usual Boehm garbage
collector, and for some programs, RBMM achieves optimal memory
consumption.}
}

@article{phil00,
title = {Cooperating Distributed Garbage Collectors For Clusters and Beyond},
author = {Michael Philippsen},
journal = CPE,
volume = 12,
number = 7,
pages = {595--610},
month = may,
year = 2000,
URL = {http://wwwipd.ira.uka.de/~phlipp/mypapers/dgc.ps.gz},
note = {Also published in 8th Int. Workshop on Compilers for Parallel Computers CPC'2000, Aussois, France},
}

@article{phip99,
author = {G. Phipps},
title = {Comparing Observed Bug and Productivity Rates for {J}ava and {C++}},
journal = SPE,
pages = {345--358},
volume = 29,
number = 4,
month = apr,
year = 1999
}

@techreport{piep93,
title = {Compiler Techniques for Managing Data Motion},
author = {Pieper},
institution = CMU,
month = dec,
year = 1993,
number = {CMU-CS-93-217},
abstract = {Software caching, automatic algorithm blocking, and data overlays are
different names for the same problem: compiler management of data movement
throughout the memory hierarchy. Modern high-performance architectures often
omit hardware support for moving data between levels of the memory hierarchy:
iWarp does not include a data cache, and Cray supercomputers do not have
virtual memory. These systems have effectively traded a more complicated
programming model for performance by replacing a hardware-controlled memory
hierarchy with a simple fast memory. The simpler memories have less logic in
the critical path, so the cycle time of the memories is improved.
For programs which fit in the resulting memory, the extra performance is
great. Unfortunately, the driving force behind supercomputing today is a class
of very large scientific problems, both in terms of computation time and in
terms of the amount of data used. Many of these programs do not fit in the
memory of the machines available. When architects trade hardware support for
data migration to gain performance, control of the memory hierarchy is left to
the programmer. Either the program size must be cut down to fit into the
machine, or every loop which accesses more data than will fit into memory must
be restructured by hand. This thesis describes how a compiler can relieve the
programmer of this burden, and automate data motion throughout the memory
hierarchy without direct hardware support.
This works develops a model of how data is accessed within a nested loop by
typical scientific programs. It describes techniques which can be used by
compilers faced with the task of managing data motion. The concentration is on
nested loops which process large data arrays using linear array subscripts.
Because the array subscripts are linear functions of the loop indices and the
loop indices form an integer lattice, linear algebra can be applied to solve
many compilation problems.
The approach it to tile the iteration space of the loop nest. Tiling allows
the compiler to improve locality of reference. The tiling basis matrix is
chosen from a set of candidate vectors which neatly divide the data set. The
execution order of the tiles is selected to maximize locality between tiles.
Finally, the tile sizes are chosen to minimize execution time.
The approach has been applied to several common scientific loop nests:
matrix-matrix multiplication, QR-decomposition, and LU-decomposition. In
addition, an illustrative example from the Livermore Loop benchmark set is
examined. Although more compiler time can be required in some cases, this
technique produces better code at no cost for most programs.}
}

@article{piqu90,
author = {Jos\'{e} M. Piquer},
title = {Un {GC} Parall\`{e}le pour un {Lisp} Distribu\'{e}},
journal = {Journ\'{e}es francophones des langages applicatifs},
month = Jan,
year = 1990,
note = "Also Bigre 69, July 1990"
}

@inproceedings{piqu90a,
author = {Jos\'{e} M. Piquer},
title = "Sharing Date Structures in Distributed {L}isp",
booktitle = "High Performance and Parallel Computing in Lisp Workshop",
address = "London",
month = Nov,
year = 1990
}

@inproceedings{piqu91,
title = "Indirect Reference Counting: A Distributed Garbage
Collection Algorithm",
author = {Jos\'{e} M. Piquer},
crossref = "PARLE91",
volume = 505,
pages = {150--165},
doi = {10.1007/BFb0035102},
comment = "Keep indirect reference counts at each node. Does not need to create
indirection cells (cf. weighted RC). Cannot handle cycles.
Appears to use send more messages than weighted RC."
}

@phdthesis{piqu91a,
author = {Jos\'{e} M. Piquer},
title = {Parall\'{e}lisme et Distribution en {L}isp},
school = "Ecole Polytecnique, Massy, France",
month = Jan,
year = 1991
}


@inproceedings{piqu92,
title = "Dynamic Revision of Choice Points During Garbage Collection in {P}rolog",
author = {Jean Fran\,{c}ois Pique},
crossref = "IWMM92",
pages = {330--343},
doi = {10.1007/BFb0017199}
}

@inproceedings{piqu95,
title = "Indirect Mark and Sweep: A Distributed {GC}",
author = {Jos\'{e} M. Piquer},
crossref = "IWMM95",
pages = {267--282},
doi = {10.1007/3-540-60368-9_28}
}

@article{piqu96,
title = "Indirect Distributed Garbage Collection: Handling Object Migration",
author = {Jos\'{e} M. Piquer},
journal = TOPLAS,
pages = "615--647",
month = sep,
year = 1996,
volume = 18,
number = 5,
}

@inproceedings{piri98,
author = {Pekka P. Pirinen},
title = {Barrier Techniques for Incremental Tracing},
pages = {20--25},
doi={10.1145/286860.286863},
crossref = {ISMM98},
abstract = {This paper presents a classification of barrier techniques
for interleaving tracing with mutator operation during an incremental
garbage collection. The two useful tricolour invariants are derived
from more elementary considerations of graph traversal. Barrier
techniques for maintaining these invariants are classified according to
the action taken at the barrier (such as scanning an object or changing
its colour), and it is shown that the algorithms described in the
literature cover all the possibilities except one. Unfortunately, the
new technique is impractical. Ways of combining barrier techniques are
also discussed. }
}

@inproceedings{pitt85,
title = "Towards a Real Time Garbage Collector for {PROLOG}",
author = "Edwin Pittomvils and Maurice Bruynooghe and Yves D. Willems",
booktitle = "1985 Symposium on Logic Programming. Boston, 1985 Jul 15--18",
pages = {185--198},
publisher = IEEE,
year = 1985,
abstract = {Inspired by the work of H. Lieberman and C. Hewitt
(1983), which describes a garbage collector which takes into account the
lifetimes of objects, the authors were able to improve the garbage collection
algorithm as described by M. Bruynooghe (1982).  The improved algorithm reduces
the time needed to mark and compact the storage area by limiting its activity
to relatively small segments of memory.  It can easily be extended to a real-
time garbage collector that preserves the important properties of increasing
the locality of references and allowing for the recuperation of memory
during backtracking.}
}

@inproceedings{pium95,
author = "Ian Piumarta",
title = "SSP Chains -- from mobile objects to mobile computing (Position Paper)",
booktitle = "{ECOOP} Workshop on Mobility, 1995",
year = 1995,
URL = "http://www-sor.inria.fr/SOR/docs/SSPMobPP_ecoop95-mobility-pp.html"
}

@inproceedings{pium95a,
title = {Garbage Collection in Distributed Object Systems},
author = {Ian Piumarta and Marc Shapiro and Paulo Ferreira},
booktitle = {Workshop on Reliability and Scalability in Distributed Object Systems, OOPSLA'95},
address = {Austin, TX},
month = oct,
year = 1995,
URL = {http://cretina.inesc.pt/people/pjpf-home/oopsla95-dist-piumarta.ps}
}

@article{pixl88,
title = "An Incremental Garbage Collection Algorithm For Multi-Mutator
Systems",
author = "C. Pixley",
address = "Microelectr  Comp Technol Corp, VLSI Computer Aided Design Program,
3500 W B Alcones Center Dr, Austin, TX 78759",
journal = "Distributed Computing",
year = 1988,
volume = 3,
number = 1,
pages = "41--50"
}

@inproceedings{pizl04,
title = {Real-time Java Scoped Memory: Design Patterns, Semantics},
author = {Filip Pizlo and J.Fox and David Holmes and Jan Vitek},
crossref = {ISORC04},
pages = {101--112},
URL = {http://homepage.mac.com/pizlo/papers/pizlo-isorc2004-scopes.pdf}
}

@inproceedings{pizl06,
title = {An Empirical Evaluation of Memory Management Alternatives for Real-time
{J}ava},
author = {Filip Pizlo and Jan Vitek},
booktitle = {27th IEEE Real-Time Systems Symposium (RTSS)},
year = 2006,
URL = {http://homepage.mac.com/pizlo/slides/pizlo-rtss2006-empirical.pdf}
}

@inproceedings{pizl07,
  title =	 {Hierarchical Real-time Garbage Collection},
  author =	 {Filip Pizlo and Antony L. Hosking and Jan Vitek},
  crossref =	 {LCTES07},
  pages =	 {123--133},
  doi =		 {10.1145/1254766.1254784}
}

@inproceedings{pizl07a,
title = {Stopless: A Real-Time Garbage Collector for Multiprocessors},
author = {Filip Pizlo and Daniel Frampton and Erez Petrank and Bjarne Steensgard},
pages = {159--172},
doi={10.1145/1296907.1296927},
crossref = {ISMM07},
}

@inproceedings{pizl08,
  title =	 {A Study of Concurrent Real-Time Garbage Collectors},
  author =	 {Filip Pizlo and Erez Petrank and Bjarne Steensgaard},
  crossref =	 {PLDI08},
  pages =	 {33-44},
  doi =		 {10.1145/1379022.1375587},
  abstract =	 {Concurrent garbage collection is highly attractive for
                  real-time systems, because offloading the collection effort
                  from the executing threads allows faster response, allowing
                  for extremely short deadlines at the microseconds
                  level. Concurrent collectors also offer much better
                  scalability over incremental collectors. The main problem
                  with concurrent real-time collectors is their
                  complexity. The first concurrent real-time garbage collector
                  that can support fine synchronization, STOPLESS, has
                  recently been presented by Pizlo et al. In this paper, we
                  propose two additional (and different) algorithms for
                  concurrent real-time garbage collection: CLOVER and
                  CHICKEN. Both collectors obtain reduced complexity over the
                  first collector STOPLESS, but need to trade a benefit for
                  it. We study the algorithmic strengths and weaknesses of
                  CLOVER and CHICKEN and compare them to STOPLESS. Finally, we
                  have implemented all three collectors on the Bartok compiler
                  and runtime for C# and we present measurements to compare
                  their efficiency and responsiveness.}
}

@inproceedings{pizl08a,
title = {Path Specialization: Reducing Phased Execution Overheads},
author = {Filip Pizlo and Erez Petrank and Bjarne Steensgaard},
crossref = {ISMM08},
pages = {81--90},
doi = {10.1145/1375634.1375647},
abstract = {As garbage collected languages become widely used, the
quest for reducing collection overheads becomes essential. In this
paper, we propose a compiler optimization called path specialization
that shrinks the cost of memory barriers for a wide variety of
garbage collectors including concurrent, incremental, and real-time
collectors. Path specialization provides a non-trivial decrease in
write-barrier overheads and a drastic reduction of read-barrier
overheads. It is effective when used with collectors that go through
various phases each employing a different barrier behavior, and is
most effective for collectors that have an idle phase, in which no
barrier activity is required. We have implemented path specialization
in the Bartok compiler and runtime for C# and tested it with
state-of-the-art concurrent and real-time collectors, demonstrating
its efficacy.}
}

@inproceedings{pizl08b,
author = {Filip Pizlo and Jan Vitek},
title = {Memory Management for Real-Time {J}ava: State of the Art},
crossref = {ISORC08},
pages = {248--254},
year = 2008,
doi = {10.1109/ISORC.2008.40},
abstract = {The Real-time Specification for Java extends the Java
platform to support real-time processing and introduces a
region-based memory model, called scoped memory, which
side-steps the Java garbage collector. While scoped memory
succeeds in protecting real-time tasks from execution time
jitter, practical experience points to shortcomings. This
paper takes stock of the state of the art in memory
management for RTSJ programs.}
}

@inproceedings{pizl10,
author = {Pizlo, Filip and Ziarek, Lukasz and Maj, Petr and Hosking, Antony L. and Blanton, Ethan and Vitek, Jan},
title = {Schism: Fragmentation-Tolerant Real-Time Garbage collection},
crossref = {PLDI10},
pages = {146--159},
doi = {10.1145/1806596.1806615},
abstract = {Managed languages such as Java and C\# are being considered for use
in hard real-time systems. A hurdle to their widespread adoption is the lack of
garbage collection algorithms that offer predictable space-and-time performance
in the face of fragmentation. We introduce SCHISM/CMR, a new concurrent and
real-time garbage collector that is fragmentation tolerant and guarantees
time-and-space worst-case bounds while providing good throughput. SCHISM/CMR
combines mark-region collection of fragmented objects and arrays (arraylets)
with separate replication-copying collection of immutable arraylet spines, so as
to cope with external fragmentation when running in small heaps. We present an
implementation of SCHISM/CMR in the Fiji VM, a high-performance Java virtual
machine for mission-critical systems, along with a thorough experimental
evaluation on a wide variety of architectures, including server-class and
embedded systems. The results show that SCHISM/CMR tolerates fragmentation
better than previous schemes, with a much more acceptable throughput penalty.}
}

@inproceedings{pizl10a,
  author =	 {Filip Pizlo and Lukasz Ziarek and Ethan Blanton and Petr Maj
                  and Jan Vitek},
  title =	 {High-level programming of embedded hard real-time devices},
  booktitle =	 {5th European Conference on Computer Systems (EuroSys)},
  pages =	 {69--82},
  year =	 2010,
  address =	 {Paris, France},
  month =	 apr,
  publisher =	 ACM,
  doi =		 {10.1145/1755913.1755922}
}

@inproceedings{plai91,
author = {David Plainfoss\'{e} and Marc Shapiro},
title = "Distributed Garbage Collection in the System is Good",
crossref = "IWOOOS91",
pages = "94--99",
URL = "http://pagesperso-systeme.lip6.fr/Marc.Shapiro/papers/SDGC_iwmm95.pdf"
}

@inproceedings{plai91a,
author = {David Plainfoss\'{e} and Marc Shapiro},
title = "A Distributed Garbage Collection as an Operating System Component",
crossref = "OOPSLA91-gc",
}

@inproceedings{plai92,
title = "Experience with Fault-Tolerant Garbage Collection in a Distributed {L}isp System",
author = {David Plainfoss\'{e} and Marc Shapiro},
crossref = "IWMM92",
pages = {116--133},
doi = {10.1007/BFb0017186},
URL = "http://www-sor.inria.fr/SOR/docs/EFTGC_iwmm92.html",
comment = "Local GC + distributed reference counting. Does not collect cycles."
}

@inproceedings{plai92a,
author = {David Plainfose{\'e} and Marc Shapiro},
title = "A Distributed {GC} in an Object-Support Operating System",
URL = "http://www-sor.inria.fr/SOR/docs/DGCOOS_iwooos92.html",
crossref = "IWOOOS92",
}

@inproceedings{plai94,
title = "A Survey of Distributed Garbage Collection Techniques",
author = {David Plainfose{\'e} and Marc Shapiro},
booktitle = "2nd Closed {BROADCAST} Workshop",
organization = "Broadcast Basic Research Action",
address = "Bruxelles (Belgique)",
month = nov,
URL = "http://www-sor.inria.fr/SOR/docs/DGC-survey.html",
year = 1994,
note = "Superseded by \cite{plai95}"
}

@phdthesis{plai94a,
author = {David Plainfoss\'{e}},
title = "Distributed Garbage Collection and Reference Management in the {S}oul Object Support System",
school = {Universit\'{e} Paris-6, Pierre-et-Marie-Curie},
year = 1994,
address = "Paris (France)",
month = jun,
note = "Available from INRIA as TU-281, ISBN-2-7261-0849-0",
URL = "http://www-sor.inria.fr/SOR/docs/Soul_plainfosse-thesis.html"
}

@inproceedings{plai95,
title = "A Survey of Distributed Garbage Collection Techniques",
author = {David Plainfoss\'{e} and Marc Shapiro},
crossref = "IWMM95",
pages = {211-249},
doi = {10.1007/3-540-60368-9_26},
URL = "http://www-sor.inria.fr/SOR/docs/SDGC_iwmm95.html"
}

@inproceedings{plak00,
author = {Manoj Plakal and Charles N. Fischer},
title = {Concurrent Garbage Collection Using Program Slices on Multithreaded Processors},
pages = {94--100},
crossref = {ISMM2000},
abstract = {
We investigate reference counting in the context of a multithreaded
architecture by exploiting two observations: (1) reference-counting can be
performed by a transformed mutator slice that isolates heap references, and
(2) hardware trends indicate that microprocessors in the near future will
soon be able to execute multiple concurrent threads on a single chip. We
generate a reference-counting collector as a transformed program slice of
an application and then execute this slice in parallel with the application as a
"run-behind" thread. Preliminary measurements of collector overheads are
encouraging.  }
}

@article{plau94,
title = "Managing the Heap",
author = "P.J. Plauger",
journal = "Journal of {C} Language Translation",
volume = 6,
number = 1,
month = sep,
year = 1994,
comment = "How to implement malloc, free, and friends"
}

@inproceedings{poll82,
  author =	 "Fred J.  Pollack and George W. Cox and Dan W. Hammerstein
                  and Kevin C. Kahn and Konrad K. Lai and Justin R. Rattner",
  title =	 "Supporting {Ada} Memory Management in the {iAPX--432}",
  crossref =	 "ASPLOS82",
  pages =	 "117--131",
  doi =		 {10.1145/800050.801835},
  comment =	 "Describes a HW/SW implementation of the on-the-fly garbage
                  collection algorithm in \cite{dijk78}"
}

@article{pome85,
title = "Prefetching Pacing Buffer to Reduce Cache Misses",
author = "J. H. Pomerene and T. R. Puzak and R. N. Rechtshaffen and F. J. Sparacio",
journal = "IBM Technical Disclosure Bulletin",
volume = 27,
number = 5,
year = 1985,
pages = "2773--2774"
}

@article{pome85a,
title = "Prefetching Confirmation Array",
author = "J. H. Pomerene and T. R. Puzak and R. N. Rechtshaffen and F. J. Sparacio",
journal = "IBM Technical Disclosure Bulletin",
volume = 27,
number = 5,
year = 1985,
pages = "2786--2787"
}

@article{pome85b,
title = "Shadow Structure to Perform {D}-Line Prefetching",
author = "J. Pomerene and T. R. Puzak and R. N. Rechtshaffen and F. J. Sparacio",
journal = "IBM Technical Disclosure Bulletin",
volume = 27,
number = 5,
year = 1985,
pages = "2987--2988"
}

@inproceedings{poon85,
title = "Cache Memories in a Functional Programming Environment",
author = "E. K. Y. Poon and Peyton Jones, Simon L. ",
booktitle = {Aspen\"{a}s Workshop on Implementation of Functional Languages,
G\"{o}teborg},
note = "Also UCL Computer Science Internal Note 1680",
year = 1985
}

@inproceedings{poss12,
author = {Raphael Poss and Clemens Grelck and Stephan Herhut and Sven-Bodo Scholz},
title = {Lazy Reference Counting for the {M}icrogrid},
booktitle = {Proceedings of the 16th Workshop on on Interaction between Compilers and Computer Architectures (INTERACT'16)},
year = 2012,
pages = {41-48},
publisher = IEEE,
doi = {10.1109/INTERACT.2012.6339625},
}

@Article{pota05,
  author =	 {Alex Potanin and James Noble and Marcus Frean and Robert
                  Biddle},
  title =	 {Scale-Free Geometry in {OO} Programs},
  journal =	 cacm,
  year =	 2005,
  volume =	 48,
  number =	 5,
  pages =	 {99-103},
  month =	 may,
  doi =		 {10.1145/1060710.1060716}
}

@misc{pozo00,
author = {Roldan Pozo and Bruce Miller},
title = {{S}ci{M}ark 2.0 Nenchmarks},
year = 2000,
howpublished = {http://math.nist.gov/scimark2/},
URL = {http://math.nist.gov/scimark2/}
}

@article{prak94,
author = {S. Prakash and Y.-H. Lee and T. Johnson},
title = {A Nonblocking Algorithm for Shared Queues Using Compare-and-Swap},
journal = IEEETransComp,
volume = 43,
number = 5,
pages = {548--559},
month = may,
year =1994}

@inproceedings{pren00,
author = {Prensa Nieto, Leonor and Javier Esparza},
title = {Verifying Single and Multi-Mutator Garbage Collectors with
{O}wicki-{G}ries in {I}sabelle/{HOL}},
booktitle = {Mathematical Foundations of Computer Science (MFCS 2000)},
editor = {M. Nielsen and B. Rovan},
year = 2000,
pages = {619--628},
publisher = SV,
series = LNCS,
volume = 1893,
address = {Bratislava, Slovakia},
month = aug # "/" # sep,
doi = {10.1007/3-540-44612-5_57}
}

@article{preu10,
  title={An Embedded {GC} Module with Support for Multiple Mutators and Weak References},
  author={Preu{\ss}er, Thomas and Reichel, Peter and Spallek, Rainer},
  journal={Architecture of Computing Systems (ARCS 2010)},
  pages={25--36},
  year=2010,
  publisher={Springer}
}

@inproceedings{pric03,
author = {D. Price and A. Rudys and D. Wallach},
title = {Garbage Collector Memory Accounting in Language-Based Systems},
booktitle = {IEEE Symposium on Security and Privacy},
pages = {263--274},
address = {Oakland, CA},
month = may,
year = 2003,
publisher = IEEEcomp
}

@inproceedings{prin96,
author = {Tony Printezis},
title = {Disk Garbage Collection Strategies for Persistent {J}ava},
booktitle = {1st International Workshop on Persistence and {J}ava},
address = {Drymen, Scotland},
URL = {http://www.dcs.gla.ac.uk/~tony/research/pjw1.ps.gz},
month = sep,
year = 1996
}

@techreport{prin96a,
author = {Tony Printezis and Quentin Cutts},
title = {Measuring the Allocation Rate of {N}apier88},
institution = "Department of Computer Science, University of Glasgow",
URL = {http://www.dcs.gla.ac.uk/~tony/research/measure.ps.gz},
month = nov,
year = 1996
}

@inproceedings{prin97,
author = {Tony Printezis and Malcolm P. Atkinson and Laurent Dayn{\`e}s and Susan Spence and Pete Bailey},
title = {The Design of a new Persistent Object Store for {PJ}ama},
booktitle = {2nd International Workshop on Persistence and {J}ava ({PJW2})},
address = {Half Moon Bay, CA},
URL = {http://www.dcs.gla.ac.uk/~tony/research/pjw2.ps.gz},
month = aug,
year = 1997
}

@phdthesis{prin00,
author = {Tony Printezis},
title = {Management of Long-Running High-Performance Persistent Object Stores},
school = {University of Glasgow},
month = may,
year = 2000
}

@inproceedings{prin00a,
author = {Tony Printezis and David Detlefs},
title = {A Generational Mostly-Concurrent Garbage Collector},
pages = {143--154},
doi={10.1145/362422.362480},
crossref = {ISMM2000},
abstract = {
This paper reports our experiences with a mostly-concurrent incremental
garbage collector, implemented in the context of a high performance
virtual machine for the Java programming language. The garbage
collector is based on the ``mostly parallel'' collection algorithm of
Boehm et al. and can be used as the old generation of a generational
memory system. It overloads efficient write-barrier code already
generated to support generational garbage collection to also identify
objects that were modified during concurrent marking. These objects
must be rescanned to ensure that the concurrent marking phase marks all
live objects. This algorithm minimises maximum garbage collection pause
times, while having only a small impact on the average garbage
collection pause time and overall execution time. We support our claims
with experimental results, for both a synthetic benchmark and real
programs.
}
}

@inproceedings{prin01,
author = {Tony Printezis},
title = {{Hot-Swapping between a Mark\&Sweep and a Mark\&Compact Garbage Collector in a Generational Environment}},
crossref = {JVM01},
URL = {http://www.usenix.org/events/jvm01/printezis.html}
}

@inproceedings{prin02,
title = {Visualising the {T}rain Garbage Collector},
author = {Tony Printezis and Alex Garthwaite},
crossref = {ISMM02},
pages = {100--105},
doi={10.1145/512429.512436},
abstract = {GCspy is an architectural framework for the collection,
transmission, storage and replay of memory management behaviour. It
makes new contributions to the understanding of the dynamic memory
behaviour of programming languages (and especially object-oriented
languages that make heavy demands on the performance of memory
managers).  GCspy's architecture allows easy incorporation into any
memory management system: it is not limited to garbage-collected
languages. It requires only small changes to the system in which it is
incorporated but provides a simple to use yet powerful data-gathering
API.  GCspy scales to allow very large heaps to be visualised
effectively and efficiently. It allows already-running, local or
remote, systems to be visualised and those systems to run at full speed
outside the points at which data is gathered. GCspy's visualisation
tool presents this information in a number of novel ways.  Deep
understanding of program behaviour is essential to the design of the
next generation of garbage collectors and explicit allocators. Until
now no satisfactory tools have been available to assist the implementer
in gaining an understanding of heap behaviour.  GCspy has been
demonstrated to be a practical solution to this dilemma. It has been
used to analyse production Java virtual machines running applications
of realistic size.  Its use has revealed important insights into the
interaction between application program and JVM and has led to the
development of better garbage collectors.}
}

@techreport{prin02a,
author = {Tony Printezis and Richard Jones},
title = {{GC}spy: An Adaptable Heap Visualisation Framework},
institution = {University of Kent},
number = {5--02},
month = mar,
year = 2002,
URL = {http://www.cs.ukc.ac.uk/pubs/2002/1364},
note = {Also University of Glasgow Technical Report}
}

@inproceedings{prin02b,
author = {Tony Printezis and Richard Jones},
title = {{GC}spy: An Adaptable Heap Visualisation Framework},
crossref = {OOPSLA02},
pages = {343-358}
}

@misc{prin04,
author = {Tony Printezis},
title = {Garbage Collection in the {J}ava {H}ot{S}pot Virtual Machine},
URL = {http://www.devx.com/Java/Article/21977/},
year = 2004
}

@article{prin06,
title = {On Measuring Garbage Collection Responsiveness},
author = {Tony Printezis},
journal =	 SCP,
volume =	 62,
number =	 2,
publisher =	 "Elsevier",
month =	 oct,
year =	 2006,
pages = {164--183},
doi = {10.1016/j.scico.2006.02.004}
}

@inproceedings{prot95,
author = {J. Proti\'{c} and M. Toma\u{s}evi\'{c} and V. Milutinovi\'{c}},
title = {A Survey of Distributed Shared Memory Systems},
booktitle = {28th Annual Hawaii International Conference on System Science (HICSS)},
volume = {I (architecture)},
pages = {74--84},
year = 1995
}

@book{prot98,
author = {J. Proti\'{c} and M. Toma\u{s}evi\'{c} and V. Milutinovi\'{c}},
title = {Distributed Shared Memory: Concepts and Systems},
publisher = IEEE,
month = aug,
year = 1997,
URL = {http://church.computer.org/cspress/CATALOG/bp07737.htm},
}

@inproceedings{przy88,
author = "Przybylski, Stephen A. and Mark Horowitz and John Hennessy",
title = "Performance Tradeoffs in Cache Design",
booktitle = "15th Annual " # ISCA,
address = "Honolulu, Hawaii",
month = jun,
year = 1988,
pages = "290--298"
}

@book{przy90,
author = "Steven A. Przybylski",
title = "Cache and Memory Hierarchy Design: A Performance-Directed
Approach",
publisher = "Morgan Kaufman",
address = "Palo Alto, CA",
year = 1990
}

@inproceedings{przy90a,
author = "Przybylski, Stephen",
title = "The Performance Impact of Block Sizes and Fetch Strategies",
crossref = "ISCA90",
pages = "160--169"
}

@inproceedings{puau92,
title = "Distributed Garbage Collection of Active Objects with No Global Synchronisation",
author = "Isabelle Puaut",
crossref = "IWMM92",
pages = {148--164},
doi = {10.1007/BFb0017188}
}

@phdthesis{puau93,
title = {Gestion d'objets actifs dans les syst\`{e}mes distribu\'{e}s: probl\'{e}matique et mise en oeuvre},
author = "Isabelle Puaut",
school = {Universit\'{e} de Rennes I},
year = 1993
}

@inproceedings{puau94,
title = "A Distributed Garbage Collector for Active Objects",
author = "Isabelle Puaut",
crossref = "PARLE94",
pages = {539--552},
doi = {10.1007/3-540-58184-7_129},
note = "Also INRIA UCIS-DIFUSION RR 2134"
}

@inproceedings{puau94a,
title = "A Distributed Garbage Collector for Active Objects",
author = "Isabelle Puaut",
crossref = "OOPSLA94",
pages = "113-128",
}

@inproceedings{puff08,
author = {Wolfgang Puffitsch},
title = {Decoupled Root Scanning in Multi-processor Systems},
booktitle = {2008 International Conference on Compilers, Architectures and Synthesis for Embedded Systems},
year = 2008,
isbn = {978-1-60558-469-0},
pages = {91--98},
address = {Atlanta, GA},
doi = {10.1145/1450095.1450111},
publisher = ACM,
}

@inproceedings{puff08a,
author = {Wolfgang Puffitsch and Martin Schoeberl},
title = {Non-Blocking Root Scanning for Real-Time Garbage Collection},
crossref = {JTRES08},
pages = {68--76},
doi = {10.1145/1434790.1434801},
}

@inproceedings{puff09,
author = {Puffitsch, Wolfgang},
title = {Data Caching, Garbage Collection, and the {J}ava Memory Model},
booktitle = {Proceedings of the 7th International Workshop on Java Technologies for Real-Time and Embedded Systems},
crossref = {JTRES09},
pages = {90--99},
doi = {10.1145/1620405.1620419},
} 

@inproceedings{puff10,
author = {Puffitsch, Wolfgang and Huber, Benedikt and Schoeberl, Martin},
title = {Worst-Case Analysis of Heap Allocations},
booktitle = {Proceedings of the 4th International Conference on Leveraging Applications of Formal Methods, Verification, and Validation - Volume Part II },
series = {ISoLA'10},
year = 2010,
isbn = {3-642-16560-5, 978-3-642-16560-3},
address = {Heraklion, Crete, Greece},
pages = {464--478},
doi = {10.1145/1939345.1939394},
publisher = SV
} 

@inproceedings{puff11,
author = {Puffitsch, Wolfgang},
title = {Hard Real-Time Garbage Collection for a {J}ava Chip Multi-Processor},
crossref = {JTRES11},
pages = {64--73},
doi = {10.1145/2043910.2043921},
}

@phdthesis{puff12,
author =      "Wolfgang Puffitsch",
title =       "Hard Real-Time Garbage Collection on Chip Multi-Processors",
school =      "Technische Universit{\"a}t Wien, Institut f{\"u}r Technische Informatik",
year =        2012
}

@article{purd70,
title = "Statistical Properties of the Buddy System",
author = "P. W. Purdom and S. M. Stigler",
journal = JACM,
publisher = ACM,
volume = 17,
number = 4,
month = oct,
year = 1970,
pages = "683--697"
}

@article{purd71,
author = "P. W. Purdom and S. M. Stigler and Tat-Ong Cheam",
title = "Statistical Investigation of Three Storage Allocation Algorithms",
journal = "BIT",
volume = 11,
year = 1971,
pages = "187--195"
}

@manual{pure92,
title = "Purify",
key = "Purify",
organization = "Pure Software",
address = "Los Altos, CA",
year = 1992
}


@phdthesis{puza85,
author = "Thomas R. Puzak",
title = "Analysis of Cache Replacement Algorithms",
school = UMass # ", Department of Electrical and Computer Engineering",
month = feb,
year = 1985
}

@inproceedings{qian02,
title = {An Adaptive, Region-based Allocator for {J}ava},
author = {Feng Qian and Laurie Hendren},
crossref = {ISMM02},
pages = {127--138},
doi={10.1145/512429.512446},
note = {Sable Technical Report 2002--1 provides a longer version.}
}

@inproceedings{qian02a,
author = {Yang Qian and Witawas Srisa-an and T. Skotiniotis and J. Morris Chang},
title = {Java Virtual Machine Timing Probes --- A Study of Object Life Span and {GC}},
booktitle = {21st IEEE International Performance, Computing and Communications Conference (IPCCC)},
addess = {Phoenix, AZ},
month = apr,
year = 2002
}

@article{quei88,
author = "Christian Queinnec",
title = "Dynamic Extent Objects",
journal = "Lisp Pointers",
publisher = ACM,
volume = 2,
number = 1,
year = 1988,
URL = "ftp://ftp.inria.fr/INRIA/Projects/icsla/Papers/DynExt-All.ps.gz"
}

@inproceedings{quei89,
title = "Mark {DURING} {S}weep rather than {M}ark {THEN} {S}weep",
author = "Christian Queinnec and Barbara Beaudoing and Jean-Pierre Queille",
crossref = {PARLE89},
volume = 365,
pages = "224--237",
doi={10.1007/3540512845_42},
URL = "ftp://ftp.inria.fr/INRIA/Projects/icsla/Papers/gcp.ps.gz",
comment = "On-the-fly garbage collection",
abstract = "Garbage Collection frees the programmer from the burden of
explicitly deallocating unused data. This facility induces a considerable
overhead but also causes some delays that may affect real-time
applications.  Guaranteed throughput (with at most short and
predictable delays) is needed in many applications such as plane or
plant control and requires at least a worst case analysis to identify
the performances of the whole system.  Traditional GC are made of two
phases: the marker which identifies all useful data, followed by the
sweeper which reclaims all useless data.  On-the-fly GC schemes were
introduced to permit an application and a collector to run
concurrently. That concurrency may lessen the GC penalty incurred by
the application.
We present here a new algorithm where the application,
the marker and the sweeper are concurrent. The benefit is to tightly
adjust collection rate to application consumption and have an allocation
time bounded by a small constant. Moreover our algorithm does not waste memory
and appears to be well suited for embedded systems.
This ``mark {\sc during} sweep'' algorithm is completely presented.  An
interesting single-processor and incremental realisation is also
analysed and followed by  some implementation variations."
}

@inproceedings{quei94,
author = "Christian Queinnec",
title = {Sharing Mutable Objects and Controlling Groups of Tasks in a concurrent and Distributed Language},
editor = {Takayasu Ito and Akinori Yonezawa},
booktitle = {Workshop on Theory and Practice of Programming (TPPP)},
series = LNCS,
volume = 700,
pages = {70--93},
address = {Sendai, Japan},
month = nov,
year = 1994,
publisher = SV
}

@inproceedings{quei99,
author = {Christian Queinnec and Luc Moreau},
title = {Graceful Disconnection},
booktitle = {Parallel and Distributed Computing for Symbolic and Irregular Applications, PDCSIA'99},
editor = {Takayasu Ito and Taiichi Yuasa},
year = 1999,
publisher = {World Scientific Publishing},
URL = {http://www.ecs.soton.ac.uk/~lavm/papers/gradisc.ps.gz},
address = {Sendai, Japan},
month = jul,
pages = {242--252},
abstract = {A distributed object system allows objects to be communicated
from site to site disregarding their physical locations.
Communicating objects often leaves a trail homing to the site
that owns the original object. To shortcut these trails reduces
the number of ``zombies'' i.e., sites that are part of the trail
but do not need the object for themselves. This paper proposes an
algorithm that allows a site to disconnect gracefully that is,
without global network synchronization and therefore
quickly. This algorithm focuses on the proper treatment of
zombies.}
}

@inproceedings{rafk09,
title = {Precise Garbage Collection for {C}},
author = {Jon Rafkind and Adam Wick and John Regehr and Matthew Flatt},
pages = {39--48},
doi = {10.1145/1542431.1542438},
crossref = {ISMM09}
}

@techreport{ram84,
title = "Parallel Garbage Collection Without Synchronization Overhead",
author = "Ashwin Ram and Janak H. Patel",
institution = {University of Illinois},
number = {CSG-35},
year = 1984
}

@inproceedings{ram85,
  title =	 "Parallel Garbage Collection Without Synchronization
                  Overhead",
  author =	 "Ashwin Ram and Janak H. Patel",
  crossref =	 {ISCA85},
  pages =	 {84--90},
  doi =		 {10.1145/327070.327134},
}

@inproceedings{rama02,
author = {Y. Srinivas Ramakrishna},
title = {Automatic Memory Management in the {J}ava {H}ot{S}pot Virtual Machine},
booktitle = {JavaOne Conference},
year = 2002,
}

@article{rama06,
  title =	 {Distributed Garbage Collection Algorithms for Timestamped
                  Data},
  author =	 {Umakishore Ramachandran and Kathleen Knobe and Nissim Harel
                  and Hasnain A. Mandviwala},
  journal =	 {IEEE Transactions on Parallel and Distributed Systems},
  month =	 oct,
  year =	 2006,
  volume =	 17,
  number =	 10,
  pages =	 {1057--1071},
  doi =		 {10.1109/TPDS.2006.138}
}

@article{rame83,
author = "S. Ramesh and S. L. Mehndiratta",
title = "The Liveness Property of On-The-Fly Garbage Collector --- a Proof",
journal = IPL,
publisher = NH,
volume = 17,
number = 4,
month = nov,
year = 1983,
pages = "189--195",
comment = {This article uses \cite{owic82} to give a more formal proof
that on-the-fly garbage collection \cite{dijk78} terminates and
is live-lock free.},
}

@manual{rams01,
author = {Norman Ramsey and Peyton Jones, Simon L. and C. Lindig and T. Nordin and D. Oliva and Nogueira Iglesias, P.},
title = {{C}{-}{-} Reference Manual},
month = nov,
year = 2001,
URL = {http://www.cminusminus.org}
}

@article{rana83,
author = "S. P. Rana",
title = "A Distributed Solution to the Distributed Termination Problem",
journal = IPL,
publisher = NH,
volume = 17,
pages = {43--46},
year = 1983,
month = jul
}

@article{rand68,
author = "Brian Randell and C. J. Kuehner",
title = "Dynamic Storage Allocation Systems",
journal = CACM,
publisher = ACM,
volume = 12,
number = 7,
month = may,
year = 1968,
pages = "297--306"
}

@article{rand69,
author = "Brian Randell",
title = "A Note on Storage Fragmentation and Program Segmentation",
journal = CACM,
publisher = ACM,
volume = 12,
number = 7,
month = jul,
year = 1969,
pages = "365--372"
}

@article{rao78,
title = "Performance Analysis of Cache Memories",
author = "G. S. Rao",
journal = JACM,
publisher = ACM,
volume = 25,
number = 3,
month = jul,
year = 1978,
pages = "378--395"
}

@inproceedings{rash87,
  author =	 "Richard Rashid and Avadis Tevanian and Michael Young and
                  David Golub and Robert Baron and David Black and William
                  Bolosky and Jonathan Chew",
  title =	 "Machine-Independent Virtual Memory Management for Paged
                  Uniprocessor and Multiprocessor Architectures",
  crossref =	 "ASPLOS87",
  pages =	 "31--39",
  doi =		 {10.1145/36206.36181}
}

@inproceedings{rath87,
title = "Design of a Self-Managing Secondary Memory",
author = "B. D. Rathi and J. C. Browne and G. J. Lipovski",
booktitle = "20th {H}awaii International Conference
on System Sciences 1987. (Volume 1 = {A}rchitecture, Decision Support
Systems and Knowledge-Based Systems.)",
address = {Kailua-Kona, HI},
month = jan,
publisher = "Western Periodicals Co",
pages = "293--302",
year = 1987,
abstract = {The 'self-managing-secondary memory' (SMSM) is intended to serve at
an intermediate level between primary memory and disks in the memory hierarchy.
It supports name based associative searching for objects, to implement
distributed and parallel name (directory) management.  It also supports
hardware memory allocation, garbage collection and compaction.  It can store
and retrieve variable size objects as readily as fixed size objects.  The SMSM
is modularly expandable in two senses = "(1) multiple units can function as an
integrated unit with respect to name management; and (2) (due to internal
parallelism) the storage capacity of each cell can be expanded over a wide
range without increase in latency or access times.  The functionality of the
SMSM can be extended to include database operations such as selection or
projection if desired.}
}

@phdthesis{rau77,
title = "Program Behavior and the Performance of Memory Systems",
author = "B. R. Rau",
school = "Stanford University",
year = 1977
}

@inproceedings{ravi05,
author = {Ravindar, A. and Srikant, Y.N.},
title = {Static Analysis for Identifying and Allocating Clusters of Immortal Objects},
booktitle = {.NET Technologies 2005},
address = {Plzen, Czech Republic},
year = 2005
}

@inproceedings{ravi13,
author = {Ravitch, Tristan and Liblit, Ben},
title = {Analyzing Memory Ownership Patterns in {C} Libraries},
crossref = {ISMM13},
doi = {10.1145/2464157.2464162},
abstract = {Programs written in multiple languages are known as polyglot
programs. In part due to the proliferation of new and productive high-level
programming languages, these programs are becoming more common in environments
that must interoperate with existing systems. Polyglot programs must manage
resource lifetimes across language boundaries. Resource lifetime management bugs
can lead to leaks and crashes, which are more difficult to debug in polyglot
programs than monoglot programs.
We present analyses to automatically infer the ownership semantics of C
libraries. The results of these analyses can be used to generate bindings to C
libraries that intelligently manage resources, to check the correctness of
polyglot programs, and to document the interfaces of C libraries. While these
analyses are unsound and incomplete, we demonstrate that they significantly
reduce the manual annotation burden for a suite of fifteen open source
libraries.},
} 

@inproceedings{rea13,
author = {Reames, Philip and Necula, George},
title = {Towards Hinted Collection: Annotations for Decreasing Garbage Collector Pause Times},
crossref = {ISMM13},
doi = {10.1145/2464157.2464158},
abstract = {Garbage collection is widely used and has largely been a boon for
programmer productivity. However, traditional garbage collection is approaching
both practical and theoretical performance limits. In practice, the maximum heap
size and heap structure of large applications are influenced as much by garbage
collector behavior as by resource availability.
We present an alternate approach to garbage collection wherein the programmer
provides untrusted deallocation hints. Usage of deallocation hints is similar to
trusted manual deallocation, but the consequence of an inaccurate hint is lost
performance not correctness. Our hinted collector algorithm uses these hints to
identify a subset of unreachable objects with both better parallel asymptotic
complexity and practical performance. On some benchmarks, our prototype
collector implementation achieves 10-20\% pause time reductions. We close with a
discussion of the design trade-offs inherent in our approach and lessons to be
learned from our collector.},
} 

@inproceedings{redd04,
author = {Uday Reddy},
title = {Semantic Models of Storage},
crossref = {SPACE04},
note = {Invited talk}
}

@article{reed79,
author = "David P. Reed and Rajendra K. Kanodia",
title = "Synchronization with Eventcounts and Sequencers",
journal = CACM,
year = 1979,
volume = 22,
number = 2,
pages = "115--123",
month = feb
}

@article{reev79,
author = "C. M. Reeves",
title = "Free Store Distribution under Random-Fit Allocation",
journal = CompJ,
publisher = BCS,
volume = 22,
number = 4,
month = nov,
year = 1979,
pages = "346--351"
}

@article{reev80,
author = "C. M. Reeves",
title = "Free Store Distribution under Random-Fit Allocation: Part 2",
journal = CompJ,
publisher = BCS,
volume = 23,
number = 4,
month = nov,
year = 1980,
pages = "298--306"
}

@article{reev82,
author = "C. M. Reeves",
title = "A Lumped-State Model of Clustering in Dynamic Storage Allocation",
journal = Compj,
volume = 27,
number = 2,
year = 1982,
pages = "135--142"
}

@article{reev83,
author = "C. M. Reeves",
title = "Free Store Distribution under Random-Fit Allocation, Part 3",
journal = CompJ,
publisher = BCS,
volume = 26,
number = 1,
month = feb,
year = 1983,
pages = "25--35"
}

@inproceedings{reic10,
author = {C. Reichenbach and Eddie Aftandilian and Nl Immerman and Sam Guyer and Yannis  Smaragdakis},
title = {What Can the {GC} Compute Efficiently? A Language for Heap Assertions
at {GC} Time},
crossref = {OOPSLA10},
URL = {http://www.eecs.tufts.edu/~eaftan/papers/deal-oopsla-2010.pdf},
doi = {10.1145/1869459.1869482},
abstract = {We present the DeAL language for heap assertions that are
efficiently evaluated during garbage collection time. DeAL is a rich,
declarative, logic-based language whose programs are guaranteed to be executable
with good whole-heap locality, i.e., within a single traversal over every live
object on the heap and a finite neighborhood around each object. As a result,
evaluating DeAL programs incurs negligible cost: for simple assertion checking
at each garbage collection, the end-to-end execution slowdown is below 2\%. DeAL
is integrated into Java as a VM extension and we demonstrate its efficiency and
expressiveness with several applications and properties from the past
literature.
Compared to past systems for heap assertions, DeAL is distinguished by its very
attractive expressiveness/efficiency tradeoff: it offers a significantly richer
class of assertions than what past systems could check with a single traversal.
Conversely, past systems that can express the same (or more) complex assertions
as DeAL do so only by suffering orders-of-magnitude higher costs.}
}

@inproceedings{reid99,
author = {Alastair Reid and John McCorquodale and Jason Baker and Wilson Hsieh and Joseph Zachary},
title = {The Need for Predictable Garbage Collection},
booktitle = {ACM SIGPLAN Workshop on Compiler Support for System Software (WCSSS)},
month = may,
year = 1999,
URL = {http://www.cs.utah.edu/flux/papers/gc-wcsss99.ps.gz},
abstract = { Modern programming languages such as Java are increasingly
being used to write systems programs. By ``systems programs,'' we mean
programs that provide critical services (compilers), are long-running
(Web servers), or have time-critical aspects (databases or query
engines). One of the requirements of such programs is predictable
behavior. Unfortunately, predictability is often compromised by the
presence of garbage collection. Various researchers have examined the
feasibility of replacing garbage collection with forms of stack
allocation that are more predictable than GC, but the applicability of
such research to systems programs has not been studied or measured. A
particularly promising approach allocates objects in the n-th stack
frame (instead of just the topmost frame): we call this deep stack
allocation. We present dynamic profiling results for several Java
programs to show that deep stack allocation should benefit systems
programs, and we describe the approach that we are developing to
perform deep stack allocation in Java. }
}

@article{rein73,
author = "E. M. Reingold",
title = "A Non-Recursive List Moving Algorithm",
journal = CACM,
publisher = ACM,
volume = 16,
number = 5,
month = may,
year = 1973,
pages = "305--307",
comment = {Optimization to the copying algorithm (feni69) which uses
Deutsch-Schorr-Waite link-reversal technique (scho67).},
}

@phdthesis{rein93,
author = "Mark B. Reinhold",
title = "Cache Performance of Garbage-Collected Programming Languages",
school = "MIT Laboratory for Computer Science",
note = "Also Technical Memo MIT/LCS/TR--581",
month = sep,
year = 1993,
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TM-581.html"
}

@inproceedings{rein94,
  author =	 "Mark B. Reinhold",
  title =	 "Cache Performance of Garbage-Collected Programs",
  crossref =	 "PLDI94",
  pages =	 {206-217},
  doi =		 {10.1145/178243.178261},
  comment =	 "ftp://ftp.nj.nec.com/pub/pls/pldi94.ps.Z"
}

@inbook{reit12,
title = {Java Enterprise Performance},
author = {Alois Reitbauer and Klaus Enzenhofer and Andreas Grabner and Michael
Kopp and Stephen Pierzchala and Steve Wilson},
chapter = {Memory Management},
URL = {http://javabook.compuware.com/content/memory/how-garbage-collection-works.aspx},
year = 2012,
publisher = {Compuware},
comment = {Useful comparison of GCs in different commercial JVMs}
}

@inproceedings{reyn01,
author = {John C Reynolds and Peter O'Hearn},
title = {Reasoning about Shared Mutable Data Structure},
crossref = {SPACE01},
note = {Invited talk}
}

@techreport{repp86,
author = "John H. Reppy and E. R. Gansner",
title = "Pegasus: A Foundation for Programming Environments",
institution = "AT\&T Bell Laboratories",
type = "Technical Memorandum",
year = 1986,
month = dec,
note = "An earlier version appeared in the 2nd ACM/SIGSOFT/SIGPLAN
Symposium on Practical Software Development Environments, December 1986,
218--227."
}

@techreport{repp93,
author = "John H. Reppy",
title = "A High-Performance Garbage Collector for {S}tandard {ML}",
institution = "AT\&T Bell Laboratories",
type = "Technical Memorandum",
year = 1993,
month = dec,
address = "Murray Hill, NJ",
URL = {http://www.smlnj.org/compiler-notes/93-tr-reppy.ps}
}

@article{ribe89,
title = "Content-Addressable Memories Applied to Execution of Logic Programs",
author = "J. C. D. F. Ribeiro and C. D. Stormon and J. V. Oldfield and M. R. Brule",
journal = "{IEE} Proceedings, Part E: Computers and Digital Techniques",
volume = 136,
number = 5,
pages = "383--388",
year = "1989",
abstract = {The paper describes techniques for using content-addressable memory
to speed up the execution of logic programs for both single and multiple
processor implementations.  The techniques allow for significant speed-ups in
unification, clause selection, branch switching, variable handling and garbage
collection.  For multiple processor implementations, the literal ordering and
environment join algorithms are improved.  In addition to the speed
improvements, some simplification of software results from performing
indexing operations in content-addressable memory.}
}

@inproceedings{ricc13,
author = {Ricci, Nathan P. and Guyer, Samuel Z. and Moss, J. Eliot B.},
title = {{E}lephant {T}racks: Portable Production of Complete and Precise {GC} Traces},
crossref = {ISMM13},
doi = {10.1145/2464157.2466484},
abstract = {We present Elephant Tracks (ET), a dynamic program analysis tool for
Java that produces detailed traces of garbage collection-related events,
including object allocations, object deaths, and pointer updates. Like prior
work, our tracing tool is based on the Merlin algorithm [6,7], but offers
several substantial new capabilities. First, it is much more precise than
previous tools: it traces method entries and exits and measures time in terms of
them, allowing it to place events precisely in the context of the program
structure. Second, it is implemented using a combination of JVM Tool Interface
(JVMTI)[13] callbacks and bytecode rewriting, and works with any standard JVM.
Finally, it produces complete traces, including weak references, events from the
Java Native Interface and sun.misc.Unsafe, and VM start up objects. In this
paper we also explore the general design space of tracing tools, and carefully
define the execution model that the traces represent.},
} 

@inproceedings{rich00,
author = {Nicolas Richer and Marc Shapiro},
title = {The Memory Behaviour of the {WWW}, or The {WWW} Considered as a Persistent Store},
pages = {136--146},
crossref = {POS00}
}

@phdthesis{rich02,
title = {Strat\'{e}gies de Gestion M\'{e}moire dans les M\'{e}moires d'Objets Persistantes Automatiques Partitionn\'{e}es},
author = {Nicolas Richer},
month = may,
year = 2002,
school = {Universit\'{e} Pierre et Marie Curie --- Paris VI}
}

@article{rich00a,
author = {Jeffrey Richter},
title = {Garbage Collection: Automatic Memory Management in the {M}icrosoft {.NET} Framework},
journal = {MSDN Magazine},
publisher = {Microsoft},
volume = 15,
number = 11,
month = nov,
year = 2000,
pages = {82--92},
URL = {http://msdn.microsoft.com/msdnmag/issues/1100/GCI/GCI.asp}
}

@article{rich00b,
author = {Jeffrey Richter},
title = {Garbage Collection -- Part 2: Automatic Memory Management in the {M}icrosoft {.NET} Framework},
journal = {MSDN Magazine},
publisher = {Microsoft},
volume = 15,
number = 13,
month = dec,
year = 2000,
pages = {82--92},
URL = {http://msdn.microsoft.com/msdnmag/issues/1200/GCI2/GCI2.asp},
}

@inproceedings{rido87,
title = "Deterministic and Stochastic Modeling of Parallel Garbage Collection:
Towards Real-Time Criteria",
author = "Olivier Ridoux",
pages = "128--136",
booktitle = "14th Annual " # ISCA,
address = {Pittsburgh, PA},
month = jun,
publisher = ACM,
year = "1987"
}


@article{ripl78,
author = "G. David Ripley and Ralph E. Griswold and David R. Hanson",
title = "Performance of Storage Management in an Implementation of {SNOBOL4}",
journal = TransSWE,
publisher = ACM,
volume = "SE--4",
number = 2,
pages = "130--137",
year = 1978,
month = mar
}

@inproceedings{rits14,
title = {Exploring Garbage Collection with {H}aswell Hardware Transactional Memory},
author = {Carl G. Ritson and Tomoharu Ugawa and Richard Jones},
doi = {10.1145/2602988.2602992},
pages = {105--115},
crossref = {ISMM14},
abstract = {Intel’s latest processor microarchitecture, Haswell, adds support
for a restricted form of transactional memory to the x86 programming model. We
explore how this can be applied to three garbage collection scenarios in Jikes
RVM: parallel copying, concurrent copying and bitmap marking. We demonstrate
gains in concurrent copying speed over traditional synchronisation mechanisms of
48–101\%. We also show how similar but portable performance gains can be achieved
through software transactional memory techniques. We identify the architectural
overhead of capturing sufficient work for transactional execution as a major
stumbling block to the effective use of transactions in the other scenarios.}
}

@mastersthesis{ritz99,
author = {Tobias Ritzau},
title = {Real-Time Reference Counting for {RT}-{J}ava},
note = {Licenciate thesis. In Link\"{o}ping Studies in Science and Technology, No. 748},
school = {Link\"{o}ping University},
month = mar,
year = 1999,
URL = {http://www.ida.liu.se/~tobri/download.php4?paper=lic.pdf}
}

@inproceedings{ritz99a,
author = {Tobias Ritzau},
title = {Real-Time Reference Counting --- Automatic memory management with short and predictable interruptions},
booktitle = {Svenska Nationella Realtidsf\"{o}reningen (SNART) Conference},
address = {Link\"{o}ping},
month = aug,
year = 1999,
}

@inproceedings{ritz00,
author = {Tobias Ritzau},
title = {Real-Time Reference Counting},
booktitle = {{J}ava for Embedded Systems workshop},
address = {London},
month = may,
year = 2000,
URL = {http://www.ida.liu.se/~tobri/download.php4?paper=rtrc.pdf}
}

@inproceedings{ritz01,
author = {Tobias Ritzau},
title = {Hard Real Time Reference Counting without External Fragmentation},
booktitle = {Java Optimization Strategies for Embedded Systems (JOSES) workshop at ETAPS},
address = {Genoa, Italy},
year = 2001,
URL = {http://www.ida.liu.se/~tobri/download.php4?paper=etaps2001.ps}
}

@inproceedings{ritz02,
author = {Tobias Ritzau and Peter Fritzson},
title = {Decreasing Memory Overhead in Hard Real-Time Garbage Collection},
booktitle = {2nd International Workshop on Embedded Software (EMSOFT)},
address = {Grenoble},
editor = {A. Sangiovanni-Vincentelli and J. Sifakis},
series = LNCS,
volume = 2491,
publisher = SV,
month = oct,
year = 2002,
comment = {RT reference counting}
}

@phdthesis{ritz03,
author = {Tobias Ritzau},
title = {Memory Efficient Hard Real-Time Garbage Collection},
school = {Link\"{o}ping University},
month = may,
year = 2003,
URL = {http://www.ida.liu.se/~tobri/download.php4?paper=ritzau-thesis.pdf}
}

@manual{RNI97,
key = {Microsoft RNI, 1997},
organisation = {Microsoft Corporation},
title = {Raw Native Interface},
year = 1997,
URL = {http://www.microsoft.com/java/sdk/20/jnative/rni.htm},
note = {Microsoft's Raw Native Interface for Java}
}

@article{robe79,
title = "Code Generation and Storage Allocation for Machines with Span-Dependent Instructions",
author = "Edward L. Robertson",
journal = TOPLAS,
publisher = ACM,
year = 1979,
month = jul,
volume = 1,
number = 1,
pages = "71--83"
}

@inproceedings{robe90,
author = "Robertson, J. and M. Devarakonda",
title = "Data Cache Management Using Frequency-Based Replacement",
booktitle = SIGMETRICS,
publisher = ACM,
year = 1990
}

@inproceedings{robe02,
author = {Sven Robertz},
title = {Applying Priorities to Memory Allocation},
crossref = {ISMM02},
pages = {1--11}
}

@inproceedings{robe03,
  title =	 {Time-Triggered Garbage Collection: Robust and Adaptive
                  Real-time {GC} Scheduling for Embedded Systems},
  author =	 {Sven Gesteg\o{a}rd Robertz and Roger Henriksson},
  crossref =	 {LCTES03},
  pages =	 {93-102},
  doi =		 {10.1145/780732.780745}
}

@mastersthesis{robe03a,
title = {Flexible Automatic Memory Management for Real-time and Embedded Systems},
author = {Sven Gesteg\o{a}rd Robertz},
note = {Lic. eng. thesis},
school = {Lund University},
year = 2003
}

@article{robs71,
author = "J. M. Robson",
title = "An Estimate of the Store Size Necessary for Dynamic Storage Allocation",
journal = JACM,
publisher = ACM,
volume = 18,
number = 3,
month = jul,
year = 1971,
pages = "416--423",
doi={10.1145/321650.321658}
}

@article{robs73,
author = "J. M. Robson",
title = "An Improved Algorithm for Traversing Binary Trees Without Auxiliary
Stack",
journal = IPL,
publisher = NH,
volume = 2,
number = 1,
month = mar,
year = 1973,
pages = "12--14",
comment = {algorithm for traversing trees without a stack or mark bits},
}

@article{robs74,
author = "J. M. Robson",
title = "Bounds for some Functions Concerning Dynamic Storage Allocation",
journal = JACM,
publisher = ACM,
volume = 21,
number = 3,
month = jul,
year = 1974,
pages = "419--499",
doi={10.1145/321832.321846}
}

@article{robs77,
  author =	 "J. M. Robson",
  title =	 "A Bounded Storage Algorithm for Copying Cyclic Structures",
  journal =	 CACM,
  publisher =	 ACM,
  volume =	 20,
  number =	 6,
  month =	 jun,
  year =	 1977,
  pages =	 "431--433",
  doi =		 {10.1145/359605.359628},
  comment =	 {algorithm for copying lists without using a stack or mark
                  bits.  It differs from the moving algorithms in that the
                  altered contents of old lists are later restored to their
                  original values.},
}

@article{robs77a,
author = "J. M. Robson",
title = "Worst Case Fragmentation of First Fit and Best Fit Storage Allocation Strategies",
journal = CompJ,
publisher = BCS,
volume = 20,
number = 3,
month = aug,
year = 1977,
pages = "242--244"
}

@article{robs80,
author = "J. M. Robson",
title = "Storage Allocation is {NP}-Hard ",
journal = IPL,
publisher = NH,
volume = 11,
number = 3,
month = nov,
year = 1980,
pages = "119--125",
doi={10.1016/0020-0190(80)90124-6},
abstract = {The problem considered in this paper is that of determining,
given a store in which some blocks have already been allocated and given a
request, where this block can be allocated without producing the result that
some request/freeing sequences are now impossible to deal with.
It will be shown that this problem is NP-hard in the sense used by Garey and
Johnson (i.e. that satisfiability is Turing reducible to it) by means of a
reduction from the Knapsack problem shown to be NP.},
}

@article{roch71,
author = "Arnold Rochfeld",
title = "New {LISP} Techniques for a Paging Environment",
journal = CACM,
publisher = ACM,
volume = 14,
number = 12,
month = Dec,
year = 1971,
pages = "791--795",
}

@inproceedings{rodr96,
  title =	 "A Cyclic Distributed Garbage Collector for {N}etwork
                  {O}bjects",
  author =	 "Helena C. C. D. Rodrigues and Richard E. Jones",
  crossref =	 "WDAG96",
  pages =	 {123--140},
  doi =		 {10.1007/3-540-61769-8_9},
  URL =		 {http://www.cs.ukc.ac.uk/pubs/1996/12/content.ps.gz},
  abstract =	 "This paper presents an algorithm for distributed garbage
                  collection and outlines its implementation within the
                  Network Objects system.  The algorithm is based on a {\em
                  reference listing} scheme, which is augmented by {\em
                  partial tracing} in order to collect distributed garbage
                  cycles.  Processes may be dynamically organised into groups,
                  according to appropriate heuristics, to reclaim distributed
                  garbage cycles.  The algorithm places no overhead on local
                  collectors and suspends local mutators only briefly. Partial
                  tracing of the distributed graph involves only objects
                  thought to be part of a garbage cycle: no collaboration with
                  other processes is required.  The algorithm offers
                  considerable flexibility, allowing expediency and
                  fault-tolerance to be traded against completeness."
}

@inproceedings{rodr98,
title = {Cyclic Distributed Garbage Collection with Group Merger},
author = "Helena C. C. D. Rodrigues and Richard E. Jones",
note = {Also UKC Technical report 17--97, December 1997},
pages = {249--273},
doi={10.1007/BFb0054095},
crossref ={ECOOP98}
}

@phdthesis{rodr98a,
author = {Helena C.C.D. Rodrigues},
title = {Cyclic Distributed Garbage Collection},
school = UKC,
year = 1998,
}

@misc{rodr95,
author = {Gustavo Rodriguez-Riviera},
title = {Cyclic Distributed Garbage Collection Without Global Synchronisation},
note = {PhD preliminary examination report},
year = 1995
}

@article{rodr97,
title = {Non-intrusive Cloning Garbage Collection with Stock Operating System Support},
author = {Gustavo Rodriguez-Rivera and Vince Russo},
journal = SPE,
volume = 27,
number = 8,
month = aug,
year = 1997,
abstract = {It is well accepted that automatic garbage collection
simplifies programming, promotes modularity, and reduces development
effort. However it is commonly believed that these advantages do not
counteract the perceived price: excessive overheads, possible long
pause times while garbage collections occur, and the need to modify
existing code. Even though there are publically available garbage
collector implementations that can be used in existing programs, they
do not guarantee short pauses, and some modification of the application
using them is still required. In this paper we describe a
snapshot-at-beginning concurrent garbage collector algorithm and its
implementation. This algorithm guarantees short pauses, and can be
easily implemented on stock UNIX-like operating systems. Our results
show that our collector performs comparable to other garbage collection
implementations on uniprocessor machines and outperforms similar
collectors on multiprocessor machines. We also show our collector to be
competitive in performance with explicit deallocation. Our collector
has the added advantage of being non-intrusive. Using a dynamic linking
technique and effective root set inferencing, we have been able to
successfully run our collector even in commercial programs where only
the binary executable and no source code is available. In this paper we
describe our algorithm, its implementation, and provide both an
algorithmic and a performance comparison between our collector and
other similar garbage collectors.}
}

@inproceedings{rodr97a,
author = {Gustavo Rodriguez-Riviera and Vince Russo},
title = {Cyclic Distributed Garbage Collection Without Global Synchronization in {CORBA}},
crossref = "OOPSLA97-gc",
URL = {http://www.cs.purdue.edu/homes/grr/backtracing.ps}
}

@inproceedings{rodr98b,
author = {Gustavo Rodriguez-Rivera and Michael Spertus and Charles Fiterman},
title = {A Non-Fragmenting, Non-Moving Garbage Collector},
pages = {79--85},
crossref = {ISMM98},
abstract = {One of the biggest disadvantages of non-copying collectors compared
to copying collectors has been their limited ability to deal with memory
fragmentation. In this paper, we describe two techniques to reduce
fragmentation without the need of copying live data. The first technique
reduces internal fragmentation in BiBOP (Big Bag of Pages) like
allocators. The second technique reduces external fragmentation using
virtual memory calls available in most modern operating systems. It
can also reduce the size of the heap after periods of great activity in
long lived applications. These techniques have been successfully used
in Geodesic Systems' Great Circle, a commercially-available
conservative garbage collector. This paper describes these techniques,
their implementation, and some experimental results. }
}

@inproceedings{rodr00,
author = {Gustavo Rodriguez-Rivera and Mike Spertus and Charles Fiterman},
title = {Conservative Garbage Collection for General Memory Allocators},
pages = {71--79},
crossref = {ISMM2000},
abstract = { This paper explains a technique that allows the use of conservative garbage
collection on general memory allocators. This is possible by using two data
structures named malloc-tables and jump-tables that are computed at
garbage collection time to map pointers to beginning of objects and their
sizes. This paper describes malloc-tables and jump-tables, an
implementation of a malloc/jump-table based conservative garbage
collector for Doug Lea's memory allocator, and experimental results that
compare this implementation with Boehm-Demers-Weiser's GC, a
state-of-the-art conservative garbage collector.  }
}

@article{roh09,
title = {A Phase-Adaptive Garbage Collector Using Dynamic Heap Partitioning and
Opportunistic Collection},
author = {Yangwoo Roh and Jaesub Kim and Kyu Ho Park},
journal = {IEICE Transactions on Information and Systems},
volume = {E92-D},
number = 10,
year = 2009,
month = oct,
pages = {2053--2063},
abstract = {Applications usually have their own phases in heap memory usage.
The traditional garbage collector fails to match various application phases
because the same heuristic on the object behavior is used throughout the entire
execution. This paper introduces a phase-adaptive garbage collector which
reorganizes the heap layout and adjusts the invocation time of the garbage
collection according to the phases. The proposed collector identifies phases by
detecting the application methods strongly related to the phase boundaries. The
experimental results show that the proposed phase-adaptive collector
successfully recognizes application phases and improves the garbage collection
time by as much as 41\%.}
}

@inproceedings{roje92,
title = "A Concurrent Generational Garbage Collector for a Parallel Graph Reducer",
author = {Niklas R\"{o}jemo},
crossref = "IWMM92",
pages = {440--453},
doi = {10.1007/BFb0017206}
}

@techreport{roje93,
author = {Niklas R\"{o}jemo},
title = "Generational Garbage Collection is Leak-Prone",
institution = "Department of Computer Science, Chalmers University",
month = jan,
year = 1993,
type = "Draft paper"
}

@inproceedings{roje94,
author = {Niklas R\"{o}jemo},
title = "nhc: A Space-Efficient Haskell Compiler",
booktitle = "Workshop on Implementation of Functional Languages",
address = "School of Information Systems, Univ. of East Anglia, Norwich",
month = sep,
year = 1994
}

@inproceedings{roje95,
title = "Generational Garbage Collection Without Temporary Space Leaks for Lazy
Functional Languages",
author = {Niklas R\"{o}jemo},
crossref = "IWMM95",
pages = {145--162},
doi = {10.1007/3-540-60368-9_22}
}

@phdthesis{roje95a,
title = "Garbage Collection, and Memory Efficiency, in Lazy Functional Languages",
author = {Niklas R\"{o}jemo},
school = "Chalmers University of Technology, Goteborg, Sweden",
year = 1995,
abstract =
"Automatic memory management is an important concept in many high order
languages. It improves productivity by abstracting away from memory management,
but it is not free! The cost can sometimes be much higher than the programmer
thought. This is especially true for lazy functional languages where it is not
always obvious when things are evaluated. This thesis describes two ways to
decrease the overhead. Faster garbage collectors and tools to aid programmers
writing more efficient programs.

The first two papers are examples of improved garbage collectors. One is
intended for a parallel machine, the other is for sequential machines. Both use
generational garbage collectors to decrease the garbage collection time.
Neither of them need the usual test-before-update used in other generational
collectors. The test could be avoided by taking advantage of the fact that only
redexes are updated in functional languages, and then only after they have been
evaluated.

The third paper describes an extended version of heap profiling. This is a tool
that helps programmers produce more memory efficient programs. In the extended
version not only static information can be profiled, but also some dynamic
properties can be observed. This aids the programmer in writing even faster and
more space efficient programs. The gain in speed can be higher than using an
infinitely fast garbage collector, since also the time to allocate the memory
goes away.

The last two papers are examples of memory efficient implementations. The first
of these papers describes a fast and space efficient implementation of parsing
combinators, the second gives an overview of a Haskell compiler.  This Haskell
compiler is not only written in a memory efficient manner, it also tries to
produce space efficient code. Some of the methods to decrease memory usage in
the compiler can be used in other lazy functional programs, not only compilers."
}

@inproceedings{roje95b,
title = {Highlights from nhc -- a space-efficient {H}askell compiler},
author = {Niklas R\"{o}jemo},
crossref = {FPCA95},
URL = {ftp://ftp.cs.chalmers.se/pub/users/rojemo/fpca95.ps.gz},
abstraxt = {Self-compiling implementations of Haskell, i.e., those written in
Haskell, have been and, except one, are still space consuming
monsters.  Object code size for the compilers themselves are 3-8Mb,
and they need 12-20Mb to recompile themselves.  One reason for the
huge demands for memory is that the main goal for these compilers is
to produce fast code.  However, the compiler described in this paper,
called "nhc" for "Nearly a Haskell Compiler", is the one above
mentioned exception.  This compiler concentrates on keeping memory
usage down, even at a cost in time.  The code produced is not fast,
but nhc is usable, and the resulting programs can be run on computers
with small memory.
This paper describes some of the implementation choices done, in the
Haskell part of the source code, to reduce memory consumption in nhc.
It is possible to use these also in other Haskell compilers with no,
or very small, changes to their run-time systems.
Time is neither the main focus of nhc nor of this paper, but there is
nevertheless a small section about the speed of nhc.  The most notable
observation concerning speed is that nhc spends approximately half the
time processing interface files, which is much more than needed in the
type checker.  Processing interface files is also the most space
consuming part of nhc in most cases.  It is only when compiling source
files with large sets of mutually recursive functions that more memory
is needed to type check than to process interface files.}
}

@inproceedings{roje96,
title = "Lag, drag, void, and use: heap profiling and space-efficient compilation revisited",
author = {Niklas R\"{o}jemo and Colin Runciman},
URL = {http://www.cs.york.ac.uk/~colin/papers/icfp96.ps.gz},
crossref = "ICFP96",
pages = "34--41"
}

@incollection{rons98,
author = {M. Ronsse and De Bosschere, K.},
title = {{JiT}I: Tracing Memory References for Data Race Detection},
booktitle = {Parallel Computing: Fundamentals, Applications and New Directions},
volume = 12,
pages = {327--334},
series = {Advances in Parallel Computing},
month = feb,
year = 1998,
publisher = NH,
editor = {D'Hollander, E. and Joubert, F.J. and Trottenberg, U.},
URL = {http://www.elis.rug.ac.be/~ronsse/diota/doc/Parco97.ps}
}

@inproceedings{rose92,
title = "Integrating the {Scheme} and {C} Languages",
author = "John H. Rose and Hans Muller",
crossref = "LFP92",
pages = "247--259",
comment = "
Uses Scheme as a control and prototyping language.
Concervative garbage collector, functions callable both ways, header
files, etc."
}

@inproceedings{rose87,
author = "John Rosenberg and J. L. Keedy",
title = "Object Management and Addressing in the {MONADS} Architecture",
crossref = "POS87",
}

@inproceedings{rose90,
title = "Stability in a Persistent Store Based on a Large Virtual Memory",
author = "J. Rosenberg and F. A. Henskens and A. L. Brown and Ron Morrison and David
 Munro",
year = 1990,
booktitle = "International Workshop on Architectural Support for Security and Pe
rsistence of Information",
publisher = "Springer Verlag and the British Computer Society",
pages = {229--245}
}

@inproceedings{rose91,
author = "John Rosenberg",
title = "Architectural Support for Persistent Objects",
pages = "48--60",
crossref = "IWOOOS91",
}

@article{ross67,
author = "D. T. Ross",
title = "The {AED} Free Storage Package",
journal = CACM,
publisher = ACM,
volume = 10,
number = 8,
month = Aug,
year = 1967,
pages = "481--492",
comment = {Memory is split into zones. Different zones can be anaged differently.
Ross says that automatic collection in zones is inefficient. No mechanism to
handle inter-zonal pointers.}
}

@inproceedings{ross83,
title = "A Garbage Collecting Associative Memory for Interactive Database
Systems",
author = "R. A. Ross",
pages = "109--123",
booktitle = "European Conference on Integrated Interactive Computing Systems
(ECICS)",
address = {Stresa, Italy},
month = sep,
editor = "P. Degano and E.  Sandewall",
publisher = ENH,
year = 1983
}

@inproceedings{roth98,
  title =	 {Dependence Based Prefetching for Linked Data Structures},
  author =	 {Amir Roth and Andreas Moshovos and Gurindar S. Sohi},
  crossref =	 {ASPLOS98},
  pages =	 {115-126},
  doi =		 {10.1145/291069.291034}
}

@inproceedings{roth98a,
  author =	 {David J. Roth and David S. Wise},
  title =	 {One-bit Counts between Unique and Sticky},
  pages =	 {49--56},
  crossref =	 {ISMM98},
  doi =		 {10.1145/286860.286866},
  abstract =	 {Stoye's one-bit reference tagging scheme can be extended to
                  local counts of two or more via two strategies. The first,
                  suited to pure register transactions, is a cache of
                  referents to two shared references.  The analog of Deutch's
                  and Bobrow's multiple-reference table, this cache is
                  sufficient to manage small counts across successive
                  assignment statements. Thus, accurate reference counts above
                  one can be tracked for short intervals, like that bridging
                  one function's environment to its successor's.  The second,
                  motivated by runtime stacks that duplicate references,
                  avoids counting any references from the stack. It requires a
                  local pointer-inversion protocol in the mutator, but one
                  still local to the referent and the stack frame. Thus, an
                  accurate reference count of one can be maintained regardless
                  of references from the recursion stack. }
}

@techreport{rous75,
author = "P. Roussel",
title = {Prolog: Manuel de R\'{e}f\'{e}rence et d'Utilisation},
institution = {G.I.A. Universit\'{e} Aix-Marseille},
year = 1975,
comment = "The first Prolog interpreter.",
}

@techreport{rovn85,
author = "Paul Rovner",
title = "On Adding Garbage Collection and Runtime Types to a Strongly-Typed,
Statically-Checked, Concurrent Language",
type = "Technical Report",
number = "CSL--84--7",
institution = PARC,
month = Jul,
year = 1985,
comment = "Reference counting can be useful for its immediacy, for
instance in {\it finalisation}, performing `clean-up' actions when objects die
(like closing files).
Developers using Mesa spend 40 percent of their development time implementing memory
management procedures and debugging errors related to explicit
storage re otoo93d"
}

@techreport{rovn85a,
author = "Paul Rovner and Roy Levin and John Wick",
title = "On Extending {M}odula-2 for Building Large, Integrated Systems",
institution = DECSRC,
address = "Palo Alto, CA",
year = 1985,
number = 3
}

@article{roy98,
author = {P. Roy and S. Seshadri and A. Silberschatz and S. Sudarshan and S. Ashwin},
title = {Garbage Collection in Object-Oriente Databases using Transactional Cyclic Reference Counting},
journal = {{VLDB} Journal: Very Large Databases},
volume = 7,
number = 3,
pages = {129--193},
year = 1998
}

@article{ruby87,
title = "Liveness Property of a Parallel Algorithm",
author = "J. Ruby",
journal = IPL,
publisher = NH,
volume = 24,
number = 4,
pages = "275--277",
year = "1987",
abstract = {The DMLSS algorithm is a well-known algorithm for concurrent
garbage collection in a LISP-like environment.  A number of proofs of its
safety and liveness properties have appeared since the algorithm was
published
in 1975.  The author presents a new proof of a liveness property of the
algorithm.}
}

@inproceedings{ruda86,
author = "M. Rudalics",
title = "Distributed Copying Garbage Collection",
crossref = "LFP86",
pages = "364--372"
}

@techreport{ruda90,
author = "M. Rudalics",
title = {Correctness of Distributed Garbage Collection Algorithms},
number = {90--40.0},
institution = {Johannes Kepler Universit\"{a}t, Linz},
year = 1990
}

@inproceedings{ruf00,
  author =	 {Erik Ruf},
  title =	 {Effective Synchronization Removal for {Java}},
  crossref =	 {PLDI00},
  pages =	 {208-218},
  doi =		 {10.1145/349299.349327},
  comment =	 {Escape analysis based on type unification; \cite{stee00}
                  says it's fast}
}

@phdthesis{rugg87,
author = "Christina Ruggieri",
title = "Dynamic Memory Allocation Techniques Based on the Lifetimes of Objects",
school = Purdue,
address = "West Lafayette, IN",
year = 1987,
month = aug
}

@inproceedings{rugg88,
author = "Christina Ruggieri and Thomas P. Murtagh",
title = "Lifetime Analysis of Dynamically Allocated Objects",
crossref = "POPL88",
pages = {285--293},
doi = {10.1145/73560.73585}
}

@techreport{runc92,
title = "Heap Profiling of Lazy Functional Programs",
author = "Colin Runciman and David Wakeling",
institution = "University of York",
number = "YCS-92-172",
URL = "ftp://ftp.cs.york.ac.uk/reports/YCS-92-172.ps.Z",
year = 1992
}

@article{runc93,
title = "Heap Profiling of Lazy Functional Programs",
author = "Colin Runciman and David Wakeling",
journal = JFP,
volume = 3,
number = 2,
pages = {217--245},
month = apr,
publisher = CUP,
URL = {http://www.cs.york.ac.uk/~colin/papers/jfp93hp.ps.gz},
year = 1993
}

@inproceedings{runc93a,
title = "Heap Profiling of a Lazy Functional Compiler",
author = "Colin Runciman and David Wakeling",
pages = {203--214},
crossref = "glasgow93",
URL = {http://www.cs.york.ac.uk/~colin/papers/ayr92.ps.gz},
}

@techreport{runc95,
title = "New Dimensions in Heap Profiling",
author = "Colin Runciman",
institution = "University of York",
number = "YCS-95-256",
URL = "ftp://ftp.cs.york.ac.uk/reports/YCS-95-256.ps.Z",
year = 1995
}

@inproceedings{runc95a,
title = {Lag, Drag and Post-Mortem Heap Profiling},
author = {Colin Runciman and Niklas R\"{o}jemo},
booktitle = {Implementation of Functional Languages Workshop},
address = {B\o{a}stad, Sweden},
month = sep,
year = 1995
}

@article{runc96,
title = "New Dimensions in Heap Profiling",
author = "Colin Runciman",
journal = JFP,
volume = 6,
number = 4,
pages = {587--620},
URL = {http://www.cs.york.ac.uk/~colin/papers/jfp96nd.ps.gz},
year = 1996
}

@inproceedings{runc96a,
title = {Heap Profiling for Space Efficiency},
author = {Colin Runciman and Niklas R\"{o}jemo},
booktitle = {2nd International School on Advanced Functional Programming},
editor = {J. Launchbury and E. Meijer and T. Sheard},
address = {Olympia, WA},
publisher = SV,
series = LNCS,
volume = 1129,
month = aug,
URL = {http://www.cs.york.ac.uk/~colin/papers/advfp96.ps.gz},
pages = "34--41",
year = 1996
}

@inproceedings{runc96b,
title = {Two-pass Heap Profiling -- a Matter of Life and Death},
author = {Colin Runciman and Niklas R\"{o}jemo},
booktitle = {Selected Papers from the 8th International Workshop on the Implementation of Functional Languages},
editor = {W. Kluge},
address = {Bonn-Bad-Godesberg},
publisher = SV,
series = LNCS,
volume = 1168,
month = sep,
URL = {http://www.cs.york.ac.uk/~colin/papers/advfp96.ps.gz},
pages = {222-232},
year = 1996
}

@inproceedings{runc01,
author = {Colin Runciman},
title = {Heap Profiling for Theoreticians},
crossref = {SPACE01},
note = {Invited talk}
}

@article{russ77,
author = "D. L. Russell",
title = "Internal Fragmentation in a Class of Buddy Systems",
journal = "{SIAM} J. Comput.",
volume = 6,
number = 4,
month = dec,
year = 1977,
pages = "607--621"
}

@article{russ94,
author = "David M. Russinoff",
title = "A Mechanically Verified Incremental Garbage Collector",
journal = "Formal Aspects of Computing",
volume = 6,
number = 4,
pages = "359--390",
publisher = SV,
year = 1994,
comment = "Uses Boyer-Moore theorem proved to prove Ben-Ari's on-the-fly
algorithm. Ben-Ari's original proof was wrong, and was repeated by Pixley.",
doi = {10.1007/BF01211305}
}

@inproceedings{russ91,
author = "Vincent F. Russo",
title = "Garbage Collecting and Object-Oriented Operating System Kernel ",
crossref = "OOPSLA91-gc",
}

@inproceedings{ryu98,
title = {Garbage Collection for Distributed Persistent Objects},
author = {Sung-Wook Ryu and B. Clifford Neuman},
booktitle = {Workshop on Compositional Software Architectures},
address = {Monterey, CA},
month = jan,
year = 1998,
URL = {http://www.objs.com/workshops/ws9801/papers/paper015.html}
}

@inproceedings{sach03,
title = {{M}ark{C}opy: Fast Copying {GC} with Less Space Overhead},
author = {Narendran Sachindran and Eliot Moss},
crossref = {OOPSLA03},
pages = {326--343},
doi = {10.1145/949305.949335}
}

@inproceedings{sach04,
title = {$\textnormal{MC}^2$: High-Performance Garbage Collection for Memory-Constrained Environments},
author = {Narendran Sachindran and J. Eliot B. Moss and Emery D. Berger},
pages = {81--98},
crossref = {OOPSLA04},
doi={10.1145/1028976.1028984},
URL = {http://www.cs.umass.edu/~emery/pubs/04-15.pdf},
abstract = {Java is becoming an important platform for
memory-constrained consumer devices such as PDAs and cellular phones,
because it provides safety and portability. Since Java uses garbage
collection, efficient garbage collectors that run in constrained memory
are essential. Typical collection techniques used on these devices are
mark-sweep and mark-compact. Mark-sweep collectors can provide good
throughput and pause times but suffer from fragmentation. Mark-compact
collectors prevent fragmentation, have low space overheads, and provide
good throughput. However, they cannot be made fully incremental and so
can suffer from long pause times.

Copying collectors can provide higher throughput than either of these
techniques, but because of their high space overhead, they previously
were unsuitable for memory-constrained devices. This paper presents
$\textnormal{MC}^2$ (Memory-Constrained Copying), a copying,
generational garbage collector that meets the demands of
memory-constrained devices with soft real-time requirements.
$\textnormal{MC}^2$ has low space overhead and tight space bounds,
prevents fragmentation, provides good throughput, and yields short
pause times. These qualities make $\textnormal{MC}^2$ also attractive
for other environments, including desktop and server systems.}
}

@inproceedings{sagi99,
author = {M. Sagiv and T. Reps and R. Wilhelm},
title = {Parametric Shape Analysis via 3-valued Logic},
crossref = {POPL99},
note = {statically analyse heap paths}
}

@inproceedings{sago04,
title = {Message Analysis-Guided Allocation and Low-Pause Incremental Garbage
Collection in a Concurrent Language},
author = {Konstantinos Sagonas and Jesper Wilhelmsson},
pages = {1--12},
crossref = {ISMM04},
doi={10.1145/1029873.1029875}
}

@inproceedings{sago06,
title = {Mark and Split},
author = {Konstantinos Sagonas and Jesper Wilhelmsson},
pages = {29--39},
crossref = {ISMM06},
}

@article{sago06a,
title = {Efficient Memory Management for Concurrent Programs that use Message Passing},
author = {Konstantinos Sagonas and Jesper Wilhelmsson},
journal =	 SCP,
volume =	 62,
number =	 2,
publisher =	 "Elsevier",
month =	 oct,
year =	 2006,
pages = {98-121},
doi={10.1016/j.scico.2006.02.006}
}

@techreport{sahl87,
author = "Dan Sahlin",
title = "Making Garbage Collection Independent of the Amount of Garbage",
type = "Research Report",
number = "SICS/R--87/87008",
institution = "SICS",
year = 1987,
note = {Appendix to SICS research report R86009 "Garbage collection for
Prolog based on WAM."},
abstract = "This appendix shows in detail how to make the time for the
garbage collection algorithm presented in [AHS 86] become
proportional to n log n, where n is the number of non-garbage
cells.  It is assumed that the reader is familiar with [AHS 86]
since no further presentation of the notation used is made here.
The compaction phase of that algorithm is proportional to the
amount of memory, i.e. proportional to the sum of garbage and non-
garbage.  This is unfortunate since for instance a garbage
collection using copying is just proportional to the amount of
non-garbage.  If a program generates much more garbage than non-
garbage, it might be a severe drawback of a garbage collection
algorithm to depend on the amount of garbage.  This paper shows
how to make the garbage collection in [AHS 86] independent of the
amount of garbage.",
}

@techreport{sahl91,
author = "Sahlin, Dan and Carlsson, Mats",
title = "Variable Shunting for the {WAM}",
institution = "Swedish Institute of Computer Science",
year = 1991,
type = "Research report",
number = "SICS/R91--07",
month = Mar,
abstract = "This paper describes how to extend the garbage
collection for WAM [ACHS88] so that it will shunt chains of bound
variables if possible.  Doing so has two advantages: 1. Space is
saved by making it possible to deallocate the intermediate cells.
This is particularly useful when those cells are associated with
frozen goals.  2.  Later dereferencing is speeded up by not
having to follow long variable chains.  The main complication of
this optimization is the treatment of the  trailed variables.  We
claim that all possible chains of variables are shunted by this
algorithm.  The algorithm has been implemented in SICStus Prolog,
and benchmark results are presented in this paper.
This paper is a revised version of [Sahlin89] and is meant to be
read in conjunction with [ACHS88] as the notation used is
presented there and only briefly summarized here.  The full
source code for the shunting algorithm is given in this paper."
}

@techreport{sala04,
author = {Guillaume Salagnac},
title = {Gestion Automatique de la M\'emoire Dynamique pour des Programmes {J}ava
Temps-R\'eel Embarqu\'es},
type = {Report de D.E.A.},
institution = {Universit\'e Joseph Fourier},
month = jun,
year = 2004,
URL = {http://www-verimag.imag.fr/~salagnac/recherche/rapports/salagnac-DEA.pdf}
}

@inproceedings{sala05,
author = {Guillaume Salagnac and S. Yovine and D. Garbervetsky},
title = {Fast Escape Analysis for Region-based Memory Management},
booktitle = {1st International Workshop on
Abstract Interpretation of Object-Oriented Languages (AIOOL)},
address = {Paris},
month = jan,
URL = {http://www-verimag.imag.fr/~yovine/articles/aiool05.pdf},
year = 2005
}

@mastersthesis{salc01,
author = {Alexandru Salcianu},
title = {Pointer Analysis and its Applications for {J}ava Programs},
school = MIT,
month = sep,
year = 2001,
URL = {http://www.mit.edu/people/salcianu/publications/sm-thesis.ps}
}

@mastersthesis{salk87,
author = "Jon D. Salkild",
title = "Implementation and Analysis of Two Reference Counting Algorithms",
school = "University College",
address = "London",
year = "1987",
comment = {Proves the incorrectness of the algorithm in
\cite{brow85} and suggests a way of fixing it.}
}

@techreport{sall84,
author = {Patrick Sall\'{e}},
title = {Syntaxe et S\'{e}mantique de {PLASMA} et {ALOG}},
institution = "LSI-ENSEEIHT, Toulouse",
year = 1984
}

@inproceedings{samp86,
author = "A. Dain Samples and David M. Ungar and Paul Hilfinger",
title = "{SOAR}: {S}malltalk Without Bytecodes",
crossref = "OOPSLA86",
pages = "107--118"
}

@inproceedings{samp92,
title = "Garbage Collection-Cooperative {C++}",
author = "A. Dain Samples",
crossref = "IWMM92",
pages = {315--329},
doi = {10.1007/BFb0017198}
}

@inproceedings{sanc01,
author = {Alfonso Sanchez and Lu\'{i}s Veiga and Paulo Ferreira},
title = {Distributed Garbage Collection for Wide Area Replicated Memory},
booktitle = {6th USENIX Conference on Object-Oriented
Technologies and Systems (COOTS)},
address = {San Antonio, TX},
month = jan,
year = 2001
}

@inproceedings{sand01,
author = {David Sands},
title = {Spikes and Ballast: The Algebra of Space},
crossref = {SPACE01},
URL = {http://www.cs.chalmers.se/~dave/papers/space.ps.gz}
}

@techreport{sank94,
title = "A Bibliography on Garbage Collection",
author = "Nandakumar Sankaran",
institution = "Clemson University",
month = feb,
year = 1994,
URL = "ftp://ftp.cs.clemson.edu/techreports/94-102.ps.Z",
note = "A small collection!"
}

@article{sank94a,
  title =	 "A Bibliography on Garbage Collection and Related Topics",
  author =	 "Nandakumar Sankaran",
  journal =	 SIGPLAN,
  volume =	 29,
  number =	 9,
  month =	 sep,
  pages =	 "140--148",
  year =	 1994,
  note =	 "A small collection!"
}

@inproceedings{sans91,
author = "Patrick M. Sansom",
title = "Combining Copying and Compacting Garbage Collection",
crossref = "glasgow91",
comment = "Dual-mode GC. `Lazy evaluation performs many updates which
generational GCs hate'."
}

@techreport{sans91a,
author = "Patrick M. Sansom",
title = "Dual-Mode Garbage Collection",
institution = "Department of Electronics and Computer Science, University of
Southampton",
number = "CSTR 91-07",
note = "3rd International Workshop on Implementation of
Functional Languages on Parallel Architectures",
month = jun,
URL = "ftp://ftp.dcs.gla.ac.uk/pub/glasgow-fp/authors/Patrick_Sansom/1991_dual-mode-gc_PAPER.ps.Z",
year = 1991
}

@inproceedings{sans93,
title = "Generational Garbage Collection for {H}askell",
author = "Patrick M. Sansom and Peyton Jones, Simon L. ",
crossref = "FPCA93",
doi={10.1145/165180.165195},
pages={106--116},
URL = "ftp://ftp.dcs.gla.ac.uk/pub/glasgow-fp/papers/gen-gc-for-haskell.ps.Z"
}

@techreport{sans94,
title = {Time and Space Profiling for Non-Strict, Higher-Order, Functional Languages},
author = "Patrick M. Sansom and Peyton Jones, Simon L. ",
institution = "University of Glasgow",
type = {Research Report},
number = {FP--1994--10},
year = 1994
}

@phdthesis{sans94a,
title = {Execution Profiling for Non-Strict Functional Languages},
author = "Patrick M. Sansom",
school = "University of Glasgow",
year = 1994
}

@article{sant81,
title = "On the Efficient Implementation of Retention Block-Structured Languages",
author = "di Santo, M.  and L. Nigro and W. Russo",
journal = "Int. J. Comput. Inf. Sci",
month = feb,
year = 1981,
volume = 10,
number = 1,
pages = "39--54",
abstract = {In block-structured languages, the storage associated with each
block or procedure activitation can be handled either by means of a deletion
strategy (automatic deletion on exit from the block or procedure) or by a
retention strategy (with deletion only when the storage proves
inaccessible).
The retention strategy is the more general of the two, in that it removes
all restrictions on the use of pointer, label, and procedure values. It is
also more secure, since it prevents dangling references. However, the most
widely used general purpose languages normally prefer deletion, since
retention, requiring more sophisticated storage management techniques, is
considered less efficient.
In developing techniques to implement a programming language efficiently,
the following general principle should be adhered to: Those parts of a
program which do not utilize a certain linguistic facility should not be
penalized by a significant overhead in the run-time due to the existence of
that facility in the language. In the specific case of programs
necessitating retention, this principle is of utmost importance, since a
large majority of programs run correctly in the presence of deletion. Such
programs are called well-stacking or WS programs.
From the Introduction...
There are a number of schemes in existence for implementing retention,
including the spaghetti stack of Bobrow and Wegbreit, the cacciatore
stack of Berry et al. and a garbage collector which is optimized for
a large subset of the WS programs by Berry and Sorkin. All of these
adhere to the enunciated principle only to a limited degree, since in all
cases there is some albeit small overhead distributed to all programs.
This paper describes a new implementation of retention, the
deletion-retention machine, which adheres to the principle almost
completely, certainly significantly better than any of the implementations
mentioned above. The new machine is also significantly simpler in
conception.
Simply stated, the machine follows the ALGOL 68 lifetime-checking stack
model until such time as the failure of a lifetime check indicates an
upward pointer and thus that garbage collection may be needed. At that time,
the machine switches to a garbage collection regime, using an improvement
of Berry and Sorkin's and Jonker's algorithms. After any particular
garbage collection, if all the compacted data fits the stack pattern, the
machine switches back to the ALGOL 68 model. Thus, if one's program does in
fact adhere to the stack and gives rise to no lifetime errors, no garbage
collection is ever done. No data is maintained and no checks are done that
is not already needed by a fully-checking ALGOL 68 implementation.
This clearly-written paper represents the most significant advance toward a
solution to the stated problem that this reviewer has seen. It is must
reading for anyone interested in language implementation and design.}
}

@article{sark95,
author = "Jean-Pierre Sarkis and Richie Bielak",
title = "Implementing Stacks",
journal = "Eiffel Outlook",
volume = 4,
number = 6,
pages = "6--9",
month = sep,
year = 1995
}

@inproceedings{sart08,
title = {No Bit Left Behind: Limits of Heap Data Compression},
author = {Jennifer B. Sartor and Martin Hirzel and Kathryn S. McKinley},
crossref = {ISMM08},
pages = {111--120},
doi = {10.1145/1375634.1375651},
abstract = {On one hand, the high cost of memory continues to drive
demand for memory efficiency on embedded and general purpose
computers. On the other hand, programmers are increasingly turning
to managed languages like Java for their functionality, programmability,
and reliability. Managed languages, however, are not known for their
memory efficiency, creating a tension between productivity and
performance. This paper examines the sources and types of memory
inefficiencies in a set of Java benchmarks. Although prior work has
proposed specific heap data compression techniques, they are typically
restricted to one model of inefficiency. This paper generalizes and
quantitatively compares previously proposed memory-saving approaches
and idealized heap compaction. It evaluates a variety of models
based on strict and deep object equality, field value equality,
removing bytes that are zero, and compressing fields and arrays
with a limited number and range of values. The results show that
substantial memory reductions are possible in the Java heap. For
example, removing bytes that are zero from arrays is particularly
effective, reducing the application's memory footprint by 44\% on
average. We are the first to combine multiple savings models on the
heap, which very effectively reduces the application by up to 86\%,
on average 62\%. These results demonstrate that future work should
be able to combine a high productivity programming language with
memory efficiency.}
}

@techreport{sart08a,
title = {No Bit Left Behind: The Limits of Heap Data Compression (Extended Version)},
author = {Jennifer B. Sartor and Martin Hirzel and Kathryn S. McKinley},
institution = {University of Texas at Austin},
number = {TR--08--17},
year = 2008,
URL = {http://www.cs.utexas.edu/users/jbsartor/ismm08-limits-compression.pdf}
}

@inproceedings{sart10,
author = {Sartor, Jennifer B. and Blackburn, Stephen M. and Frampton, Daniel and Hirzel, Martin and McKinley, Kathryn S.},
title = {Z-rays: Divide Arrays and Conquer Speed and Flexibility},
crossref = {PLDI10},
pages = {471--482},
doi = {10.1145/1806596.1806649},
abstract = {Arrays are the ubiquitous organization for indexed data. Throughout
programming language evolution, implementations have laid out arrays
contiguously in memory. This layout is problematic in space and time. It causes
heap fragmentation, garbage collection pauses in proportion to array size, and
wasted memory for sparse and over-provisioned arrays. Because of array
virtualization in managed languages, an array layout that consists of
indirection pointers to fixed-size discontiguous memory blocks can mitigate
these problems transparently. This design however incurs significant overhead,
but is justified when real-time deadlines and space constraints trump
performance.

This paper proposes z-rays, a discontiguous array design with flexibility and
efficiency. A z-ray has a spine with indirection pointers to fixed-size memory
blocks called arraylets, and uses five optimizations: (1) inlining the first N
array bytes into the spine, (2) lazy allocation, (3) zero compression, (4) fast
array copy, and (5) arraylet copy-on-write. Whereas discontiguous arrays in
prior work improve responsiveness and space efficiency, z-rays combine time
efficiency and flexibility. On average, the best z-ray configuration performs
within 12.7\% of an unmodified Java Virtual Machine on 19 benchmarks, whereas
previous designs have two to three times higher overheads. Furthermore, language
implementers can configure z-ray optimizations for various design goals. This
combination of performance and flexibility creates a better building block for
past and future array optimization.}
}

@mastersthesis{sati94,
author = "S. Satishkumar",
title = "Register Allocation for Accurate Garbage Collection of {C++}",
school = "Iowa State University",
month = jul,
note = "Technical report ISUTR 94--12",
year = 1994,
URL = "http://www.cs.iastate.edu/tech-reports/TR94-13.ps"
}

@inproceedings{saun74,
author = "Robert A. Saunders",
title = "The {LISP} System for the {Q--32} Computer",
pages = "220--231",
crossref = "berk74",
comment = "Uses Edwards' two pointer compactifying algorithm"
}

@article{sche88a,
author = "W. F. Schelter and M. Ballantyne",
title = "{K}yoto {C}ommon {L}isp",
journal = "AI Expert",
volume = 3,
number = 3,
pages = "75--77",
year = 1988,
comment = "AKCL conservatively marks the run-time stack rather than using a
special stack to protect objects against GC. Leaks rare if ever."
}

@article{sche88,
title = "The Implementation of a Distributed {S}malltalk",
author = "M. Schelvis and E. Bledoeg",
institution = "Oce Nederland, POB 101, 5900 MA Venlo, Netherlands",
journal = LNCS,
publisher = SV,
year = 1988,
volume = "322",
pages = "212--232"
}

@article{sche89,
title = "Incremental Distribution of Timestamp Packets --- a New Approach to
Distributed Garbage Collection",
author = "M. Schelvis",
address = "Parcplace Systems, Mt View, Ca, 94043",
journal = Sigplan,
publisher = ACM,
year = 1989,
volume = 24,
number = 10,
pages = "37--48"
}

@inproceedings{schi90,
author = "J. Schimpf",
title = "Garbage Collection for {P}rolog Based on Twin Cells",
booktitle = "2nd {NACLP} Workshop on Logic Programming Architectures and
Implementations",
publisher = MIT,
year = 1990,
URL = {http://www.icparc.ic.ac.uk/eclipse/reports/gc_naclp90.ps.gz}
}

@inproceedings{schn01,
title = {Automatic Persistent Memory Management for the {S}potless {J}ava Virtual Machine on the {P}alm Connected Organizer},
author = {Daniel Schneider and Bernd Mathiske and Matthias Ernst and Matthew Seidl},
crossref = {JVM01},
URL = {http://www.usenix.org/events/jvm01/schneider.html}
}

@inproceedings{schn06,
title = {Scalable Locality-Conscious Multithreaded Memory Allocation},
author = {Scott Schneider and Christos Antonopoulos and Dimitrios Nikolopoulos},
pages = {84--94},
crossref = {ISMM06},
}

@inproceedings{scho06,
author = {Martin Schoeberl},
title = {Real-Time Garbage Collection for {J}ava},
crossref = {ISORC06},
pages = {424--432},
URL = {http://www.jopdesign.com/doc/rtgc_sched.pdf}
}


@inproceedings{scho07,
author = {Martin Schoeberl and Jan Vitek},
title = {Garbage Collection for Safety Critical {J}ava},
crossref = {JTRES07},
pages =	{85--93},
doi = {10.1145/1288940.1288953},
comment = {http://www.jopdesign.com/doc/scjgc.pdf}
}

@inproceedings{scho08,
author = {Martin Schoeberl and Wolfgang Puffitsch},
title = {Non-Blocking Object Copy for Real-Time Garbage Collection},
crossref = {JTRES08},
pages = {77--84},
URL = {10.1145/1434790.1434802},
}

@article{scho10,
author    = {Martin Schoeberl},
title     = {Scheduling of Hard Real-Time Garbage Collection},
journal   = {Real-Time Systems},
volume    = 45,
number    = 3,
year      = 2010,
pages     = {176--213},
doi        = {10.1007/s11241-010-9095-4},
}

@article{scho10a,
author = {Schoeberl, Martin and Puffitsch, Wolfgang},
title = {Non-blocking Real-Time Garbage Collection},
journal = TECS,
volume = 10,
number = 1,
month = aug,
year = 2010,
issn = {1539-9087},
pages = {6:1--6:28},
numpages = {28},
doi = {10.1145/1814539.1814545},
publisher = ACM,
} 

@inproceedings{scho10b,
author = {Martin Schoeberl andThomas B. Preusser and Sascha Uhrig},
title = {The Embedded {J}ava Benchmark Suite {J}em{B}ench},
crossref = {JTRES10},
URL = {10.1145/1850771.1850789},
}

@techreport{scho84,
author = "R. Schooler and James W. Stamos",
title = "Proposal for a Small {S}cheme Implementation",
institution = "MIT Laboratory for Computer Science",
type = "Technical Memo",
number = "MIT/LCS/TM--267",
month = oct,
year = 1987,
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TM-267.html"
}

@article{scho67,
author = "H. Schorr and W. Waite",
title = "An Efficient Machine Independent Procedure for Garbage Collection in Various List Structures",
journal = CACM,
publisher = ACM,
volume = 10,
number = 8,
month = aug,
year = 1967,
pages = "501--506",
abstract = "Deutsch-Schorr-Waite pointer reversal algorithm."
}

@phdthesis{schm92,
author = "William J. Schmidt",
title = "Issues in the Design and Implementation of a Real-Time Garbage Collection Architecture",
year = 1992,
school = "Iowa State University",
address = "Ames, Iowa",
note = "Technical report ISUTR 92-25",
URL = "http://www.cs.iastate.edu/tech-reports/TR92-25.ps"
}

@techreport{schm92a,
author = "William J. Schmidt and Kelvin Nilsen",
title = "Experimental Measurements of a Real-Time Garbage Collection Architecture",
institution = "Iowa State University",
note = "Technical report ISUTR 92-26",
URL = "http://www.cs.iastate.edu/tech-reports/TR92-26.ps",
year = 1992
}

@inproceedings{schm94,
  author =	 "William J. Schmidt and Kelvin D. Nilsen",
  title =	 "Performance of a Hardware-Assisted Real-Time Garbage
                  Collector",
  crossref =	 "ASPLOS94",
  pages =	 "76--85",
  doi =		 {10.1145/195473.195504},
  URL =		 {http://www.newmonics.com/webroot/technologies/gc/asplos.ps}
}

@techreport{schre94,
author = "Schreiner, Wolfgang ",
institution = "Research Institute for Symbolic Computation (RISC-Linz), Johannes Kepler University",
title = "Garbage Collection on a Stack",
year = 1994,
address = "{L}inz, {A}ustria",
URL = "http://info.risc.uni-linz.ac.at:70/9/archive/reports/paralab/gcstack.dvi.Z",
month = jan
}

@techreport{schu85,
author = "Shultis, Jon.",
title = "Imminent Garbage Collection",
institution = "University of Colorado, Department of Computer Science",
year = 1985,
number = "CU-CS-305-85"
}

@inproceedings{schu94,
author = {Wolfram Schulte},
title = {Deriving Reference Count Garbage Collectors},
booktitle = {6th International Symposium on Programming
Language Implementation and Logic Programming},
pages = {102--116},
month = sep,
year = 1994
}

@techreport{schw74,
author = "Jacob T. Schwartz",
title = "More on Copy Optimization of {SETL} Programs",
number = 131,
type = "SETL Newsletter",
institution = "Courant Inst. of Mathematical Sciences, New York University",
year = 1974,
month = jun
}

@techreport{schw76,
author = "Jacob T. Schwartz",
title = "A coarser, but simpler and considerably more efficient copy optimization
technique",
number = 176,
type = "SETL Newsletter",
institution = "Courant Inst. of Mathematical Sciences, New York University",
year = 1976,
month = aug
}

@techreport{schw76a,
author = "Jacob T. Schwartz",
title = "A coarser, but simpler and considerably more efficient copy optimization",
number = 176,
type = "SETL Newsletter",
institution = "Courant Inst. of Mathematical Sciences, New York University",
year = 1976,
month = aug
}

@inproceedings{schw78,
author = "Jerald Schwarz",
title = "Verifying the Safe Use of Destructive Operations in Applicative Programs",
booktitle = "Program Transformations --- Proceedings of the 3rd International Symposium on Programming",
year = 1978,
pages = "395--411"
}

@manual{scriptx,
title = "Script{X} Architectural Overview",
label = "Kaleida",
organization = "Kaleida Labs.",
}

@techreport{seid97,
author = {Matthew L. Seidl and Benjamin Zorn},
title = {Predicting References to Dynamically Allocated Objects},
institution = {University of Colorado},
number = {CU-CS-826-97},
month = jan,
year = 1997,
URL = {http://www.cs.colorado.edu/~seidl/papers/TR-ref-pred.ps}
}

@inproceedings{seid99,
title = {Low Cost Methods for Predicting Heap Object Behavior},
author = {Matthew L. Seidl and Benjamin Zorn},
booktitle = {2nd Workshop on Feedback Directed Optimization},
pages = {83--90},
address = {Haifa, Israel},
month = nov,
year = 1999,
URL = {http://www.cs.colorado.edu/~seidl/papers/fdo.page.ps}
}

@techreport{seid99a,
title = {Implementing Heap-Object Behavior Prediction Efficiently and Effectively},
author = {Matthew L. Seidl and Benjamin Zorn},
institution = {University of Colorado},
number = {CU-CS-893-99},
month = {dec},
year = 1999,
note = {Submitted to Software - Practice and Experience},
URL = {http://www.cs.colorado.edu/~seidl/papers/TR-journal.ps}
}

@inproceedings{seli90,
author = "Robert Seliger",
title = "Extending {C++} to Support Remote Procedure Call, Concurrency,
Exception Handling and Garbage Collection",
booktitle = "Usenix {C++} Conference",
pages = "241--264",
year = 1990,
publisher = UA
}

@inproceedings{seli95,
title = "Incremental Mature Garbage Collection using the Train Algorithm",
author = "Jacob Seligmann and Steffen Grarup",
URL = "http://www.daimi.aau.dk/~beta/Papers/Train/train.ps",
pages = {235--252},
crossref = "ECOOP95",
doi={10.1007/3-540-49538-X_12},
comment = "Implements and fixes bug in the train algorithm"
}

@phdthesis{serr94,
author = "Manuel Serrano",
title = "Vers un Compilation Portable {\em et} Performante des Langages Fonctionnels",
month = dec,
year = 1994,
school = {Universit\'{e} Paris 6},
comment = "uses BDW conservative garbage collector for Scheme and ML compilers. Bigloo"
}

@inproceedings{serr96,
author = {Manuel Serrano and Marc Feeley},
title = {Storage Use Analysis and its Applications},
crossref = {ICFP96},
URL = {http://www.iro.umontreal.ca/~feeley/papers/icfp96.ps.gz}
}

@inproceedings{serr00,
title = {Understanding Memory Allocation of {S}cheme Programs},
author = {Manuel Serrano and Hans-J Boehm},
crossref = {ICFP00}
}

@inproceedings{serr09,
title = {Placement Optimization Using Data Context Collected During Garbage Collection},
author = {Mauricio J. Serrano and Xiaotong Zhuang},
pages = {69--78},
doi = {10.1145/1542431.1542442},
crossref = {ISMM09}
}

@inproceedings{sewa92,
title = "Generational Garbage Collection for Lazy Graph Reduction",
author = "Julian Seward",
crossref = "IWMM92",
pages = {200-217},
doi = {10.1007/BFb0017191}
}

@inproceedings{sewe10,
author = {Sewe, Andreas and Yuan, Dingwen and Sinschek, Jan and Mezini, Mira},
title = {Headroom-based Pretenuring: Dynamically Pretenuring Objects that Live ``Long Enough''},
crossref = {PPPJ10},
pages = {29--38},
doi = {http://doi.acm.org/10.1145/1852761.1852767},
URL =
{http://www.stg.tu-darmstadt.de/media/st/publications/headroom_based_pretenuring.pdf}
}

@inproceedings{sewe12,
 author = {Sewe, Andreas and Mezini, Mira and Sarimbekov, Aibek and Ansaloni, Danilo and Binder, Walter and Ricci, Nathan and Guyer, Samuel Z.},
 title = {{n}ew Scala() instanceof {J}ava: a Comparison of the Memory Behaviour
 of {J}ava and {S}cala Programs},
 crossref = {ISMM12},
 pages = {97--108},
 doi = {10.1145/2258996.2259010},
 abstract = {While often designed with a single language in mind, managed
 runtimes like the Java virtual machine (JVM) have become the target of not one
 but many languages, all of which benefit from the runtime's services. One of
 these services is automatic memory management. In this paper, we compare and
 contrast the memory behaviour of programs written in Java and Scala,
 respectively, two languages which both target the same platform: the JVM. We
 both analyze core object demographics like object lifetimes as well as
 secondary properties of objects like their associated monitors and identity
 hash-codes. We find that objects in Scala programs have lower survival rates
 and higher rates of immutability, which is only partly explained by the memory
 behaviour of objects representing closures or boxed primitives. Other metrics
 vary more by benchmark than language.}
}

@phdthesis{sewe12a,
author = {Sewe, Andreas},
title = {Design and Analysis of a {S}cala Benchmark Suite for the {J}ava Virtual
Machine},
school = {Technische Universit\"{a}t Darmstadt},
month = nov,
year =2012
}

@inproceedings{shah00,
author = {Ran Shaham and Elliot K.  Kolodner and Mooly Sagiv},
title = {On the Effectiveness of {GC} in {J}ava},
pages = {12--17},
URL = {http://citeseer.nj.nec.com/shaham00effectiveness.html},
crossref = {ISMM2000},
abstract = {
We study the effectiveness of garbage collection (GC) algorithms by
measuring the time difference between the actual collection time of an
object and the potential earliest collection time for that object. Our ultimate
goal is to use this study in order to develop static analysis techniques that
can be used together with GC to allow earlier reclamation of objects. The
results may also be used to pinpoint application source code that could be
rewritten in a way that would allow more timely GC. Specifically, we
compare the objects reachable from the root set to the ones that are
actually used again. The idea is that GC could reclaim unused objects even
if they are reachable from the root set. Thus, our experiments indicate a kind
of upper bound on storage savings that could be achieved. We also try to
characterize these objects in order to understand the potential benefits of
various static analysis algorithms. The Java Virtual Machine (JVM) was
instrumented to measure objects that are reachable, but not used again, and
to characterize these objects. Experimental results are shown for the
SPECjvm98 benchmark suite. The potential memory savings for these
benchmarks range from 23\% to 67\%
}
}

@inproceedings{shah01,
  title =	 {Heap Profiling for Space-Efficient {J}ava},
  author =	 {Ran Shaham and Elliot K. Kolodner and Mooly Sagiv},
  crossref =	 {PLDI01},
  pages =	 {104-113},
  doi =		 {10.1145/378795.378820}
}

@inproceedings{shah02,
title = {Estimating the Impact of Liveness Information on Space Consumption in {J}ava},
author = {Ran Shaham and Elliot Kolodner and Mooly Sagiv},
crossref = {ISMM02},
pages = {64--75}
}

@inproceedings{shah03,
title = {Establishing Local Temporal Heap Safety Properties with Applications to
Compile-Time Memory},
author = "Ran Shaham and E. Yahav and Elliot Kolodner and Mooly Sagiv",
booktitle = {Static Analysis Symposium (SAS)},
series = LNCS,
volume = 2694,
publisher = SV,
pages = {483--503},
month = jun,
year = 2003,
doi = {10.1007/3-540-44898-5_27}
}

@inproceedings{shah12,
 author = {Shahriyar, Rifat and Blackburn, Stephen M. and Frampton, Daniel},
 title = {Down For The Count?  Getting Reference Counting Back in the Ring},
 crossref = {ISMM12},
 pages = {73--84},
 doi = {10.1145/2258996.2259008},
 abstract = {Reference counting and tracing are the two fundamental approaches that have
 underpinned garbage collection since 1960. However, despite some compelling
 advantages, reference counting is almost completely ignored in implementations
 of high performance systems today. In this paper we take a detailed look at
 reference counting to understand its behavior and to improve its performance.
 We identify key design choices for reference counting and analyze how the
 behavior of a wide range of benchmarks might affect design decisions. As far as
 we are aware, this is the first such quantitative study of reference counting.
 We use insights gleaned from this analysis to introduce a number of
 optimizations that significantly improve the performance of reference counting.
We find that an existing modern implementation of reference counting has an
average 30\% overhead compared to tracing, and that in combination, our
optimizations are able to completely eliminate that overhead. This brings the
performance of reference counting on par with that of a well tuned mark-sweep
collector. We keep our in-depth analysis of reference counting as general as
possible so that it may be useful to other garbage collector implementers. Our
finding that reference counting can be made directly competitive with well tuned
mark-sweep should shake the community's prejudices about reference counting and
perhaps open new opportunities for exploiting reference counting's strengths,
such as localization and immediacy of reclamation.}
} 

@inproceedings{shah13,
author = {Shahriyar, Rifat and Blackburn, Stephen Michael and Yang, Xi and McKinley, Kathryn S.},
title = {Taking off the Gloves with Reference Counting {I}mmix},
crossref = {OOPSLA13},
pages = {93--110},
doi = {10.1145/2509136.2509527},
abstract = {Despite some clear advantages and recent advances, reference
counting remains a poor cousin to high-performance tracing garbage collectors.
The advantages of reference counting include a) immediacy of reclamation, b)
incrementality, and c) local scope of its operations. After decades of
languishing with hopelessly bad performance, recent work narrowed the gap
between reference counting and the fastest tracing collectors to within 10\%.
Though a major advance, this gap remains a substantial barrier to adoption in
performance-conscious application domains.
Our work identifies heap organization as the principal source of the remaining
performance gap. We present the design, implementation, and analysis of a new
collector, RC Immix, that replaces reference counting's traditional free-list
heap organization with the line and block heap structure introduced by the Immix
collector. The key innovations of RC Immix are 1) to combine traditional
reference counts with per-line live object counts to identify reusable memory
and 2) to eliminate fragmentation by integrating copying with reference counting
of new objects and with backup tracing cycle collection. In RC Immix, reference
counting offers efficient collection and the line and block heap organization
delivers excellent mutator locality and efficient allocation. With these
advances, RC Immix closes the 10\% performance gap, matching the performance of
a highly tuned production generational collector. By removing the performance
barrier, this work transforms reference counting into a serious alternative for
meeting high performance objectives for garbage collected languages.}
}

@mastersthesis{shan89,
author = "Shang, Heping",
title = "Consistent Global State Algorithms and an Application in Distributed Garbage Collection",
year = 1989,
school = "Concordia University, Canada"
}

@inproceedings{shan08,
title = {Jolt: Lightweight Dynamic Analysis and Removal of Object Churn},
author = {Ajeet Shankar and Matthew Arnold and Rastislav Bodik},
crossref = {OOPSLA08},
pages = {127--142},
doi = {10.1145/1449764.1449775},
abstract = {It has been observed that component-based applications
exhibit object churn, the excessive creation of short-lived objects,
often caused by trading performance for modularity. Because churned
objects are short-lived, they appear to be good candidates for stack
allocation. Unfortunately, most churned objects escape their
allocating function, making escape analysis ineffective.  We reduce
object churn with three contributions. First, we formalize two
measures of churn, capture and control (15). Second, we develop
lightweight dynamic analyses for measuring both capture and control.
Third, we develop an algorithm that uses capture and control to
inline portions of the call graph to make churned objects non-escaping,
enabling churn optimization via escape analysis.  JOLT is a lightweight
dynamic churn optimizer that uses our algorithms. We embedded JOLT
in the JIT compiler of the IBM J9 commercial JVM, and evaluated
JOLT on large application frameworks, including Eclipse and JBoss.
We found that JOLT eliminates over 4 times as many allocations as
a state-of-the-art escape analysis alone.}
}

@techreport{shap90,
author = {Marc Shapiro and Olivier Gruber and David Plainfoss\'{e}},
title = "A Garbage Detection Protocol for a Realistic Distributed Object-Support System",
institution = "INRIA-Rocquencourt",
type = "Rapports de Recherche",
number = 1320,
month = nov,
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC90/Shapiro.ps.Z",
year = 1990,
comment = "Node-group collector",
note = "Superseded by \cite{shap91}"
}

@inproceedings{shap91,
author = "Marc Shapiro",
title = "A Fault-Tolerant, Scalable, Low-Overhead Distributed Garbage
Collection Protocol",
booktitle = "10th Symposium on Reliable Distributed Systems",
address = "Pisa",
month = sep,
year = 1991,
URL = "http://www-sor.inria.fr/SOR/docs/DGC_rds91.html"
}

@inproceedings{shap92,
author = {Marc Shapiro and Peter Dickman and David Plainfoss\'{e}},
title = "Robust, Distributed References and Acyclic Garbage Collection",
booktitle = "Symposium on Principles of Distributed Computing",
address = "{V}ancouver, {C}anada",
publisher = ACM,
pages = {135--146},
month = aug,
year = 1992,
URL = "http://www-sor.inria.fr/SOR/docs/RDRAGC_podc92.html",
note = "Superseded by \cite{shap92a}"
}

@techreport{shap92a,
author = {Marc Shapiro and Peter Dickman and David Plainfoss\'{e}},
title = "{SSP} Chains: Robust, Distributed References Supporting Acyclic Garbage Collection",
institution = INRIA,
type = "Rapports de Recherche",
number = 1799,
month = nov,
year = 1992,
URL = "http://www-sor.inria.fr/SOR/docs/SSPC_rr1799.html",
note = "Also available as Broadcast Technical Report 1"
}

@inproceedings{shap92b,
author = "Marc Shapiro and Julien Maisonneuve and Pierre Collet",
title = "Implementing References as Chains of Links",
crossref = "IWOOOS92",
}

@techreport{shap93,
author = "Marc Shapiro",
title = "Flexible Bindings for Fine-Grain and Fragmented Objects in Distributed Systems",
institution = INRIA,
type = "Rapports de Recherche",
number = "2007",
year = 1993
}

@techreport{shap94,
author = "Marc Shapiro and Paulo Ferreira",
title = "Larchant--{RDOSS}: a Distributed Shared Persistent Memory and its Garbage Collector",
institution = INRIA,
month = nov,
year = 1994,
note = "Superseded by \cite{shap95}",
URL = "http://www-sor.inria.fr/SOR/docs/RDOSS_rr2399.html"
}

@inproceedings{shap94a,
author = "Shapiro, Marc and Plainfoss{\'e}, David and Ferreira, Paulo and Amsaleg, Laurent",
title = "Some Key Issues in the Design of Distributed Garbage Collection and References",
booktitle = "Unifying Theory and Practice in Distributed Systems",
year =  1994,
address = "Dagstuhl (Germany)",
month = sep,
URL = "http://www-sor.inria.fr/SOR/docs/key-issues-GC_utpdcs94.html"
}

@inproceedings{shap95,
author = "Marc Shapiro and Paulo Ferreira",
title = "Larchant--{RDOSS}: a Distributed Shared Persistent Memory and its Garbage Collector",
booktitle = "Workshop on Distributed Algorithms",
editor = {J.-M. H\'{e}lary and M. Raymond},
series = LNCS,
number = 972,
publisher = SV,
pages = "198--214",
address = "Le Mont Saint-Michel",
month = sep,
year = 1995,
URL = "http://www-sor.inria.fr/SOR/docs/LRDSPMGC_wdag95.html"
}

@inproceedings{shap97,
author = {Marc Shapiro and Sytse Kloosterman and Fabio Riccardi},
title = {{PerDiS} --- a Persistent Distributed Store for Cooperative Applications},
booktitle = {3rd Cabernet Plenary Workshop},
year = 1997,
address = {Rennes (France)},
month = apr,
URL = {ftp://ftp.inria.fr/INRIA/Projects/SOR/PPDSCA_cabernet97.ps.gz},
abstract = {The PerDiS platform deploys a novel technology for the
distributed sharing of information: a persistent distributed store,
which provides a shared memory abstraction which is tranparently made
persistent thanks to distributed garbage collection. This data sharing
platform supports interactive concurrent engineering applications in a
virtual enterprise. In this paper we give an overview of the project,
its motivation and the PerDiS platform architecture. We also address
some expected problems and related work. }
}

@inproceedings{shap00,
title = {Recent Advances in Distributed Garbage Collection},
author = {Marc Shapiro and Le Fessant, Fabrice and Paulo Ferreira},
crossref = {krak00},
pages = {104--126},
URL = {http://www-sor.inria.fr/publi/RAIDGC_lncs1752.html}
}

@inproceedings{shar91,
title = "Parallel Generational Garbage Collection",
author = "Ravi Sharma and Mary Lou Soffa",
crossref = "OOPSLA91",
pages = "16--32",
}

@techreport{shaw87,
author = "Robert A. Shaw",
title = "Improving Garbage Collector Performance in Virtual Memory",
institution = "Stanford University",
year = 1987,
number = "CSL-TR-87-323",
month = mar,
note = "Also Hewlett-Packard Laboratories report STL--TM--87--05, Palo Alto, 1987"
}

@phdthesis{shaw88,
author = "Robert A. Shaw",
title = "Empirical Analysis of a {L}isp System",
school = "Stanford University",
note = " Technical Report CSL-TR-88-351",
year = 1988,
comment = "Write barrier."
}

@article{shen74,
author = "K. K. Shen and J. L. Peterson",
title = "A Weighted Buddy Method for Dynamic Storage Allocation",
journal = CACM,
publisher = ACM,
volume = 17,
number = 10,
month = oct,
year = 1974,
pages = "558--562"
}

@inproceedings{shen04,
  author =	 {Xipeng Shen and Yutao Zhong and Chen Ding},
  title =	 {Locality Phase Prediction},
  crossref =	 {ASPLOS04},
  pages =	 {165--176},
  doi =		 {10.1145/1024393.1024414}
}

@article{shen09,
 author = {Shen, Xipeng and Mao, Feng and Tian, Kai and Zhang, Eddy Zheng},
 title = {The Study and Handling of Program Inputs in the Selection of Garbage Collectors},
 journal = {SIGOPS Operating Systems Review},
 volume = 43,
 number = 3,
 month = jul,
 year = 2009,
 issn = {0163-5980},
 pages = {48--61},
 doi = {10.1145/1618525.1618531},
 publisher = ACM,
 abstract = {Many studies have shown that the best performer among a set of
 garbage collectors tends to be different for different applications.
 Researchers have proposed application specific selection of garbage collectors.
 In this work, we concentrate on a second dimension of the problem: the
 influence of program inputs on the selection of garbage collectors. We collect
 tens to hundreds of inputs for a set of Java benchmarks, and measure their
 performance on Jikes RVM with different heap sizes and garbage collectors. A
 rigorous statistical analysis produces four-fold insights. First, inputs
 influence the relative performance of garbage collectors significantly, causing
 large variations to the top set of garbage collectors across inputs. Profiling
 one or few runs is thus inadequate for selecting the garbage collector that
 works well for most inputs. Second, when the heap size ratio is fixed, one or
 two types of garbage collectors are enough to stimulate the top performance of
 the program on all inputs. Third, for some programs, the heap size ratio
 significantly affects the relative performance of different types of garbage
 collectors. For the selection of garbage collectors on those programs, it is
 necessary to have a cross-input predictive model that predicts the minimum
 possible heap size of the execution on an arbitrary input. Finally, by
 adopting statistical learning techniques, we investigate the cross-input
 predictability of the influence. Experimental results demonstrate that with
 regression and classification techniques, it is possible to predict the best
 garbage collector (along with the minimum possible heap size) with reasonable
 accuracy given an arbitrary input to an application. The exploration opens the
 opportunities for tailoring the selection of garbage collectors to not only
 applications but also their inputs.}
} 

@inproceedings{shid14,
title = {Trash in Cache: Detecting Eternally Silent Stores},
author = {Jonathan Shidal and Zachary Gottlieb and Ron K. Cytron and Krishna M. Kavi},
crossref = {MSPC14},
doi = {10.1145/2618128.2618133},
abstract = {The gap between processing and storage speeds remains a concern for
computer system designers and application developers. This disparity can be
bridged in part by eliminating unnecessary stores, thereby reducing the amount
of traffic that flows from the processor and first-level caches to the slower
components of the storage subsystem. Reducing the "write" traffic can improve
program performance, save power, and increase the longevity of storage
components that have limited write endurance. Techniques have been proposed and
evaluated for identifying various classes of stores that can be silenced. A
relatively unexplored class of such stores are those that would write data that
is dirty, but dead. Such data appears as if it needs to be written back to
memory from cache, yet it can be proven that the application can never
subsequently access the data.
In this paper, we suggest identifying garbage (trash) in cache, so that the
dirty bytes associated with the trash need not be written to memory. We propose
and evaluate a simple technique based on reference counting that finds a subset
of these "eternally silent" (dead) stores. When applied to popular benchmarks,
our results show that a significant fraction of the writes to memory can be
silenced based on the impossibility of an application subsequently accessing the
data.}
}

@inproceedings{shin85,
author = "Heonshik Shin and Miroslaw Malek",
title = "Parallel Garbage Collection with Associative Tag",
booktitle = "{IEEE} Conference on Parallel Processing",
address = "Chicago",
publisher = IEEE,
pages = "369--375",
year = 1985
}

@article{shiv92,
author = {N.G. Shivaratri and P. Krueger and M. Singhal},
title = {Load Distributing for Locally Distributed Systems},
journal = {Computer},
volume = 25,
number = 12,
pages = {33--44},
month = dec,
year = 1992
}

@inproceedings{shiv99,
author = {O. Shivers and J.W. Clark and R. McGrath},
title = {Atomic Heap Transactions and Fine-Grain Interrupts},
crossref = {ICFP99}
}

@article{shor75,
author = "J. E. Shore",
title = "On the External Storage Fragmentation Produced by First-Fit
and Best-Fit Allocation Strategies",
journal = CACM,
publisher = ACM,
volume = 18,
number = 8,
month = aug,
year = 1975,
pages = "433--440"
}

@article{shor77,
author = "J. E. Shore",
title = "Anomalous Behavior of the Fifty-Percent Rule in Dynamic Memory Allocation",
journal = CACM,
publisher = ACM,
volume = 20,
number = 11,
month = nov,
year = 1977,
pages = "558--562"
}

@inproceedings{shuf01,
title = {Characterizing the Memory Behavior of {J}ava Workloads: A Structured View and Opportunities for Optimizations},
author = {Yefim Shuf and Mauricio Serrano and Manish Gupta and Jaswinder Pal Singh},
booktitle = SIGMETRICS,
month = jun,
year = 2001,
abstract = {This paper studies the memory behavior of important Java
workloads used in benchmarking Java Virtual Machines (JVMs), based on
instrumentation of both application and library code in a
state-of-the-art JVM, and provides structured information about these
workloads to help guide systems' design. We begin by characterizing the
inherent memory behavior of the benchmarks, such as information on the
breakup of heap accesses among different categories and on the hotness
of references to fields and methods. We then provide detailed
information about misses in the data TLB and caches, including the
distribution of misses over different kinds of accesses and over
different methods. In the process, we make interesting discoveries
about TLB behavior and limitations of data prefetching schemes
discussed in the literature in dealing with pointer-intensive Java
codes. Throughout this paper, we develop a set of recommendations to
computer architects and compiler writers on how to optimize computer
systems and system software to run Java programs more efficiently. This
paper also makes the first attempt to compare the characteristics of
SPECjvm98 to those of a server-oriented benchmark, pBOB, and explain
why the current set of SPECjvm98 benchmarks may not be adequate for a
comprehensive and objective evaluation of JVMs and just-in-time (JIT)
compilers.

We discover that the fraction of accesses to array elements is quite
significant, demonstrate that the number of "hot spots" in the
benchmarks is small, and show that field reordering cannot yield
significant performance gains.  We also show that even a fairly large
L2 data cache is not effective for many Java benchmarks. We observe
that instructions used to prefetch data into the L2 data cache are
often squashed because of high TLB miss rates and because the TLB does
not usually have the translation information needed to prefetch the
data into the L2 data cache. We also find that co-allocation of
frequently used method tables can reduce the number of TLB misses and
lower the cost of accessing type information block entries in virtual
method calls and runtime type checking}
}

@inproceedings{shuf02,
title = {Exploiting Prolific Types for Memory Management and Optimizations},
author = {Yefim Shuf and Manish Gupta and Rajesh Bordawekar and Jaswinder Pal Singh},
crossref = {POPL02}
}

@inproceedings{shuf02a,
title = {Creating and Preserving Locality of {J}ava Applications at Allocation and Garbage Collection Times},
author = {Yefim Shuf and Manish Gupta and Hubertus Franke and Andrew Appel and Jaswinder Pal Singh},
crossref = {OOPSLA02},
doi={10.1145/582419.582422},
pages={13--25},
abstract = {The growing gap between processor and memory speeds is
motivating the need for optimization strategies that improve data
locality. A major challenge is to devise techniques suitable for
pointer- intensive applications.  This paper presents two techniques
aimed at improving the memory behavior of pointer-intensive
applications with dynamic memory allocation, such as those written in
Java. First, we present an allocation time object placement technique
based on the recently introduced notion of "prolific" (frequently
instantiated) types.  We attempt to co-locate, at allocation time,
objects of prolific types that are connected via object references.
Then, we present a novel technique for traversing live objects at
garbage collection (GC) time. The benefits of this techniques are
twofold:  (i) it improves performance of GC due to better locality
during a heap traversal and (ii) it restructures surviving objects in a
way that enhances locality.  On multiprocessors, this technique can
further reduce overhead due to synchronization and false sharing. The
experimental results, on a well-known suite of Java benchmarks
(SPECjvm98, SPECjbb2000, and jOlden), from an implementation of these
techniques in the Jikes RVM, are very encouraging. The object
co-allocation technique improves application performance by up to 21\%
(10\% on average) in the Jikes RVM configured with a non-copying
mark-and-sweep collector. The locality-based traversal technique
reduces GC times by up to 20\% (10\% on average) and improves
performance of applications by up to 14\% (6\% on average) in the Jikes
RVM configured with a copying semi-space collector. Both techniques
combined can improve application performance by up to 22\% (10\% on
average) in the Jikes RVM configured with a non-copying mark-and-sweep
collector.}
}

@mastersthesis{sieb97,
author = {Fridtjof Siebert},
title = {Implementierung eines Eiffel-Compilers f\"{u}r SUN/SPARC},
school = {Universitaet Stuttgart},
year = 1997,
URL = {http://www.fridi.de/rts/papers/da97_fsiebert.pdf},
note = {Diplomarbeit 1484. In German}
}

@inproceedings{sieb98,
author = {Fridtjof Siebert},
title = {Guaranteeing Non-Disruptiveness and Real-Time Deadlines in an Incremental Garbage Collector},
pages = {130-137},
crossref = {ISMM98},
abstract = {For Garbage Collection (GC) to be a generally accepted means of
memory management it is required to prove its efficiency. This paper
presents a scheme that guarantees that an incremental Garbage
Collector will have completed its collection cycle before the system
runs out of memory. Furthermore, it is shown that the work that has to
be done by the collector in one incremental step is limited by a small
constant depending on the percentage of total memory used by the
application program. This result then allows a suitable trade-off
between memory demand and GC overhead to be found. },
doi = {10.1145/286860.286874},
URL = {http://www.fridi.de/rts/papers/ismm98_fsiebert.pdf}
}

@inproceedings{sieb99,
author = {Fridtjof Siebert},
title = {Real-Time Garbage Collection in Multi-Threaded Systems on a Single Processor},
booktitle = {20th IEEE Real-Time Systems Symposium (RTSS)},
address = {Phoenix, AZ},
pages =	 {277-278},
abstract = {We show the difficulties that arise for the implementation
of a real-time garbage collector in a multi-threaded system. A
mechanism for synchronization between threads and the garbage collector
activities is proposed for a single processor system. It is shown how
this mechanism can be used to maintain exact information on roots, to
implement efficient write-barriers, to do incremental or even
constant-time root-scanning and to guarantee short pre-emption time of
garbage collector activity.  Special aspects of an implementation for
Java that are affected by this mechanism will also be addressed.
Finally, experimental data is presented to show that the proposed
mechanisms can efficiently be used in real programs.},
URL = {http://www.fridi.de/rts/papers/rtss99_fsiebert_long.pdf},
doi = {10.1109/REAL.1999.818854},
month = dec,
year = 1999
}

@inproceedings{sieb99a,
author = {Fridtjof Siebert},
title = {Hard Real-Time Garbage Collection in the {J}amaica {V}irtual {M}achine},
crossref = {RTCSA99},
doi={10.1109/RTCSA.1999.811198},
pages = {96--102},
abstract = {Java's automatic memory management is the main reason that
prevents Java from being used in hard real-time
environments. We present the garbage collection mechanism that is
used by the Jamaica Virtual Machine, an implementation of the Java
Virtual Machine Specification. This mechanism differs
significantly from existing implementations in the way threads are
implemented, root references are found and in the object layout
that is used. The implementation provides hard real-time
guarantees while it allows unrestricted use of the Java language.
Even dynamic allocation of normal garbage-collected Java objects
is possible with hard real-time guarantees.},
URL = {http://www.fridi.de/rts/papers/rtcsa99_fsiebert.pdf},
}

@inproceedings{sieb00,
author = {Fridtjof Siebert},
title = {Eliminating External Fragmentation in a Non-Moving Garbage Collector for {J}ava},
booktitle = {Compilers, Architecture, and Synthesis for Embedded Systems (CASES)},
publisher = ACM,
pages={9--17},
address = {San Jose, CA},
month = nov,
year = 2000,
abstract = {Fragmentation can cause serious loss of memory in systems
that are using dynamic memory management. Any useful memory management
system must therefore provide means to limit fragmentation. Today's
garbage collector implementations often do this by moving objects in a
way that free memory is non-fragmented. This paper presents a new
object model that is based on fixed size blocks. The model eliminates
external fragmentation without the need to move objects. A Java virtual
machine and a static Java bytecode compiler that use this object model
have been implemented and analysed using the SPECjvm98 benchmark suite.
This Java implementation allows for deterministic memory management as
needed in real-time systems that is difficult to achieve with moving
collectors and unparalleled by current implementations.},
URL = {http://www.aicas.com/papers/cases2000_fsiebert.pdf},
doi = {10.1145/354880.354883}
}

@inproceedings{sieb01,
author = {Fridtjof Siebert and Andy Walter},
title = {Deterministic Execution of {J}ava's Primitive Bytecode Operations},
crossref = {JVM01},
abstract = {For the application of Java in realtime and safety critical
domains, an analysis of the worst-case execution times of primitive
Java operations is necessary. All primitive operations must either
execute in constant time or have a reasonable upper bound for their
execution time. The difficulties that arise for a Java virtual machine
and a Java compiler in this context will be presented here. This
includes the implementation of Javas class and interface model, class
initialization, monitors and automatic memory management.A new Java
virtual machine and compiler that solves these difficulties has been
implemented and its performance has been analysed.},
URL = {http://www.aicas.com/papers/jvm01_siebert_walter.pdf}
}

@inproceedings{sieb01a,
author = {Fridtjof Siebert},
title = {Constant-Time Root Scanning for Deterministic Garbage Collection},
crossref = {CC01},
abstract = {Root scanning is the task of identifying references to heap
objects that are stored outside of the heap itself, in global and local
variables and on the execution stack. Root scanning is particularly
difficult within an incremental garbage collector that needs to be
deterministic or give hard real-time guarantees. Here, a method that
allows exact root scanning is presented. The basic idea is to ensure
that copies of all root references exist on the heap whenever the
garbage collector might become active. This approach reduces the root
scanning phase of the garbage collection cycle to an efficient
constant-time operation. A Java virtual machine and a static Java
byte-code compiler that use this technique have been implemented and
analysed using the SPECjvm98 benchmark suite. This Java implementation
allows for deterministic memory management as needed in real-time
systems that is difficult to achieve with traditional methods to
perform root scanning.},
URL = {http://www.aicas.com/papers/cc01_fsiebert.pdf}
}

@book{sieb02,
author = {Fridtjof Siebert},
title = {Hard Realtime Garbage Collection in Modern Object Oriented Programming Languages},
publisher ={aicas Books},
pages = 252,
year = 2002
}

@inproceedings{sieb04,
author = {Fridtjof Siebert},
title = {The Impact of Realtime Garbage Collection on Realtime {J}ava
Programming},
crossref = {ISORC04},
pages = {33--40},
}

@inproceedings{sieb07,
  author =	 {Fridtjof Siebert},
  title =	 {Realtime Garbage Collection in the {J}amaica{VM} 3.0},
  crossref =     {JTRES07},
  pages =	 {94--103},
  doi =		 {10.1145/1288940.1288954},
  publisher =	 ACM,
}


@inproceedings{sieb08,
author = {Fridtjof Siebert},
title = {Limits of Parallel Marking Collection},
crossref = {ISMM08},
pages = {21--29},
doi = {10.1145/1375634.1375638},
abstract = {More and more, parallel multicore systems will be used
even in low-end devices such as embedded controllers that require
realtime guarantees. When garbage collection is used in these
systems, parallel or concurrent garbage collection brings important
performance advantages. In the context of realtime systems, it has
to be shown that a parallel garbage collector implementation not
only performs well in most cases, but guarantees on its performance
in the worst case are required.  This paper analyses the difficulties
a parallel mark-and-sweep garbage collector faces during a parallel
mark phase. The performance of such a garbage collector degrades
when only some of the available processors can perform scanning
work in the mark phase. Whenever the grey set contains fewer elements
than the number of available processors, some processors may be
stalled waiting for new objects to be added to the grey set. This
paper gives an upper bound for the number of stalls that may occur
as a function of simple properties of the memory graph.  This upper
bound is then determined for the Java applications that are part
of the SPECjvm98 benchmark suite and the theoretical worst-case
scalability of a parallel mark phase is analysed. The presented
approach is then applied to a Java virtual machine that has uniform
mark steps, which at first results in poor worst-case scalability.
A small change in the implementation is then proposed and analysed
to achieve good scalability even in the worst case.}
}

@inproceedings{sieb10,
author = {Siebert, Fridtjof},
title = {Concurrent, Parallel, Real-Time Garbage-Collection},
crossref = {ISMM10},
pages = {11--20},
doi = {10.1145/1806651.1806654},
abstract = {With the current developments in CPU implementations, it becomes
obvious that ever more parallel multicore systems will be used even in embedded
controllers that require real-time guarantees. When garbage collection is used
in these systems, parallel and concurrent garbage collection brings important
performance advantages in the average case. In a real-time system, however,
guarantees on the GC's performance in the worst case are required.

This paper explains how the single-CPU real-time GC of the Java implementation
JamaicaVM was changed to make it a hard real-time garbage collector that is
parallel and concurrent. Parallel means that an arbitrary number of CPUs may
perform GC work in parallel, while concurrent means that the GC work can be
performed concurrently to the application code without pre-empting the
application. In addition, the single units of work that this garbage collector
has to perform are very small and uniform and the total amount of GC work is
bounded by a function of the heap size, such that it becomes possible for any
application that has a bounded amount of reachable memory to run the GC work
such that sufficient GC progress can be ensured for the application never to run
out of heap space.}
}

@incollection{sieb12,
title = {Parallel Real-Time Garbage Collection},
author = {Fridtjof Sebert},
booktitle = {Distributed, Embedded and Real-time Java Systems},
chapter = 4,
pages = {79--99},
year = 2012,
publisher = {Springer},
doi = {10.1007/978-1-4419-8158-5_4},
abstract = {With the current developments in CPU implementations, it becomes
obvious that ever more parallel multicore systems will be used even in embedded
controllers that require real-time guarantees. When garbage collection is used
in these systems, parallel and concurrent garbage collection brings important
performance advantages in the average case. In a real-time system, however,
guarantees on the GC’s performance in the worst case are required. This chapter
explains the basic concepts for parallel real-time garbage collectors, the major
real-time Java virtual machine implementations and their approach to parallel
real-time memory management. Two implementations, Metronome-TS and JamaicaVM
will be presented in more detail since these two represent two typical instances
of the time-based and work-based approaches of running the garbage collector. A
discussion at the end of this chapter will compare the fundamental differences
in the presented approaches. A final section on related work puts the presented
implementations into a wider context on current garbage collection research.}
}

@inproceedings{sieg06,
title = {Improving Locality With Parallel Hierarchical Copying {GC}},
author = {David Siegwart and Martin Hirzel},
pages = {52--63},
crossref = {ISMM06},
doi = {10.1145/1133956.1133964}
}

@article{sikl72,
author = "L. Siklossy",
title = "Fast and Readonly Algorithms for Traversing Trees Without an Auxiliary Stack",
journal = IPL,
publisher = NH,
volume = 1,
number = 4,
month = jun,
year = 1972,
pages = "149--152",
comment = {algorithm for traversing trees without a stack or mark bits},
}

@inproceedings{sing06,
  title =	 {Visualized Adaptive Runtime Subsystems},
  author =	 {Jeremy Singer and Chris Kirkham},
  booktitle =	 {ACM Symposium on Software Visualization},
  address =	 {Brighton, UK},
  pages =	 {195--196},
  year =	 2006,
  doi =		 {10.1145/1148493.1148541}
}

@inproceedings{sing06a,
  title =	 {Dynamic Analysis of Program Concepts in {Java}},
  author =	 {Jeremy Singer and Chris C. Kirkham},
  crossref =	 {PPPJ06},
  pages =	 {31--39},
  doi =		 {10.1145/1168054.1168060},
  URL =		 {http://www.cs.man.ac.uk/~jsinger/pdfs/pppj06.pdf}
}

@inproceedings{sing07,
  title =	 {Towards Intelligent Analysis Techniques for Object
                  Pretenuring},
  author =	 {Jeremy Singer and Gavin Brown and Mikel Lujan and Ian
                  Watson},
  crossref =	 {PPPJ07},
  doi =		 {10.1145/1294325.1294353},
  pages =	 {203--208}
}

@inproceedings{sing07a,
title = {Intelligent Selection of Application-Specific Garbage Collectors},
author = {Jeremy Singer and Gavin Brown and Ian Watson and John Cavazos},
pages = {91--102},
crossref = {ISMM07},
doi={10.1145/1296907.1296920}
}

@inproceedings{sing08,
author = {Jeremy Singer and Sebastien Marion and Gavin Brown and Richard Jones
and Mikel L\'{u}jan and Chris Ryder and Ian Watson},
title = {An Information Theoretic Evaluation of Software Metrics for Object Lifetime Prediction},
booktitle = {2nd Workshop on Statistical and Machine Learning Approaches to Architectures and Compilation (SMART'08)},
address = {Goteborg, Sweden},
month = jan,
year = 2008,
pages = 15,
URL = {http://www.cs.kent.ac.uk/pubs/2008/2641},
}

@inproceedings{sing10,
author = {Singer, Jeremy and Jones, Richard and Brown, Gavin and Luj\'{a}n, Mikel},
title = {The Economics of Garbage Collection},
crossref = {ISMM10},
pages = {103--112},
doi = {10.1145/1806651.1806669},
abstract = {This paper argues that economic theory can improve our understanding
of memory management. We introduce the allocation curve, as an analogue of the
demand curve from microeconomics. An allocation curve for a program
characterises how the amount of garbage collection activity required during its
execution varies in relation to the heap size associated with that program. The
standard treatment of microeconomic demand curves (shifts and elasticity) can be
applied directly and intuitively to our new allocation curves. As an application
of this new theory, we show how allocation elasticity can be used to control the
heap growth rate for variable sized heaps in Jikes RVM.},
}

@inproceedings{sing11,
title = {Garbage Collection Auto-Tuning for {J}ava MapReduce on Multi-cores},
author = {Jeremy Singer and George Kovoor and Gavin Brown and Mikel Luj\'{a}n},
pages = {109--118},
crossref = {ISMM11},
doi = {1993478.1993495},
abstract = {MapReduce has been widely accepted as a simple programming pattern
that can form the basis for efficient, large-scale, distributed data processing.
The success of the MapReduce pattern has led to a variety of implementations for
different computational scenarios. In this paper we present MRJ, a MapReduce
Java framework for multi-core architectures. We evaluate its scalability on a
four-core, hyperthreaded Intel Core i7 processor, using a set of standard
MapReduce benchmarks. We investigate the significant impact that Java runtime
garbage collection has on the performance and scalability of MRJ. We propose the
use of memory management auto-tuning techniques based on machine learning. With
our auto-tuning approach, we are able to achieve MRJ performance within 10\% of
optimal on 75\% of our benchmark tests.}
}

@mastersthesis{sing88,
author = "Singh, Ramanand",
title = "A Realization of Multiprocessing Garbage Collection Algorithm for
Rule-Based Expert Systems",
year = 1988,
school = "West Virginia University"
}

@mastersthesis{sing90,
author = "Singh, Tajinder P.",
title = "Hardware Design of a Real-Time Copying Garbage Collection System",
school = "Iowa State University, Department of Computer Science",
year = 1990,
number = "TR90-21",
month = Aug,
abstract = "This thesis presents the design of a real-time copying-
type garbage collection system which is capable of providing
better  real-time response and throughput than is currently
available. The improvement is achieved on the basis of three
factors: a special hardware module to aid the memory management
unit for speedy execution of memory requests, a concurrent
garbage collection processor, and delayed copying for large
objects to improve the real-time response.  The hardware design
is presented in the form of AHPL code.  The simulation results
obtained justify the desirability of the system.  The drawbacks
of the suggested system are considered and a suggestion is made
for further improvements."
}

@article{sing92a,
author = "Jaswinder Pal Singh and Harold S. Stone and Dominique Thiebaut",
title = "A Model of Workloads and its Use in Miss-Rate Prediction for
Fully-Associative Caches",
journal = IEEETransComp,
publisher = IEEE,
volume = 41,
number = 7,
month = jul,
year = 1992,
pages = "811--825"
}

@inproceedings{sing92,
author = "Singhal, Vivek and Sheetal V. Kakkad and Paul R. Wilson",
title = "{T}exas: an Efficient, Portable Persistent Store",
crossref = "POS92",
pages = "11-33"
}

@inproceedings{sire96,
title = {Writing an Operating System Using {M}odula-3},
author = {Emin G\"{u}n Sirer and Stefan Savage and Przemyslaw Pardyak and Greg P. DeFouw and Brian N. Bershad},
booktitle = {Workshop on Compiler Support for Systems Software},
year = 1996,
URL = {http://www.cs.washington.edu/homes/egs/papers/m3os.ps},
comment = {Describes their experience with using Modula-3 to implement SPIN}
}

@inproceedings{siva12,
author = {Sivaramakrishnan, KC and Ziarek, Lukasz and Jagannathan, Suresh},
title = {Eliminating Read Barriers Through Procrastination and Cleanliness},
crossref = {ISMM12},
pages = {49--60},
doi = {10.1145/2258996.2259005},
abstract = {Managed languages typically use read barriers to interpret
forwarding pointers introduced to keep track of copied objects. For example, in
a multicore environment with thread-local heaps and a global, shared heap, an
object initially allocated on a local heap may be copied to a shared heap if it
becomes the source of a store operation whose target location resides on the
shared heap. As part of the copy operation, a forwarding pointer may be
established in the original object to point to the copied object. This level of
indirection avoids the need to update all of the references to the object that
has been copied.
In this paper, we consider the design of a managed runtime that eliminates read
barriers. Our design is premised on the availability of a sufficient degree of
concurrency to stall operations that would otherwise necessitate the copy.
Stalled actions are deferred until the next local collection, avoiding exposing
forwarding pointers to the mutator. In certain important cases, procrastination
is unnecessary -- lightweight runtime techniques can sometimes be used to allow
objects to be eagerly copied when their set of incoming references is known, or
when it can be determined that having multiple copies would not violate program
semantics.
We evaluate our techniques on 3 platforms: a 16-core AMD64 machine, a 48-core
Intel SCC, and an 864-core Azul Vega 3. Experimental results over a range of
parallel benchmarks indicate that our approach leads to notable performance
gains (20 - 32\% on average) without incurring any additional complexity.}
}

@article{skot02,
title = {Estimating Internal Memory Fragmentation for {J}ava Programs},
author = {Therapon Skotiniotis and J. Morris Chang},
journal = JSS,
volume = 64,
number = 3,
month = dec,
year = 2002,
pages = {235--246},
abstract = {Dynamic memory management has been an important part of a
large class of computer programs and with the recent popularity of
object oriented programming languages, more specifically Java, high
performance dynamic memory management algorithms continue to be of
great importance. In this paper, an analysis of Java programs, provided
by the SPECjvm98 benchmark suite, and their behavior, as this relates
to fragmentation, is performed. Based on this analysis, a new model is
proposed which allows the estimation of the total internal
fragmentation that Java systems will incur prior to the programs
execution. The proposed model can also accommodate any variation of
segregated lists implementation. A comparison with a previously
introduced fragmentation model is performed as well as a comparison
with actual fragmentation values that were extracted from
Finally the idea of a test-bed application that will use the proposed
model to provide to programmers/developers the ability to know, prior
to a programs execution, the fragmentation and memory utilization of
their programs, is also introduced. With this application at hand
developers as well as designers of applications could better assess the
stability, efficiency as well reliability of their applications at
compile time.},
URL = {http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6V0N-47TNY25-1&_coverDate=12%2F15%2F2002&_alid=74011184&_rdoc=1&_fmt=&_orig=search&_qd=1&_cdi=5651&_sort=d&_acct=C000010239&_version=1&_urlVersion=0&_userid=125871&md5=548c0452d7145eaaf6c7b1132bc62af7},
comment = {Entirely unconvincing.}
}

@techreport{skub96,
author = {M. Skubiszewski and N. Porteix},
title = {{GC}-consistent Cuts of Databases},
type = {Rapport de Recherche},
number = 2681,
institution = {Institut National de la Recherche en Infromatique et Automatique,
Rocquencourt},
month = apr,
year = 1996,
URL = {ftp://ftp.inria.fr/INRIA/publication/RR/RR-2681.ps.gz}
}

@inproceedings{skub97,
author = {M. Skubiszewski and P. Valduriez},
title = {Concurrent Garbage Collection in {O2}},
booktitle = {23rd International Conference on Very Large Databases (VLDB)},
editor = {M. Jarke and M.J. Carey and K.R. Dittrich and F.H. Lochovsky
and P. Loucopoulos and M.A. Jeusfeld},
address = {Athens},
month = may,
pages = {356--365},
publisher = MK,
year = 1997
}

@article{slat91,
author = "Michael Slater",
title = "{PA} Workstations Set Price/Performance Records",
journal = "Microprocessor Report",
volume = 5,
number = 6,
month = apr,
year = 1991
}

@article{slea85,
  author =	 "Daniel Dominic Sleator and Robert Endre Tarjan",
  title =	 "Self-adjusting binary search trees",
  journal =	 JACM,
  year =	 1985,
  volume =	 32,
  number =	 3,
  pages =	 "562--686",
  month =	 jul,
  doi =		 "10.1145/3828.3835",
}

@article{slus87,
author = "Maciej Slusarek",
title = "An Off-Line Storage Allocation Algorithm",
journal = IPL,
publisher = NH,
volume = 24,
number = 2,
month = jan,
year = 1987,
pages = "71--75"
}

@inproceedings{smar04,
title = {General Adaptive Replacement Policies},
author = {Yannis Smaragdakis},
pages = {108--119},
crossref = {ISMM04}
}

@techreport{smet93,
author = "S. Smetsers and E. Barendsen and van Eekelen, M. J. C. D and R. Plasmeijer",
title = "Guaranteeing Safe Destructive Updates through a Type System with Uniqueness Information for Graphs",
institution = "University of Nijmegen",
number = "93--4",
year = 1993
}

@article{smit76,
author = "Alan J. Smith",
title = "A Modified Working Set Paging Algorithm",
journal = IEEETransSWE,
publisher = IEEE,
volume = "C-25",
number = 9,
month = sep,
year = 1976,
pages = "907--914"
}

@article{smit78,
author = "Alan J. Smith",
title = "Sequential Program Prefetching in Memory Hierarchies",
journal = IEEETransComp,
publisher = IEEE,
volume = 11,
number = 12,
month = dec,
year = 1978,
pages = "7--21"
}

@article{smit82,
author = "Alan J. Smith",
title = "Cache Memories",
journal = "Computing Surveys",
publisher = ACM,
volume = 14,
number = 3,
month = sep,
year = 1982,
pages = "473--530"
}

@inproceedings{smit85,
author = "Alan J. Smith",
title = "Cache Evaluation and the Impact of Workload Choice",
crossref = "ISCA85",
pages = "64--73"
}

@article{smit86,
author = "Alan J. Smith",
title = "Bibliography and Readings on CPU Cache Memories and Related Topics",
journal = "Computer Architecture News",
volume = 14,
number = 1,
year = 1986,
month = jan,
pages = "22--42"
}

@article{smit87,
author = "Alan J. Smith",
title = "Line (Block) Size Choice for CPU Cache Memories",
journal = IEEETransComp,
publisher = IEEE,
volume = "C-36",
number = 9,
month = sep,
year = 1987,
pages = "1063--1075"
}

@techreport{smit89,
author = "Jane Smith",
title = "A Garbage Collector for {FP9}",
institution = "University of New Dundee",
year = 1989
}

@techreport{smit97,
author = {Frederick Smith and Greg Morrisett},
title = {Mostly Copying Collection: A Viable Alternative to Conservative Mark-Sweep},
institution = Cornell,
year = 1997
}

@inproceedings{smit98,
author = {Frederick Smith and Greg Morrisett },
title = {Comparing Mostly-Copying and Mark-Sweep Conservative Collection},
pages = {68--78},
crossref = {ISMM98},
abstract = {Many high-level language compilers generate C code and then invoke
a C compiler for code generation, register allocation, stack
management, and low-level optimization. To date, most of these
compilers link the resulting code against a conservative mark-sweep
garbage collector in order to reclaim unused memory. We introduce a
new collector, MCC, based on an extension of mostly-copying
collection.

We analyze the various design decisions made in \mcc and provide a
performance comparison to the most widely used conservative
mark-sweep collector (the Boehm-Demers-Weiser collector). Our
results show that a good mostly-copying collector can outperform a
mature highly-optimized mark-sweep collector when physical
memory is large relative to the live data. A surprising result of our
analysis is that cache behavior has a greater impact on overall
performance than either collector time, or allocation code. }
}

@inproceedings{smit01,
author = {L.A. Smith and J.M. Bull and J. Obdrzalek},
title = {A Parallel {J}ava {G}rande Benchmark Suite},
booktitle = {Conference on Supercomputing (SC)},
address = {Denver, CO},
month = nov,
year = 2001
}

@article{snep87,
title = "Algorithms for On-The-Fly Garbage Collection Revisited",
author = "van de Snepscheut, Jan",
pages = "211--216",
journal = IPL,
publisher = NH,
year = "1987",
month = mar,
volume = 24,
number = 4
}

@techreport{snyd79,
author = "A. Snyder",
title = "A Machine Architecture to Support an Object-Oriented Language",
institution = "MIT Laboratory for Computer Science",
type = "Technical Memo",
number = "MIT/LCS/TR--209",
month = mar,
year = 1979,
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TR-209.html"
}

@techreport{soba88,
author = "Sobalvarro, Patrick ",
institution = "{MIT} {AI} {L}ab",
title = "A Lifetime-Based Garbage Collector for {L}isp Systems on General-Purpose Computers",
year = 1988,
URL = "ftp://publications.ai.mit.edu/ai-publications/1994/AITR-1417.ps.Z",
month = feb,
number = "{AITR}-1417",
type = "Bachelor of Science thesis",
doi = {1721.1/6795}
}

@techreport{soma04,
author = {Sunil Soman and Chandra Krintz and David Bacon},
title = {Dynamic Selection of Application-Specific Garbage Collectors},
institution = {UCSB},
number = {2004--09},
month = jan,
year = 2004,
URL = {http://www.cs.ucsb.edu/~ckrintz/papers/2004-09.pdf},
abstract = {In this paper, we describe a novel execution environment
that can dynamically switch between garbage collection (GC) systems. As
such, it enables application-specific GC selection. In addition, the
system can switch between different GC systems while the program is
executing. Our system is novel in that it is able to switch between a
wide range of diverse collection systems. To empirically evaluate our
system, we implemented annotation-guided GC selection and we show its
efficacy for a wide range of benchmarks and heap sizes. In addition, we
implemented a simple heuristic that automatically identifies when to
switch collectors when program execution behavior warrants it. Our
system introduces an average overhead of 4\% for both annotation-guided
and automatic switching. Perhaps more importantly however, we
significantly improve performance over selecting the wrong collection
system (by 19\% using annotation-guided selection and by 16\% using
automatic switching, on average).}
}

@inproceedings{soma04a,
author = {Sunil Soman and Chandra Krintz and David Bacon},
title = {Dynamic Selection of Application-Specific Garbage Collectors},
pages = {49--60},
doi={10.1145/1029873.1029880},
crossref = {ISMM04}
}

@inproceedings{soma06,
title = {Task-Aware Garbage Collection in a Multi-Tasking Virtual Machine},
author = {Sunil Soman and Laurent Dayn{\`e}s and Chandra Krintz},
pages = {64--73},
crossref = {ISMM06},
doi={10.1145/1133956.1133965}
}

@inproceedings{soma06a,
  author =	 {Sunil Soman and Chandra Krintz},
  title =	 {Efficient and General On-Stack Replacement for Aggressive
                  Program Specialization},
  booktitle =	 {International Conference on Software Engineering Research
                  and Practice (SERP) \& Conference on Programming Languages and
                  Compilers, Volume 2},
  year =	 2006,
  month =	 jun,
  pages =	 {925--932},
  address =	 {Las Vegas, NV},
  publisher =	 {CSREA Press},
  isbn =	 {1-932415-91-2}
}

@inproceedings{soma08,
title = {$\textnormal{MTM}^2$: Scalable Memory Management for Multi-Tasking Managed Runtime
Environments},
author = {Sunil Soman and Chandra Krintz and Laurent Dayn{\`e}s},
crossref = {ECOOP08},
doi={10.1007/978-3-540-70592-5_15},
pages={335--361}
}

@inproceedings{sous93,
author = "Pedro Sousa",
title = "Garbage Collection of Persistent Objects in a Distributed Object-Oriented Platform",
crossref = "OOPSLA93-gc",
}

@inproceedings{spal06,
title = {Asserting Memory Shape using Linear Logic},
author = {Frances Spalding and Limin Jia},
pages = {2--13},
crossref = {SPACE06}
}

@inproceedings{spar93,
title = "Fixing Some Space Leaks without a Garbage Collector",
author = "Jan Sparud",
address = "Chalmers University of Technology",
crossref = "FPCA93",
}

@misc{specjvm98, key = {SPECjvm98},
institution = {Standard Performance Evaluation Corporation},
title = {{SPEC} JVM98 benchmarks},
year = 1998,
howpublised = {http://www.spec.org/jvm98},
URL = {http://www.spec.org/jvm98}
}

@misc{specjvm2008, key = {SPECjvm2008},
institution = {Standard Performance Evaluation Corporation},
title = {{SPEC} JVM2008 benchmarks},
year = 1998,
howpublised = {http://www.spec.org/jvm2008},
URL = {http://www.spec.org/jvm2008}
}

@article{sper96a,
title = "Automating Memory Management",
author = "Michael Spertus",
journal = "Object Currents",
URL = "http://www.sigs.com/publications/docs/oc/9602/oc9602.c.spertus.html",
publisher = "SIGS Publications, Inc",
month = jan,
year = 1996,
}

@article{sper96,
title = "Garbage Collection in {C++}",
author = "Michael Spertus",
journal = "Object magazine",
publisher = "SIGS Publications, Inc",
volume = 5,
number = 9,
month = mar,
year = 1996,
comment = "Largely pro-GC propaganda from President of Geodesic Systems"
}

@article{sper97,
title = {{C++} and Garbage Collection},
author = "Michael Spertus",
journal = Dobbs,
volume = 22,
number = 12,
month = dec,
pages = {36--41},
year = 1997
}

@misc{spin,
key = "SPIN",
title = "The {SPIN} Operating System",
howpublished = "A collection of papers available on the WWW",
URL = "http://www.cs.washington.edu/research/projects/spin/www/",
comment = "An operating system written in Modula-3 that, according to David
Chase, takes advantage of system-level optimisations made possible by GC"
}

@inproceedings{spoo04,
author = {Daniel Spoonhower and Guy Blelloch and Robert Harper},
title = {Incremental Copying Collection with Pinning (Progress Report)},
crossref = {SPACE04},
}

@inproceedings{spoo05,
  author =	 {Daniel Spoonhower and Guy Blelloch and Robert Harper},
  title =	 {Using Page Residency to Balance Tradeoffs in Tracing Garbage
                  Collection},
  crossref =	 {VEE05},
  pages =	 {57--67},
  doi =		 {10.1145/1064979.1064989}
}

@inproceedings{spoo06,
  title =	 {Eventrons: A Safe Programming Construct for High-Frequency
                  Hard Real-Time Applications},
  author =	 {Daniel Spoonhower and Joshua Auerbach and David F. Bacon and
                  Perry Cheng and David Grove},
  crossref =	 {PLDI06},
  pages =	 {283-294},
  doi =		 {10.1145/1133981.1134015}
}

@inproceedings{spoo08,
  title =	 {Space Profiling for Parallel Functional Programs},
  author =	 {Daniel Spoonhower and Guy E. Blelloch and Robert Harper and
                  Phillip B. Gibbons},
  booktitle =	 {13th } # ICFP,
  address =	 {Victoria, BC, Canada},
  month =	 sep,
  year =	 2008,
  pages =	 {253--264},
  doi =		 {10.1145/1411203.1411240},
}

@inbook{srik08,
author = {Y. N. Srikant and Priti Shankar},
title = {The Compiler Design Handbook: Optimizations and Machine Code Generation},
chapter = {Garbage Collection Techniques},
publisher = {CRC Press},
edition = {Second},
year = 2008
}

@article{sris99,
author = {Witiwas Srisa-an and C. D. Lo and J. Morris Chang},
title = {A Hardware Implementation of Realloc function},
journal = {Integration, the {VLSI} Journal},
volume = 28,
pages = {173--184},
publisher = ES,
year = 1999
}

@inproceedings{sris99a,
author = {Witiwas Srisa-an and C. D. Lo and J. Morris Chang},
title = {A Hardware Implementation of Realloc function},
booktitle = {IEEE Annual Workshop on VLSI (WVLSI)},
address = {Orlando, FL},
month = apr,
pages = {697--699},
year = 1999
}

@inproceedings{sris00,
author = {Witiwas Srisa-an and Chia-Tien Dan Lo and J. Morris Chang},
title = {Active Memory: Garbage-Collected Memory for Embedded Systems},
booktitle = {Second Annual Workshop on Hardware Support for Objects and Microarchitectures for {J}ava},
address = {Austin, TX},
month = sep,
year = 2000,
pages = {11--15}
}

@inproceedings{sris00a,
author = {Witiwas Srisa-an and Chia-Tien Dan Lo and J. Morris Chang},
title = {Scalable Hardware-algorithm for Mark-sweep Garbage Collection},
booktitle = {Euromicro Conference on Digital System Design},
address = {Maastricht, Netherlands},
month = sep,
year = 2000,
pages = {274--279}
}

@inproceedings{sris00b,
author = {Witiwas Srisa-an and J. Morris Chang and Chia-Tien Dan Lo},
title = {Do Generational Schemes Improve the Garbage Collection Efficiency?},
booktitle = {IEEE International Symposium on Performance Analysis of Systems and Software},
address = {Austin, TX},
publisher = IEEE,
month = apr,
year = 2000,
pages = {58--63},
URL = {http://ieeexplore.ieee.org/iel5/6790/18223/00842283.pdf}
}

@inproceedings{sris00c,
author = {J. Morris Chang and Witiwas Srisa-an and Chia-Tien Dan Lo},
title = {Architectural Support for Dynamic Memory Management},
booktitle = {IEEE International Conference on Computer Design},
address = {Austin, TX},
month = sep,
year = 2000,
pages = {99-104}
}

@article{sris02,
author = {Witiwas Srisa-an and Chia-Tien Dan Lo and J. Morris Chang},
title = {Object Resizing and Reclamation through the Use of Hardware Bit-maps},
journal = {International Journal of Microprocessors and Microsystems},
publisher = {Elsevier Science},
volume = 25,
year = 2002,
pages = {459--467}
}

@article{sris02a,
author = {Witiwas Srisa-an and Chia-Tien Dan Lo and J. Morris Chang},
title = {A Performance Perspective on the Active Memory System},
journal = {International Journal of Microprocessors and Microsystems},
volume = 26,
number = {9--10},
publisher = {Elsevier Science},
month = dec,
year = 2002,
pages = {421--432}
}

@inproceedings{sris02b,
author = {Witiwas Srisa-an and Chia-Tien Dan Lo and J. Morris Chang},
title = {Performance Enhancements to the Active Memory System},
booktitle = {IEEE International Conference on Computer Design (ICCD)},
address = {Freiburg, Germany},
month = sep,
year = 2002,
pages = {249--256}
}

@article{sris03,
author = {Witiwas Srisa-an and Chia-Tien Dan Lo and J. Morris Chang},
title = {Active Memory Processor: A Hardware Garbage Collector for Real-time {J}ava Embeded Devices},
journal = {IEEE Transactions on Mobile Computing},
volume = 2,
number = 2,
month = {April--June},
year = 2003,
pages = {89--101}
}

@article{sris03a,
author = {Witiwas Srisa-an and Chia-Tien Dan Lo and J. Morris Chang},
title = {Hardware Support for Garbage Collection in Embedded Systems Using the Active Memory Module},
journal = {International Journal of Microprocessors and Microsystems},
publisher = {Elsevier Science},
year = {to appear}
}

@inproceedings{sris05,
author = {Witiwas Srisa-an and M. Oey and S. Elbaum},
title = {Garbage Collection in the Presence of Remote Objects: A Case Study},
booktitle = {International Symposium on Distributed Objects and Applications},
address = {Agia Napa, Cyprus},
month = oct,
year = 2005,
pages = {1065--1082}
}

@article{sris05a,
author = {Witiwas Srisa-an and M. Oey},
title = {Remote Objects: The Next Garbage Collection Challenge},
journal = {Journal of Object Technology},
volume = 4,
number = 4,
month = {May--June},
year = 2005,
pages = {155--172}
}

@techreport{stal80,
author = "Richard M. Stallman",
title = "Phantom Stacks: If You Look Too Hard, They Aren't There",
institution = "MIT AI Laboratory",
type = "AI Memo",
number = 556,
month = jul,
year = 1980
}

@MastersThesis{stam82,
  author =	 {James William Stamos},
  title =	 {A Large Object-Oriented Virtual Memory: Grouping Strategies,
                  Measurements, and Performance},
  school =	 {Department of Electrical Engineering and Computer Science,
                  Massachusetts Institute of Technology},
  year =	 1982,
  month =	 apr,
  doi =		 {1721.1/15807}
}

@article{stam84,
title = "Static Grouping of Small Objects to Enhance Performance of a Paged Virtual Memory",
author = "Stamos, James W.",
journal = TransCompSys,
publisher = ACM,
volume = 2,
number = 3,
month = May,
year = 1984,
pages = "155--180",
doi={10.1145/190.194},
comment = "Using the garbage collector to improve performance"
}

@techreport{stam86,
author = "James W. Stamos",
title = "Programmer-Invoked Local Garbage Collection: A Design",
number = "unpublished draft",
institution = "MIT",
year = 1986
}

@book{stan80,
author = "Thomas A. Standish",
title = "Data Structure Techniques",
publisher = AW,
year = 1980,
comment = {book with sections on garbage collection --- valuable reference},
}

@inproceedings{stan07,
title = {Mark-Sweep or Copying? A ``Best of Both Worlds'' Algorithm and a
Hardware-Supported Real-Time Implementation},
author = {Sylvain Stanchina and Mattias Meyer},
pages = {173--182},
crossref = {ISMM07},
}



@mastersthesis{stap90,
author = "Stapleton, Sue M",
title = "Real-Time Garbage Collection for General Purpose Languages",
school = "Iowa State University, Department of Computer Science",
year = 1990,
number = "TR90-13",
month = Aug,
abstract = "Programming languages that support dynamically
allocated memory enable programmers to abstract memory
management, freeing the development process from time consuming
details and troublesome bugs associated with allocation and
reclamation of dynamically allocated memory.  The garbage
collection scheme described in this paper is real time in the
sense that allocation of memory is performed in time proportional
to the size of the memory request and all other memory operations
execute in constant time.  The scheme is general purpose in that
it defines a memory protocol whereby multiple languages and
applications are able to share access to a global garbage
collected memory.
The algorithm presented in this paper is based upon Baker's
algorithm for real-time garbage collection of lists.  This
algorithm differs from Baker's in that it supports arbitrarily
large objects, including overlapping slices of large arrays."
}

@article{stee75,
author = "Guy L. Steele",
title = "Multiprocessing Compactifying Garbage Collection",
journal = CACM,
publisher = ACM,
volume = 18,
number = 9,
pages = "495--508",
month = Sep,
doi={10.1145/361002.361005},
comment = "First parallel garbage collection algorithm.
Uses a stack (rather than colours a la Dijkstra) to communicate between
mutator and collector.
Complex because it includes compaction, parameter passing mechanism,
synchronisation as well as GC.",
year = "1975"
}

@article{stee76,
author = "Guy L. Steele",
title = "Corrigendum: Multiprocessing Compactifying Garbage Collection",
journal = CACM,
publisher = ACM,
volume = 19,
number = 6,
pages = "354",
month = Jun,
comment = "Correction to the algorithm in \cite{stee75}",
year = "1976",
doi={10.1145/360238.360247}
}

@techreport{stee77,
author = "Guy L. Steele",
title = "Data Representation in {PDP-10} {MACLISP}",
institution = MITAI,
type = {AI Memo},
number = 421,
year = 1977,
}

@techreport{stee78,
author = "Guy L. Steele",
title = "{RABBIT}: A Compiler for {SCHEME}",
institution = MIT,
year = 1978,
month = may
}

@phdthesis{stee87,
author = "Steenkiste, Peter",
title = "Lisp on a Reduced-Instruction-Set Processor:  Characterization and
Optimization",
school = "Stanford University",
note = "Available as Technical Report CSL-TR-87-324",
month = mar,
year = 1987
}

@inproceedings{stee87a,
  author =	 "Peter Steenkiste and John Hennessy",
  title =	 "Tags and Type Checking in {LISP}: Hardware and Software
                  Approaches",
  crossref =	 "ASPLOS87",
  pages =	 "50--59",
  doi =		 {10.1145/36206.36183}
}

@inproceedings{stee89,
author = "Peter Steenkiste",
title = "The Impact of Code Density on Instruction Cache Performance",
crossref = {ISCA89},
pages = "252--259",
doi={10.1145/74925.74954}
}

@inproceedings{stee00,
author = {Bjarne Steensgaard},
title = {Thread-Specific Heaps for Multi-Threaded Programs},
pages = {18--24},
crossref = {ISMM2000},
doi={10.1145/362422.362432},
abstract = {
Given an escape analysis, a memory management system may allocate
thread-specific data in thread-specific heaps and allocate shared data in a
shared heap. Garbage collection of data in a thread-specific heaps can be
done independent of other threads and of data in their thread-specific
heaps. For multi-threaded programs, thread-specific heaps allow less
garbage collection latency for active threads. On multi-processor
computers, thread-specific heaps allow concurrent garbage collection of
different thread-specific heaps with minimal synchronization overhead. We
present an escape analysis and a sample memory management system
using thread-specific heaps.
}
}

@inproceedings{stef93,
author = {Darko Stefanovi\'{c}},
title = "The Garbage Collection Toolkit as an Experimentation Tool",
crossref = "OOPSLA93-gc",
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/gc-workshop93b.ps.Z}
}

@mastersthesis{stef93a,
author = {Darko Stefanovi\'{c}},
title = {Generational Copying Garbage Collection for {S}tandard {ML}: a Quantitative Study},
school = UMass,
year = 1993
}

@inproceedings{stef94,
  author =	 {Darko Stefanovi\'{c} and J. Eliot B. Moss},
  title =	 "Characterisation of Object Behaviour in {S}tandard {ML} of
                  {N}ew {J}ersey",
  crossref =	 "LFP94",
  pages =	 {43-54},
  doi =		 {10.1145/182409.182428},
  comment =	 {ftp://ftp.cs.umass.edu/pub/osl/papers/lfp94.ps.Z}
}

@techreport{stef98,
author = {Darko Stefanovi\'{c} and J. Eliot B. Moss and Kathryn S.  McKinley},
title = {On Models for Object Lifetime},
institution = UMass,
month = feb,
year = 1998,
}

@techreport{stef98a,
author = {Darko Stefanovi\'{c} and J. Eliot B. Moss and Kathryn S.  McKinley},
title = {Oldest-First Garbage Collection},
institution = UMass,
number = {98--81},
month = apr,
year = 1998,
}

@phdthesis{stef99,
author = {Darko Stefanovi\'{c}},
title = {Properties of Age-Based Automatic Memory Reclamation Algorithms},
school = UMass,
year = 1999
}

@techreport{stef99a,
author = {Darko Stefanovi\'{c} and J. Eliot B. Moss and Kathryn S.  McKinley},
title = {Age-Based Garbage Collection},
institution = UMass,
month = apr,
year = 1999,
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/oopsla99.ps.Z},
note = {preliminary version of a paper to appear in OOPSLA'99}
}

@inproceedings{stef99b,
  author =	 {Darko Stefanovi\'{c} and Kathryn S. McKinley and J. Eliot
                  B. Moss},
  title =	 {Age-Based Garbage Collection},
  crossref =	 {OOPSLA99},
  doi =		 {10.1145/320384.320425},
  pages =	 {370-381}
}

@inproceedings{stef00,
author = {Darko Stefanovi\'{c} and Kathryn S. McKinley and J. Eliot B. Moss},
title = {On Models for Object Lifetime Distributions},
pages = {137--142},
crossref = {ISMM2000},
abstract = {
Analytical models of object lifetimes are appealing because they would
enable mathematical analysis or fast simulation of the memory
management behavior of programs. In this paper, we investigate models
for object-oriented programs such as Java and Smalltalk. We present
analytical models and compare them with observed lifetimes for 58
Smalltalk and Java programs. We find that observed lifetime
distributions do not match previously proposed object lifetime models,
but do agree in salient shape characteristics with the gamma
distribution family used in statistical survival analysis for general
populations.  }
}

@inproceedings{stef02,
title = {Older-First Garbage Collection in Practice: Evaluation in a {J}ava
Virtual Machine},
author = {Darko Stefanovi\'{c} and Matthew Hertz and Stephen Blackburn and Kathryn
McKinley and J. Eliot Moss},
crossref = {MSP02},
doi={10.1145/773146.773042},
pages={25--36}
}

@unpublished{sten76,
author = {V. Stenning},
title = {On-the-fly Garbage Collection},
note = {Unpublished notes, cited by \cite{grie77}},
year = 1976,
comment = {The Woodger-Stenning scenario, cited by \cite{grie77}}
}

@inproceedings{step83,
  author =	 "C. J. Stephenson",
  title =	 "New Methods of Dynamic Storage Allocation (Fast Fits)",
  booktitle =	 "9th " # SOSP,
  series =	 SIGOPS # " 17(5)",
  pages =	 {30--32},
  address =	 {Bretton Woods, NH},
  publisher =	 ACM,
  month =	 oct,
  year =	 1983,
  doi =		 {10.1145/800217.806613}
}

@inproceedings{stic99,
  author =	 {James M. Stichnoth and Guei-Yuan Lueh and Michal Cierniak},
  title =	 {Support for Garbage Collection at Every Instruction in a
                  {Java} Compiler},
  crossref =	 {PLDI99},
  pages =	 {118--127},
  doi =		 {10.1145/301618.301652},
  URL =
                  {http://riss.keris.or.kr:8080/pubs/citations/proceedings/pldi/301618/p118-stichnoth/}
}

@techreport{ston82,
author = "Harold S. Stone",
title = "Parallel Memory Allocation Using the {FETCH}-{AND}-{ADD} Instruction",
institution = "IBM Thomas J. Watson Research Center",
address = "Yorktown Heights, NY",
month = nov,
year = 1982
}

@article{ston92,
author = "Harold S. Stone and John Turek and Joel L. Wolf",
title = "Optimal Partitioning of Cache Memory",
journal = IEEETransComp,
publisher = IEEE,
volume = 41,
number = 9,
month = sep,
year = 1992,
pages = "1054--1068"
}

@inproceedings{stoy84,
author = "Will R. Stoye and T. J. W. Clarke and Arthur C. Norman",
title = "Some Practical Methods for Rapid Combinator Reduction",
crossref = "LFP84",
pages = "159--166",
doi={10.1145/800055.802032},
comment = "
The SKIM -- special purpose Turner combinator machine.
Useful empirical data.
Few cells shared, many are short lived."
}

@phdthesis{stout97,
author = "David Stoutamire",
title = "Portable, Modular Expression of Locality",
school = UCB, 
URL = "http://www.stoutamire.com/david/berkeley_thesis.ps.gz",
year = 1997,
abstract = {
It is difficult to achieve high performance while programming in the
large. In particular, maintaining locality hinders portability and
modularity. Existing methodologies are not sufficient: explicit
communication and coding for locality require the programmer to violate
encapsulation and compositionality of software modules, while automated
compiler analysis remains unreliable.

This thesis presents a performance model that makes thread and object
locality explicit. Zones form a runtime hierarchy that reflects the
intended clustering of threads and objects, which are dynamically
mapped onto hardware units such as processor clusters, pages, or cache
lines. This conceptual indirection allows programmers to reason in the
abstract about locality without committing to the hardware of a
specific memory system. Zones complement conventional coding for
locality and may be added to existing code to improve performance
without affecting correctness.

The integration of zones into the Sather language is described,
including an implementation of memory management customized to
parameters of the memory system. }
}

@article{stra89,
title = "Object Management in a Persistent {S}malltalk System",
author = "A. Straw and F. Mellender and S. Riegel",
institution = "Eastman Kodak Co., Advanced Computer Research Laboratory,
901 Elmgrove Rd, Rochester, NY, 14653",
journal = SPE,
publisher = Wiley,
year = 1989,
volume = 19,
number = 8,
pages = "719--737",
abstract = {The main goal of the Alltalk project is to provide transparent
database support to the Smalltalk programmer.  As a first step towards this
goal, the current version of Alltalk extends Smalltalk-80 by providing
persistence to Smalltalk objects without adding a database sublanguage, new
language syntax, classes or methods.  This paper describes the implementation
of object management in Alltalk, including database layout, database access
methods, in-memory object management and high-level interface from the
interpreter.  It also discusses how the object manager is integrated in a
unique way with the operations of the Alltalk garbage collector and
interpreter.}
}

@book{stob07,
title = {Modern Concepts Applied to {C}++ --- Object Persistence, Reflection,
Events, Garbage Collection and Thread Safety in {C}++},
author = {Torsten Strobl},
publisher = {Verlag},
month = aug,
year = 2007
}

@book{stro91,
author = "Bjarne Stroustrup",
title = "The {C++} Programming Language",
publisher = AW,
edition = "Second",
month = dec,
year = 1991
}

@misc{stro96,
title = "Proposal to Acknowledge that Garbage Collection for {C++} is Possible",
author = "Bjarne Stroustrup",
address = "AT\&T Research, Murray Hill, NJ",
month = may,
year = 1996,
note = "From the C++ core language mailing list, 27 May 1996",
abstract = {The ARM, "The C++ Programming Language (2nd edition)", and
"The Design and Evolution of C++" all mention that automatic garbage collection
of C++ is possible, but that an implementation is not required to
provide a garbage collector. This is a proposal to make this explicit
in the standard and to specify a couple of details of what it means
to collect garbage. The proposal is for clarification rather than
significant normative changes.

Introduction

The most loudly proclaimed fundamental weakness of C++ these days
is the absence of automatic garbage collection. This criticism is
harming C++'s reputation, scaring potential users away, and restricting
the range of applications for which C++ is a strong contender as an
implementation language. For many applications automatic garbage
collection is indeed a very powerful tool and the right tool for
the job.

It is my firm opinion that the complaints about the lack of garbage
collection in C++ will continue, will become louder as more alternative
languages provide garbage collection, and that the cases where the
complaint is based on valid reasons will become more frequent.

My defense has traditionally been that garbage collection is possible
for C++ and that garbage collecting implementations do indeed exist.
Currently both public domain and commercial garbage collectors for C++
are shipping. Nothing in the definition of C++ requires garbage
collection - and if it did serious harm would be done to many C++
users - but on the other hand nothing prevents it from being done
either. See D&E for a fairly detailed discussion of C++ and garbage
collection.

However, the "permitted but not required" position is weakened by
being implicit rather than explicit in the draft standard and by
a couple of possible alternatives in the meaning of "garbage
collection for C++." I therefore propose to make "permitted but not
required" explicit by defining what it means to be "garbage."

My proposal reflects my opinion that we now have seen enough
implementations to know that automatic garbage collection is
viable for C++ and also a convergence of opinion of how to handle
the unspecified cases. I expect to see a significant increase in
the use of garbage collectors with C++ over the next few years.
Providers and users of garbage collectors or C++ would like their
implementations to be standards conforming and to know precisely
what that means.

Most of the suggestions below are clarifications and only one
affects conformance.}
}

@inproceedings{stro98,
  title =	 {Schedule-Independent Storage Mapping for Loops},
  author =	 {Mills Strout, Michelle and Larry Carter and Jeanne Ferrante
                  and Beth Simon},
  crossref =	 {ASPLOS98},
  pages =	 {24-33},
  doi =		 {10.1145/291069.291015},
  comment =	 {was "Finding a Storage Reuse Pattern for any Legal Loop
                  Schedule"}
}

@article{stum90,
author = "M. Stumm and Songnian Zhou",
title = "Algorithms Implementing Distributed Shared Memory",
journal = "IEEE Computing",
publisher = IEEE,
volume = 23,
number = 5,
month = May,
year = 1990
}

@inproceedings{stum90a,
author = "Michael Stumm and Songnian Zhou",
title = "Fault Tolerant Distributed Shared Memory",
booktitle = "IEEE International Conference on Parallel Distributed Computing",
publisher = IEEE,
month = dec,
year = 1990
}

@techreport{styg67,
author = "P. Stygar",
title = "{LISP} 2 Garbage Collector Specifications",
institution = "System Development Corporation",
number = "TN-3417/500/00",
month = apr,
year = 1967
}

@inproceedings{subr91,
author = "Indira Subramanian",
title = "Managing Discardable Pages with an External Pager",
booktitle = "USENIX Mach Symposium",
publisher = UA,
address = "Monterey, CA",
month = nov,
year = 1991,
pages = "77--85"
}

@inproceedings{sugi83,
author = "Sugimoto, S. and others",
title = "A Multi-Microprocessor System for {C}oncurrent {L}isp",
booktitle = "International Conference on Parallel Processing",
year = 1983,
month = jun
}

@inproceedings{suga03,
  author =	 {Toshio Suganuma and Toshiaki Yasue and Toshio Nakatani},
  title =	 {A Region-Based Compilation Technique for a {Java}
                  Just-In-Time Compiler},
  crossref =	 "PLDI03",
  pages =	 {312-323},
  doi =		 {10.1145/781131.781166}
}

@inproceedings{sull91,
author ={Mark Sullivan and Ram Chillarege},
title = {Software Defects and their Impact on System Availability --
A Study of Field Failures in Operating Systems},
booktitle = {Digest of the 21st International Symposium on Fault Tolerant Computing},
pages = {2--9},
month = jun,
year = 1991,
comment = {Authors ascribe almost half the errors in IBM MVS to pointer
and array access errors}
}

@article{sult02,
author = {Florin Sultan and Thu D. Nguyen and Liviu Iftode},
title = {Lazy Garbage Collection of Recovery State for Fault-Tolerant Distributed Shared Memory},
journal = {{IEEE} Transactions on Parallel and Distributed Systems},
volume = 13,
number = 10,
month = oct,
year = 2002,
pages = { 673-686},
URL = {http://csdl.computer.org/comp/trans/td/2002/07/l7toc.htm},
note = {This paper contains some errors which led to the paper being reprinted in \cite{sult02a}}
}

@article{sult02a,
author = {Florin Sultan and Thu D. Nguyen and Liviu Iftode},
title = {Lazy Garbage Collection of Recovery State for Fault-Tolerant Distributed Shared Memory},
journal = {{IEEE} Transactions on Parallel and Distributed Systems},
volume = 13,
number = 10,
month = oct,
year = 2002,
pages = {1085--1098},
URL = {http://csdl.computer.org/comp/trans/td/2002/10/lxtoc.htm}
}

@inproceedings{sun97,
title = {A {S}malltalk Memory Profiler and its Performance Enhancement},
author = {Jingyu Sun and Edward F. Gehringer},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/was-rtf.ps},
crossref = {OOPSLA97-gc}
}

@inproceedings{sund05,
author = {H. Sundell},
title = {Wait-Free Reference Counting and Memory Management},
booktitle = {19th International Parallel and Distributed Processing Symposium (IPDPS)},
address = {Denver, CO},
month = apr,
year = 2005,
publisher = IEEEcomp,
doi={10.1109/IPDPS.2005.451}
}

@inproceedings{suzu95,
title = "{MOA} --- A Fast Sliding Compaction Scheme for a Large Storage Space",
author = "Mitsugu Suzuki and Hiroshi Koide and Motoaki Terashima",
crossref = "IWMM95",
pages = {197--210},
doi = {10.1007/3-540-60368-9_25}
}

@article{suzu95a,
author = "Mitsugu Suzuki and Motoaki Terashima",
title = "Time- and Space-Efficient Garbage Collection Based on Sliding Compaction",
journal = "Transaction of Information Processing (IPSJ)",
volume = 36,
number = 4,
pages = "925--931",
year = 1995
}

@article{swam06,
title = {Safe Manual Memory Management in {C}yclone},
author = {Nikhil Swamy and Michael Hicks and Greg Morrisett and Dan Grossman and
Trevor Jim},
journal =	 SCP,
volume =	 62,
number =	 2,
publisher =	 "Elsevier",
month =	 oct,
year =	 2006,
pages = {122--144}
}

@techreport{swan86,
author = "M. Swanson",
title = "An Improved Portable Copying Garbage Collector",
institution = "University of Utah",
type = "{OPnote}",
number = "86--03",
month = feb,
year = 1986
}

@techreport{swin86,
author = "Daniel C. Swinehart and Polle T. Zellweger and Richard J. Beach
and Robert B. Hagmann",
title = "A Structural View of the {C}edar Programming Environment",
institution = "Xerox Corporation",
number = "CSL--86--1",
year = 1986
}

@article{szok77,
  title =	 "Some Remarks on New Instances and Garbage Collection",
  author =	 {P\'{e}ter Sz\"{o}ke},
  note =	 "Strathclyde Algol-68 Conference",
  journal =	 SIGPLAN,
  publisher =	 ACM,
  volume =	 12,
  number =	 6,
  month =	 Jun,
  year =	 1977
}

@inproceedings{szyn99,
author = {R. Szymanek and K. Kuchcinski},
title = {Design Space Exploration in System Level Synthesis under Memory Constraints},
booktitle = {Euromicro 35},
address = {Milan},
month = sep,
year = 1999,
doi = {10.1109/EURMIC.1999.794441}
}

@inproceedings{szyn00,
author = {R. Szymanek and K. Kuchcinski},
title = {Task Assignment and Scheduling under Memory Constraints},
booktitle = {Euromicro 2000},
year = 2000,
doi = {10.1109/EURMIC.2000.874619}
}

@inproceedings{szyn01,
author = {R. Szymanek and K. Kuchcinski},
title = {A Constructive Algorithm for Memory-Aware Task Assignment and Scheduling},
booktitle = {9th International Symposium on Hardware/Software Codesign},
address = {Copenhagen},
month = apr,
year = 2001,
doi = {10.1145/371636.371706}
}

@mastersthesis{szym01a,
author = {R. Szymanek},
title = {Memory Aware Task Assignment and Scheduling for Multiprocessor Embedded Systems},
school = "Department of Computer Science, Lund University",
month = jun,
year = 2001,
ISSN = {1404-1219},
URL = {http://www.dna.lth.se/Research/ESD/doc/radek_lic.ps.gz}
}

@mastersthesis{tadm78,
author = "M. Tadman",
title = "Fast-Fit: A New Hierarchical Dynamic Storage Allocation Technique",
school = "University of California, Irvine",
year = 1978
}

@inproceedings{take90,
author = "Tomohiro Takeda",
title = "A Garbage Collecting Method for Object-Oriented Concurrent
Languages",
crossref = "OOPSLA90-gc",
}

@book{tane88,
author = "Andrew S. Tanenbaum",
title = "Computer Networks",
edition = "Second",
publisher = PH,
year = 1988
}

@inproceedings{tang08,
title = {{L}eak{S}urvivor: Towards Safely Tolerating Memory Leaks for
Garbage-Collected Languages},
author = {Yan Tang and Qi Gao and Feng Qin},
booktitle = {USENIX Annual Technical Conference},
pages = {307--320},
year = 2008,
URL = {http://www.usenix.org/event/usenix08/tech/full_papers/tang/tang.pdf}
}

@incollection{tang12,
title = {Memory Safety for Safety Critical Java},
author = {Daniel Tang and Ales Plsek and Jan Vitek},
booktitle = {Distributed, Embedded and Real-time Java Systems},
chapter = 10,
pages = {235--264},
year = 2012,
publisher = {Springer},
doi = {10.1007/978-1-4419-8158-5_10},
abstract = {Memory is a key resource in computer systems. Safety-critical
systems often must operate for long periods of time with limited available
memory. Programmers must therefore take great care to use memory sparingly and
avoid programming errors. This chapter introduces the memory management API of
the Safety Critical Java specification and presents a static technique for
ensuring memory safety.}
}

@inproceedings{tara92,
title = "Ecological Memory Management in a Continuation Passing {P}rolog Engine",
author = "Paul Tarau",
crossref = "IWMM92",
pages = {344--356},
doi = {10.1007/BFb0017200}
}

@inproceedings{tara11,
title = {Integrated Symbol Table, Engine and Heap Memory Management in
Multi-Engine {P}rolog},
author = {Paul Tarau},
crossref = {ISMM11},
pages = {129--138},
doi = {1993478.1993497},
abstract = {We describe an integrated solution to symbol, heap and logic engine
memory management in a context where exchanges of arbitrary Prolog terms occur
between multiple dynamically created engines, implemented in a new Java-based
experimental Prolog system.
As our symbols represent not just Prolog atoms, but also handles to Java objects
(including arbitrary size integers and decimals), everything is centered around
a symbol garbage collection algorithm ensuring that external objects are shared
and exchanged between logic engines efficiently.
Taking advantage of a tag-on-data heap representation of Prolog terms, our
algorithm performs in-place updates of live symbol references directly on heap
cells.
With appropriate fine tuning of collection policies our algorithm provides an
integrated memory management solution for Prolog systems, with amortized cost
dominated by normally occurring heap garbage collection costs.}
}

@inproceedings{tard93,
author = "David Tarditi and Amer Diwan",
title = "The Full Cost of a Generational Copying Garbage Collection Implementation",
crossref = "OOPSLA93-gc",
URL = "ftp://ftp.cs.umass.edu/pub/osl/papers/gc-workshop93a.ps.Z"
}

@techreport{tard94,
author = "David Tarditi and Amer Diwan",
title = "Measuring the Cost of Storage Management",
institution = CMU,
number = "CMU-CS-94-201",
year = 1994,
URL = "http://www.cs.cmu.edu/afs/cs.cmu.edu/project/fox-1/dtarditi/dist/CMU-CS-94-201.ps",
note = "Accepted for publication in " # LSC
}

@article{tard96,
author = "David Tarditi and Amer Diwan",
title = "Measuring the Cost of Storage Management",
journal = LSC,
volume = 9,
number = 4,
year = 1996,
}

@inproceedings{tard00,
author = {David Tarditi},
title = {Compact Garbage Collection Tables},
pages = {50--58},
crossref = {ISMM2000},
doi = {10.1145/362422.362437},
abstract = {
Garbage collection tables for finding pointers on the stack can be
represented in 20-25\% of the space previously reported. Live pointer
information is often the same at many call sites because there are few
pointers live across most call sites. This allows live pointer information to be
represented compactly by a small index into a table of descriptions of
pointer locations. The mapping from program counter values to those small
indexes can be represented compactly using several techniques. The
techniques all assign numbers to call sites and use those numbers to index
an array of small indexes. One technique is to represent an array of return
addresses by using a two-level table with 16-bit offsets. Another technique
is to use a sparse array of return addresses and interpolate the exact
number via disassembly of the executable code.
}
}

@article{tarj72,
author = {R. Tarjan},
title = {Depth-first search and linear graph algorithms},
journal = {{SIAM} Journal of Computing},
volume = 1,
number = 2,
year = 1992
}

@inproceedings{taur97,
author = {Kenjiro Taura and Akinori Yonezawa},
institution = {University of Tokyo},
title = {An Effective Garbage Collection Strategy for Parallel Programming
Languages on Large Scale Distributed-Memory Machines},
crossref = {PPoPP97},
pages = {264--275},
doi = {10.1145/263764.263801}
}

@phdthesis{taur97a,
title = {Efficient and Reusable Implementation of Fine-Grain Multithreading and Garbage Collection on Distributed-Memory Parallel Computers},
author = {Kenjiro Taura and Akinori Yonezawa},
school = {University of Tokyo},
URL = {http://web.yl.is.s.u-tokyo.ac.jp/pub/papers/},
year = 1997
}

@article{tay13,
title = "An Equation-Based Heap Sizing Rule",
author = "Y.C. Tay and Xuanran Zong and Xi He",
journal = "Performance Evaluation",
volume = 70,
number = 11,
pages = "948--964",
year = 2013,
doi = "http://dx.doi.org/10.1016/j.peva.2013.05.009",
url = "http://www.sciencedirect.com/science/article/pii/S0166531613000606",
abstract = {For garbage-collected applications, dynamically-allocated objects
are contained in a heap. Programmer productivity improves significantly if there
is a garbage collector to automatically deallocate objects that are no longer
needed by the applications. However, there is a run-time performance overhead in
garbage collection, and this cost is sensitive to heap size H: a smaller H will
trigger more collection, but a large H can cause page faults, as when H exceeds
the size M of main memory allocated to the application.
This paper presents a Heap Sizing Rule for how H should vary with M. The Rule
can help an application trade less page faults for more garbage collection, thus
reducing execution time. It is based on a Heap-Aware Page Fault Equation that
models how the number of page faults depends on H and M. Experiments show that
this rule outperforms the default policy used by JikesRVM’s heap size manager.
Specifically, the number of faults and the execution time are reduced for both
static and dynamically changing M.}
}

@inproceedings{tayl86,
author = "George S. Taylor and Paul N. Hilfinger and James R. Larus and David A. Patterson and Benjamin G. Zorn",
title = "Evaluation of the {SPUR} {Lisp} Architecture",
booktitle = "13th Annual " # ISCA,
month = jun,
year = 1986
}

@book{tayl89,
title = "Parallel Logic Programming Techniques",
author = "S. Taylor",
publisher = PH,
year = "1989",
pages = "205",
isbn = "0--13--648767--X",
abstract = {This book explains the basics of parallel programming at a high level,
assuming that the reader is acquainted both with implementations of
sequential Prolog based on the Warren abstract machine (WAM) and with
fundamental concepts of parallel logic programming languages.
Chapter 4 covers the run-time environment for parallel logic programs.
An implementation of an abstract interpreter demonstrates problems such as
system-wide garbage collection and detection of global termination. The
author presents a suitable algorithm for each problem.  }
}


@article{tel87,
title = "The Derivation of On-The-Fly Garbage Collection Algorithms from
Distributed Termination Detection Protocols",
author = "Gerard Tel and Richard B. Tan and van Leeuwen, Jan ",
institution = "State University of  Utrecht, Department of Computer Science, POB 80012, 3508 TD Utrecht,
Netherlands",
journal = LNCS,
publisher = SV,
year = 1987,
volume = 247,
pages = "445--455"
}

@article{tel88,
title = "The Derivation of Graph Marking Algorithms from Distributed
Termination Detection Protocols",
author = "Gerard Tel and Richard B. Tan and van Leeuwen, Jan ",
address = "University of  Utrecht, Department of Computer Science, 3508 TA Utrecht, Netherlands",
journal = "Science Of Computer Programming",
year = 1988,
volume = 10,
number = 2,
pages = "107--137"
}

@inproceedings{tel91,
title = "The Derivation of Distributed Termination Detection Algorithms
from Garbage Collection Schemes",
author = "Gerard Tel and Friedmann Mattern",
institution = "{Department of Computer Science, Utrecht University, Netherlands} and
{University of  Kaiserslautern, Department of Computer Science, Germany}",
crossref = "PARLE91",
volume = 505,
pages = {137--149},
doi = {10.1007/BFb0035101},
comment = "Every active process and every message contains a reference to an object Z.
Z unreachable is equivalent to termination."
}

@article{tel93,
title = "The Derivation of Distributed Termination Detection Algorithms
from Garbage Collection Schemes",
author = "Gerard Tel and Friedmann Mattern",
institution = "{Department of Computer Science, Utrecht University, Netherlands} and
{University of  Kaiserslautern, Department of Computer Science, Germany}",
journal = TOPLAS,
publisher = ACM,
year = 1993,
month = Jan,
volume = 15,
number = 1,
comment = "Termination detection problem for distributed algorithms can be modelled as an
instance of the GC problem."
}

@book{tel91a,
author = "Gerard Tel",
title = "Topics in Distributed Algorithms",
publisher = CUP,
address = "New York",
series = "Cambridge international series on parallel computation",
volume = 1,
year = 1991,
ISBN = {0-521-47376-6}
}

@book{tel94,
author = "Gerard Tel",
title = "Introduction to Distributed Algorithms",
publisher = CUP,
year = 1994,
ISBN = {0-521-47069-2}
}

@incollection{temp91,
author = "Josef Templ",
title = "Garbage Collection on Open Arrays",
pages = "51--57",
booktitle = {Oberon Technical Notes},
editor = {Cuno Pfister and Beat Heeb and Josef Templ},
month = mar,
URL = "ftp://ftp.inf.ethz.ch/pub/publications/tech-reports/1xx/156.ps",
year = 1991,
note = "ETHZ Technical Report 156",
publisher = {ETH Eidgen\"{o}ssische Technische Hochschule Z\"{u}rich}
}

@inproceedings{tene11,
  author =	 {Gil Tene and Balaji Iyengar and Michael Wolf},
  title =	 {{C4}: The Continuously Concurrent Compacting Collector},
  crossref =	 {ISMM11},
  pages =	 {79--88},
  doi =		 {10.1145/1993478.1993491}
}

@article{tera78,
author = "Motoaki Terashima and  Eiichi Goto",
title = "Genetic Order and Compactifying Garbage Collectors",
journal = IPL,
publisher = NH,
volume = 7,
number = 1,
month = Jan,
year = 1978,
pages = "27--32",
comment = {algorithm for compacting varisized cells},
doi = {10.1016/0020-0190(78)90034-0}
}

@techreport{tera04,
author = {T. Terauchi and Alex Aiken},
title = {Memory Management with Use-Counted Regions},
institution = UCB,
numbr = {UCS/CSD--04--1314},
month = mar,
year = 2004
}

@inproceedings{tere14,
title = {M$^3$: High-Performance Memory Management from Off-The-Shelf Components},
author = {David Terei and Alex Aiken and Jan Vitek},
pages = {2--13},
crossref = {ISMM14},
doi = {10.1145/2602988.2602995},
abstract = {Real-world garbage collectors in managed languages are complex. We
investigate whether this complexity is really necessary and show that by having
a different (but wider) interface between the collector and the developer, we
can achieve high performance with off-the-shelf components for real
applications. We propose to assemble a memory manager out of multiple, simple
collection strategies and to expose the choice of where to use those strategies
in the program to the developer. We describe and evaluate an instantiation of
our design for C. Our prototype allows developers to choose on a per-type basis
whether data should be reference counted or reclaimed by a tracing collector.
While neither strategy is optimised, our empirical data shows that we can
achieve performance that is competitive with hand-tuned C code for real-world
applications.}
}

@article{terr88,
author = "Douglas B. Terry and Daniel C. Swinehart",
title = "Managing Stored Voice in the Etherphone System",
journal = TransCompSys,
publisher = ACM,
volume = 6,
number = 1,
pages = "3--27",
month = feb,
year = 1988,
abstract = "The voice mailer in the Etherphone system provides
facilities for recording, editing, and playing stored
voice in a distributed personal-computing environment.
It provides the basis for applications such as voice
mail, annotation of multimedia documents, and voice
editing using standard text-editing techniques. To
facilitate sharing, the voice manager stores voice on a
special voice file server that is accessible via the
local internet. Operations for editing a passage of
recorded voice simply build persistent data structures
to represent the edited voice. These data structures,
implementing an abstraction called voice ropes, are
stored in a server database and consist of lists of
intervals within voice files. Clients refer to voice
ropes solely by reference. Interests, additional
persistent data structures maintained by the server,
serve two purposes: First, they provide a sort of
directory service for managing the voice ropes that
have been created. More importantly, they provide a
reliable reference-counting mechanism, permitting the
garbage collection of voice ropes that are no longer
needed. These interests are grouped into classes; for
some important classes, obsolete interests can be
detected and deleted by a class-specific algorithm that
runs periodically."
}

@manual{texa87,
key = "Explorer",
organisation = "Texas Instruments",
title = "Explorer (tm) System Software Design Notes",
note = "Texas Instruments part number 2243208--0001*A",
month = jun,
year = 1987
}

@inproceedings{thac87,
  author =	 "Charles P. Thacker and Lawrence C. Stewart",
  title =	 "Firefly: A Multiprocessor Workstation",
  crossref =	 "ASPLOS87",
  pages =	 "164--172",
  doi =		 {10.1145/36206.36199},
  note =	 "Also DEC SRC Research report 23, December 1987"
}

@article{thaz87,
title = "On the Structural Locality of Reference in {L}isp List Access
Streams",
author = "M. J. Thazhuthaveetil and A. R. Pleszkun",
address = "{Penn State University, Department of Elect Engn} and
{University of  Wisconsin, Department of Computer Science, Madison, WI}",
journal = IPL,
publisher = NH,
year = 1987,
volume = 26,
number = 2,
pages = "105--110"
}

@article{thes77,
author = "Arne Thesen and Tad Pinkerton",
title = "Predicting the Availability of Contiguous Memory",
journal = "International Journal of Computer and Information Sciences",
volume = 6,
number = 4,
pafges = "279--287",
month = dec,
year = 1977
}

@article{thie89,
author = "Dominique Thiebaut",
title = "The Fractal Dimension of Computer Programs and its Application
to the Prediction of the Cache Miss Ratio",
journal = IEEETransComp,
publisher = IEEE,
month = jul,
year = 1989,
pages = {1012--1026}
}

@article{thie92,
author = "Dominique Thiebaut and Joel L. Wolf and Harold S. Stone",
title = "Synthetic Traces for Trace-Driven Simulation of Cache Memories",
journal = IEEETransComp,
publisher = IEEE,
volume = 41,
number = 4,
month = apr,
year = 1992,
pages = "388-410"
}

@techreport{thom96,
author = {Clark D. Thomborson},
title = {When Virtual Memory isn't Enough},
institution = {University of Auckland},
number = 136,
URL = {http://www.cs.auckland.ac.nz/~techrep/TR136/doc.ps},
month = nov,
year = 1996
}

@phdthesis{thom87,
author = "James G. Thompson",
title = "Efficient Analysis of Caching Systems",
school = UCB,
month = oct,
year = 1987,
note = "Also technical report UCB/CSD 87/374"
}

@techreport{thom81,
author = "R. E. Thomas",
title = "A Dataflow Computer with Improved Asymptotic Performance",
institution = "MIT Laboratory for Computer Science",
year = 1981,
number = "MIT/LCS/TR--265",
comment = {Weighted reference counting},
}

@phdthesis{thom93,
author = {Stephen P. Thomas},
title = {The Pragmatics of Closure Reduction},
school = "The Computing Laboratory, University of Kent at Canterbury",
month = oct,
year = 1993,
comment = "Tailored GC. GC routines are generated at compile time for
each closure. Uses a copying collector but it must be recursive as
different slots in environment frames may be traced by different
routines."
}

@techreport{thom94,
author = "Stephen P. Thomas and Richard E. Jones",
title = "Garbage Collection for Shared Environment Closure Reducers",
institution = "University of Kent and University of Nottingham",
number = "31--94",
URL = "http://www.cs.ukc.ac.uk/pubs/1994/147/",
month = dec,
year = 1994,
annote = "Describes some of the issues facing the implementor of a
                  garbage collector for TIM.  Covers space leaks, need for
                  recursion, tailored garbage collections."
}

@unpublished{thom95,
author = "Stephen P. Thomas",
title = "Having Your Cake and Eating It: Recursive Depth-First Copying Garbage
Collection with No Extra Stack",
institution = "University of Nottingham",
month = may,
year = 1995,
note = "Personal communication"
}

@article{thom95a,
title = "Garbage Collection in Shared-Environment Closure Reducers:
Space-Efficient Depth First Copying using a Tailored Approach",
author = "Stephen P. Thomas",
pages = "1--7",
journal = IPL,
month = oct,
year = 1995,
volume = 56,
number = 1,
doi={10.1016/0020-0190(95)00131-U}
}

@misc{thom98,
author = {Thomas, S. and Charnell, W. and Darnell, S. and Dias, B. A. A. and
Kramskoy, J. G. P. and Sextonand, J. and Wynn, J. and Rautenbach, K. and
Plummer, W.},
title ={Low-Contention Grey Object Sets for Concurrent, Marking Garbage
Collection},
howpublished = {United States Patent Application, 20020042807},
year = 1998
}

@unpublished{thom88,
author = "Simon J. Thompson and Rafael D. Lins",
title = "Cyclic Reference Counting: A Correction to {B}rownbridge's Algorithm",
address = "The University of Kent at Canterbury, England",
year = 1988,
note = "Unpublished notes",
comment = {Presents a correction to Brownbridge's algorithm which is
similar to the one suggested in \cite{salk87}}
}

@article{thor72,
author = "Lars-Erik Thorelli",
title = "Marking Algorithms",
journal = "BIT",
volume = 12,
number = 4,
year = 1972,
pages = "555--568",
comment = {variant of Deutsch-Schorr-Waite algorithm for varisized cells.},
}

@article{thor76,
author = "Lars-Erik Thorelli",
title = "A Fast Compactifying Garbage Collector",
journal = "BIT",
volume = 16,
number = 4,
year = 1976,
pages = "426--441",
comment = {variant of Deutsch-Schorr-Waite algorithm for varisized cells.},
}

@book{tick88,
author = {E. Tick},
title = {Memory performance of {P}rolog Architectures},
publisher = {Kluwer},
year = 1988
}

@inproceedings{tick92,
title = "A Compile-Time Memory-Reuse Scheme for Concurrent Logic Programs",
author = "S. Duvvuru and R. Sundararajan and E. Tick and A. V. S. Sastry and L. Hansen and X. Zhong",
crossref = "IWMM92",
pages = {264--276},
doi = {10.1007/BFb0017195},
}

@inproceedings{tiki05,
author = {Tikir, Mustafa M. and Hollingsworth, Jeffery K.},
title = {{NUMA}-Aware {J}ava Heaps for Server Applications},
booktitle = {19th IEEE International Parallel and Distributed Processing Symposium (IPDPS)},
address = {Denver, CO},
year = 2005,
pages = {108.2},
doi = {10.1109/IPDPS.2005.299},
publisher = IEEEcomp,
}

@techreport{ting75,
author = "D. W. Ting",
title = "Some Results of the Space Requirements of Dynamic Memory Allocation Algorithms",
institution = Cornell,
number = "75-229",
month = feb,
year = 1975
}

@techreport{toft94,
author = {Mads Tofte and Jean-Pierre Talpin},
title = {A Theory of Stack Allocation in Polymorphically Typed Languages},
number = {Computer Science 93/15},
institution = {University of Copenhagen},
month = jul,
year = 1993
}

@inproceedings{toft94a,
author = {Mads Tofte and Jean-Pierre Talpin},
title = {Implementation of the Typed Call-by-Value $\lambda$-Calculus using a Stack of Regions},
crossref = {POPL94},
URL = {http://www.acm.org/sigplan/proceedings/popl94/PS/S6P1.PS},
pages = {188--201},
doi={10.1145/174675.177855}
}

@article{toft97,
  author =	 {Mads Tofte and Jean-Pierre Talpin},
  title =	 {Region-Based Memory Management},
  journal =	 {Information and Computation},
  volume =	 132,
  number =	 2,
  month =	 feb,
  year =	 1997,
  pages =	 {109-176},
  URL =
                  {http://www.diku.dk/research-groups/topps/activities/kit2/infocomp97.ps},
  note =	 {An earlier version of this was presented at \cite{POPL94}}
}

@techreport{toft97a,
author = {Mads Tofte and Lars Birkedal and Martin Elsman and Niels Hallenberg and Tommy H{\o}jfeld Olesen and Peter Sestoft and Peter Bertelsen},
title = {Programming with {R}egions in the {ML} {K}it},
number = {DIKU-TR-97/12},
institution = DIKU,
month = apr,
year = 1997,
URL = {http://www.diku.dk/research-groups/topps/activities/kit2/diku97-12.a4.ps.gz}
}

@inproceedings{toft98,
author = {Mads Tofte},
title = {A Brief Introduction to {R}egions},
pages = {186--195},
crossref= {ISMM98},
abstract = {Region-based memory management is a novel form of memory
management for ML-like languages. At runtime, the store is organised as
a stack of so-called regions. A static analysis, called region
inference, determines when regions are allocated and de-allocated and,
for every value-producing expression, into what region the value should
be stored.

The talk gives and overview of the compilation steps that are involved
in region-based memory management for Standard ML. The main emphasis of
the talk is on organisation of a region-based runtime system. The work
is based on experience with the ML Kit with Regions, a new Standard ML
compiler which used regions, instead of traditional garbage collection
techniques, for memory management.}
}

@article{toft98a,
author = {Mads Tofte and Lars Birkedal},
title = {A Region Inference Algorithm},
journal = TOPLAS,
volume = 20,
number = 4,
pages = {734--767},
month = jul,
year = 1998
}

@techreport{toft01,
author = {Mads Tofte and Lars Birkedal and Martin Elsman and Niels Hallenberg and Tommy H{\o}jfeld Olesen and Peter Sestoft},
title = {Programming with {R}egions in the {ML} {K}it, version 4},
institution = {IT University of Copenhagen},
month = oct,
year = 2001,
URL = {http://www.it.edu/research/mlkit/dist/mlkit-4.3.0.pdf}
}

@inproceedings{toft01a,
author = {Mads Tofte and Niels Hallenberg},
title = {Region-based memory management in perspective},
crossref = {SPACE01},
note = {Invited talk}
}

@article{toft04,
author = {Mads Tofte and Lars Birkedal and Martin Elsman and Niels Hallenberg},
title = {A Retrospective on Region-based Memory Management},
journal = {Higher-Order and Symbolic Computation},
volume = 17,
number = 3,
month = sep,
year = 2004,
doi={10.1023/B:LISP.0000029446.78563.a4},
pages={245--265}
}

@inproceedings{tolm94,
  author =	 "Andrew Tolmach",
  title =	 "Tag-Free Garbage Collection Using Explicit Type Parameters",
  crossref =	 "PLDI94",
  pages =	 "1--11",
  doi =		 {10.1145/182409.182411},
  comment =	 "ftp://ftp.cs.pdx.edu/pub/faculty/apt/tagfree_gc.ps",
}

@phdthesis{tong97,
author    = "Guanshan Tong",
title     = "Leveled Garbage Collection For Automatic Memory Management",
school    = "University of Chicago",
URL="http://www.cs.uchicago.edu/~guanshan/Dissertation/dissertation.ps",
month     = nov,
year      = 1997,
abstract = {Generational garbage collection is one of the most popular
memory management techniques. However, poor predictions of object
lifetimes can greatly reduce the effectiveness of generational
garbage collectors. Some research has addressed this problem,
but without much success.
This dissertation presents Leveled Garbage Collection, a new
algorithm that is not based on object ages. It uses a heap
structure and collection scheme similar to those of generational
garbage collectors, and has a non-age-based promotion policy
that doesn't promote all of the live objects, but still
guarantees ample free space immediately after each garbage
collection.
Performance evaluation shows that Leveled Garbage Collection
not only substantially outperforms generational garbage
collectors on a wide range of problems, but also demonstrates
superior virtual memory performance. }
}

@article{tong01,
author    = {Guanshan Tong and Michael J. O'Donnell},
title     = {Leveled Garbage Collection},
journal = {The Journal of Functional and Logic Programming},
publisher = {EAPLS},
month =jul,
year = 2001,
abstract = {Generational garbage collection (GGC) is one of the most popular
garbage collection techniques. GGC gains a performance advantage by performing
minor collections on the younger objects in the heap, reducing the number of
major collections of the whole heap. A promotion policy determines when an
object moves from the younger generation to the older. The design of GGC has
been justified by the plausible assumption that many objects die very young, and
a few live a very long time. But, attempts to tune the performance of GGC by
adjusting the promotion policy have been disappointing - only the simplest
immediate promotion policy has proved attractive. The success of GGC is probably
due to simplicity and to avoiding scans of the whole heap, rather than to
accurate lifetime predictions.
This paper presents Leveled Garbage Collection (LGC), a new algorithm that is
not based on object ages. It uses a heap structure and collection scheme similar
to those of generational garbage collectors, and has a non-age-based promotion
policy that doesn't promote all of the live objects, but still guarantees ample
free space immediately after each garbage collection. By tuning LGC's promotion
policy, we can often improve on GGC with immediate promotion.
Performance comparisons show that LGC outperforms GGC with immediate promotion
policy in many cases, while losing only slightly on cases favorable to immediate
promotion. LGC has a substantial advantage when the heap fits in main memory,
and an even greater advantage as the heap gets paged to disk.},
URL = {http://scholar.lib.vt.edu/ejournals/JFLP/jflp-mirror/articles/2001/A2001-05/JFLP-A2001-05.pdf}

}

@inproceedings{tong10,
title = {Exploiting Memory Usage Patterns to Improve Garbage Collections in {J}ava},
author = {Liangliang Tong and Francis C.M. Lau},
crossref = {PPPJ10}
}

@inproceedings{tong10a,
title = {Index-Compact Garbage Collection},
author = {Liangliang Tong and Francis C.M. Lau},
booktitle = {Proceedings of the Eighth Asian Symposium on Programming Languages
and Systems (APLAS'10)},
address = {Shanghai, China},
series = LNCS,
number = 6461,
pages = {271--286},
year = 2010
}

@article{topo79,
author = "R. Topor",
title = "The Correctness of the {S}chorr--{W}aite List Marking Algorithm",
journal = ActInf,
publisher = SV,
volume = 11,
number = 3,
year = 1979,
comment = {proves the correctness of the link reversal algorithm by Deutsch-Schorr-Waite},
}

@article{torp08,
  title =	 {Local Reasoning about a Copying Garbage Collector},
  author =	 {Noah Torp-Smith and Lars Birkedal and John C. Reynolds},
  journal =	 TOPLAS,
  volume =	 30,
  number =	 4,
  month =	 jul,
  year =	 2008,
  doi =		 {10.1145/1377492.1377499},
  abstract =	 {We present a programming language, model, and logic
                  appropriate for implementing and reasoning about a memory
                  management system. We state semantically what is meant by
                  correctness of a copying garbage collector, and employ a
                  variant of the novel separation logics to formally specify
                  partial correctness of Cheney's copying garbage collector in
                  our program logic. Finally, we prove that our implementation
                  of Cheney's algorithm meets its specification using the
                  logic we have given and auxiliary variables.}
}

@phdthesis{tour88,
author = {Toura\"{i}vane},
title = {La R\'{e}cup\'{e}ration de M\'{e}moire dans les Machines
Non-D\'{e}terministes},
school = {Universit\'{e} d'Aix-Marseille},
year = 1988,
}

@techreport{toua88,
author = "Touati, Herv\'{e}",
title = "A Prolog Garbage Collector for {A}quarius",
institution = UCB,
number = "UCB//CSD-88-443",
month = aug,
year = 1988,
abstract = "Our design is the result of an attempt to incorporate into
Prolog implementations the ideas which made generation scavenging
successful for Lisp and Smalltalk. The main challenge was to take
Prolog technique of memory recovery upon backtracking based on
stack deallocation. We were able to do so with little extra overhead
top of the global stack. This strategy has several advantages: it
improves the locality of the executing program by keeping the data
structures compacted and by allocating new objects in a fixed part
of the address space; it improves the locality and the predictability
of the garbage collection, which can concentrate its efforts on the
fixed size area where new objects are allocated; and it allows us to
use simpler, time-efficient garbage collection algorithms. The
performance of the algorithm is further enhanced by the use of
copying algorithms whenever made possible by the deterministic
nature of the executing program."
}

@inproceedings{toua88a,
author = {Touati, Herv\'{e} and Toshiyuki Hama},
title = {A Light-Weight {P}rolog Garbage Collector},
booktitle = {International Conference on Fifth Generation Computer Systems},
address = {Tokyo},
pages = {922--930},
year = 1988
}

@inproceedings{tran08,
title = {A Reference Counting Garbage Collection Algorithm for Cyclical
Functional Programming},
author = {Trancon y Widemann, Baltasar},
crossref = {ISMM08},
pages = {71--80},
doi = {10.1145/1375634.1375645},
abstract = {Reference-counting garbage collection is known to have
problems with the collection of cyclically connected data. There
are two historically significant styles of cycle-aware algorithms:
The style of Brownbridge that maintains a subset of marked edges
and the invariant that every cycle contains at least one marked
edge, and the style of Martinez-Lins-Wachenchauzer (MLW) that
involves local mark-and-scan procedures to detect cycles. The former
is known to be difficult to design and implement correctly, and the
latter to have pathological efficiency for a number of very typical
situations. We present a novel algorithm that combines both approaches
to obtain reasonably efficient local mark-and-scan phases with a
marking invariant that is rather cheap to maintain. We demonstrate
that the assumptions of this algorithm about mutator activity
patterns make it well-suited, but not limited, to a functional
programming technique for cyclic data. We evaluate the approach in
comparison with simple and more sophisticated MLW algorithms using
a simple benchmark based on that functional paradigm.},
comment = {Looks correct though the proof has errors.
However, implementation is for an unusual style of functional programming
and it's not clear how a general language would insert weak edges.}
}

@inproceedings{tull93,
title = "Limitations of Cache Prefetching on a Bus-Based Multiprocessor",
author = "Dean M. Tullsen and Susan J. Eggers",
crossref = "ISCA93",
pages = {278--288}
}

@inbook{turb08,
  title =	 {Garbage Collection},
  booktitle =	 {Design Concepts in Programing Languages},
  author =	 {Franklyn Turbak and David Gifford and Mark A. Sheldon},
  chapter =	 18,
  year =	 2008,
  publisher =	 MIT,
}

@article{turn79,
author = "David A. Turner",
title = "A New Implementation Technique for Applicative Languages",
journal = SPE,
publisher = Wiley,
volume = 9,
year = 1979,
pages = {31--49},
month = jan,
doi={10.1002/spe.4380090105},
comment = "The Turner combinators paper."
}

@incollection{turn81,
author = "David A. Turner",
title = "Recursion Equations as a Programming Language",
booktitle = "Functional Programming and its Applications",
editor = "John Darlington and Peter Henderson and David Turner",
month = jan,
pages = "1--28",
publisher = CUP,
year = 1981
}

@inproceedings{turn85,
author = "David A. Turner",
title = "Miranda --- a Non-Strict Functional Language with Polymorphic Types",
crossref = "FPCA85",
pages = "1--16",
}

@inproceedings{ueda90,
author = "K. Ueda and M. Morita",
title = "A New Implementation for Flat {GHC}",
crossref = "ICLP90",
pages = "3--17",
}

@inproceedings{ueno1,
author = {Ueno, Katsuhiro and Ohori, Atsushi and Otomo, Toshiaki},
title = {An Efficient Non-Moving Garbage Collector for Functional Languages},
crossref = {ICFP11},
pages = {196--208},
doi = {http://doi.acm.org/10.1145/2034773.2034802},
keywords = {bitmap marking, generational collectors, non-moving garbage collection, sml\#},
abstract = {Motivated by developing a memory management system that allows
functional languages to seamlessly inter-operate with C, we propose an
efficient non-moving garbage collection algorithm based on bitmap marking and
 report its implementation and performance evaluation.
In our method, the heap consists of sub-heaps $H_i | c \le i \le B$ of
exponentially increasing allocation sizes ($H_i$ for $2^i$ bytes) and a special
sub-heap for exceptionally large objects. Actual space for each sub-heap is
dynamically allocated and reclaimed from a pool of fixed size allocation
segments. In each allocation segment, the algorithm maintains a bitmap
representing the set of live objects. Allocation is done by searching for the
next free bit in the bitmap. By adding meta-level bitmaps that summarize the
contents of bitmaps hierarchically and maintaining the current bit position in
the bitmap hierarchy, the next free bit can be found in a small constant time
for most cases, and in $\log_{32}(segmentSize)$ time in the worst case on a
32-bit architecture. The collection is done by clearing the bitmaps and tracing
live objects. The algorithm can be extended to generational GC by maintaining
multiple bitmaps for the same heap space. The proposed method does not require
compaction and objects are not moved at all. This property is significant for a
functional language to inter-operate with C, and it should also be beneficial in
supporting multiple native threads.
The proposed method has been implemented in a full-scale Standard ML compiler.
Our benchmark tests show that our non-moving collector performs as efficiently
as a generational copying collector designed for functional languages.}
} 

@inproceedings{ugaw10,
author = {Ugawa, Tomoharu and Iwasaki, Hideya and Yuasa, Taiichi},
title = {Improved Replication-based Incremental Garbage Collection for Embedded Systems},
crossref = {ISMM10},
pages = {73--82},
doi = {10.1145/1806651.1806664},
abstract = {We have developed an incremental compacting garbage collector for
embedded Java systems. The collector divides the heap into equal sized pages and
uses the segregated free lists for fast allocation. Collectors that have such a
heap layout have a problem of fragmentation in allocating objects larger than
the page size. We solve this problem by using the replication-based incremental
compaction. The compactor evacuates all objects in one area, the evacuation
area, of the heap, thereby creating a large chunk of free space. We developed an
algorithm for choosing the evacuation area that effectively cures fragmentation.
The compactor does not use any read-barriers. Instead, it uses a technique
similar to the replication-based incremental copying collection. This needs
forwarding pointers for all evacuated objects. Rather than introducing an extra
field for each object, we use a hash table to store forwarding pointers.
Evaluation of this garbage collector implemented in Sun's J2ME Java Virtual
Machine showed that all the benchmarks used were able to run without memory
starvation using the heap sizes of only 151\%-286\% of the maximum amount of live
data plus 8 KB of the hash table. Experiments on a desktop computer, though it
is not a platform for embedded systems, showed that the maximum pause time was
shorter than 200 microseconds, which was comparable to that of our implementation of the
snapshot-at-the-beginning collector without compaction. On an ARM processor, the
runtime overhead was 1\%-16\% with 8.0\% on average compared to the mark-sweep
collector.}
}

@inproceedings{ugaw10b,
  author =	 {Ugawa, Tomoharu and Iwasaki, Hideya and Yuasa, Taiichi},
  title =	 {Starvation-Free Heap Size for Replication-Based Incremental
                  Compacting Garbage Collection},
  booktitle =	 {International Conference on Lisp},
  pages =	 {43--52},
  year =	 2010,
  address =	 {Reno/Sparks, NV},
  month =	 oct,
  doi =		 {10.1145/1869643.1869649}
}

@inproceedings{ugaw14,
title = {Reference Object Processing in On-The-Fly Garbage Collection},
author = {Tomoharu and Richard Jones and Carl G. Ritson},
doi = {10.1145/2602988.2602991},
pages = {59--69},
crossref = {ISMM14},
abstract = {Most proposals for on-the-fly garbage collection ignore the question
of Java’s weak and other reference types. However, we show that reference
types are heavily used in DaCapo benchmarks. Of the few collectors that do
address this issue, most block mutators, either globally or individually, while
processing reference types. We introduce a new framework for processing
reference types on-the-fly in Jikes RVM. Our framework supports both insertion
and deletion write barriers. We have model checked our algorithm and
incorporated it in our new implementation of the Sapphire on-the-fly collector.
Using a deletion barrier, we process references \emph{while mutators are
running} in less than three times the time that previous approaches take
\emph{while mutators are halted}; our overall execution times are no worse, 
and often better.}
}

@incollection{unga83,
author = "David M. Ungar and David A. Patterson",
title = "Berkeley {S}malltalk: Who Knows Where the Time Goes?",
crossref = "Smalltalk-BHWA",
pages = "189--206",
}

@inproceedings{unga84,
title =	 "Generation Scavenging: A Non-Disruptive High Performance Storage Reclamation Algorithm",
author = "David M. Ungar",
booktitle = {ACM/SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments},
series = SIGPLAN # { 19(5)},
pages =	 "157--167",
publisher = ACM,
month =	 apr,
address = {Pittsburgh, PA},
year =	 1984,
doi={10.1145/800020.808261},
comment = {One of the original papers (and suggested to be better to
          read than Liebermann and Hewitt).  Uses only two
          generations.  Paging-out recently allocated data is
          expensive.  Doesn't pay to make heap area larger than the
          available main memory.  Avoids some of this problem.
          Recursive freeing in reference counters: 5 percent Berkeley
          Smalltalk, 1.9 percent Dorado Smalltalk.  },
}

@book{unga86,
title = "The Design and Evaluation of a High Performance {S}malltalk System",
author = "David M. Ungar",
publisher = MIT,
series = "{ACM} distinguished dissertation 1986",
year = 1986,
abstract = {This is a Ph.D. dissertation in book form. It is also the ACM Distinguished
Dissertation of 1986.
The research reported in this book is related to the design and performance
evaluation of a RISC (reduced instruction set computer) system designed to
run the Smalltalk-80 exploratory programming environment (EPE). EPE
provides a rapid program development cycle for programmers. Smalltalk
systems are object-oriented programming systems that provide program
abstraction and reduction in written code. Unfortunately, such systems so
far have been large, expensive (exceeding 80,000), and slow. The author
has taken Smalltalk-80 EPE and has tried to design a language-specific RISC
system that he calls SOAR (Smalltalk on a RISC). SOAR is a mix of VLSI
technology and intelligent software routines that gets a better performance
at a lower cost compared to existing systems. The author and his colleagues
have built VLSI implementations of SOAR and a Smalltalk interpreter and
have tested the design and performance of SOAR. The book presents all these
in amazing detail.
The book has seven chapters and a bibliography, followed by two appendices.
Chapter 5 describes a new garbage-collection method called ``generation
scavenging.'' The synopsis of past work is nicely done indeed. The new
algorithm and its code in pidgin C are described in detail. With appropriate
diagrams, the author explains how objects are created, saved, and removed from
the memory (memory-reclamation) and also compares the algorithm with some
existing ones. The performance evaluation and advantages of the suggested
algorithm are detailed in the text and tables. Some disadvantages are also
mentioned.
The above algorithm allocates a ``tenure'' status to objects surviving
garbage collection. What if such objects are not needed just after being
tenured? Moreover, at what point can an object be tenured? These issues are
the subject of chapter 6. This chapter describes the analysis and
evaluation of the issues mentioned. The experiments were done on Berkeley}
}

@inproceedings{unga88,
  title =	 "Tenuring Policies for Generation-Based Storage Reclamation",
  author =	 "David M. Ungar and Frank Jackson",
  crossref =	 {OOPSLA88},
  pages =	 "1--17",
  doi =		 {10.1145/62083.62085},
  comment =	 "All 3 US commercial Smalltalks (DigiTalk, Tektronix and
                  ParcPlace) use generational GCs"
}

@inproceedings{unga91,
author = "David M. Ungar and Frank Jackson",
title = "Outwitting {GC} Devils: A Hybrid Incremental Garbage Collector",
crossref = "OOPSLA91-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/ungar.ps"
}

@article{unga92,
title = "An Adaptive Tenuring Policy for Generation Scavengers",
author = "David M. Ungar and Frank Jackson",
journal = TOPLAS,
publisher = ACM,
year = 1992,
volume = 14,
number = 1,
pages = "1--27",
doi={10.1145/111186.116734},
comment = {The performance of generational scavenging schemes may be poor if many objects
are fairly long-lived. Performance may be improved by
(a) segregating large bitmaps and strings, and
(b) adapting the scavenger's tenuring policy according to demographic
feedback.
Copying collector but uses a separate large object area.
State-of-art Smalltalk uses less than 5 percent GC, better than 100ms pause-time.}
}

@inproceedings{unga09,
author = {David M. Ungar and S.S. Adams},
title = {Hosting an Object heap on Many-Core Hardware: an Exploration},
booktitle = {5th Symposium on Dynamic Languages},
pages = {99--110},
year = 2009
}

@inproceedings{ungu97,
title = {Formal Models of Distributed Memory Management},
author = {Christian Ungureanu and Benjamin Goldberg},
pages = {280--291},
crossref = {ICFP97},
URL = {http://www.acm.org/pubs/articles/proceedings/fp/258948/p280-ungureanu/p280-ungureanu.pdf}
}

@techreport{unni00,
title = {Automatic Accurate Stack Space and Heap Space Analysis for High-Level Languages},
author = {Leena Unnikrishnan and Scott D. Stoller and Yanhong A. Liu},
institution = {Indiana University},
number = 538,
month = apr,
year = 2000,
URL = {http://www.cs.sunysb.edu/~leena/papers/dar012.ps.gz},
abstract = {This paper describes a general approach for automatic and accurate space
and space-bound analyses for high-level languages, considering stack
space, heap allocation and live heap space usage of programs. The approach
is based on program analysis and transformations and is fully
automatic. The analyses produce accurate upper bounds in the presence of
partially known input structures. The analyses have been implemented, and
experimental results confirm the accuracy.}
}

@inproceedings{unni01,
  title =	 {Automatic Accurate Live Memory Analysis for
                  Garbage-Collected Languages},
  author =	 {Leena Unnikrishnan and Scott D. Stoller and Yanhong A. Liu},
  crossref =	 {LCTES01},
  pages =	 {102-111},
  doi =		 {10.1145/384197.384212},
  URL =		 {http://www.cs.sunysb.edu/~leena/papers/LCTES2001.ps.gz},
  abstract =	 {This paper describes a general approach for automatic and
                  accurate live heap space and live heap space-bound analyses
                  for high-level languages.  The approach is based on program
                  analysis and transformations and is fully automatic.  The
                  space-bound analysis produces accurate (tight) upper bounds
                  in the presence of partially known input structures.  The
                  analyses have been implemented and experimental results
                  confirm their accuracy.}
}

@techreport{unni01a,
author = {Leena Unnikrishnan and Scott D. Stoller and Yanhong A. Liu},
title = {Optimized Live Heap Bound Analysis},
institution = {SUNY at Stony Brook},
number = {DAR 01-2},
month = oct,
year = 2001,
URL = {http://www.cs.sunysb.edu/~leena/papers/dar012.ps.gz},
abstract = {This paper describes a general approach for optimized live heap space and
live heap space-bound analyses for garbage-collected languages.  The approach
is based on program analysis and transformations and is fully automatic.  The
space-bound analysis produces accurate (tight) upper bounds in the presence
of partially known input structures.  The optimization drastically improve
the analysis efficiency.  The analyses have been implemented and experimental
results confirm their accuracy and efficiency.}
}

@inproceedings{unni09,
title = {Parametric Heap Usage Analysis for Functional Programs},
author = {Leena Unnikrishnan and Scott D. Stoller},
pages = {139--148},
doi = {10.1145/1542431.1542451},
crossref = {ISMM09}
}

@inproceedings{valo95,
author = {J.D. Valois},
title = {Lock-Free Linked Lists Using Compare-and-Swap},
booktitle = "14th ACM Symposium on Principles of Distributed Computing (PODC) ",
pages = {214--222},
month = aug,
year = 1995
}

@phdthesis{valo95a,
author = {J.D. Valois},
title = {Lock-free data structures},
school = {Rensselaer Polytechnic Institute},
year = 1995
}

@inproceedings{vand03,
  title =	 {A Typed Interface for Garbage Collection},
  author =	 {Joseph C. Vanderwaart and Karl Crary},
  crossref =	 {TLDI03},
  pages =	 {109--122},
  doi =		 {10.1145/604174.604189}
}

@inproceedings{vard02,
title = {Using Passive Object Garbage Collection Algorithms},
author = {Abhay Vardhan and Gul Agha},
crossref = {ISMM02},
pages = {106--113}
}

@article{varh97,
title = {Adapting {J}ava for Embedded Systems},
author = {Peter Varhol},
journal = {Computer Design},
month = oct,
year = 1997,
pages = 75,
comment = {NewMonics Inc real-time Java}
}

@Article{varm08,
  author =	 {Carsten Varming and Lars Birkedal},
  title =	 {Higher-Order Separation Logic in Isabelle/HOLCF},
  journal =	 {Electronic Notes in Theoretical Computer Science},
  year =	 2008,
  volume =	 218,
  pages =	 {371--389},
  month =	 oct,
  doi =		 {10.1016/j.entcs.2008.10.022}
}

@inproceedings{vata84,
title = "Finding Temporary Terms in {PROLOG} Programs.",
author = "P. Vataja and E. Ukkonen",
institution = "University of Helsinki, Helsinki, Finland",
booktitle = "International Conference on Fifth Generation Computer Systems",
address = "Tokyo",
month = nov,
publisher = "Ohmsha Ltd",
pages = "275--282",
year = 1984,
isbn = "4--274--07221--5",
abstract = {We consider the memory management in backtrack-based Prolog
implementations where the Prolog terms are represented as linked data
structures that may have shared substructures.  An approach called direct
garbage collection is examined.  The goal is to develop methods for locating at
any moment of the Prolog program execution the terms which are not needed any
more and which do not share substructures with terms that are still needed.
Two methods for these temporary terms are proposed.  The dynamic method is
applied together with the program execution.  The static method is applied
before the program is actually executed, but the outputs can be utilized in
organizing garbage collection of every subsequent execution of the
program, as long as the program does not change.}
}

@inproceedings{vaug90,
author = "Francis Vaughan and T. Schunke and B. Koch and A. Dearle and C. Marlin
 and C. Barter",
title = "A Persistent Distributed Architecture Supported by the Mach Operating
System",
booktitle = "1st USENIX Conference on the Mach Operating System",
publisher = UA,
year = 1990,
pages = {123--140}
}

@inproceedings{vaug92,
author = "Francis Vaughan and Alan Dearle",
title = "Supporting Large Persistent Stores Using Conventional Hardware",
crossref = "POS92",
}

@inproceedings{vaug00,
author = {Francis A. Vaughan and William F. Brodie-Tyrrell and  Katrina E. Falkner and David S. Munro},
title = {Bounded Parallel Garbage Collection: Implementation and Adaptation},
booktitle = {7th Australian Parallel and Real Time (PART)},
address = {Sydney},
year = 2000,
URL = {http://www.cs.adelaide.edu.au/users/jacaranda/publications.html},
comment = {Implementation of \cite{blel99}}
}

@inproceedings{vech03,
title = {Class Unloading with a Concurrent Garbage Collector in an Embedded {J}ava
{VM}},
author = {Martin T. Vechev and Peter D. Petrov},
booktitle = {Embedded Systems and Applications 2003 (ESA'03)},
year = 2003
}

@inproceedings{vech04,
title = {Write Barrier Elision for Concurrent Garbage Collectors},
author = {Martin Vechev and David F. Bacon},
pages = {13--24},
crossref = {ISMM04},
doi = {10.1145/1029873.1029876}
}

@inproceedings{vech05,
  title =	 {Derivation and Evaluation of Concurrent Collectors},
  author =	 {Martin Vechev and David F. Bacon and Perry Cheng and David
                  Grove},
  crossref =	 {ECOOP05},
  doi =		 {10.1007/11531142_25},
  pages =	 {577--601}
}

@inproceedings{vech06,
  title =	 {Correctness-Preserving Derivation of Concurrent Garbage
                  Collection Algorithms},
  author =	 {Martin T. Vechev and Eran Yahav and David F. Bacon},
  crossref =	 {PLDI06},
  pages =	 {341--353},
  doi =		 {10.1145/1133981.1134022}
}

@inproceedings{vech07,
  title =	 {{CGCE}xplorer: A Semi-Automated Search Procedure for
                  Provably Correct Concurrent Collectors},
  author =	 {Martin T. Vechev and Eran Yahav and David F. Bacon and Noam
                  Rinetzky},
  crossref =	 {PLDI07},
  pages =	 {456-467},
  doi =		 {10.1145/1250734.1250787}
}

@phdthesis{vech07a,
author = {Martin Vechev},
title = {Derivation and Evaluation of Concurrent Collectors},
school = {University of Cambridge},
year = 2007
}

@inproceedings{vech10,
author = {Vechev, Martin and Yahav, Eran and Yorsh, Greta},
title = {PHALANX: parallel checking of expressive heap assertions},
crossref = {ISMM10},
pages = {41--50},
doi = {10.1145/1806651.1806658},
abstract = {Unrestricted use of heap pointers makes software systems difficult
to understand and to debug. To address this challenge, we developed PHALANX -- a
practical framework for dynamically checking expressive heap properties such as
ownership, sharing and reachability. PHALANX uses novel parallel algorithms to
efficiently check a wide range of heap properties utilizing the available cores.
PHALANX runtime is implemented on top of IBM's Java production virtual machine.
This has enabled us to apply our new techniques to real world software. We
checked expressive heap properties in various scenarios and found the runtime
support to be valuable for debugging and program understanding. Further, our
experimental results on DaCapo and other benchmarks indicate that evaluating
heap queries using parallel algorithms can lead to significant performance
improvements, often resulting in linear speedups as the number of cores
increases.
To encourage adoption by programmers, we extended an existing JML compiler to
translate expressive JML assertions about the heap into their efficient
implementation provided by PHALANX. To debug her program, a programmer can
annotate it with expressive heap assertions in JML, that are efficiently checked
by PHALANX.}
}

@inproceedings{vegd89,
  author =	 "Steven R. Vegdahl and Uwe F. Pleban",
  title =	 "The Runtime Environment of {Screme}, a {Scheme}
                  Implementation for the 88000",
  crossref =	 "ASPLOS89",
  pages =	 "172--182",
  doi =		 {10.1145/70082.68199}
}

@article{veig03,
author = {Lu\'{i}s Veiga and Paulo Ferreira},
title = {Complete Distributed Garbage Collection, an Experience with {R}otor},
journal = {IEE Research Journals -- Software},
volume = 150,
number = 5,
month = oct,
year = 2003
}

@techreport{veig04,
author = {Lu\'{i}s Veiga and Paulo Ferreira},
title = {Asynchronous, Complete Distributed Garbage Collection},
institution = {INESC--ID, Lisboa},
number = {RT/11/2004},
month = jun,
year = 2004
}

@inproceedings{veig05,
author = {Lu\'{i}s Veiga and Paulo Ferreira},
title = {Asynchronous Complete Distributed Garbage Collection},
booktitle = {19th IEEE International Symposium on Parallel and Distributed
Processing},
address = {Denver, CO},
month = apr,
year = 2005
}

@techreport{veig05b,
author = {Lu\'{i}s Veiga and Paulo Ferreira},
title = {A Comprehensive Approach for Memory Management of Replicated Objects},
number = {RT/07/2005},
institution = {INESC-ID, Lisbon},
month = apr,
year = 2005
}

@phdthesis{veig07,
author = {Lu\'{i}s Veiga},
title = {{OBIWAN}: Middleware for Memory Management of Replicated Objects in
Distributed and Mobile Computing},
school = {Univesidade T\'{e}cnica de Lisboa, Instituto Superior T\'{e}cnico},
month = mar,
year = 2007
}

@article{veigo8,
author = {Lu\'{i}s Veiga and P. Pereira and Paulo Ferreira},
title = {Complete Distributed Garbage Collection using {DGC}-Consistent Cuts and .{NET} {AOP}-Support},
publisher = {IET},
year = 2007,
journal = {IET Software},
volume = 1,
number = 6,
pages = {263--279},
comment = {http://link.aip.org/link/?SEN/1/263/1},
doi = {10.1049/iet-sen:20070015}
}

@article{veil76,
author = "G. Veillon",
title = "Transformations de Programmes Recursifs",
journal = "R.A.I.R.O. Informatique",
volume = 10,
number = 9,
month = sep,
year = 1976,
pages = "7--20",
comment = {transforms the classical recursive marking algorithm into
Deutsch-Schorr-Waite pointer reversal algorithm},
}

@inproceedings{vela04,
title = {Adaptive Tuning of Reserved Space in an {A}ppel Collector},
author = {Jos\'{e} Manuel Velasco and Antonio Ortiz and Katzalin Olcoz and Francisco
Tirado},
pages = {543--559},
crossref = {ECOOP04}
}

@inproceedings{vela04a,
title = {Energy-Aware Modelling of Garbage Collectors for New Dynamic Embedded Systems},
author = {Jos\'{e} Manuel Velasco and Atienza, David and Pinuel, L. and Catthoor, Francky},
booktitle={1st International Workshop on Power-Aware Real-Time Computing},
address = {Pisa, Italy},
year = 2004,
URL = "http://www.cs.pitt.edu/PARC/parc-2.pdf",
comment = "Uses Jikes RVM, running on top of Simple Scalar, with CACTI
power consumption modelling, concludes (rather unusually!) that
generational GC is actually _good_ in terms of power consumption!",
}

@inproceedings{vela04b,
author = {Jos\'{e} Manuel Velasco and David Atienza and Francky Catthoor and and
Francisco Tirado and Katzalin Olcoz and Jose Manuel Mendias},
title = {Garbage Collector Refinement for New Dynamic Multimedia Applications on
Embedded Systems},
booktitle = {8th Annual Workshop on Interaction between Compilers and Computer
Architecture (INTERACT-8 2004)},
address = {Madrid, Spain},
pages = {25--32},
month = feb,
year = 2004
}

@inproceedings{vela04c,
author = {Jos\'{e} Manuel Velasco and Antonio Ortiz and Katzalin Olcoz and Francisco Tirado},
title = {Dynamic Management of Nursery Space Organization in Generational
Collection},
booktitle = {8th Annual Workshop on Interaction between Compilers and Computer
Architecture (INTERACT-8 2004)},
address = {Madrid, Spain},
pages = {33--40},
month = feb,
year = 2004
}

@inproceedings{vela05,
author = {Jos\'{e} Manuel Velasco and David Atienza and Katzalin Olcoz and Francky Catthoor},
title = {Performance Evaluation of Barrier Techniques for Distributed Tracing
Garbage Collectors},
booktitle = {International Conference on Parallel Computing (PARCO)},
address = {Malaga, Spain},
pages = {549--556},
year = 2005
}

@inproceedings{vela05a,
author = {Jos\'{e} Manuel Velasco and David Atienza and Katzalin Olcoz and
Francky Catthoor and Francisco Tirado and Jose Manuel Mendias},
title = {Energy Characterization of Garbage Collectors for Dynamic Applications
on Embedded Systems},
booktitle = {International Workshop on Integrated Circuit and System Design,
Power and Timing Modeling, Optimization and Simulation PATMOS 2005},
pages = {69--78},
address = {Leuven, Belgium},
year = 2005
}

@inproceedings{vela09,
author = {Jos\'{e} Manuel Velasco and David Atienza and Katzalin Olcoz},
title = {Exploration of Memory Hierarchy Configurations for Efficient Garbage
Collection on High-performance Embedded Systems},
booktitle = {GLSVLSI},
year = 2009,
}

@inproceedings{veld07,
title = {Supporting Huge Address Spaces in a Virtual Machine for {J}ava on a
Cluster},
author = {Ronald Veldema and Michael Philippsen},
crossref = {LCPC07},
address = {Urbana, IL},
month = oct,
year = 2007,
URL = {http://polaris.cs.uiuc.edu/lcpc07/accepted/14_Final_Paper.pdf}
}

@inproceedings{veld12,
title = {Parallel Memory Defragmentation on a {GPU}},
author = {Ronald Veldema and Michael Philippsen},
crossref = {MSPC12},
doi = {10.1145/2247684.2247693},
pages = {38--47},
abstract = {High-throughput memory management techniques such as malloc/free or
mark-and-sweep collectors often exhibit memory fragmentation leaving allocated
objects interspersed with free memory holes. Memory defragmentation removes such
holes by moving objects around in memory so that they become adjacent
(compaction) and holes can be merged (coalesced) to form larger holes. However,
known defragmentation techniques are slow. This paper presents a parallel
solution to best-effort partial defragmentation that makes use of all available
cores. The solution not only speeds up defragmentation times significantly, but
it also scales for many simple cores. It can therefore even be implemented on a
GPU.
One problem with compaction is that it requires all references to moved objects
to be retargeted to point to their new locations. This paper further improves
existing work by a better identification of the parts of the heap that contain
references to objects moved by the compactor and only processes these parts to
find the references that are then retargeted in parallel.
To demonstrate the performance of the new memory defragmentation algorithm on
many-core processors, we show its performance on a modern GPU. Parallelization
speeds up compaction 40 times and coalescing up to 32 times. After compaction,
our algorithm only needs to process 2\%--4\% of the total heap to retarget
references.}
}

@inproceedings{veng09,
title = {Modeling, Analysis and Throughput Optimization of a Generational Garbage Collector},
author = {David Vengerov},
pages = {1--9},
doi = {10.1145/1542431.1542433},
crossref = {ISMM09}
}

@mastersthesis{venk91,
author = "Nalini Venkatasubramanian",
title = "Hierarchical Garbage Collection in Scalable Distributed Systems",
school = "University of Illinois, Urbana-Champaign",
year = 1991,
}

@techreport{venk92,
author = "Venkatasubramanian, Nalini and Agha, Gul and Talcott, Carolyn",
title = "Hierarchical Garbage Collection in Scalable Distributed Systems",
institution = "Department of Computer Science, University of Illinois at Urbana-Champaign",
year = 1992,
number = "UIUCDCS-R-92-1740",
month = Apr
}

@inproceedings{venk92a,
title = "Scalable Distributed Garbage Collection for Systems of Active Objects",
author = "Nalini Venkatasubramanian and Gul Agha and Carolyn Talcott",
crossref = "IWMM92",
pages = "134--147",
doi = {10.1007/BFb0017187}
}

@book{venn98,
title = {Inside the {J}ava {V}irtual {M}achine},
series = {The {J}ava Masters Series},
author = {Bill Venners},
publisher = {Computing McGraw-Hill},
ISBN = {0-07-913248-0},
month = feb,
year = 1998,
pages = 579,
note = {Chapter 9: Garbage Collection},
URL = {http://www.artima.com/insidejvm/ed2/gc.html}
}

@inproceedings{vens05a,
author = {Venstermans, Kris and  Eeckhout, Lieven and  De Bosschere, Koen},
title = {Implicit Typing for 64-bit Object Header Reduction in {J}ava},
booktitle = {5th ACES Symposium},
year = 2005,
month = sep,
pages = {78--81},
publisher = {Academia Press},
address = {Gent},
URL = {http://escher.elis.UGent.be/publ/Edocs/DOC/P105_142.pdf}
}

@article{vens07,
author = {Venstermans, Kris and  Eeckhout, Lieven and  De Bosschere, Koen},
title = {Java Object Header Elimination for Reduced Memory Consumption in 64-Bit Virtual Machines},
journal = TACO,
year = 2007,
month = 9,
volume = 4,
number = 3,
pages = 30,
publisher = ACM,
}

@inproceedings{vens07a,
author = {Venstermans, Kris and  Eeckhout, Lieven and  De Bosschere, Koen},
title = {Object-Relative Addressing: Compressed Pointers in 64-bit {J}ava Virtual Machines},
crossref = {ECOOP07},
pages = {79--100},
abstract = {64-bit address spaces come at the price of pointers requiring twice
as much memory as 32-bit address spaces, resulting in increased memory usage.
Increased memory usage is especially of concern on machines that are heavily
loaded with memory-intensive applications; overall system performance can
quickly deteriorate once physical memory is exhausted. This paper reduces the
memory usage of 64-bit pointers in the context of Java virtual machines through
pointer compression, called Object-Relative Addressing (ORA). The idea is to
compress 64-bit raw pointers into 32-bit offsets relative to the referencing
object`s virtual address. Unlike previous work on the subject using a constant
base address for compressed pointers, ORA allows for applying pointer
compression to Java programs that allocate more than 4GB of memory. Our
experimental results using Jikes RVM and the SPECjbb and DaCapo benchmarks on an
IBM POWER4 machine show that the overhead introduced by ORA is statistically
insignificant on average compared to raw 64-bit pointer representation, while
reducing the total memory usage by 10\% on average and up to 14.5\% for some
applications.},
URL = {http://escher.elis.UGent.be/publ/Edocs/DOC/P107_134.pdf}
}

@misc{venn98a,
author = {Bill Venners},
title = {Object Finalization and Cleanup},
month = jun,
year = 1998,
URL = {http://www.javaworld.com/javaworld/jw-06-1998/jw-06-techniques.html},
abstract = {This installment of the Design Techniques column discusses
the design guidelines that pertain to the end of an object's life. Columnist
Bill Venners gives an overview of the rules of garbage collection, discusses
finalizers, and suggests ways to design objects such that finite resources
aren't monopolized. [all Java related] }
}

@inproceedings{vero13,
title = {Visualizing the Allocation and Death of Objects},
author = {Raoul L. Veroy and Nathan P. Ricci and Samuel Z. Guyer},
booktitle = {Proceeding o: First IEEE Working Conference on Software Visualization},
year = 2013,
abstract = {We present memory allocation and death plots, a visualization
technique for showing both which method an object is allocated in a Java
program, and in which method that object eventually dies. This relates the place
in a program's execution where memory is first used to the place it is no longer
used, thus helping the programmer to better understand the memory behavior of a
program.}
}

@phdthesis{vest87,
title = "Garbage Collection:  An Exercise in Distributed, Fault-Tolerant
Programming",
author = "Stephen C. Vestal",
school = "University of Washington, Seattle, WA",
year = "1987",
comment = "Looks very similar to Jones + Lins Cyclic Weighted Reference Counting"
}

@inproceedings{vija01,
title = {Energy Behavior of {J}ava Applications from the Memory Perspective},
author = {N. Vijaykrishnan and M. Kandemir and S. Kim and S. Tomar and A. Sivasubramaniam and M. J. Irwin},
crossref= {JVM01},
URL = {http://www.usenix.org/events/jvm01/vijaykrishnan.html}
}

@inproceedings{vird95,
title = "A Garbage Collector for the Concurrent Real-Time Language {E}rlang",
author = "Robert Virding",
crossref = "IWMM95",
pages = {343--354},
doi = {10.1007/3-540-60368-9_33}
}

@article{vo95,
author = "Kiem-Phong Vo",
title = "Vmalloc: A General and Efficient Memory Allocator",
journal = SPE,
publisher = Wiley,
year = 1996,
volume = 26,
number = 3,
pages = {357--374},
URL = {URL:http://www.research.att.com/sw/tools/vmalloc/}
}

@article{vold83,
author = "J. Voldman and B. Mandelbrot and L. W. Hoevel and J. Knight and
P. Rosenfeld",
title = "Fractal Nature of Software-Cache Interaction",
journal = "IBM Journal of Research and Development",
volume = 27,
number = 2,
month = mar,
year = 1983,
pages = "164--170"
}

@article{vuil80,
  author =	 "Jean Vuillemin",
  title =	 "A unifying look at data structures",
  journal =	 CACM,
  year =	 1980,
  volume =	 29,
  number =	 4,
  pages =	 "229--239",
  month =	 apr,
  doi =		 {10.1145/358841.358852},
  annote =	 "Introduced Cartesian trees, used in fast-fits allocators"
}

@article{wadl76,
author = "Philip L. Wadler",
title = "Analysis of an Algorithm for Real-Time Garbage Collection",
journal = CACM,
publisher = ACM,
volume = 19,
number = 9,
month = Sep,
year = 1976,
pages = "491--500",
comment = {Presents analytical analysis of on-the-fly garbage collection algorithm
in \cite{dijk76b}.}
}

@inproceedings{wadl84,
title = "Listlessness is Better than Laziness: Lazy Evaluation and Garbage
Collection at Compile Time",
author = "Philip L. Wadler",
pages = "45--52",
crossref = "LFP84",
}

@article{wadl87,
author = "Philip L. Wadler",
title = "Fixing Some Space Leaks with a Garbage Collector",
journal = SPE,
publisher = Wiley,
volume = 17,
number = 9,
pages = "595--609",
month = sep,
year = "1987",
URL = "ftp://ftp.dcs.gla.ac.uk/pub/glasgow-fp/authors/Philip_Wadler/leak.dvi",
abstract = "Some functional programs may use more space than would be expected.
A modification to the garbage collector is suggested which solves this problem
in some cases. Related work is discussed.",
}

@inproceedings{wagn11,
title = {Compartmental Memory Management in a Modern Web Browser},
author = {Gregor Wagner and Andreas Gal and Christian Wimmer and Brendan Eich and Michael Franz},
pages = {119--128},
crossref = {ISMM11},
doi = {1993478.1993496},
abstract = {Since their inception, the usage pattern of web browsers has changed
substantially. Rather than sequentially navigating static web sites, modern web
browsers often manage a large number of simultaneous tabs displaying dynamic web
content, each of which might be running a substantial amount of client-side
JavaScript code. This environment introduced a new degree of parallelism that
was not fully embraced by the underlying JavaScript virtual machine
architecture. We propose a novel abstraction for multiple disjoint JavaScript
heaps, which we call compartments. We use the notion of document origin to
cluster objects into separate compartments.
Objects within a compartment can reference each other directly. Objects across
compartments can only reference each other through wrappers. Our approach
reduces garbage collection pause times by permitting collection of sub-heaps
(compartments), and we can use cross-compartment wrappers to enforce cross
origin object access policy.}
}

@book{wait73,
author = "W. M. Waite",
title = "Implementing Software for Nonnumeric Applications",
publisher = PH,
year = 1973,
comment = {algorithm for compacting varisized cells},
}

@phdthesis{wake90,
author = "David Wakeling",
title = "Linearity and Laziness",
school = "University of York",
month = nov,
year = 1990,
comment = "Uses Wadler's linear logic to optimise heap usage.
Disappointing results."
}

@inproceedings{wake91,
author = "David Wakeling and Colin Runciman",
title = "Linearity and Laziness",
crossref = "FPCA91",
pages = "215--240",
}

@article{wald72,
author = "O. C. Walden",
title = "A Note on {C}heney's Non-Recursive List-Compacting Algorithm",
journal = CACM,
publisher = ACM,
volume = 15,
number = 4,
month = apr,
year = 1972,
page = 275,
comment = {Optimization to the copying algorithm (feni69) based on (chen70)},
}

@article{walk00,
title = {Typed Memory Management in a Calculus of Capabilities},
author = {David Walker and Karl Crary and Greg Morrisett},
journal = TOPLAS,
volume = 24,
number = 4,
year = 2000,
pages = {701--771}
}

@inproceedings{walk01,
author = {David Walker},
title = {On Linear Types and Regions},
crossref = {SPACE01},
}

@inproceedings{walk04,
author = {David Walker},
title = {Stacks, Heaps and Regions: One Logic to Bind Them},
crossref = {SPACE04},
note = {Invited talk}
}

@book{wall91,
author = "Larry Wall and Randal L. Schwartz",
title = "Programming Perl",
publisher = "O'Reilly and Associates, Inc.",
year = 1991
}

@inproceedings{wall93,
title = "An Incremental Garbage Collector for Embedded Real-Time Systems",
author = "Malcolm Wallace and Colin Runciman",
booktitle = "Chalmers Winter Meeting",
address = "Tanum Strand, Sweden",
year = 1993,
pages = "273--288",
note = "Published as Programming Methodology Group, Chalmers University of Technology, Technical Report 73",
URL = "ftp://ftp.cs.york.ac.uk/pub/malcolm/rtgc.html",
comment = "Based on Yuasa and also Quenniac's Mark-during-sweep"
}

@techreport{wang99,
title = {Safe Garbage Collection = Regions + Intensional Type Analysis},
author = {Daniel C. Wang and Andrew W. Appel},
institution = {Princeton},
month = jul,
year = 1999,
URL = {http://ncstrl.cs.Princeton.EDU/expand.php?id=TR-609-99},
abstract = {We present a technique to implement type-safe garbage collectors by combining existing type systems used for compiling type-safe languages. We adapt
the type systems used in region inference (Tofte, Talpin 1994) and intensional type analysis (Harper, Morrisett 1995) to construct a safe stop-and-copy
garbage collector for higher-order polymorphic languages. Rather than using region inference as the primary method of storage management, we show
how it can be used to implement a garbage collector which is provably safe. We also introduce a new region calculus with non-nested object life-times
which is significantly simpler than previous calculi. Our approach also formalizes more of the interface between garbage collectors and code generators.
The efficiency of our safe collectors are algorithmically competitive with unsafe collectors. }
}

@techreport{wang00,
title = {Type-Preserving Garbage Collectors (Extended Version)},
author = {Daniel C. Wang and Andrew W. Appel},
institution = princeton,
month = dec,
year = 2000,
URL = {http://ncstrl.cs.Princeton.EDU/expand.php?id=TR-624-00}
}

@inproceedings{wang01,
  title =	 {Type-Preserving Garbage Collectors},
  author =	 {Daniel C. Wang and Andrew W. Appel},
  crossref =	 {POPL01},
  pages =	 {166-178},
  doi =		 {10.1145/360204.360218},
  URL =		 {http://www.cs.princeton.edu/faculty/appel/papers/typegc.pdf}
}

@mastersthesis{wang89,
author = "Thomas Wang",
title = "The {MM} Garbage Collector for {C++}",
school = "California State Polytechnic University",
year = 1989,
month = oct
}

@article{wang94a,
  author =	 "Thomas Wang",
  address =	 "wang@cup.hp.com, Hewlett-Packard, Cupertino, ca.",
  title =	 "Better {C}: An Object-Oriented {C} Language with Automatic
                  Memory Manager Suitable for Interactive Applications",
  journal =	 SIGPLAN,
  publisher =	 ACM,
  volume =	 29,
  number =	 11,
  month =	 dec,
  pages =	 "104--111",
  year =	 1994
}

@article{wang94b,
  author =	 "Thomas Wang",
  address =	 "wang@cup.hp.com, Hewlett-Packard, Cupertino, ca.",
  title =	 "Eliminate Memory Fragmentation through Holes in the Heap",
  journal =	 SIGPLAN,
  publisher =	 ACM,
  volume =	 29,
  number =	 11,
  month =	 dec,
  pages =	 "112--113",
  year =	 1994,
  comment =	 "Use a lightweight version of AIX's disclaim to indicate that
                  a copying collector is no longer interested in Fromspace
                  pages. Lightweight means unmap the page but do not clear
                  it."
}

@article{wang95,
author = {Y. Wang and P. Chung and I. Lin and W.K.Fuchs},
title = {Checkpoint Space Reclamation for Uncoordinated Checkpointing in Message-Passing Systems},
journal = {IEEE Transactions on Parallel and Distributed Systems},
volume = 6,
number = 5,
month = may,
year = 1995,
pages = {546--554}
}

@inproceedings{wang06,
author = {W. Wang and C.A. Varela},
title = {Distributed Garbage Collection for Mobile Actor Systems: the Pseudo
Root Approach},
booktitle = {1st International Conference on Grid and Pervasive Computing (GPC)},
address = {Taichung, Taiwan},
month = may,
year = 2006,
publisher = SV
}

@inproceedings{wang08,
  title =	 {Conditional Correlation Analysis for Safe Region-based
                  Memory Management},
  author =	 {Xi Wang and Zhilei Xu and Xuezheng Liu and Zhenyu Guo and
                  Xiaoge Wang and Zheng Zhang},
  crossref =	 {PLDI08},
  pages =	 {45-55},
  doi =		 {10.1145/1375581.1375588},
  abstract =	 {Region-based memory management is a popular scheme in
                  systems software for better organization and performance. In
                  the scheme, a developer constructs a hierarchy of regions of
                  different lifetimes and allocates objects in regions. When
                  the developer deletes a region, the runtime will recursively
                  delete all its subregions and simultaneously reclaim objects
                  in the regions. The developer must construct a consistent
                  placement of objects in regions; otherwise, if a region that
                  contains pointers to other regions is not always deleted
                  before pointees, an inconsistency will surface and cause
                  dangling pointers, which may lead to either crashes or
                  leaks.  This paper presents a static analysis tool RegionWiz
                  that can find such lifetime inconsistencies in large C
                  programs using regions.  The tool is based on an analysis
                  framework that generalizes the relations and constraints
                  over regions and objects as conditional correlations. This
                  framework allows a succinct formalization of consistency
                  rules for region lifetimes, preserving memory safety and
                  avoiding dangling pointers. RegionWiz uses these consistency
                  rules to implement an efficient static analysis to compute
                  the conditional correlation and reason about region lifetime
                  consistency; the analysis is based on a context-sensitive,
                  field-sensitive pointer analysis with heap cloning.
                  Experiments with applying RegionWiz to six real-world
                  software packages (including the RC compiler, Apache web
                  server, and Subversion version control system) with two
                  different region-based memory management interfaces show
                  that RegionWiz can reason about region lifetime consistency
                  in large C programs. The experiments also show that
                  RegionWiz can find several previously unknown inconsistency
                  bugs in these packages.}
}

@techreport{warr77,
author = "David H. D. Warren",
title = "Implementing {P}rolog --- Compiling Logic Programs",
volume = "1 and 2",
type = "D.A.I. Research Report",
number = "39, 40",
institution = "University of Edinburgh",
year = 1977,
comment = "Edinburgh Prolog divides memory into local stack (control part) and
global stack (data part).
Uses a mark and compact collector.",
}

@inproceedings{warr80,
author = "David H. D. Warren",
title = "An Improved {P}rolog Implementation which Optimises Tail-Recursion",
booktitle = "Workshop on Logic Programming, Debrecen, Hungary",
year = 1980,
comment = "Structure copying:simplifies gc algorithms (bruy82)." ,
}

@article{warr82,
author = "David H. D. Warren",
title = "Perpetual Processes --- an Unexploited {P}rolog Technique",
journal = "Logic Programming Newsletter",
volume = 3,
year = 1982,
comment = "Infinite loops which do not consume space.",
}

@techreport{warr83,
author = "David H. D. Warren",
title = "An Abstract {P}rolog Instruction Set",
type = "Technical Note",
number = 309,
institution = "SRI International",
year = 1983,
comment = "The WAM.",
}

@inproceedings{warr84,
author = "David A. Warren",
title = "Efficient {P}rolog Memory Management for Flexible Control Strategies",
booktitle = "International Symposium on Logic Programming",
year = 1984,
publisher = IEEE,
}

%check year
@mastersthesis{wash89,
author = "Washabaugh, Douglas Markham",
title = "Real-Time Garbage Collection of Actors in a Distributed System",
year = 1989,
school = "Virginia Polytechnic Institute and State University"
}

@inproceedings{wash90,
author = "Washabaugh, Douglas Markham and Dennis Kafura",
title = "Real-Time Garbage Collection of Actors",
booktitle = "11th Real-Time Systems Symposium",
pages = "21--30",
month = dec,
year = 1990,
}

@inproceedings{wash91,
author = "Douglas M. Washabaugh and D. Kafura",
title = "Distributed Garbage Collection of Active Objects",
booktitle = "icdcs11",
pages = "369--276",
month = may,
year = 1991,
}

@article{wats76,
title = {Tuning {G}arwick's algorithm for repacking sequential storage},
author = {Watson and David Wise},
journal = {BIT},
month = dec,
year = 1976,
volume = 16,
number = 4,
pages = {442--450}
}

@techreport{wats86,
author = "Ian Watson",
title = "An Analysis of Garbage Collection for Distributed Systems",
institution = "Department of Computer Science, University of  Manchester",
year = 1986
}

@inproceedings{wats87,
author = "Paul Watson and Ian Watson",
title = "An Efficient Garbage Collection Scheme for Parallel Computer Architectures",
crossref = "PARLE87",
volume = 259,
pages = "432--443",
doi = {10.1007/3-540-17945-3_25}
}

@inproceedings{wats87a,
author = "Paul Watson and Ian Watson",
title = "Graph Reduction in a Parallel Virtual Memory Environment",
booktitle = "Graph Reduction Workshop",
address = "Santa Fe, NM",
publisher = SV,
series = LNCS,
volume = 279,
editor = "J. H. Fasel and R. M. Keller",
year = "1987",
pages = "265--274",
abstract = "This paper examines the area of memory organization and the
mechanism
which are required to ensure thet the full benefits of this implementation
strategy are maintained whilst achieving an efficient physical structure.
The major areas of interest are the maintenance of locality and the use of
storage management techniques which minimize communication."}


@inproceedings{weem90,
author = "P. Weemeeuw and B. Demoen",
title = {A la Recherche de la M\'{e}moire Perdue, or: Memory Compaction for
Shared Memory Multiprocessors --- Design and Specification},
booktitle = "2nd North American Conference on Logic Programming",
editor = "S. Debray and M. Hermenegildo",
pages = "306--320",
year = 1990,
}

@inproceedings{weem92,
title = "Garbage Collection in {A}urora: An Overview",
author = "Patrick Weemeeuw and Bart Demoen",
crossref = "IWMM92",
pages = {454--472},
doi = {10.1007/BFb0017207}
}


@article{wegb72a,
author = "B. Wegbreit",
title = "A Generalised Compactifying Garbage Collector",
journal = CompJ,
publisher = BCS,
volume = 15,
number = 3,
month = Aug,
year = 1972,
pages = "204--208",
comment = {algorithm for compacting varisized cells with no break table.
Divides the memory into a fixed number of equal segments},
}

@article{wegb72b,
author = "B. Wegbreit",
title = "A Space Efficient List Structure  Tracing  Algorithm",
journal = IEEETransComp,
publisher = IEEE,
month = sep,
year = 1972,
pages = "1098--1010",
comment = {presents a modification of Deutsch-Schorr-Waite algorithm which
uses a bit stack instead of a bit per cell},
}

@inproceedings{wegi08,
  author =	 {Michal Wegiel and Chandra Krintz},
  title =	 {The Mapping Collector: Virtual Memory Support for
                  Generational, Parallel, and Concurrent Compaction},
  crossref =	 {ASPLOS08},
  pages =	 {91-102},
  doi =		 {10.1145/1346281.1346294},
  abstract =	 {Parallel and concurrent garbage collectors are increasingly
                  employed by managed runtime environments (MREs) to maintain
                  scalability, as multi-core architectures and multi-threaded
                  applications become pervasive. Moreover, state-of-the-art
                  MREs commonly implement compaction to eliminate heap
                  fragmentation and enable fast linear object allocation.  Our
                  empirical analysis of object demographics reveals that
                  unreachable objects in the heap tend to form clusters large
                  enough to be effectively managed at the granularity of
                  virtual memory pages.  Even though processes can manipulate
                  the mapping of the virtual address space through the
                  standard operating system (OS) interface on most platforms,
                  extant parallel/concurrent compactors do not do so to
                  exploit this clustering behavior and instead achieve
                  compaction by performing, relatively expensive, object
                  moving and pointer adjustment.  We introduce the Mapping
                  Collector (MC), which leverages virtual memory operations to
                  reclaim and consolidate free space without moving objects
                  and updating pointers. MC is a nearly-single-phase compactor
                  that is simpler and more efficient than previously reported
                  compactors that comprise two to four phases. Through
                  effective MRE-OS coordination, MC maintains the simplicity
                  of a non-moving collector while providing efficient parallel
                  and concurrent compaction.  We implement both stop-the-world
                  and concurrent MC in a generational garbage collection
                  framework within the open-source HotSpot Java Virtual
                  Machine. Our experimental evaluation using a multiprocessor
                  indicates that MC significantly increases throughput and
                  scalability as well as reduces pause times, relative to
                  state-of-the-art, parallel and concurrent compactors.  }
}

@inproceedings{wegi08a,
  author =	 {Michal Wegiel and Chandra Krintz},
  title =	 {{XMem}: Type-safe, Transparent, Shared Memory for
                  Cross-Runtime Communication and Coordination},
  crossref =	 {PLDI08},
  pages =	 {327--338},
  doi =		 {10.1145/1375581.1375621},
  abstract =	 {Developers commonly build contemporary enterprise
                  applications using type-safe, component-based platforms,
                  such as J2EE, and architect them to comprise multiple tiers,
                  such as a web container, application server, and database
                  engine. Administrators increasingly execute each tier in its
                  own managed runtime environment (MRE) to improve reliability
                  and to manage system complexity through the fault
                  containment and modularity offered by isolated MRE
                  instances. Such isolation, however, necessitates expensive
                  cross-tier communication based on protocols such as object
                  serialization and remote procedure calls. Administrators
                  commonly co-locate communicating MREs on a single host to
                  reduce communication overhead and to better exploit
                  increasing numbers of available processing cores. However,
                  state-of-the-art MREs offer no support for more efficient
                  communication between co-located MREs, while fast
                  inter-process communication mechanisms, such as shared
                  memory, are widely available as a standard operating system
                  service on most modern platforms.  To address this growing
                  need, we present the design and implementation of XMem ---
                  type-safe, transparent, shared memory support for co-located
                  MREs. XMem guarantees type-safety through coordinated,
                  parallel, multi-process class loading and garbage
                  collection. To avoid introducing any level of indirection,
                  XMem manipulates virtual memory mapping. In addition, object
                  sharing in XMem is fully transparent: shared objects are
                  identical to local objects in terms of field access,
                  synchronization, garbage collection, and method invocation,
                  with the only difference being that shared-to-private
                  pointers are disallowed. XMem facilitates easy integration
                  and use by existing communication technologies and software
                  systems, such as RMI, JNDI, JDBC, serialization/XML, and
                  network sockets.  We have implemented XMem in the
                  open-source, production quality HotSpot Java Virtual
                  Machine. Our experimental evaluation, based on core
                  communication technologies underlying J2EE, as well as using
                  open-source server applications, indicates that XMem
                  significantly improves throughput and response time by
                  avoiding the overheads imposed by object serialization and
                  network communication.}
}

@article{wegi09,
author = {Michal Wegiel and Chandra Krintz},
title = {The Single-Referent Collector: Optimizing Compaction for the Common Case},
journal = TACO,
year = 2009
}

@inproceedings{wegi10,
author = {Wegiel, Michal and Krintz, Chandra},
title = {Cross-language, type-safe, and transparent object sharing for co-located managed runtimes},
crossref = {OOPSLA10},
pages = {223--240},
doi = {1869459.1869479},
abstract = {As software becomes increasingly complex and difficult to analyze,
it is more and more common for developers to use high-level, type-safe,
object-oriented (OO) programming languages and to architect systems that
comprise multiple components. Different components are often implemented in
different programming languages. In state-of-the-art multicomponent,
multi-language systems, cross-component communication relies on remote procedure
calls (RPC) and message passing. As components are increasingly co-located on
the same physical machine to ensure high utilization of multi-core systems,
there is a growing potential for using shared memory for cross-language
cross-runtime communication.
We present the design and implementation of Co-Located Runtime Sharing (CoLoRS),
a system that enables cross-language, cross-runtime type-safe, transparent
shared memory. CoLoRS provides object sharing for co-located OO runtimes for
both static and dynamic languages. CoLoRS defines a language-neutral
object/classmodel,which is a static-dynamic hybrid and enables class evolution
while maintaining the space/time efficiency of a static model. CoLoRS uses type
mapping and class versioning to transparently map shared types to private types.
CoLoRS also contributes a synchronization mechanism and a parallel, concurrent,
on-the-fly GC algorithm, both designed to facilitate cross-language
cross-runtime object sharing.
We implement CoLoRS in open-source, production-quality runtimes for Python and
Java. Our empirical evaluation shows that CoLoRS extensions impose low overhead.
We also investigate RPC over CoLoRS and find that using shared memory to
implement co-located RPC significantly improves both communication throughput
and latency by avoiding data structure serialization.}
}

@manual{wein81,
author = {Daniel Weinreb and David Moon},
title = {{LISP} Machine Manual},
edition = {Fourth edition},
organization = MITAI,
month = jul,
year = 1981
}

@phdthesis{wein76,
author = "Charles B. Weinstock",
title = "Dynamic Storage Allocation Techniques",
school = CMU,
address = "Pittsburgh, PA",
month = apr,
year = 1976
}

@article{wein88,
  author =	 "Charles B. Weinstock and William A. Wulf",
  title =	 "Quickfit: An Efficient Algorithm for Heap Storage
                  Allocation",
  journal =	 SIGPLAN,
  volume =	 23,
  number =	 10,
  pages =	 "141--144",
  year =	 1988
}


@inproceedings{weis89,
title = "The {P}ortable {C}ommon {R}untime Approach to Interoperability",
author = "Mark Weiser and Alan Demers and Carl Hauser",
booktitle = "12th " # SOSP,
publisher = ACM,
month = Dec,
year = 1989
}

@book{weis67,
author = "C. Weissman",
title = "{L}isp 1.5 Primer",
publisher = "Dickenson Publ.",
address = "Belmont, CA",
year = 1967,
}

@article{weiz62,
author = "J. Weizenbaum",
title = "Knotted List Structures",
journal = CACM,
publisher = ACM,
volume = 5,
number = 3,
year = 1962,
pages = "161--165",
comment = "Pointed by Steele (stee75) as one of the first uses of reference counting",
}

@article{weiz63,
author = "J. Weizenbaum",
title = "Symmetric List Processor",
journal = CACM,
publisher = ACM,
volume = 6,
number = 9,
month = sep,
year = 1963,
pages = "524--544",
comment = "A smoother reference counting method.
Pointers are deleted lazily."
}

@article{weiz64,
author = "J. Weizenbaum",
title = "More on the Reference Counter Method",
journal = CACM,
publisher = ACM,
volume = 7,
number = 1,
pages = 38,
year = 1964
}

@article{weiz69,
author = "J. Weizenbaum",
title = "Recovery of Reentrant List Structures in {SLIP}",
journal = CACM,
publisher = ACM,
volume = 12,
number = 7,
month = jul,
year = 1969,
pages = "370--372",
doi={10.1145/363156.363159},
comment = "Suggested combining reference counting with mark-scan."
}

@techreport{weng79,
author = "K.-S. Weng",
title = "An Abstract Implementation for a Generalised Dataflow Language",
institution = MITLCS,
number = "MIT/LCS/TR228",
year = 1979
}

@inproceedings{welc04,
  author =	 {Adam Welc and Suresh Jagannathan and Antony L. Hosking},
  title =	 {Transactional Monitors for Concurrent Objects},
  crossref =	 {ECOOP04},
  pages =	 {519--542},
  doi =		 {10.1007/978-3-540-24851-4_24}
}

@inproceedings{welc05,
  author =	 {Adam Welc and Suresh Jagannathan and Antony L. Hosking},
  title =	 {Safe Futures for {J}ava},
  crossref =	 {OOPSLA05},
  pages =	 {439--453},
  doi =		 {10.1145/1094811.1094845}
}

@phdthesis{went88,
author = "E. P. Wentworth",
title = "An Environment for Investigating Functional Languages and
Implementations",
school = "University of Port Elizabeth, South Africa",
year = 1988
}

@article{went90,
title = "Pitfalls of Conservative Garbage Collection",
author = "E. P. Wentworth",
journal = SPE,
publisher = Wiley,
volume = 20,
number = 7,
pages = "719--727",
year = 1990,
abstract = {Researchers have recently proposed conservative garbage collection
as a technique which allows smooth integration of automatic memory management
into existing high-level languages.  Conservative techniques carry the cost of
some leakage --- they fail to reclaim all the available garbage.  This paper
reports on a conservative collector and measurements of its leakage.  The
results indicate that the loss depends critically on the application = "a Lisp
interpreter shows very small leakage (typically less than 5 per cent of the
total heap space for classroom examples), whereas the garbage collector
collapses completely when used with a KRC interpreter.  Uncovering the reasons
reveals that it is possible to write Lisp programs that also fail.  Previous
work has used very sparsely populated address spaces where the probability for
leakage was minimized.  This work considers small, densely populated address
spaces, and probably represents a worst-case scenario.  Although the
conservative technique appears to be a cost-effective and clean way of
integrating automatic memory management into an off-the-shelf host
language, we are led to conclude that it is not reliable in all situations.}
}

@inproceedings{whal99,
  title =	 {Compositional Pointer and Escape Analysis for {J}ava
                  Programs},
  author =	 {John Whaley and Martin Rinard},
  pages =	 {187--206},
  crossref =	 {OOPSLA99},
  doi =		 {10.1145/320384.320400},
  comment =	 {http://citeseer.nj.nec.com/whaley99compositional.html},
  note =	 {By analysing which objects escape methods/threads, we can
                  allocate on the stack / avoid synchronisations.}
}

@inproceedings{whil92,
title = "Incremental Garbage Collection for the {S}pineless {T}agless {G}-Machine",
author = "R. Lyndon While and Tony Field",
booktitle = "Massey Functional Programming Workshop",
editor = "Evan Ireland and Nigel Perry",
publisher = "Department of Computer Science, Massey University",
year = 1992
}

@techreport{whil92a,
author = "R. Lyndon While",
title = "A Viable Software Read-Barrier",
institution = "Imperial College, London",
type = "Departmental Report",
number = "DoC 92/12",
year = 1992
}

@inproceedings{whit13,
author = {White, David R. and Singer, Jeremy and Aitken, Jonathan M. and Jones, Richard E.},
title = {Control Theory for Principled Heap Sizing},
crossref = {ISMM13},
doi = {10.1145/2464157.2466481},
abstract = {We propose a new, principled approach to adaptive heap sizing based
on control theory. We review current state-of-the-art heap sizing mechanisms, as
deployed in Jikes RVM and HotSpot. We then formulate heap sizing as a control
problem, apply and tune a standard controller algorithm, and evaluate its
performance on a set of well-known benchmarks. We find our controller adapts the
heap size more responsively than existing mechanisms. This responsiveness allows
tighter virtual machine memory footprints while preserving target application
throughput, which is ideal for both embedded and utility computing domains. In
short, we argue that formal, systematic approaches to memory management should
be replacing ad-hoc heuristics as the discipline matures. Control-theoretic heap
sizing is one such systematic approach.},
} 

@techreport{whit98,
title = {The {GC} Interface in the {EVM}},
author = {Derek White and Alex Garthwaite},
institution = {Sun Microsystems Laboratories},
number = {SML TR--98--67},
month = dec,
year = 1998,
URL = {http://dl.acm.org/ft_gateway.cfm?id=974971&type=pdf}
}

@inproceedings{whit80,
author = "Jon L. White",
title = "Address/Memory Management for a Gigantic {L}isp Environment,
or, {GC} {C}onsidered {H}armful",
crossref = {LFP80},
pages = "119--127",
doi={10.1145/800087.802797}
}

@inproceedings{whit90,
author = "Jon L. White",
title = "Three Issues in Objected-Oriented Garbage Collection",
crossref = "OOPSLA90-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC90/White.ps.Z",
}

@article{whit97,
title = {Deferred Garbage Collection},
author = {Marc White},
journal = {MacTech magazine},
volume = 13,
number = 12,
year = 1997,
URL = {http://www.mactech.com/articles/mactech/Vol.13/13.12/DeferredGarbageCollection/}
}

@inproceedings{whit92,
author = "Seth J. White and David J. Dewitt",
title = "A Performance Study of Alternative Object Faulting and Pointer Swizzling Strategies",
booktitle = "18th International Conference on Very Large Data Bases",
year = 1992,
month = oct,
address = "Vancouver, British Columbia, Canada",
}

@inproceedings{whit94,
author = "Seth J. White and David J. Dewitt",
title = "QuickStore: A High Performance Mapped Object Store",
booktitle = "SIGMOD94",
pages = "395--406",
year = 1994
}

@inproceedings{whol84,
author = "Skef Wholey and Scott E. Fahlman",
title = "The Design of an Instruction set for {C}ommon {L}isp",
crossref = "LFP84",
pages = "150--158",
}

@techreport{whol85,
author = "Skef Wholey and Scott E. Fahlman and Joseph Ginder",
title = "Revised Internal Design of {S}pice {L}isp",
institution = CMU,
month = jan,
year = 1985
}

@inproceedings{wick04,
title = {Memory Accounting Without Partitions},
author = {Adam Wick and Matthew Flatt},
pages = {120--130},
crossref = {ISMM04}
}

@inproceedings{wild91,
author = "J. Wild and Hugh Glaser and Pieter Hartel",
title = "Statistics on Storage Management in a Lazy Functional Language
Implementation",
booktitle = "3rd Workshop on Parallel and Distributed Processing",
address = "Sofia",
editor = "Sendov",
URL = "http://www-ala.doc.ic.ac.uk/papers/A.Bennett/fast_works/1.4.bulg91.ps.gz",
year = 1991,
publisher = ENH,
month = apr,
note = "Also appears in
4th International Workshop on Parallel Implementation of Functional Languages, Aachen, September 1992,
ed. H. Kuchen and R. Loogen,
Aachener Informatik-Berichte 92--16"
}

@article{wile89,
  title =	 "Pgraphite: An Experiment in Persistent Typed Object
                  Management",
  author =	 "J. C. Wileden and A. L. Wolf and C. D. Fisher and
                  P. L. Tarr",
  pages =	 "130--142",
  journal =	 SIGPLAN,
  month =	 feb,
  year =	 1989,
  volume =	 24,
  number =	 2,
  issn =	 "0362--1340",
  abstract =	 {The paper describes PGRAPHITE, a prototype tool in an
                  Arcadia environment for managing persistent typed objects. A
                  typed object is a datum whose type, in the sense of Ada's
                  strong type system, is known to all programs that use
                  it. The way the program accesses the object is determined by
                  its internal structure as specified by its type. A
                  persistent object is a datum which exists longer than any
                  activation of any program that may access it; the datum is
                  usually stored on a disk medium. The usual program data that
                  are allocated and deallocated during one activation of the
                  program are nonpersistent.  It is desirable that persistence
                  of an object be orthogonal to all other aspects of the
                  object. That is, the code which uses an object based on its
                  type structure should be the same for persistent and
                  nonpersistent objects.  The paper correctly observes that
                  for persistence to be truly orthogonal in this sense, it is
                  essential that an object be deallocated only after it has
                  ceased to be accessible to all potential users. Therefore
                  implicit persistence, called retention elsewhere, is
                  followed. The paper also observes that such implicit
                  persistence is expensive in general because it can require
                  garbage collection. Thus, most systems abandon implicit
                  persistence in favor of program-ordered deallocation, which
                  can cause references that are still available to point to
                  nothing. By deciding on a particular set of object and
                  persistent store manipulation operations, however, it should
                  be possible to limit the complexity of determining when an
                  object is inaccessible and thus deallocatable. PGRAPHITE
                  implements these operations.  Rather than get bogged down in
                  the already well-understood details of implementing a
                  complete typing system, the authors decided to build the
                  tool as an extension of the existing system GRAPHITE, which
                  handles nonpersistent graph objects, that is, data whose
                  types are arcs, nodes, collections of nodes, etc. The object
                  and persistent store manipulation operations mentioned in
                  the previous paragraph are added to GRAPHITE to get
                  PGRAPHITE. The rapidly developed prototype tool has allowed
                  experimentation and exploration of alternative models and
                  implementations of persistence.  I found the paper clear,
                  lively, and informative. It showed me a new way to view my
                  old work on retention and got me all excited. A proof of the
                  liveliness of the paper and my excitement is the abundance
                  of argumentative comments that the paper provoked me to
                  write in the margin of my copy.  The paper was fun to read.}
}

@phdthesis{wilh05,
author= {Jesper Wilhelmsson},
title = {Efficient Memory Management for Message-Passing Concurrency --- part {I}: Single-threaded execution},
school = {Uppsala University},
year = 2005,
number = {2005-001},
type = {Licentiate thesis},
month = may,
abstract = {Manual memory management is error prone. Some of the
errors it causes, in particular memory leaks and dangling
pointers, are hard to find. Manual memory management
becomes even harder when concurrency enters the picture. It
therefore gets more and more important to overcome the
problems of manual memory management in concurrent software
as the interest in these applications increases with the
development of new, multi-threaded, hardware.

To ease the implementation of concurrent software many
programming languages these days come with automatic memory
management and support for concurrency. This support,
called the concurrency model of the language, comes in many
flavors (shared data structures, message passing, etc.).
The performance and scalability of applications implemented
using such programming languages depends on the concurrency
model, the memory architecture, and the memory manager used
by the language. It is therefore important to investigate
how different memory architectures and memory management
schemes affect the implementation of concurrent software
and what performance tradeoffs are involved.

This thesis investigates ways of efficiently implementing
the memory architecture and memory manager in a concurrent
programming language. The concurrency model which we
explore is based on message passing with copying semantics.
We start by presenting the implementation of three
different memory architectures for concurrent software and
give a detailed characterization of their pros and cons
regarding message passing and efficiency in terms of memory
management. The issue examined is whether to use private
memory for all processes in a program or if there may be
benefits in sharing all or parts of the memory. In one of
the architectures looked at, called hybrid, a static
analysis called message analysis is used to guide the
allocation of message data.

Because the hybrid architecture is the enabling technology
for a scalable multi-threaded implementation, we then focus
on the hybrid architecture and investigate how to manage
the memory using different garbage collection techniques.
We present pros and cons of these techniques and discuss
their characteristics and their performance in concurrent
applications. Finally our experiences from turning the
garbage collector incremental are presented. The
effectiveness of the incremental collector is compared to
the non-incremental version. On a wide range of benchmarks,
the incremental collector we present is able to sustain
high mutator utilization (about 80\% during collection
cycles) at a low cost.

This work is implemented in an industrial-strength
implementation of the concurrent functional programming
language Erlang. Our eventual goal is to use the hybrid
architecture and the incremental garbage collector as the
basis for an efficient multi-threaded implementation of
Erlang. The work described in this thesis is a big step in
that direction.}
}

@Article{wilh08,
  author =	 {Reinhard Wilhelm and Jakob Engblom and Andreas Ermedahl and
                  Niklas Holsti and Stephan Thesing and David B. Whalley and
                  Guillem Bernat and Christian Ferdinand and Reinhold Heckmann
                  and Tulika Mitra and Frank Mueller and Isabelle Puaut and
                  Peter P. Puschner and Jan Staschulat and Per Stenstr{\o}m},
  title =	 {The worst-case execution-time problem --- overview of
                  methods and survey of tools},
  journal =	 TECS,
  year =	 2008,
  volume =	 7,
  number =	 3,
  month =	 apr,
  doi =		 {10.1145/1347375.1347389}
}

@article{wilk64,
author = "Maurice V. Wilkes",
title = "An Experiment with a Self-Compiling Compiler for a Simple
List-Processing Language",
journal = "Annual Review in Automatic Programming",
volume = 4,
publisher = "Pergamon Press",
pages = "1--48",
year = 1964,
comment = "WISP --- the language that Schorr-Waite used"
}

@inproceedings{wilk64a,
author = "Maurice V. Wilkes",
title = "Lists and Why They Are Useful",
booktitle = "19th ACM National Conference",
publisher = ACM,
month = aug,
year = 1964,
comment = "WISP --- the language that Schorr-Waite used"
}

@inproceedings{will98,
  title =	 {Autonomous Garbage Collection: Resolving Memory Leaks in
                  Long Running Network Applications},
  author =	 {B. Willard and O. Frieder},
  booktitle =	 {International Conference On Computer
                  Communications and Networks (ICCCN)},
  address =	 {Lafayette, LO},
  pages =	 {886--896},
  month =	 oct,
  year =	 1998,
  publisher =	 IEEE,
  doi =		 {10.1109/ICCCN.1998.998857}
}

@article{will00,
title = {Autonomous Garbage Collection: Resolving Memory Leaks in Long-Running
Server Applications},
author = {B. Willard and O. Frieder},
pages = {887--900},
journal = {Computer Communications},
volume = 23,
number = 10,
month = may,
year = 2000
}

@inproceedings{will87,
title = "Dynamic Grouping in an Object-Oriented Virtual Memory Hierarchy",
author = "Ifor W. Williams and Mario I. Wolczko and Trevor P. Hopkins",
institution = "University of  Manchester, Department of Computer Science, Manchester, UK",
crossref = "ECOOP87",
pages = "79--88"
}

@inproceedings{will87a,
author = "Ifor W. Williams and Mario I. Wolczko and T. P. Hopkins",
title = "Realisation of a Dynamic Grouped Object-Oriented Virtual Memory
Hierarchy",
pages = "298--308",
crossref = "POS87",
note = "Persistent Programming Research Report, Universities of
Glasgow and St Andrews, number PPRR--44--87"
}

@techreport{will90,
author = "Williams, Ifor and Mario I. Wolczko and Trevor Hopkins",
title = "Realization of a Dynamically Grouped Object-Oriented Memory Hierarchy",
type = "Technical Report",
institution = "University of Manchester Department of Computer Science",
address = "Manchester",
year = 1990
}

@inproceedings{will91,
author = "Ifor W. Williams and Mario I. Wolczko",
title = "An Object-Based Memory Architecture",
pages = "114--130",
crossref = "POS90"
}

@article{wils88,
  title =	 "Opportunistic Garbage Collection",
  author =	 "Paul R. Wilson",
  pages =	 "98--102",
  journal =	 SIGPLAN,
  month =	 dec,
  year =	 1988,
  volume =	 23,
  number =	 12
}

@mastersthesis{wils88b,
author = "Paul R. Wilson",
title = "Two Comprehensive Virtual Copy Mechanisms",
school = "University of Illinois at Chicago, Electrical Engineering and Computer
Science Department",
address = "Chicago, IL",
year = 1988
}

@article{wils89,
  title =	 "A Card-Marking Scheme for Controlling Intergenerational
                  References in Generation-Based Garbage Collection on Stock
                  Hardware",
  author =	 "Paul R. Wilson and Thomas G. Moher",
  journal =	 SIGPLAN,
  year =	 1989,
  volume =	 24,
  number =	 5,
  pages =	 "87--92",
  doi =		 {10.1145/66068.66077},
  abstract =	 {Like D. Moon's Ephemeral Garbage Collector ours does not
                  actually record which individual locations hold
                  intergenerational pointers.  Ours uses a software analogue
                  to pages, called cards.  Since individual locations are not
                  remembered, whole cards must be scanned at scavenge time to
                  find pointers into younger generations.  This
                  lowered-resolution recording has two benefits, the space
                  required for recording is greatly reduced, and the base cost
                  of examining this information (at scavenge time) is
                  similarly decreased.  To minimize the continual run-time
                  overhead, we record only whether a location is modified.
                  These benefits may be significant in large heaps, especially
                  if locality is poor or the page size is large.}
}

@article{wils89a,
  title =	 "A Simple Bucket-Brigade Advancement Mechanism for
                  Generation-Based Garbage Collection",
  author =	 "Paul R. Wilson",
  pages =	 "38--46",
  journal =	 SIGPLAN,
  month =	 may,
  year =	 1989,
  volume =	 24,
  number =	 5,
  doi =		 {10.1145/66068.66070}
}

@inproceedings{wils89b,
title = "Design of the Opportunistic Garbage Collector",
author = "Paul R. Wilson and Thomas G. Moher",
crossref = "OOPSLA89",
pages = "23--35",
doi = "10.1145/74877.74882",
comment = "Avoids some of the locality problems of simpler copying GCs."
}

@inproceedings{wils90,
author = "Paul R. Wilson",
title = "Some Issues and Strategies in Heap Management and Memory Hierarchies",
crossref = "OOPSLA90-gc",
note = "Also in SIGPLAN Notices 23(1):45--52, January 1991",
}

@techreport{wils90a,
title = "Pointer Swizzling at Page Fault Time: Efficiently Supporting Huge Address Spaces on Standard Hardware",
author = "Paul R. Wilson",
number = "UIC--EECS--90--6",
institution = "University of Illinois at Chicago, Electrical Engineering and Computer Science Department",
address = "Chicago, IL",
month = Dec,
year = 1990,
note = "Also in Computer Architecture News, 19(4):6--13, June 1991"
}

@techreport{wils90b,
title = "Caching Consideration for Generational Garbage Collection: A
Case Study of Large and Set-Associative Caches",
author = "Paul R. Wilson and Michael S. Lam and Thomas G. Moher",
institution = "University of Illinois at Chicago EECS Department",
number = "UIC--EECS--90--5",
address = "Chicago, IL",
month = Dec,
year = 1990,
note = "Improved version appears in \cite{LFP92}",
comment = "Careful attention improves locality.
More recently, Eliot Moss and his students at UMass (currently visiting
at CMU) have done some experiments with Standard ML of NJ that suggest that
the miss penalties may be lower than expected from the sheer number of
misses, at least on the architecture they experimented with;  this
may be sensitive to details of the cache design.  (See also Koopman
and Lee's paper, cited in this paper.)"
}

@inproceedings{wils91,
  title =	 {Effective ``Static-Graph'' Reorganization to Improve
                  Locality in Garbage-Collected Systems},
  author =	 {Paul R. Wilson and Michael S. Lam and Thomas G. Moher},
  crossref =	 {PLDI91},
  pages =	 {177--191},
  doi =		 {10.1145/113445.113461},
  comment =	 {As it doesn't pay to make heap larger than main memory,
                  equally locality within cache memory is important.}
}

@inproceedings{wils91a,
author = "Wilson, Paul R. and Barry Hayes",
title = "Report on the 1991 Workshop on Garbage Collection in Object-Oriented Systems",
note = "Addendum. Also distributed as a special issue of ACM SIGPLAN Notices, and OOPS Messenger 3(4), October 1992.",
crossref = "OOPSLA91",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GCreport91.ps",
}

@inproceedings{wils91b,
author = "Paul R. Wilson",
title = "Operating System Support for Small Objects",
crossref = "IWOOOS92",
}

@phdthesis{wils91c,
author = "Paul R. Wilson",
title = "Heap Management and Memory Hierarchies",
school = "University of Illinois at Chicago",
month = Dec,
year = 1991
}

@inproceedings{wils92,
author = "Paul R. Wilson and Michael S. Lam and Thomas G. Moher",
title = "Caching Considerations for Generational Garbage Collection",
crossref = "LFP92",
pages = "32--42",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/cache.ps",
comment = "Generational techniques can recapture some of the locality
characteristics of reference counting.",
comment = "Garbage collection is not the problem; heap allocation is.
Heap allocation (particularly in functional languages) does not
meet the assumptions upon which the memory heirarchy is based.
Analysis on some real programs shows that 2 or 4 way set associative
caches are better than direct mapped caches, and that relatively small
tuning factors can change cache misses fairly significantly.
Cyclic memory reuse patterns can fare poorly in hierarchical memories because
of LRU replacement policies."
}

@inproceedings{wils92a,
title = "Pointer Swizzling at Page Fault Time: Efficiently and Compatibly
Supporting Huge Addresses on Standard Hardware",
author = "Paul R. Wilson and Sheetal V. Kakkad",
crossref = "IWOOOS92",
pages = {364--377},
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/swizz.ps",
doi = {10.1109/IWOOOS.1992.252959}
}

@article{wils92b,
author = "Wilson, Paul R. and Shubhendu S. Mukherjee and Sheetal V. Kakkad",
title = "Anomalies and Adaptation in the Analysis and Development of Prepaging P
olicies",
journal = JSS,
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/prefetchsim.ps",
year = 1992
}

@inproceedings{wils92c,
title = "Uniprocessor Garbage Collection Techniques",
author = "Paul R. Wilson",
crossref = "IWMM92",
pages = {1--42},
doi = {10.1007/BFb0017182},
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/gcsurvey.ps",
}

@inproceedings{wils92d,
title = "Garbage Collection and Memory Hierarchy",
author = "Paul R. Wilson",
crossref = "IWMM92",
note = "Discussion Session"
}

@unpublished{wils92e,
title = "Efficient Tracing Using Virtual Memory Address Protection",
author = "Paul R. Wilson and Atif Chaudrhy",
note = "In preparation",
year = 1992
}

@inproceedings{wils93,
author = "Paul R. Wilson and Mark S. Johnstone",
title = "Truly Real-Time Non-Copying Garbage Collection",
crossref = "OOPSLA93-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC93/wilson.ps"
}

@unpublished{wils93a,
author = "Paul R. Wilson and Mark Johnstone",
title = "Truly Real-Time Non-Moving Implicit-Reclamation Garbage Collection",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/rtgc",
year = 1993,
month = mar,
note = "Rough Draft"
}

@techreport{wils94,
title = "Uniprocessor Garbage Collection Techniques",
author = "Paul R. Wilson",
institution = "University of Texas",
month = jan,
year = 1994,
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/bigsurv.ps",
note = "Expanded version of the IWMM92 paper"
}

@article{wils94a,
author = "Wilson, Paul R. and Shubhendu S. Mukherjee and Sheetal V. Kakkad",
title = "Anomalies and Adaptation in the Analysis and Development of Prepaging Policies",
journal = JSS,
note = "Technical Communication",
year = 1994
}

@inproceedings{wils95,
title = "Dynamic Storage Allocation: A Survey and Critical Review",
author = "Paul R. Wilson and Mark S. Johnstone and Michael Neely and David Boles",
crossref = "IWMM95",
pages={1--116},
doi={10.1007/3-540-60368-9_19},
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps",
}

@unpublished{wils95a,
title = "Memory Allocation Policies Reconsidered",
author = "Paul R. Wilson and Mark S. Johnstone and Michael Neely and David Boles
",
year = 1995,
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/submit/PUT_IT_HERE/frag.ps",
note = "Unpublished manuscript",
annote = "From University of Texas at Austin, Dept of Computer Science"
}

@techreport{wimm12,
title = {Maxine: An Approachable Virtual Machine For, and In, {J}ava},
author = {Christian Wimmer and Michael Haupt and Van De Vanter, Michael L. and
Mick Jordan and Laurent Dayn\`{e}s and and Douglas Simon},
institution = {Oracle Labs},
year = 2012,
URL = {https://wikis.oracle.com/display/MaxineVM/Technical+Report},
}

@inproceedings{wins89,
author = "William Winsborough",
title = "Path-Dependent Reachability Analysis for Multiple Specialization",
booktitle = "North American Conference on Logic Programming",
editor = "E. Lusk and R. Overbeek",
pages = "113--153",
publisher = MIT,
year = 1989
}

@article{wise76,
title = {Tuning {G}arwick's algorithm for repacking sequential storage},
author = {David S. Wise and Daniel C. Watson},
journal = {BIT},
volume = 16,
number = 4,
year = 1976,
month = dec,
pages = {442--450}
}

@article{wise77,
author = "David S. Wise and Daniel P. Friedman",
title = "The One-Bit Reference Count",
journal = "BIT",
volume = 17,
number = 3,
pages = "351--359",
year = "1977",
doi={10.1007/BF01932156},
abstract= {Deutsch and Bobrow propose a storage reclamation scheme
for a heap which is a hybrid of garbage collection and reference
counting.  The point of the hybrid scheme is to keep track of very low
reference counts between necessary invocation of garbage collection so
that nodes which are allocated and rather quickly abandoned can be
returned to available space, delaying necessity for garbage
collection.  We show how such a scheme may be implemented using the
mark bit already required in every node by the garbage collector.
Between garbage collections that bit is used to distinguish nodes with
a reference count known to be one.  A significant feature of our
scheme is a small cache of references to nodes whose implemented
counts ``ought to be higher'' which prevents the loss of logical count
information in simple manipulations of uniquely referenced structures.},
comment = {Uses only one bit for reference counting and relies on
mark-scan to recycle cell with multiple references and cycles}
}

@techreport{wise78,
title = "The Double Buddy-System",
author = "David S. Wise",
number = {TR79},
type = "Computer Science Technical Report",
institution = "Indiana University",
address = "Bloomington, IN",
month = dec,
year = 1978
}

@article{wise79,
  author =	 "David S. Wise",
  title =	 "Morris' Garbage Compaction Algorithm Restores Reference
                  Counts",
  journal =	 TOPLAS,
  publisher =	 ACM,
  volume =	 1,
  numnber =	 1,
  month =	 jul,
  year =	 1979,
  pages =	 "115--120",
  doi =		 {10.1145/357062.357070}
}

@inproceedings{wise85,
author = "David S. Wise",
title = "Design for a Multiprocessing Heap with On-board Reference
Counting",
crossref = "FPCA85",
pages = "289--304",
abstract = {In this short paper, the author describes an architecture for a memory
system that implements cell reference counting in a way that would be
useful for LISP-like languages. He argues that reference counting has a
useful place in heap management along with garbage collection because
reference counting can be done in a decentralized way, while garbage
collection is centralized. In a multiprocessor system, reference-counted
memory could increase the time between garbage collections and thus
decrease the fraction of the time when processors have to wait for a
centralized garbage collector to run.
The author's system implements LISP CONS cells. Each cell consists roughly
of a pair of 32-bit pointers and, for each pointer, an 11-bit reference
count and some status bits. Each time a pointer is written, it increments
the count in the newly pointed-to cell and decrements the count in the
formerly pointed-to cell, using a ``back door'' that does not require the
processor to wait. Free space is just a list of cells with zero reference
counts. Since the reference-count field is of finite size, counts can
occasionally overflow; at this point, a cell's count is marked infinite and
it will not be reclaimed until the next garbage collection.
The author refines this scheme with some ``sting'' bits, which let each
cell act as a test and set interlock, and a ``don't count'' bit, which lets
circular lists be counted and reclaimed in the common case where the cell
that closes the cycle is known when the cycle is created. The memory can
also run in a garbage collection mode in which the same hardware that fixed
up the reference counts turns out to be useful in implementing the standard
pointer reversing garbage collection scheme. Finally, the author describes
his efforts at hardware chip implementation, which he admits haven't
gotten very far yet.
This approach seems plausible, and it is indeed likely that most of the
lists created by a LISP program are amenable to reclamation by this
scheme.
Nonetheless, I cannot help but wonder whether one would do better to use
more conventional hardware and better software. His proposed chips store
about 64K bits apiece; garbage collection is delayed by a factor of 4
compared to that for a memory made of regular 64K chips. I could do the
same by using regular 256K chips and quadrupling the size of the memory.
Reports of real or simulated performance of Wise's system would make his
case much more persuasive.}
}

@techreport{wise93,
author = "Wise, David S. ",
title = "Stop-and-copy and One-Bit Reference Counting.",
type = "Computer Science Technical Report",
institution = "Indiana University",
number = 360,
URL = "ftp://ftp.cs.indiana.edu/pub/techreports/TR360.ps.Z",
month = mar,
year = 1993,
note = {See also \citet{wise93a}}
}

@article{wise93a,
author = "Wise, David S. ",
title = "Stop-and-copy and One-Bit Reference Counting.",
journal = IPL,
volume = 46,
number = 5,
month = jul,
pages = {243--249},
year = 1993,
doi={10.1016/0020-0190(93)90103-G},
comment = {TR \cite{wise93} is ther better version of this work.}
}

@techreport{wise94,
author = "Wise, David S.  and Heck, Brian  and Hess, Caleb  and Hunt, Willie  and Ost, Eric ",
institution = "Indiana University, Computer Science Department",
title = "Uniprocessor Performance of a Reference-Counting Hardware Heap",
year = 1994,
URL = "ftp://ftp.cs.indiana.edu/pub/techreports/TR401.ps.Z",
month = may,
number = "{TR}-401",
}

@inproceedings{wise96,
  author =	 {Wise, David S. and J. Walgenbach},
  title =	 {Static and Dynamic partitioning of Pointers as Links and
                  Threads},
  booktitle =	 {1996 } # ICFP,
  publisher =	 ACM,
  series =	 SIGPLAN # " 31(6)",
  month =	 jun,
  pages =	 {42--49},
  year =	 1996,
  doi =		 {10.1145/232627.232634}
}

@article{wise97,
author = "Wise, David S. and Hess, Caleb and Hunt, Willie  and Ost, Eric ",
title = "Research Demonstration of a Hardware Reference-Counting Heap",
journal = LSC,
volume = 10,
number = 2,
pages = {151--181},
year = 1997,
month = jul,
URL = {http://www.wkap.nl/oasis.htm/136324},
comment = {This is the same paper as \cite{wise94}.}
}

@inproceedings{wise66,
author = "N. E. Wiseman",
title = "A Simple List Processing Package for the {PDP--7}",
booktitle = "DECUS 2nd European Seminar",
address = {Aachen},
month = oct,
pages = "37--42",
year = 1966
}

@techreport{wise85a,
author = "Wiseman, Simon R.",
title = "A Garbage Collector for a Large Distributed Address Space",
number = "85009",
institution = "Royal Signals and Radar Establishment",
address = "Malvern, UK",
year = 1985
}

@phdthesis{wise88,
author = "Wiseman, Simon R.",
title = "Garbage Collection in Distributed Systems",
year = 1988,
school = "University of Newcastle upon Tyne"
}

@inproceedings{with91,
title = "How Real is ``Real Time'' Garbage Collection?",
author = "P. Tucker Withington",
crossref = "OOPSLA91-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/withington.ps"
}

@article{wodo69,
author = "P. L. Wodon",
title = "Data Structure and Storage Allocation",
journal = "BIT",
volume = 9,
number = 3,
year = 1969,
pages = "270--282",
}

@incollection{wodo71,
author = "P. L. Wodon",
title = "Methods of Garbage Collection for {A}lgol--68",
crossref = "Algol68",
pages = "245--262",
comment = {variant of Deutsch-Schorr-Waite algorithm for varisized cells.},
}

@inproceedings{wolc90,
author = "Mario I. Wolczko and Ifor Williams",
title = "Garbage Collection in High Performance System",
crossref = "OOPSLA90-gc",
}

@incollection{wolc90a,
author = "Mario I. Wolczko",
title = "Garbage Collection",
booktitle = "Case Studies in Systematic Software Development",
publisher = PH,
year = 1990,
editor = "Cliff B. Jones and Roger C. F. Shaw",
chapter = 8,
pages = "211-233"
}

@inproceedings{wolc92,
author = "Wolczko, Mario I. and Williams, Ifor",
title = "Multi-Level {GC} in a High-Performance Persistent Object System",
comment = "large (512K) SW-controlled cache, accessed by SW-generated obj ID; in-cache GC",
pages = {396--418},
crossref = "POS92",
}

@inproceedings{wolc93,
author = "Mario I. Wolczko and Ifor Williams",
title = "An Alternative Architecture for Objects: Lessons from the {MUSHROOM} Project",
crossref = "OOPSLA93-gc",
}

@article{wolf89,
title = "Practical Comparison of Two Object-Oriented Languages",
author = "W. Wolf",
journal = "IEEE Software",
publisher = IEEE,
volume = 6,
number = 5,
pages = "61--68",
year = "1989",
abstract = { The author compares two very different object-oriented programming
languages, Flavors and C++ , with respect to their merits and how
design decisions in each language influence various aspects of
programming.
The fundamental difference between the two languages is that C++ is
strongly typed while Flavors is weakly typed.  The comparison follows the
completion of two very similar programming projects, one using Flavors
and the other C++ , allowing direct comparison of software implementation
methods in these languages.  The projects involved the design of two systems
for describing and generating electronic hardware.  Differences in implementing
all three object-oriented language mechanisms--data abstraction, inheritance,
and runtime method determination--are discussed.  Typing, memory management,
syntax aids, and the programming environment are examined.  It is concluded
that the choice of a language can have a profound influence on program
design.}
}

@inproceedings{woll96,
author = {A. Wollrath and R. Riggs and Jim Waldo},
title = {A Distributed Object Model for the {J}ava system},
booktitle = {Conference on Object-Oriented Technologies},
address = {Toronto, Canada},
publisher = {Usenix},
year = 1996,
month = jun
}

@article{wong87,
title = "Garbage Collection Coprocessor System",
author = "K. F. Wong",
journal = "Electronics Letters",
volume = 23,
number = 15,
pages = "798--800",
year = "1987",
abstract = {The intelligent cell memory system is coprocessor system to achieve
on-the-fly garbage collection.  Analyses on its experimental results reveal
its advantages over conventional garbage collection approaches.}
}

@article{wood81,
author = "M. C. Woodward",
title = "Multiprocessor Garbage Collection --- a New Solution",
journal = "Computer Studies",
volume = 115,
year = 1981
}

@inproceedings{wrig93,
author = "D. A. Wright and C. A. Baker-Finch",
title = "Usage Analysis with Natural Reduction Types",
booktitle = "3rd International Workshop on Static Analysis",
year = 1993
}

@techreport{wrig05,
author = {Gregory Wright and Matthew L. Seidl and Mario Wolczko},
title = {An Object-Aware Memory Architecture},
institution = {Sun Microsystems Laboratories},
number = {SML--TR--2005--143},
month = feb,
year = 2005
}

@article{wrig06,
title = {An Object-Aware Memory Architecture},
author = {Gregory Wright and Matthew L. Seidl and Mario Wolczko},
journal =	 SCP,
volume =	 62,
number =	 2,
publisher =	 "Elsevier",
month =	 oct,
year =	 2006,
pages = {145--163}
}

@techreport{wrig08,
title = {A Hardware-Assisted Concurrent \& Parallel {GC} Algorithm},
author = {Gregory Wright},
institution = {Oracle Laboratories},
month = nov,
year = 2008,
URL = {http://labs.oracle.com/docs/index.php?id=2008-0577},
abstract = {Tutorial on the Maxwell algorithm (hardware assistance for
concurrent and parallel GC) for an external audience. This is a draft for early
release to academic collaborators.}
}

@mastersthesis{wu89,
author = "Wu, Meizhen",
title = "A Parallel Garbage Collection Algorithm for Virtual Memory",
year = 1989,
school = "Auburn University"
}

@techreport{wu89a,
author = "Wu, Zhibo",
title = "A Real Time Distributed Garbage Collection Method",
institution = "University of Exeter. Department of Computer Science",
year = 1989,
note = "Year maybe 1992",
type = "Research report",
number = "R 181"
}

@inproceedings{wu07,
author = {Ming Wu and Xiao-Feng Li},
title = {Task-Pushing: a Scalable Parallel {GC} Marking Algorithm without
Synchronization Operations},
booktitle = {IEEE International Parallel and Distribution Processing Symposium
(IPDPS)},
address = {Long Beach, CA},
month = mar,
year = 2007,
pages = {1--10},
doi={10.1109/IPDPS.2007.370317},
URL = {http://people.apache.org/~xli/papers/ipdps07-task-pushing.pdf}
}

@inproceedings{xian06,
author = {Feng Xian and Witawas Srisa-an and Hong Jiang},
title = {Evaluating Hardware Support for Reference Counting Using Software
Configurable Processors},
booktitle = {17th IEEE International Conference on Application-Specific Systems, Architectures, and Processors},
address = {Steamboat Springs, CO},
month = sep,
year = 2007,
pages = {297--302}
}

@inproceedings{xian06a,
author = {Feng Xian and Witawas Srisa-an and Hong Jiang},
title = {Investigating the Throughput Degradation Behavior of {J}ava
Application Servers: A View from Inside the Virtual Machine},
booktitle = {4th International Conference on Principles and Practices of Programming in Java},
address = {Mannheim, Germany},
year = 2006,
pages = {40--49}
}

@inproceedings{xian07,
author = {Feng Xian and Witawas Srisa-an and C. Jia and Hong Jiang},
title = {{AS-GC}: An Efficient Generational Garbage Collector for {J}ava
Application Servers},
crossref = {ECOOP07},
doi={10.1007/978-3-540-73589-2_7},
pages={126--150},
abstract = {A generational collection strategy utilizing a single nursery cannot
efficiently manage objects in application servers due to variance in their
lifespans. In this paper, we introduce an optimization technique designed for
application servers that exploits an observation that remotable objects are
commonly used as gateways for client requests. Objects instantiated as part of
these requests (remote objects) often live longer than objects not created to
serve these remote requests (local objects). Thus, our scheme creates remote and
local objects in two separate nurseries; each is properly sized to match the
lifetime characteristic of the residing objects. We extended the generational
collector in HotSpot to support the proposed optimization and found that given
the same heap size, the proposed scheme can improve the maximum throughput of an
application server by 14\% over the default collector. It also allows the
application server to handle 10\% higher workload prior to memory exhaustion.},
URL = {http://cse.unl.edu/~witty/papers/pdf/ecoop_2007.pdf}
}

@inproceedings{xian07a,
author = {Feng Xian and Witawas Srisa-an and Hong Jiang},
title = {Allocation-Phase Aware Thread Scheduling Policies to Improve Garbage Collection Performance},
pages = {79--90},
crossref = {ISMM07},
doi = {10.1145/1296907.1296919}
}

@inproceedings{xian07b,
author = {Feng Xian and Witawas Srisa-an and Hong Jiang},
title = {{M}icro{P}hase: An Approach to Proactively Invoking Garbage Collection for Improved Performance},
pages = {77--96},
crossref = {OOPSLA07},
doi = {10.1145/1297027.1297034}
}

@article{xian08,
title = {Garbage Collection: {J}ava Application Servers' {A}chilles Heel},
author = {Feng Xian and Witawas Srisa-an and Hong Jiang},
journal = SCP,
volume = 70,
number = {2--3},
month = feb,
year = 2008,
doi = {10.1016/j.scico.2007.07.008},
abstract = {Java application servers are gaining popularity as a way for
businesses to conduct day-to-day operations. While strong emphasis has been
placed on how to obtain peak performance, only a few research efforts have
focused on these servers' ability to sustain top performance in spite of the
ever-changing demands from users. As a preliminary study, we conducted an
experiment to observe the throughput degradation behavior of a widely-used Java
application server running a standardized benchmark and found that throughput
performance degrades ungracefully. Thus, the goal of this work is three-fold:
(i) to identify the primary factors that cause poor throughput degradation, (ii)
to investigate how these factors affect throughput degradation, and (iii) to
observe how changes in algorithms and policies governing these factors affect
throughput degradation.}
}

@article{xian05,
  title =	 {Minimizing Memory Requirement of Real-time Systems with
                  Concurrent Garbage Collector},
  author =	 {Yuqiang Xian and Guangze Xiong},
  journal =	 SIGPLAN,
  volume =	 40,
  number =	 3,
  month =	 mar,
  year =	 2005,
  pages =	 {40--48},
  doi =		 {10.1145/1057474.1057476}
}

@inproceedings{xu11,
author = {Xu, Guoqing and Bond, Michael D. and Qin, Feng and Rountev, Atanas},
title = {{L}eak{C}haser: Helping Programmers Narrow Down Causes of Memory Leaks},
crossref= {PLDI11},
pages = {270--282},
doi = {10.1145/1993498.1993530},
abstract = {In large programs written in managed languages such as Java and C\#,
holding unnecessary references often results in memory leaks and bloat,
degrading significantly their run-time performance and scalability. Despite the
existence of many leak detectors for such languages, these detectors often
target low-level objects; as a result, their reports contain many false warnings
and lack sufficient semantic information to help diagnose problems. This paper
introduces a specification-based technique called LeakChaser that can not only
capture precisely the unnecessary references leading to leaks, but also explain,
with high-level semantics, why these references become unnecessary.
At the heart of LeakChaser is a three-tier approach that uses varying levels of
abstraction to assist programmers with different skill levels and code
familiarity to find leaks. At the highest tier of the approach, the programmer
only needs to specify the boundaries of coarse-grained activities, referred to
as transactions. The tool automatically infers liveness properties of these
transactions, by monitoring the execution, in order to find unnecessary
references. Diagnosis at this tier can be performed by any programmer after
inspecting the APIs and basic modules of a program, without understanding of the
detailed implementation of these APIs. At the middle tier, the programmer can
introduce application-specific semantic information by specifying properties for
the transactions. At the lowest tier of the approach is a liveness checker that
does not rely on higher-level semantic information, but rather allows a
programmer to assert lifetime relationships for pairs of objects. This task
could only be performed by skillful programmers who have a clear understanding
of data structures and algorithms in the program.
We have implemented LeakChaser in Jikes RVM and used it to help us diagnose
several real-world leaks. The implementation incurs a reasonable overhead for
debugging and tuning. Our case studies indicate that the implementation is
powerful in guiding programmers with varying code familiarity to find the root
causes of several memory leaks---even someone who had not studied a leaking
program can quickly find the cause after using LeakChaser's iterative process
that infers and checks properties with different levels of semantic
information.}
} 

@inproceedings{su13,
author = {Xu, Guoqing},
title = {Resurrector: A Tunable Object Lifetime Profiling Technique for Optimizing Real-world Programs},
crossref = {OOPSLA13},
pages = {111--130},
numpages = {20},
doi = {10.1145/2509136.2509512},
abstract = {Modern object-oriented applications commonly suffer from severe
performance problems that need to be optimized away for increased efficiency and
user satisfaction. Many existing optimization techniques (such as object pooling
and pretenuring) require precise identification of object lifetimes. However, it
is particularly challenging to obtain object lifetimes both precisely and
efficiently: precise profiling techniques such as Merlin introduce several
hundred times slowdown even for small programs while efficient approximation
techniques often sacrifice precision and produce less useful lifetime
information. This paper presents a tunable profiling technique, called
Resurrector, that explores the middle ground between high precision and high
efficiency to find the precision-efficiency sweet spot for various livenes sbased
optimization techniques. Our evaluation shows that Resurrector is both more
precise and more efficient than the GC-based approximation, and it is
orders-of-magnitude faster than Merlin. To demonstrate Resurrector's usefulness,
we have developed client analyses to find allocation sites that create large
data structures with disjoint lifetimes. By inspecting program source code and
reusing data structures created from these allocation sites, we have achieved
significant performance gains. We have also improved the precision of an
existing optimization technique using the lifetime information collected by
Resurrector.}
}

@inproceedings{yama98,
author = {Hirotaka Yamamoto and Kenjiro Taura and Akinori Yonezawa},
title = {Comparing Reference Counting and Global Mark-and-Sweep on Parallel Computers},
booktitle = {Languages, Compilers, and Run-time Systems (LCR)},
series = LNCS,
publisher = SV,
month = may,
year = 1998,
doi = {10.1007/3-540-49530-4_15}
}

@inproceedings{yama98a,
author = {Hirotaka Yamamoto and Kenjiro Taura and Akinori Yonezawa},
title = {Performance Comparison between Reference Counting and Global {GC} on Distributed-Memory Parallel Computers},
booktitle = {Joint Symposium on Parallel Processing (JSPP)},
month = jun,
year = 1998,
URL = {http://ftp.yl.is.s.u-tokyo.ac.jp/pub/papers-japanese/jspp98-gc.ps.gz},
note = {In Japanese}
}

@inproceedings{yang01,
author = {Hongseok Yang},
title = {An Example of Local Reasoning in {BI} Pointer Logic: the {S}chorr-{W}aite Graph Marking Algorithm},
crossref = {SPACE01},
URL = {http://www.students.uiuc.edu/~hyang/paper/SchorrWaite.pdf http://www.students.uiuc.edu/~hyang/paper/SchorrWaite.ps.gz}
}

@inproceedings{yang02,
author = {Qian Yang and Witawas Srisa-an and Therapon Skotiniotis and J. Morris Chang},
title = {Java Virtual Machine Probes --- a Study of Object Life Span and {GC}},
booktitle = {21st {IEEE} International Performance, Computing and
Communications Conference ({IPCCC})},
address = {Phoenix, AZ},
month = apr,
year = 2002
}

@inproceedings{yang04,
title = {Autonomic Heap Sizing: Taking Real Memory Into Account},
author = {Ting Yang and Emery D. Berger and Matthew Hertz and Scott F. Kaplan
and J. Eliot B. Moss},
pages = {61--72},
crossref = {ISMM04},
doi = {10.1145/1029873.1029881}
}

@inproceedings{yang06,
  title =	 {{CRAMM}: Virtual Memory Support for Garbage-Collected
                  Applications},
  author =	 {Ting Yang and Emery D. Berger and Scott F. Kaplan and
                  J. Eliot B. Moss},
  booktitle =	 {7th USENIX Symposium on Operating System Design and
                  Implementation},
  year =	 2006,
  publisher =	 UA,
  pages =	 {103--116},
  address =	 {Seattle, WA},
  month =	 nov,
  URL =          {http://www.usenix.org/events/osdi06/tech/yang_ting.html},
}

@inproceedings{yang12,
 author = {Yang, Xi and Blackburn, Stephen M. and Frampton, Daniel and Hosking, Antony L.},
 title = {Barriers Reconsidered, Friendlier Still!},
 crossref = {ISMM12},
 pages = {37--48},
 doi = {10.1145/2258996.2259004},
 abstract = {Read and write barriers mediate access to the heap allowing the
 collector to control and monitor mutator actions. For this reason, barriers are
 a powerful tool in the design of any heap management algorithm, but the
 prevailing wisdom is that they impose significant costs. However, changes in
 hardware and workloads make these costs a moving target. Here, we measure the
 cost of a range of useful barriers on a range of modern hardware and workloads.
 We confirm some old results and overturn others. We evaluate the
 microarchitectural sensitivity of barrier performance and the differences among
 benchmark suites. We also consider barriers in context, focusing on their
 behavior when used in combination, and investigate a known pathology and
 evaluate solutions. Our results show that read and write barriers have average
 overheads as low as 5.4\% and 0.9\% respectively. We find that barrier overheads
 are more exposed on the workload provided by the modern DaCapo benchmarks than
 on old SPECjvm98 benchmarks. Moreover, there are differences in barrier
 behavior between in-order and out-of- order machines, and their respective
 memory subsystems, which indicate different barrier choices for different
 platforms. These changing costs mean that algorithm designers need to
 reconsider their design choices and the nature of their resulting algorithms in
 order to exploit the opportunities presented by modern hardware.}
} 

@inproceedings{yang10,
title = {Heap Garbage Collection with Reference Counting},
author = {Wuu Yang and Huei-Ru Tseng and Rong-Hang Jan},
booktitle = {Fifth International Conference on Software and Data Technologies},
address = {Athens, Greece},
month = jul,
year = 2010,
comment = {Optimises CRC algorithms by terminating partial traversal when it
encounters a node known to be live. This is implemented by having 2 reference
counts, one for heap references and one for references from roots.}
}

@inproceedings{yasu91,
author = "Masahiro Yasugi and Akinori Yonezawa",
title = "Towards User (Application) Language-Level Garbage Collection in Object-Oriented Concurrent Languages",
crossref = "OOPSLA91-gc",
}

@inproceedings{ye97,
author = {Xinfeng Ye and John Keane},
title = {Collecting Cyclic Garbage in Distributed Systems},
booktitle = {International Symposium on Parallel Architectures, Algorithms and Networks ({ISPAN} '97)},
address = {Taipei, Taiwan},
month = dec,
year = 1997,
URL = {http://csdl.computer.org/dl/proceedings/ispan/1997/8259/00/82590227.pdf},
abstract = {The proposed garbage collection scheme identifies and
collects cycles of garbage scattered across several machines. The
scheme identifies a garbage cycle by investigating: (a) whether the
transitive closure of a given object form a cycle, and (b) whether
objects in the transitive closure are referenced by objects outside the
closure. The algorithm only traces objects in the transitive closure of
the object suspected to be in a garbage cycle. Thus, compared to normal
mark-sweep, the algorithm here has better scalability. In contrast to
partly-mark-sweep, which marks objects in two rounds, this algorithm
identifies garbage in one round. Thus, the algorithm here is more
efficient in terms of speed. This algorithm does not interfere with the
mutators' operations. Unlike many other schemes, the algorithm here
does not require an object to reserve any memory to hold the
information for running the algorithm. Thus, a large amount of memory
can be saved.}
}

@inproceedings{yeat97,
author = "Stuart A. Yeates and Michel de Champlain",
title = "Design Patterns in Garbage Collection",
booktitle = "4th Annual Conference on the Pattern Languages of Programs",
year = 1997,
editor = "Robert S. Hanmer and Don Roberts",
address = "Monticello, IL",
month = "2-5 September",
note = "Published as technical report \# WUCS-97-34 of Washington
                  University (not peer reviewed)",
comment = "Not a peer reviewed publication but a 'shepparded' one.",
volume = "6 ``General Techniques''",
abstract = "This paper describes several design patterns found in
                  garbage collectors. The patterns we present are divided into
                  two groups. The first group are two new design patterns:
                  {\it Rootset\/} and {\it TriColour\/} that have been used in
                  the garbage collection domain for up to 20 years. The second
                  group of patterns are reported in the GoF book, such as {\it
                  Adapter\/}, {\it Facade\/}, {\it Iterator\/} and {\it
                  Proxy\/},but we examine their use in the garbage collection
                  domain. By applying these patterns, their solutions provide
                  a less efficient, but simpler and more flexible way of
                  implementing and reusing garbage collectors in programming
                  languages than current low-level methods.",
URL = {http://www.cs.waikato.ac.nz/~syeates/pubs/plop2.ps.gz}
}

@mastersthesis{yeat97a,
author = "Stuart Yeates",
title = "Design Patterns in Garbage Collection",
school = "University of Canterbury",
year = 1997,
address = "Christchurch, New Zealand",
month = jun,
URL = {http://www.cs.waikato.ac.nz/~syeates/pubs/thesis.ps.gz}
}

@inproceedings{yeat97b,
author = "Stuart A. Yeates and Michel de Champlain",
title = "Design of a Garbage Collector Using Design Patterns",
booktitle = "25th Conference of TOOLS Pacific.",
year = 1997,
editor = "Christine Mingins and Roger Duke and Bertrand Meyer",
organization = "ISE (Interactive Software Engineering)",
address = "Melbourne",
pages = "77-92",
annote = {We present six design patterns---Adapter, Facade, Iterator,
                  Proxy, RootSet and TriColour---found during a review of four
                  different garbage collectors. We also capture the design
                  decisions and trade-offs behind the low-level implementation
                  that characterises most garbage collectors. A garbage
                  collector for real-time applications is then designed using
                  the design patterns. We discuss the selected algorithm and
                  various implementation techniques. Finally the performance
                  of the collector is examined using formal methods. This
                  paper presents a novel attempt to "mine" and capture the
                  essential design decisions and trade-offs in garbage
                  collectors. },
URL = {http://www.cs.waikato.ac.nz/~syeates/pubs/tools2.ps.gz}
}

@article{yelo77,
author = "L. Yelowitz and  A. G. Duncan",
title = "Abstractions, Instantiations and Proofs of Marking Algorithms",
journal = Sigplan,
publisher = ACM,
volume = 12,
number = 8,
month = Aug,
year = 1977,
comment = {proves the correctness of several marking algorithms},
pages = "13--21"
}

@techreport{yi92,
author = {Kwangkeun Yi and Harrison III, Williams Ludwell},
title = {Interprocedural Data Flow Analysis for Compile-time Memory
Management},
number = 1244,
institution = {Center for Supercomputing Research and Development,
University of Illinois},
month = aug,
year = 1992
}

@techreport{yip91,
author = "Yip, G. May",
title = "Incremental, Generational Mostly-Copying Garbage Collection in Uncooperative Environments",
institution = "Digital, Western Research Laboratory",
year = 1991,
number = "91/8",
month = jun,
URL = "ftp://ftp.digital.com/pub/DEC/WRL/research-reports/WRL-TR-91.8.ps",
note = "Masters Thesis --- MIT, Cambridge, MA, 1991",
abstract = "The thesis of this project is that incremental
collection can be done feasibly and efficiently in an
architecture and compiler independent manner.  The design and
implementation of an incremental, generational mostly-copying
garbage collector for C++ is presented.  The collector achieves,
simultaneously, real-time performance (from incremental
collection), low total garbage collection delay (from
generational collection), and the ability to function without
hardware and compiler support (from mostly-copying collection).
The incremental collector runs on commercially-available
uniprocessors, such as the DECstation 3100, without any special
hardware support.
It uses UNIX's user controllable page protection facility
(mprotect) to synchronize between the scanner (of the collector)
and the mutator (of the application program).  Its implementation
does not require any modification to the C++ compiler.  The
maximum garbage collection pause  is well within the 100-
millisecond limit imposed by real-time applications  executing on
interactive workstations.  Compared to its non-incremental
version, the total execution time of the incremental collector is
not adversely affected."
}

@inproceedings{yong94,
author = "V.-F. Yong and J. Naughton amd J.-B. Yu",
title = "Storage Reclamation and Reorganization in Client--Server Persistent Object Stores",
booktitle = "International Conference on Data Engineering",
address = "Houston, TX",
pages = "120--133",
month = feb,
year = 1994
}

@inproceedings{yu03,
author = {Dachuan Yu and Nadeem A. Hamid and Zhong Shao},
title = {Building Certified Libraries for {PCC}: Dynamic Storage Allocation},
crossref = {ESOP03},
pages = {101--127},
doi = {10.1007/3-540-36575-3_25}
}

@inproceedings{yu96,
author = {W. Yu and A. Cox},
title = {Conservative Garbage Collection on Distributed Shared Memory System},
booktitle = {6th International Conference on Distributed Computing Systems (ICDCS)},
pages = {402--410},
month = may,
year = 1996
}

@article{yu08,
  author =	 {Zoe C. H. Yu and Francis C. M. Lau and Cho-Li Wang},
  title =	 {Object Co-location and Memory Reuse for {J}ava Programs},
  journal =	 TACO,
  volume =	 4,
  number =	 4,
  year =	 2008,
  issn =	 {1544-3566},
  pages =	 {1--36},
  doi =		 {10.1145/1328195.1328199},
  publisher =	 ACM,
  address =	 {New York, NY},
  abstract =	 {We introduce a new memory management system, STEMA, which
                  can improve the execution time of Java programs. STEMA
                  detects prolific types on-the-fly and co-locates their
                  objects in a special memory space which supports reuse of
                  memory. We argue and show that memory reuse and co-location
                  of prolific objects can result in improved cache locality,
                  reduced memory fragmentation, reduced GC time, and faster
                  object allocation. We evaluate STEMA using 16
                  benchmarks. Experimental results show that STEMA performs
                  2.7\%, 4.0\%, and 8.2\% on average better than MarkSweep,
                  CopyMS, and SemiSpace.}
}

@techreport{yuas85,
author = "Taiichi Yuasa and Masumi Hagiya",
title = "Kyoto {C}ommon {L}isp Report",
institution = "Teikoku Insatsu Publishing, Kyoto",
year = 1985
}

@article{yuas90,
author = "Taiichi Yuasa",
address = "Kyoto Univ, Math Sci Research Inst., Kyoto 606, Japan",
title = "Real-Time Garbage Collection on General-Purpose Machines",
journal = JSS,
volume = 11,
number = 3,
  month =	 mar,
pages = "181--198",
year = 1990,
  doi =		 {10.1016/0164-1212(90)90084-Y},
comment = "Snapshot-at-beginning algorithm.
When a location is written to, previous contents saved onto a stack.
Thus all objects live at the beginning of a GC will be reached.
Large advantage of Baker on stock hardware is that only heap pointer writes
must be treated specially to preserve the invariants."
}


@inproceedings{yuas92,
title = "Memory Management and Garbage Collection of an Extended {Common} {L}isp System for Massively Parallel {SIMD} Architecture",
author = "Taiichi Yuasa",
crossref = "IWMM92",
pages = {490--506},
doi = {10.1007/BFb0017209}
}

@inproceedings{yuas02,
author = "Taiichi Yuasa",
title = {Return Barrier},
booktitle = {International {L}isp Conference},
year = 2002
}

@inproceedings{yuha86,
title = "Evaluation of the {Facom} {Alpha} {L}isp Machine.",
author = "M. Yuhara and A. Hattori and M. Niwa and M. Kishimoto and H. Hayashi",
booktitle = "13th Annual International Symposium on Computer Architecture",
address = "Tokyo",
publisher = IEEE,
month = jun,
year = 1986,
abstract = {The FACOM ALPHA is the first and only commercially dedicated
processor for Lisp and Prolog manufactured in Japan.  The authors discuss
the evaluation of the FACOM ALPHA for Lisp execution when compared with a
general-purpose computer.  The CPU use rate for machine instructions and the
utilization ratio of the hardware resources are discussed.  The interaction
between the garbage collector and the virtual memory system, which
improves system response time, is explained.}
}

@inproceedings{yung10,
  title={A Graph-Based Algorithm of Mostly Incremental Garbage Collection for Active Object Systems},
  author={Yung, Chung and Syu, Jheng-Jyun and Yang, Shiang-Yu},
  booktitle={International Computer Symposium (ICS)},
  pages={988--996},
  year=2010,
  organization=IEEE
}

@inproceedings{zabe07,
author = {Zabel, Martin and Preuber, Thomas B. and Reichel, Peter and Spallek, Rainer G.},
title = {Secure, Real-Time and Multi-Threaded General-Purpose Embedded {J}ava Microarchitecture},
booktitle = {10th Euromicro Conference on Digital System Design Architectures, Methods and Tools},
year = 2007,
pages = {59--62},
doi = {10.1109/DSD.2007.97},
publisher = IEEEcomp,
abstract = {This paper presents a novel implementation of an embedded Java
microarchitecture for secure, real-time, and multi-threaded applications. A
general-purpose platform is established through the support of modern features
of object-oriented languages, such as exception handling, automatic garbage
collection and interface types. New techniques have been implemented for
specific real-time issues, such as an integrated stack and thread management for
fast context switching, concurrent garbage collection for real-time threads and
autonomous control flows through preemptive round-robin scheduling.}
}

@article{zave75,
author = "Derek A. Zave",
title = "A Fast Compacting Garbage Collector",
journal = IPL,
publisher = NH,
volume = 3,
number = 6,
month = Jul,
year = 1975,
pages = "167--169",
comment = {algorithm for compacting varisized cells},
}

@article{zee02,
  title =	 {Write Barrier Removal by Static Analysis},
  author =	 {Karen Zee and Martin Rinard},
  journal =	 SIGPLAN,
  volume =	 37,
  number =	 4,
  month =	 apr,
  year =	 2002,
  doi =		 {10.1145/510857.510866}
}

@inproceedings{zee02a,
title = {Write Barrier Removal by Static Analysis},
author = {Karen Zee and Martin Rinard},
pages = {191--210},
doi={10.1145/582419.582439},
crossref = {OOPSLA02}
}

@inproceedings{zend06,
author = {Olivier Zendra},
title = {Memory and Compiler Optimizations for Low-Power and Energy},
booktitle ={Implementation, Compilation, Optimization of Object-Oriented
Languages, Programs and Systems ({ICOOOLPS}'2006)},
pages = 8,
address = {Nantes, France},
month = jul,
year = 2006,
URL = {http://www.loria.fr/~zendra/publications/zendra_icooolps_2006.pdf}
}

@inproceedings{zhan98,
title = {Experiments with Combined Analysis for Pointer Aliasing},
author = {Sean Zhang and Barbara G. Ryder and William A. Landi},
crossref = {PASTE98},
pages = {11--18},
doi = {10.1145/277631.277635}
}

@inproceedings{zhan06,
title = {Program-Level Adaptive Memory Management},
author = {Chengliang Zhang and Kirk Kelsey and Xipeng Shen and Chen Ding and Matthew Hertz and Mitsunori Ogihara},
pages = {174--183},
crossref = {ISMM06},
doi = {10.1145/1133956.1133979}
}

@inproceedings{zhan08,
  title =	 {Online Phase-Adaptive Data Layout Selection},
  author =	 {Chengliang Zhang and Martin Hirzel},
  pages =	 {309--334},
  crossref =	 {ECOOP08},
  doi =		 {10.1007/978-3-540-70592-5_14}
}

@article{zhao87,
author = "W. Zhao and K. Ramamritham and J. A. Stankovic",
title = "Scheduling Tasks with Resource Requirements in Hard Real-Time Systems",
journal = IEEETransSWE,
volume = {SE-13},
number = 5,
pages = "564--577",
month = may,
year = 1987,
doi={10.1109/TSE.1987.233201}
}

@inproceedings{zhao09,
title = {Allocation Wall: A Limiting Factor of {J}ava Applications on Emerging
Multi-core Platforms},
author = {Yi Zhao and Jin Shi and Kai Zheng and Haichuan Wang and Haibo Lin and Ling Shao},
pages = {361--376},
crossref = {OOPSLA09},
doi = {10.1145/1640089.1640116}
}

@inproceedings{zhon08,
title = {Sampling-based Program Locality Approximation},
author = {Yutao Zhong and Wentao Chang},
crossref = {ISMM08},
pages = {91--100},
doi = {10.1145/1375634.1375648},
abstract = {Reuse signature, or reuse distance pattern, is an
accurate model for program memory accessing behaviors. It has been
studied and shown to be effective in program analysis and optimizations
by many recent works. However, the high overhead associated with
reuse distance measurement restricts the scope of its application.
This paper explores applying sampling in reuse signature collection
to reduce the time overhead. We compare different sampling strategies
and show that an enhanced systematic sampling with a uniform coverage
of all distance ranges can be used to extrapolate the reuse distance
distribution. Based on that analysis, we present a novel sampling
method with a measurement accuracy of more than 99\%. Our average
speedup of reuse signature collection is 7.5 while the best improvement
observed is 34. This is the first attempt to utilize sampling in
measuring reuse signatures. Experiments with varied programs and
instrumentation tools show that sampling has great potential in
promoting the practical uses of reuse signatures and enabling more
optimization opportunities.}
}

@article{zhao12,
title = {Optimal Tenuring and Major Collection Times for a Generational Garbage
Collector},
author = {Xufeng Zhao and Syouji Nakamura and Toshio Nakagawa},
journal = {Asia-Pacific Journal of Operational Research},
volume = 29,
number = 3,
month = jun,
year = 2012,
doi = {10.1142/S0217595912400180},
abstract = {It is an important problem to determine the tenuring collection time
or major collection time to meet the pause time goal for a generational garbage
collector. From such a viewpoint, this paper proposes two stochastic models
based on the working schemes of a generational garbage collector: Garbage
collections occur at a nonhomogeneous Poisson process. Minor collections are
made when the garbage collector begins to work, tenuring collection is made at a
planned time T or at the first collection time when surviving objects have
exceeded K for the first model. Major collection is made at time T or at the Nth
collection for the second model. Using the techniques of cumulative processes
and reliability theory, expected cost rates are obtained, and optimal policies
of tenuring and major collection times which minimize them are discussed
analytically and computed numerically.}
}




Read More: http://www.worldscientific.com/doi/abs/10.1142/S0217595912400180
@article{zhou92,
author = "Songnian Zhou and Michael Stumm and Kai Li and David Wortman",
title = "Heterogeneous Distributed Shared Memory",
journal = "IEEE Transactions on Parallel and Distributed Systems",
publisher = IEEE,
volume = 3,
number = 5,
pages = "540--554",
month = Sep,
year = 1992
}

@inproceedings{zhou00,
author = {Neng-Fa Zhou},
title = {Garbage Collection in {B}-{P}rolog},
booktitle = {1st Workshop on Memory Management in Logic Programming Implementations},
month = jul,
year = 2000,
URL = {http://www.sci.brooklyn.cuny.edu/~zhou/#PUB},
}

@inproceedings{zhou12,
 author = {Zhou, Jin and Demsky, Brian},
 title = {Memory Management for Many-core Processors with Software Configurable Locality Policies},
 crossref = {ISMM12},
 pages = {3--14},
 doi = {10.1145/2258996.2259000},
 abstract = {As processors evolve towards higher core counts, architects will
 develop more sophisticated memory systems to satisfy the cores' increasing
 thirst for memory bandwidth. Early many-core processor designs suggest that
 future memory systems will likely include multiple controllers and distributed
 cache coherence protocols. Many-core processors that expose memory locality
 policies to the software system provide opportunities for automatic tuning that
 can achieve significant performance benefits.
Managed languages typically provide a simple heap abstraction. This paper
presents techniques that bridge the gap between the simple heap abstraction of
modern languages and the complicated memory systems of future processors. We
present a NUMA-aware approach to garbage collection that balances the competing
concerns of data locality and heap utilization to improve performance. We
combine a lightweight approach for measuring an application's memory behavior
with an online, adaptive algorithm for tuning the cache to optimize it for the
specific application's behaviors.
We have implemented our garbage collector and cache tuning algorithm and present
results on a 64-core TILEPro64 processor.}
} 

@inproceedings{zigm00,
author = {John Zigman and Stephen M. Blackburn and J. Eliot B. Moss},
title = {{TMOS}: a Transactional Garbage Collector},
pages = {116--135},
crossref = {POS00}
}

@phdthesis{zigm04,
author = {John Zigman},
title = {A General Framework for the Description and Construction of
Hierarchical Garbage Collection Algorithms},
school = {Australian National University},
year = 2004
}

@inproceedings{zill07,
title = {Accordion Arrays: Selective Compression of {U}nicode arrays in {J}ava},
author = {Craig Zilles},
pages = {55--66},
crossref = {ISMM07},
}


@techreport{zorn87,
author = "Benjamin Zorn and Paul Hilfinger and Kinson Ho and James R. Larus",
title = "{SPUR} {Lisp}: Design and implementation",
number = "UCB/CSD 87/373",
institution = UCB,
month = oct,
year = 1987
}

@inproceedings{zorn88,
title = {A Memory Allocation Profiler for {C} and {L}isp Programs},
author = "Benjamin Zorn and Paul Hilfinger and Kinson Ho and James R. Larus",
booktitle = {Summer USENIX Conference},
pages = {223--237},
month = jun,
year = 1988,
URL = {ftp://ftp.digital.com/pub/misc/mprof-3.0.tar},
ABSTRACT = {This paper describes inprof, a tool used to study the memory
allocation behavior of programs.  mprof records the amount of memory
each function allocates, breaks down allocation information by type
and size, and displays a program's dynamic cal graph so that functions
indirectly responsible for memory allocation are easy to identify.
mprof is a two-phase tool.  The monitor phase is linked into executing
programs and records information each time memory is allocated.  The
display phase reduces the data generated by the monitor and displays
the information to the user in several tables. mprof has been
implemented for C and Kyoto Common Lisp.  Measurements of these
implementations are presented.}
}

@phdthesis{zorn89,
author = "Zorn, Benjamin G.",
title = "Comparative Performance Evaluation of Garbage Collection Algorithms",
school = UCB, 
note = "Technical Report UCB/CSD 89/544",
URL = "ftp://tr-ftp.cs.berkeley.edu/pub/tech-reports/csd/csd-89-544/",
month = mar,
year = 1989,
comment = "Reduces read barrier overhead by using knowledge of special
cases. Overheads of the order of 20 percent.",
abstract = "This thesis shows that object-level, trace-driven
simulation can facilitate evaluation of language runtime systems
and reaches new conclusions about the relative performance of
important garbage collection algorithms. In particular, I reach
the unexpected conclusion that mark-and-sweep garbage collection,
when augmented with generations, shows comparable CPU performance
and much better reference locality than the more widely used
copying algorithms. In the past, evaluation of garbage collection
algorithms has been limited by the high cost of implementing the
algorithms. Substantially different algorithms have rarely been
compared in a systematic way.
With the availability of high-performance, low-cost workstations,
trace-driven performance evaluation of these algorithms is now
economical. This thesis describes MARS, a runtime system
simulator that is driven by operations on program objects, and
not memory addresses. MARS has been attached to a commercial
Common Lisp system and eight large Lisp applications are used in
the thesis as test programs. To illustrate the advantages of the
object-level tracing technique used by MARS, this thesis compares
the relative performance of stop-and-copy, incremental, and mark-
and-sweep collection algorithms, all organized with multiple
generations. The comparative evaluation is based on several
metrics: CPU overhead, reference locality, and interactive
availability.
Mark-and-sweep collection shows slightly higher CPU overhead than
stop-and-copy ability (5 percent), but requires significantly less
physical memory to achieve the same page fault rate (30-40 percent).
Incremental collection has very good interactive availability,
but implementing the read barrier on stock hardware incurs a
substantial CPU overhead (30-60 percent). In the future, I will use MARS
to investigate other performance aspects of sophisticated runtime
systems."
}

@inproceedings{zorn90,
author = "Benjamin Zorn",
title = "Comparing Mark-and-Sweep and Stop-and-Copy Garbage Collection",
crossref = "LFP90",
abstract = {Stop-and-copy garbage collection has been preferred to
mark-and-sweep collection in the last decade because its collection time
is proportional to the size of reachable data and not the memory size.
This paper compares the CPU overhead and the memory requirements of the
two collection algorithms extended with generations, and finds that
mark-and-sweep collection requires at most a small amount of additional
CPU overhead (3--6 percent) but requires an average of 20 percent (and up to 40 percent) less
memory to achieve the same page fault rate. The comparison is based on
results obtained using trace-driven simulation with large Common Lisp
programs.
Many recent papers on copying gc algorithms have mentioned mark-and-sweep
collection only in passing, noting that because the cost is proportional to
the size of memory, mark-and-sweep collection is less efficient that copying
collection [....]. Appel, Ellis, and Li note that the cost of mark-and-sweep
collection is probably somewhat higher than the cost of copying collection,
but concede that other costs (allocation, barriers, vm overhead) effect
performance enough that copying collectors may not necessarily be the most
effective.
I note that the cost of sweeping is just an extension of the cost of
allocation, and quantify that cost to be up to 5 percent in allocation intensive
programs.  },
}

@inproceedings{zorn90a,
author = "B. Zorn",
title = "Designing Systems for Evaluation: A Case Study of Garbage Collection",
crossref = "OOPSLA90-gc",
}

@techreport{zorn90b,
author = "Zorn, Benjamin",
title = "Barrier Methods for Garbage Collection",
institution = "University of Colorado, Boulder",
year = 1990,
number = "CU-CS-494-90",
URL = "ftp://ftp.cs.colorado.edu/pub/cs/techreports/zorn/CU-CS-494-90.ps.Z",
month = Nov,
abstract = "Garbage collection algorithms have been enhanced in
recent years with two methods: generation-based collection and
Baker incremental copying collection.  Generation-based
collection requires special actions during certain store
operations to implement the 'write barrier.'  Incremental
collection requires special actions on certain load operations to
implement the 'read barrier.'  This paper evaluates the
performance of different implementations of the read and write
barriers and reaches several important conclusions.  First, the
inlining of barrier checks results in surprisingly low overheads,
both for the write barrier (2-6 percent) and the read barrier (< 20 percent).
Contrary to previous belief, these results suggest that a Baker-
style read barrier can be implemented efficiently without
hardware support. Second, the use of operating system traps to
implement garbage collection methods results in extremely high
overheads because the cost of trap handling is so high.  Since
this large overhead is completely unnecessary, operating system
memory protection traps should be reimplemented to be as fast as
possible.  Finally, the performance of these approaches on
several machine architectures is compared to show that the
results are generally applicable."
}

@techreport{zorn91,
author = "Benjamin Zorn",
title = "The Effect of Garbage Collection on Cache Performance",
number = "CU--CS--528--91",
URL = "ftp://ftp.cs.colorado.edu/pub/cs/techreports/zorn/CU-CS-528-91.ps.Z",
institution = "University of Colorado at Boulder",
month = May,
comment = "compares mark-sweep and generational GC with various cache sizes;
says mark-sweep is significantly better with direct-mapped cache",
year = 1991
}

@techreport{zorn92,
author = "Benjamin Zorn",
title = "The Measured Cost of Garbage Collection",
number = "CU--CS--573--92",
month = apr,
year = 1992,
URL = "ftp://ftp.cs.umd.edu/pub/papers/TRs/3370.ps.Z",
institution = "University of Colorado at Boulder",
abstract = "Dynamic storage allocation is an important part of
many computer programs and will be increasingly important as
object- oriented programming styles become more widely used.
Experience indicates that for many programs, dynamic storage
allocation is so important that programmers feel compelled to
provide their own optimized implementations to avoid the overhead
of system libraries.  Conservative garbage collection   has been
suggested as an important algorithm for dynamic storage
management in C programs.  In this paper, I evaluate the costs of
different  dynamic storage management algorithms, including
programmer optimized algorithms; standard, widely-used library
routines; and a publicly available conservative garbage
collection algorithm.
Surprisingly, I find that programmer optimization has little or
no effect on program performance.  I also find that the true cost
of conservative garbage collection is not the CPU overhead, but
the memory system overhead of the algorithm.  I conclude that
conservative garbage collection is a promising alternative to
explicit storage management and that the performance of
conservative collection is likely to be improved in the future.
C programmers should now seriously consider using conservative
garbage collection instead of malloc/free in programs they
write.",
address = "Department of Computer Science, Boulder, Colorado",
comment = "measures Boehm 1.6 (non-generational) against various mallocs;
cache misses, page fault measurements.  Overall result: pretty
comparable (but ignores optimization problem)"
}

@techreport{zorn92a,
author = "Benjamin Zorn and Dirk Grunwald",
title = "Evaluating Models of Memory Allocation",
institution = "University of Colorado",
type = "Computer Science Technical Report",
number = "CU-CS-603-92",
month = jul,
URL = {ftp://ftp.cs.colorado.edu/pub/cs/techreports/zorn/CU-CS-603-92.ps.Z},
year = 1992,
}

@techreport{zorn92b,
author = "Benjamin Zorn and Dirk Grunwald",
title = "Empirical Measurements of Six Allocation-Intensive {C} Programs",
institution = "University of Colorado",
type = "Computer Science Technical Report",
number = "CU-CS-604-92",
month = jul,
year = 1992,
URL = {ftp://ftp.cs.colorado.edu/pub/cs/techreports/zorn/CU-CS-604-92.ps.Z},
}

@article{zorn92c,
  author =	 "Benjamin Zorn and Dirk Grunwald",
  title =	 "Empirical Measurements of Six Allocation-Intensive {C}
                  Programs",
  journal =	 SIGPLAN,
  volume =	 27,
  number =	 12,
  pages =	 {71--80},
  year =	 1992,
}

@article{zorn93,
author = "Benjamin Zorn",
title = "The Measured Cost of Conservative Garbage Collection",
journal = SPE,
publisher = Wiley,
volume = 23,
pages = "733--756",
doi={10.1002/spe.4380230704},
abstract = "Because dynamic memory management is an important part of a large
class of computer programs, high-performance algorithms for dynamic
memory management have been, and will continue to be, of considerable
interest.  Experience indicates that for many programs, dynamic
storage allocation is so important that programmers feel compelled to
write and use their own domain-specific allocators to avoid the
overhead of system libraries.  Conservative garbage collection has
been suggested as an important algorithm for dynamic storage
management in C programs.  In this paper, I evaluate the costs of
different dynamic storage management algorithms, including
domain-specific allocators; widely-used general-purpose allocators;
and a publicly available conservative garbage collection algorithm.
Surprisingly, I find that programmer enhancements often have little
effect on program performance.  I also find that the true cost of
conservative garbage collection is not the CPU overhead, but the
memory system overhead of the algorithm.  I conclude that conservative
garbage collection is a promising alternative to explicit storage
management and that the performance of conservative collection is
likely to be improved in the future.  C programmers should now
seriously consider using conservative garbage collection instead of
malloc/free in programs they write.",
year = 1993
}

@article{zorn94,
author = "Benjamin Zorn and Dirk Grunwald",
title = "Evaluating Models of Memory Allocation",
journal = "ACM Transactions on Modelling and Computer Simulation",
publisher = ACM,
volume = 4,
number = 1,
year = 1994
}

@inproceedings{zorn98,
  title =	 {Segregating Heap Objects by Reference Behavior and Lifetime},
  author =	 {Benjamin Zorn and M. Seidl},
  crossref =	 {ASPLOS98},
  pages =	 {12-23},
  doi =		 {10.1145/291069.291012},
}



% CROSS REFERENCES

% BOOKS

@book{Algol68,
booktitle = "Algol--68 Implementation",
title = "Algol--68 implementation",
editor = "J. E. L. Peck",
publisher = "North-Holland",
address = "Amsterdam",
year = 1971,
pages = "198--238",
}

@misc{belo03,
author = {George Belotsky},
title = {{C}++ Memory Management: From Fear to Triumph},
howpublished = {O'Reilly linuxdevcenter.com},
month = jul,
year = 2003,
URL = {http://www.linuxdevcenter.com/pub/a/linux/2003/08/07/cpp_mm-3.html}
}

% First edition 1964
@book{berk74,
editor = "E. C. Berkeley and Daniel G. Bobrow",
title = "The Programming Language {LISP}: Its Operation and Applications",
booktitle = "The Programming Language {LISP}: Its Operation and Applications",
publisher = "Information International, Inc.",
address = "Cambridge, MA",
year = 1974,
edition = "Fourth",
URL = {http://www.softwarepreservation.org/projects/LISP/book/III_LispBook_Apr66.pdf}
}

@inproceedings{berl00,
author = {Alexandru Berlea and Sorin Cotofana and Irina Athanasiu and John Glossner and Stamatis Vassiliadis},
title = {Garbage Collection for the {D}elft {J}ava Processor},
booktitle = {18th {IASTED} International Conference, Applied Informatics},
address = {Innsbruck},
year = 2000 ,
URL = {http://www.informatik.uni-trier.de/~aberlea/publications/ai2000/GCforDJP.doc.gz}
}

@book{Smalltalk-BHWA,
editor = "Glenn Krasner",
booktitle = "Smalltalk-80: Bits of History, Words of Advice",
title = "Smalltalk-80: Bits of History, Words of Advice",
publisher = AW,
year = 1983,
comment = "Early implementations spent 20-70 percent of time in GC"
}

% CONFERENCES

@proceedings{krak00,
  title =	 {Recent Advances in Distributed Systems},
  editor =	 {S. Krakowiak and S.K. Shrivastava},
  series =	 LNCS,
  volume =	 1752,
  publisher =    SV,
  chapter =	 5,
  month =	 feb,
  year =	 2000,
  URL =          {http://link.springer.de/link/service/series/0558/tocs/t1752.htm}
}

@proceedings{ASPLOS82,
  key =		 "ASPLOS 1982",
  title =	 "1st " # ASPLOS,
  booktitle =	 "1st " # ASPLOS,
  address =	 {Palo Alto, CA},
  month =	 mar,
  year =	 1982,
  series =	 SIGARCH # { 10(2)},
  publisher =    ACM
}

@proceedings{ASPLOS87,
  key =		 "ASPLOS 1987",
  title =	 "2nd " # ASPLOS,
  booktitle =	 "2nd " # ASPLOS,
  address =	 "Palo Alto, CA",
  month =	 oct,
  year =	 1987,
  series =	 SIGARCH # { 15(5)},
  publisher =    ACM
}

@proceedings{ASPLOS89,
  key =		 "ASPLOS 1989",
  title =	 "3rd " # ASPLOS,
  booktitle =	 "3rd " # ASPLOS,
  address =	 "Boston, MA",
  month =	 apr,
  year =	 1989,
  series =	 SIGARCH # { 17(2)},
  publisher =    ACM
}

@proceedings{ASPLOS91,
  key =		 "ASPLOS 1991",
  title =	 "4th " # ASPLOS,
  booktitle =	 "4th " # ASPLOS,
  address =	 "Santa Clara, CA",
  month =	 apr,
  year =	 1991,
  series =	 SIGARCH # { 19(2)},
  publisher =    ACM
}

@proceedings{ASPLOS92,
  key =		 "ASPLOS 1992",
  title =	 "5th " # ASPLOS,
  booktitle =	 "5th " # ASPLOS,
  address =	 "Boston, MA",
  month =	 oct,
  year =	 1992,
  series =	 SIGPLAN # { 27(9)},
  publisher =    ACM
}

@proceedings{ASPLOS94,
  key =		 "ASPLOS 1994",
  title =	 "6th " # ASPLOS,
  booktitle =	 "6th " # ASPLOS,
  address =	 {San Jose, CA},
  year =	 1994,
  month =	 oct,
  series =	 SIGPLAN # { 29(11)},
  publisher =    ACM
}

@proceedings{ASPLOS96,
  key =		 "ASPLOS 1996",
  title =	 "7th " # ASPLOS,
  booktitle =	 "7th " # ASPLOS,
  address =	 {Cambridge, MA},
  month =	 oct,
  year =	 1996,
  series =	 SIGPLAN # { 31(9)},
  publisher =    ACM
}

@proceedings{ASPLOS98,
  key =		 "ASPLOS 1998",
  title =	 "8th " # ASPLOS,
  booktitle =	 "8th " # ASPLOS,
  address =	 "San Jose, CA",
  month =	 oct,
  year =	 1998,
  series =	 SIGPLAN # { 33(11)},
  publisher =	 ACM,
  doi =		 {10.1145/291069}
}

@proceedings{ASPLOS00,
  key =		 "ASPLOS 2000",
  title =	 "9th " # ASPLOS,
  booktitle =	 "9th " # ASPLOS,
  address =	 "Cambridge, MA",
  month =	 nov,
  year =	 2000,
  series =	 SIGPLAN # { 35(11)},
  publisher =    ACM,
  doi =		 {10.1145/356989},
}

@proceedings{ASPLOS02,
  key =		 "ASPLOS 2002",
  title =	 "10th " # ASPLOS,
  booktitle =	 "10th " # ASPLOS,
  address =	 "San Jose, CA",
  month =	 oct,
  year =	 2002,
  series =	 SIGPLAN # { 37(10)},
  publisher =    ACM
}

@proceedings{ASPLOS04,
  key =		 "ASPLOS 2004",
  editor =	 {Shubu Mukherjee and Kathryn S. McKinley},
  title =	 "11th " # ASPLOS,
  booktitle =	 "11th " # ASPLOS,
  address =	 "Boston, MA",
  month =	 oct,
  year =	 2004,
  series =	 SIGPLAN # { 39(11)},
  publisher =    ACM,
  doi =		 {10.1145/1024393}
}

@proceedings{ASPLOS06,
  key =		 {ASPLOS 2006},
  editor =	 {John Paul Shen and Margaret Martonosi},
  title =	 "Twelfth " # ASPLOS,
  booktitle =	 "Twelfth " # ASPLOS,
  address =	 {San Jose, CA},
  month =	 oct,
  year =	 2006,
  series =	 SIGPLAN # { 41(11)},
  publisher =    ACM
}

@proceedings{ASPLOS08,
  key =		 {ASPLOS 2008},
  editor =	 {Susan J. Eggers and James R. Larus},
  title =	 "13th " # ASPLOS,
  booktitle =	 "13th " # ASPLOS,
  address =	 {Seattle, WA},
  month =	 mar,
  year =	 2008,
  series =	 SIGPLAN # { 43(3)},
  publisher =    ACM,
  doi =		 {10.1145/1346281}
}

@proceedings{ASPLOS09,
  key =		 {ASPLOS 2009},
  editor =	 {Soffa, Mary Lou},
  title =	 "14th " # ASPLOS,
  booktitle =	 "14th " # ASPLOS,
  address =	 {Seattle, WA},
  month =	 mar,
  year =	 2008,
  series =	 SIGPLAN # { 43(3)},
  publisher =    ACM,
  doi =		 {10.1145/1508244}
}

@proceedings{CC00,
  key =		 "CC 2000",
  booktitle =	 "9th " # CC,
  title =	 "9th " # CC,
  year =	 2000,
  month =	 apr,
  address =	 "Berlin",
  publisher =	 SV,
  series =	 LNCS,
  volume =	 2027,
  doi =		 {10.1007/3-540-46423-9}
}

@proceedings{CC01,
  key =		 "CC 2001",
  booktitle =	 "10th " # CC,
  title =	 "10th " # CC,
  year =	 2001,
  month =	 apr,
  address =	 "Genova, Italy",
  publisher =	 SV,
  series =       LNCS,
  volume =       1781,
}

@proceedings{CC05,
  key =		 "CC 2005",
  booktitle =	 "14th " # CC,
  title =	 "14th " # CC,
  year =	 2005,
  month =	 apr,
  address =	 "Edinburgh",
  publisher =	 SV,
  series =       LNCS,
  volume =       3443,
  doi={10.1007/b107108}
}

@proceedings{CC06,
  key =		 "CC 2006",
  booktitle =	 "15th " # CC,
  title =	 "15th " # CC,
  year =	 2006,
  month =	 apr,
  address =	 "Vienna",
  publisher =	 SV,
  series =       LNCS,
  volume =       3923,
}

@proceedings{CC07,
  key =		 "CC 2007",
  booktitle =	 "16th " # CC,
  title =	 "16th " # CC,
  year =	 2007,
  month =	 mar,
  address =	 "Braga, Portugal",
  publisher =	 SV,
  series =	 LNCS,
  volume =	 4420,
  doi =		 {10.1007/978-3-540-71229-9}
}

@proceedings{CGO03,
  key = "CGO 2003",
  title = "1st " # CGO,
  booktitle = "1st " # CGO,
  publisher = IEEEcomp,
  year      = 2003,
  month     = mar,
  address   = "San Francisco, CA",
  isbn      = {0-7695-1913-X}
}

@proceedings{CGO04,
  title =	 "2nd " # CGO,
  year =	 2004,
  key =		 {CGO 2004},
  booktitle =	 "2nd " # CGO,
  address =	 {San Jose, CA},
  month =	 mar,
  publisher =	 IEEEcomp
}

@proceedings{CGO05,
  title =	 {3rd } # CGO,
  year =	 2005,
  key =		 {CGO 2005},
  booktitle =	 {3rd } # CGO,
  address =	 {San Jose, CA},
  month =	 mar,
  publisher =	 IEEEcomp
}

@proceedings{CGO06,
  title =	 {4th } # CGO,
  year =	 2006,
  key =		 {CGO 2006},
  booktitle =	 {4th } # CGO,
  address =	 {New York, NY},
  month =	 mar,
  publisher =	 IEEEcomp
}

@proceedings{CGO07,
  title =	 {5th } # CGO,
  year =	 2007,
  key =		 {CGO 2007},
  booktitle =	 {5th } # CGO,
  address =	 {San Jose, CA},
  month =	 mar,
  publisher =	 IEEEcomp
}

@proceedings{CGO08,
  title =	 {6th } # CGO,
  year =	 2008,
  key =		 {CGO 2008},
  booktitle =	 {6th } # CGO,
  address =	 {Boston, MA},
  month =	 apr,
  publisher =	 ACM
}

@proceedings{CGO09,
  title =	 {7th } # CGO,
  year =	 2009,
  key =		 {CGO 2009},
  booktitle =	 {7th } # CGO,
  address =	 {Seattle, WA},
  month =	 mar,
  publisher =	 IEEEcomp
}

@proceedings{CGO10,
  title =	 {8th } # CGO,
  year =	 2010,
  key =		 {CGO 2010},
  booktitle =	 {8th } # CGO,
  address =	 {Toronto, Canada},
  month =	 apr,
  publisher =	 ACM
}

@proceedings{ECOOP84,
  key =		 "ECOOP 1984",
  booktitle =	 ECOOP,
  title =	 ECOOP,
  year =	 1984
}

@proceedings{ECOOP87,
  key =		 "ECOOP 1987",
  booktitle =	 ECOOP,
  title =	 ECOOP,
  editor =	 {J. B\'{e}zivin and J.-M. Hullot and P. Cointe and Henry
                  Lieberman},
  series =	 LNCS,
  publisher =	 SV,
  month =	 jun,
  year =	 1987,
  volume =	 276,
  address =	 {Paris, France},
  doi =		 {10.1007/3-540-47891-4}
}

@proceedings{ECOOP93,
  key =		 "ECOOP 1993",
  booktitle =	 {7th } # ECOOP,
  title =	 {7th } # ECOOP,
  editor =	 "Oscar Nierstrasz",
  series =	 LNCS,
  publisher =	 SV,
  month =	 jul,
  year =	 1993,
  volume =	 707,
  address =	 "Kaiserslautern, Germany",
  doi =		 {10.1007/3-540-47910-4}
}

@proceedings{ECOOP94,
  key =		 "ECOOP 1994",
  booktitle =	 "8th " # ECOOP,
  title =	 "8th " # ECOOP,
  editor =	 "M. Tokoro and R. Pareschi",
  series =	 LNCS,
  publisher =	 SV,
  volume =	 821,
  year =	 1994,
  address =	 {Bologna, Italy},
  doi =		 {10.1007/BFb0052172}
}

@proceedings{ECOOP95,
  key =		 "ECOOP 1995",
  booktitle =	 {9th } # ECOOP,
  title =	 {9th } # ECOOP,
  editor =	 "Oscar Nierstrasz",
  series =	 LNCS,
  volume =	 952,
  publisher =	 SV,
  month =	 aug,
  year =	 1995,
  address =	 {\o{A}arhus, Denmark},
  doi =		 {10.1007/3-540-49538-X}
}

@proceedings{ECOOP98,
  key =		 "ECOOP 1998",
  title =	 "12th " # ECOOP,
  booktitle =	 "12th " # ECOOP,
  address =	 {Brussels, Belgium},
  editor =	 {Eric Jul},
  series =	 LNCS,
  volume =	 1445,
  publisher =	 SV,
  month =	 jul,
  year =	 1998,
  doi =		 {10.1007/BFb0054083}
}

@proceedings{ECOOP99,
  key =		 "ECOOP 1999",
  title =	 {13th } # ECOOP,
  booktitle =	 {13th } # ECOOP,
  address =	 {Lisbon, Portugal},
  series =	 LNCS,
  volume =	 1628,
  publisher =	 SV,
  editor =	 {Rachid Guerraoui},
  month =	 jul,
  year =	 1999,
  doi =		 {10.1007/3-540-48743-3}
}

@proceedings{ECOOP01,
  key =		 "ECOOP 2001",
  title =	 {15th } # ECOOP,
  booktitle =	 {15th } # ECOOP,
  editor =	 {J{\o}rgen Lindskov Knudsen},
  address =	 {Budapest, Hungary},
  month =	 jun,
  year =	 2001,
  series =	 LNCS,
  volume =	 2072,
  publisher =	 SV,
  doi =		 {10.1007/3-540-45337-7}
}

@proceedings{ECOOP02,
  key =		 "ECOOP 2002",
  title =	 {16th } # ECOOP,
  booktitle =	 {16th } # ECOOP,
  year =	 2002,
  month =	 jun,
  series =	 LNCS,
  volume =	 2374,
  publisher =	 SV,
  address =	 {M\'{a}laga, Spain},
  editor =	 {Boris Magnusson},
  doi =		 {10.1007/3-540-47993-7}
}

@proceedings{ECOOP03,
  key =		 "ECOOP 2003",
  title =	 {17th } # ECOOP,
  booktitle =	 {17th } # ECOOP,
  year =	 2003,
  month =	 jun,
  address =	 {Darmstadt, Germany},
  series =	 LNCS,
  volume =	 2743,
  publisher =	 SV,
  editor =	 {Luca Cardelli},
  doi =		 {10.1007/b11832}
}

@proceedings{ECOOP04,
  key =		 "ECOOP 2004",
  title =	 {18th } # ECOOP,
  booktitle =	 {18th } # ECOOP,
  address =	 {Oslo, Norway},
  month =	 jun,
  year =	 2004,
  series =	 LNCS,
  volume =	 3086,
  publisher =	 SV,
  editor =	 {Martin Odersky},
  doi =		 {10.1007/b98195}
}

@proceedings{ECOOP05,
  key =		 "ECOOP 2005",
  title =	 {19th } # ECOOP,
  booktitle =	 {19th } # ECOOP,
  editor =	 {Andrew P. Black},
  address =	 {Glasgow, Scotland},
  month =	 jul,
  year =	 2005,
  series =	 LNCS,
  volume =	 3586,
  publisher =	 SV,
  doi =		 {10.1007/11531142}
}

@proceedings{ECOOP07,
  key =		 "ECOOP 2007",
  title =	 {21st } # ECOOP,
  booktitle =	 {21st } #ECOOP,
  address =	 {Berlin, Germany},
  month =	 jul,
  year =	 2007,
  series =	 LNCS,
  volume =	 4609,
  publisher =	 SV,
  editor =	 {Erik Ernst},
  doi =		 {10.1007/978-3-540-73589-2}
}

@proceedings{ECOOP08,
  key =		 "ECOOP 2008",
  title =	 {22nd } # ECOOP,
  booktitle =	 {22nd } # ECOOP,
  address =	 {Paphos, Cyprus},
  month =	 jul,
  year =	 2008,
  series =	 LNCS,
  volume =	 5142,
  publisher =	 SV,
  editor =	 {Jan Vitek},
  doi =		 {10.1007/978-3-540-70592-5}
}

@proceedings{ECOOP09,
  key =		 "ECOOP 2009",
  title =	 {23rd } # ECOOP,
  booktitle =	 {23rd } # ECOOP,
  address =	 {Genoa, Italy},
  month =	 jul,
  year =	 2009,
  series =	 LNCS,
  volume =	 5653,
  publisher =	 SV,
  editor =	 {Sophia Drossopoulou},
  doi =		 {10.1007/978-3-642-03013-0}
}

@proceedings{ECOOP11,
  key =		 "ECOOP 2011",
  title =	 {25th } # ECOOP,
  booktitle =	 {25th } # ECOOP,
  address =	 {Lancaster, UK},
  month =	 jul,
  year =	 2011,
  series =	 LNCS,
  volume =	 6813,
  publisher =	 SV,
  editor =	 {Mira Mezini},
  doi =		 {10.1007/978-3-642-22655-7}
}

@proceedings{EMSOFT01,
  key =		 "EMSOFT 2001",
  title =	 {1st International Workshop on Embedded Software (EMSOFT)},
  booktitle =	 {1st International Workshop on Embedded Software (EMSOFT)},
  address =	 {Tahoe City, CA},
  editor =	 {T.A. Henzinger and C.M. Kirsch},
  series =	 LNCS,
  volume =	 2211,
  publisher =	 SV,
  year =	 2001,
  doi =		 {10.1007/3-540-45449-7}
}

@proceedings{ESOP86,
  key =		 "ESOP 1986",
  title =	 ESOP,
  booktitle =	 ESOP,
  editor =	 {Bernard Robinet and Reinhard Wilhelm},
  address =	 {Saarbr\"{u}cken, Germany},
  publisher =	 SV,
  series =	 LNCS,
  volume =	 213,
  month =	 mar,
  year =	 1986,
  doi =		 {10.1007/3-540-16442-1}
}

@proceedings{ESOP90,
  title =	 ESOP,
  year =	 1990,
  key =		 {ESOP 1990},
  booktitle =	 ESOP,
  editor =	 {Neil D. Jones},
  volume =	 432,
  series =	 LNCS,
  address =	 {Copenhagen, Denmark},
  month =	 may,
  publisher =	 SV,
  doi =		 {10.1007/3-540-52592-0}
}

@proceedings{ESOP92,
  key =		 "ESOP 1992",
  title =	 ESOP,
  booktitle =	 ESOP,
  address =	 {Rennes, France},
  month =	 feb,
  publisher =	 SV,
  series =	 LNCS,
  volume =	 582,
  year =	 1992,
  doi =		 {10.1007/3-540-55253-7}
}

@proceedings{ESOP03,
  key =		 "ESOP 2003",
  title =	 ESOP,
  booktitle =	 ESOP,
  address =	 {Warsaw, Poland},
  editor =	 {Pierpaolo Degano},
  month =	 apr,
  series =	 LNCS,
  publisher =	 SV,
  year =	 2003,
  doi =		 {10.1007/3-540-36575-3},
}

@proceedings{FPCA85,
  key =		 "FPCA 1985",
  booktitle =	 FPCA,
  title =	 FPCA,
  editor =	 "Jean-Pierre Jouannaud",
  series =	 LNCS,
  publisher =	 SV,
  volume =	 201,
  month =	 sep,
  year =	 1985,
  address =	 "Nancy, France",
  doi =		 {10.1007/3-540-15975-4}
}

@proceedings{FPCA87,
  key =		 "FPCA 1987",
  booktitle =	 FPCA,
  title =	 FPCA,
  editor =	 "Gilles Kahn",
  series =	 LNCS,
  publisher =	 SV,
  volume =	 274,
  month =	 sep,
  year =	 1987,
  address =	 "Portland, OR",
  doi =		 {10.1007/3-540-18317-5}
}

@proceedings{FPCA89,
  key =		 "FPCA 1989",
  booktitle =	 FPCA,
  title =	 FPCA,
  publisher =	 ACM,
  month =	 aug,
  year =	 1989,
  address =	 "Imperial College, London"
}

@proceedings{FPCA91,
  key =		 "FPCA 1991",
  booktitle =	 FPCA,
  title =	 FPCA,
  editor =	 "John Hughes",
  publisher =	 SV,
  series =	 LNCS,
  volume =	 523,
  month =	 aug,
  year =	 1991,
  address =	 "Cambridge, MA",
  doi =		 {10.1007/3-540-54396-1}
}

@proceedings{FPCA93,
  key =		 "FPCA 1993",
  booktitle =	 FPCA,
  title =	 FPCA,
  editor =	 "John Hughes",
  publisher =	 ACM,
  month =	 jun,
  year =	 1993,
  address =	 "Copenhagen, Denmark",
  doi =		 {10.1145/165180},
}

@proceedings{FPCA95,
  key =		 "FPCA 1995",
  booktitle =	 FPCA,
  title =	 FPCA,
  month =	 jun,
  year =	 1995,
  publisher =	 ACM,
  address =	 {La Jolla, CA},
  doi =		 {10.1145/224164},
}

@proceedings{glasgow88,
  key =		 "GWFP 1988",
  booktitle =	 GWFP,
  title =	 GWFP,
  year =	 1988,
  editor =	 "Cordelia Hall and R. John M. Hughes and John T. O'Donnell",
  publisher =	 "Glasgow University Computer Science Report 89/R4",
  month =	 feb,
}

@proceedings{glasgow90,
  key =		 "GWFP 1990",
  booktitle =	 "3rd Annual " # GWFP,
  title =	 "3rd Annual " # GWFP,
  year =	 1991,
  editor =	 "Simon L. {Peyton Jones} and G. Hutton and C. K. Hols",
  publisher =	 SV,
}

@proceedings{glasgow91,
  key =		 "GWFP 1991",
  booktitle =	 "4th Annual " # GWFP,
  title =	 "4th Annual " # GWFP,
  year =	 1992,
  editor =	 "Simon L. {Peyton Jones} and G. Hutton and C. K. Hols",
  publisher =	 SV,
  series =	 "Workshops in Computer Science",
}

@proceedings{glasgow93,
  key =		 "GWFP 1993",
  booktitle =	 "6th Annual " # GWFP,
  title =	 "6th Annual " # GWFP,
  year =	 1993,
  publisher =	 SV,
  series =	 "Workshops in Computer Science",
}

@proceedings{ICFP96,
  key =		 "ICFP 1996",
  booktitle =	 "1st " # ICFP,
  title =	 "1st " # ICFP,
  address =	 {Philadelphia, PA},
  publisher =	 ACM,
  month =	 may,
  year =	 1996,
}

@proceedings{ICFP97,
  key =		 "ICFP 1997",
  booktitle =	 "2nd " # ICFP,
  title =	 "2nd " # ICFP,
  address =	 {Amsterdam},
  publisher =	 ACM,
  month =	 jun,
  year =	 1997,
}

@proceedings{ICFP98,
  key =		 "ICFP 1998",
  booktitle =	 "3rd " # ICFP,
  title =	 "3rd " # ICFP,
  address =	 {Baltimore, MA},
  publisher =	 ACM,
  month =	 sep,
  year =	 1998,
}

@proceedings{ICFP99,
  key =		 "ICFP 1999",
  booktitle =	 "4th " # ICFP,
  title =	 "4th " # ICFP,
  address =	 {Paris},
  publisher =	 ACM,
  month =	 sep,
  year =	 1999,
}

@proceedings{ICFP00,
  key =		 "ICFP 2000",
  booktitle =	 "5th " # ICFP,
  title =	 "5th " # ICFP,
  address =	 {Montreal},
  publisher =	 ACM,
  month =	 sep,
  year =	 2000,
  doi =		 {10.1145/351240},
}

@proceedings{ICFP02,
  key =		 "ICFP 2002",
  booktitle =	 "7th " # ICFP,
  title =	 "7th " # ICFP,
  address =	 {Pittsburgh, PA},
  series =	 SIGPLAN # " 37(9)",
  publisher =	 ACM,
  month =	 sep,
  year =	 2002,
  doi =		 {10.1145/581478}
}

@proceedings{ICFP08,
  key =		 "ICFP 2008",
  booktitle =	 "13th " # ICFP,
  title =	 "13th " # ICFP,
  address =	 {Victoria, BC, Canada},
  publisher =	 ACM,
  month =	 sep,
  year =	 2008,
}

@proceedings{ICFP10,
  key =		 "ICFP 2010",
  booktitle =	 "15th " # ICFP,
  title =	 "15th " # ICFP,
  address =	 {Baltimore, MD},
  publisher =	 ACM,
  month =	 sep,
  year =	 2010,
}

@proceedings{ICFP11,
  key =		 "ICFP 2011",
  booktitle =	 "16th " # ICFP,
  title =	 "16th " # ICFP,
  address =	 {Tokyo, Japan},
  publisher =	 ACM,
  month =	 sep,
  year =	 2011,
}

@proceedings{ICLP82,
  key =		 "ICLP 1982",
  booktitle =	 "1st " # ICLP,
  title =	 "1st " # ICLP,
  year =	 1982,
}

@proceedings{ICLP84,
  key =		 "ICLP 1984",
  booktitle =	 "2nd " # ICLP,
  title =	 "2nd " # ICLP,
  year =	 1984,
  editor =	 {S.-A. T\"{a}rnlund},
  address =	 "Uppsala, Finland"
}

@proceedings{ICLP86,
  key =		 "ICLP 1986",
  booktitle =	 "3rd " # ICLP,
  title =	 "3rd " # ICLP,
  year =	 1986,
  editor =	 "E. Schapiro",
  address =	 "London",
  publisher =	 SV,
  sweries =	 LNCS,
  volume =	 225
}

@proceedings{ICLP87,
  key =		 "ICLP 1987",
  booktitle =	 "4th " # ICLP,
  title =	 "4th " # ICLP,
  year =	 1987,
  editor =	 "J. L. Lassez",
  address =	 "Melbourne",
  publisher = MIT
}

@proceedings{ICLP88,
  key =		 "ICLP 1988",
  booktitle =	 "5th " # ICLP,
  title =	 "5th " # ICLP,
  year =	 1988,
  publisher = MIT
}

@proceedings{ICLP90,
  key =		 "ICLP 1990",
  booktitle =	 "7th " # ICLP,
  title =	 "7th " # ICLP,
  editor =	 "D. H. D. Warren and P. Szeredi",
  year =	 1990,
  address =	 "Jerusalem",
  publisher = MIT
}

@proceedings{ICLP02,
  key =		 "ICLP 2002",
  booktitle =	 "18th " # ICLP,
  title =	 "18th " # ICLP,
  editor =	 {P.J. Stuckey},
  year =	 2002,
  publisher =	 SV,
  series =	 LNCS,
  volume =	 2401,
  URL =
                  {http://link.springer.de/link/service/series/0558/tocs/t2401.htm}
}

@proceedings{ICSE04,
  key =		 "ICSE 2004",
  title =	 {26th International Conference on Software Engineering},
  booktitle =	 {26th International Conference on Software Engineering},
  address =	 {Edinburgh},
  month =	 may,
  year =	 2004,
  publisher = IEEEcomp
}

@proceedings{ISCA85,
  key =		 "ISCA 1985",
  title =	 "12th Annual " # ISCA,
  booktitle =	 "12th Annual " # ISCA,
  month =	 jun,
  year =	 1985,
  publisher =	 IEEE,
}
@proceedings{ISCA89,
  key =		 "ISCA 1989",
  title =	 "16th Annual " # ISCA,
  booktitle =	 "16th Annual " # ISCA,
  month =	 may,
  year =	 1989,
  publisher =	 IEEE,
  address =	 {Jerusalem, Israel}
}


@proceedings{ISCA90,
  key =		 "ISCA 1990",
  title =	 "17th Annual " # ISCA,
  booktitle =	 "17th Annual " # ISCA,
  address =	 "Seattle, WA",
  month =	 may,
  year =	 1990,
  publisher =	 IEEE
}

@proceedings{ISCA91,
  key =		 "ISCA 1991",
  title =	 "18th Annual " # ISCA,
  booktitle =	 "18th Annual " # ISCA,
  address =	 "Toronto, Canada",
  month =	 may,
  year =	 1991,
  publisher =	 ACM
}

@proceedings{ISCA92,
  key =		 "ISCA 1992",
  title =	 "19th Annual " # ISCA,
  booktitle =	 "19th Annual " # ISCA,
  address =	 "Gold Coast, Australia",
  month =	 may,
  year =	 1992,
  publisher =	 ACM
}

@proceedings{ISCA93,
  key =		 "ISCA 1993",
  title =	 "20th Annual " # ISCA,
  booktitle =	 "20th Annual " # ISCA,
  address =	 "San Diego, CA",
  month =	 may,
  year =	 1993,
  publisher =	 IEEE
}

@proceedings{ISCA94,
  key =		 "ISCA 1994",
  title =	 "21st Annual " # ISCA,
  booktitle =	 "21st Annual " # ISCA,
  address =	 "Chicago, IL",
  month =	 apr,
  year =	 1994,
  publisher =	 IEEE
}

@proceedings{ISCA09,
  key =		 {ISCA 2009},
  title =	 {36th Annual} # ISCA,
  booktitle =	 {36th Annual} # ISCA,
  year =	 2009,
  address =	 {Austin, TX},
  month =	 jun,
  publisher =	 ACM
}

@proceedings{ISCA12,
  key =		 {ISCA 20112},
  title =	 {39th Annual} # ISCA,
  booktitle =	 {39th Annual} # ISCA,
  year =	 2012,
  address =	 {Portland, OR},
  month =	 jun,
  publisher =	 ACM
}

@proceedings{IWMM92,
  key =		 "IWMM 1992",
  booktitle =	 IWMM,
  title =	 IWMM,
  editor =	 "Yves Bekkers and Jacques Cohen",
  address =	 "St Malo, France",
  publisher =	 {Springer},
  series =	 LNCS,
  volume =	 637,
  month =	 "17--19~" # sep,
  year =	 1992,
  doi =		 {10.1007/BFb0017181}
}

@proceedings{IWMM95,
  key =		 "IWMM 1995",
  title =	 IWMM,
  booktitle =	 IWMM,
  address =	 "Kinross, Scotland",
  editor =	 "Henry G. Baker",
  publisher =	 {Springer},
  series =	 LNCS,
  volume =	 986,
  month =	 "27--29~" # sep,
  year =	 1995,
  doi =		 {10.1007/3-540-60368-9}
}

@proceedings{ISMM98,
  key =		 "ISMM 1998",
  title =	 {1st } # ISMM,
  booktitle =	 {1st } # ISMM,
  editor =	 {Peyton Jones, Simon L. and Richard Jones},
  address =	 {Vancouver, Canada},
  month =	 oct,
  year =	 1998,
  series =	 SIGPLAN # { 34(3)},
  publisher =	 ACM,
  ISBN =	 {1-58113-114-3},
  comment =	 {ISMM is the successor to the IWMM series of workshops},
  doi =		 {10.1145/286860}
}

@proceedings{ISMM2000,
  key =		 "ISMM 2000",
  title =	 {2nd } # ISMM,
  booktitle =	 {2nd } # ISMM,
  editor =	 {Craig Chambers and Antony L. Hosking},
  address =	 {Minneapolis, MN},
  month =	 oct,
  year =	 2000,
  series =	 SIGPLAN # { 36(1)},
  publisher =	 ACM,
  ISBN =	 {1-58113-263-8},
  doi =		 {10.1145/362422}
}

@proceedings{ISMM02,
  key =		 "ISMM 2002",
  title =	 {3rd } # ISMM,
  booktitle =	 {3rd } # ISMM,
  editor =	 {Hans-J. Boehm and David Detlefs},
  address =	 {Berlin, Germany},
  series =	 SIGPLAN # { 38(2 supplement)},
  publisher =	 ACM,
  month =	 jun,
  year =	 2002,
  doi =		 {10.1145/773146}
}

@proceedings{ISMM04,
  key =		 "ISMM 2004",
  title =	 {4th } # ISMM,
  booktitle =	 {4th } # ISMM,
  editor =	 {David F. Bacon and Amer Diwan},
  address =	 {Vancouver, Canada},
  month =	 oct,
  year =	 2004,
  publisher =	 ACM,
  doi =		 {10.1145/1029873},
  URL =		 {http://www.research.ibm.com/ismm04/program.html}
}

@proceedings{ISMM06,
  key =		 "ISMM 2006",
  title =	 {5th } # ISMM,
  booktitle =	 {5th } # ISMM,
  editor =	 {Erez Petrank and J. Eliot B. Moss},
  address =	 {Ottawa, Canada},
  month =	 jun,
  year =	 2006,
  publisher =	 ACM,
  doi =		 {10.1145/1133956}
}

@proceedings{ISMM07,
  key =		 "ISMM 2007",
  title =	 {6th } # ISMM,
  booktitle =	 {6th } # ISMM,
  editor =	 {Greg Morrisett and Mooly Sagiv},
  address =	 {Montr{\'e}al, Canada},
  month =	 oct,
  year =	 2007,
  publisher =	 ACM,
  doi =		 {10.1145/1296907}
}

@proceedings{ISMM08,
  key =		 "ISMM 2008",
  booktitle =	 {7th } # ISMM,
  title =	 {7th } # ISMM,
  editor =	 {Richard Jones and Steve Blackburn},
  address =	 {Tucson, AZ},
  publisher =	 ACM,
  month =	 jun,
  year =	 2008,
  doi =		 {10.1145/1375634}
}

@proceedings{ISMM09,
  key =		 "ISMM 2009",
  booktitle =	 {8th } # ISMM,
  title =	 {8th } # ISMM,
  editor =	 {Hillel Kolodner and Guy Steele},
  address =	 {Dublin, Ireland},
  publisher =	 ACM,
  month =	 jun,
  year =	 2009,
  doi =		 {10.1145/1542431}
}

@proceedings{ISMM10,
  key =		 "ISMM 2010",
  booktitle =	 {9th } # ISMM,
  title =	 {9th } # ISMM,
  editor =	 {Jan Vitek and Doug Lea},
  address =	 {Toronto, Canada},
  publisher =	 ACM,
  month =	 jun,
  year =	 2010,
  doi =		 {10.1145/1806651}
}

@proceedings{ISMM11,
  key =		 "ISMM 2011",
  booktitle =	 {10th } # ISMM,
  title =	 {10th } # ISMM,
  editor =	 {Hans Boehm and David Bacon},
  address =	 {San Jose, CA},
  publisher =	 ACM,
  month =	 jun,
  year =	 2011,
  doi =		 {10.1145/1993478}
}

@proceedings{ISMM12,
  key =		 "ISMM 2012",
  booktitle =	 {11th } # ISMM,
  title =	 {11th } # ISMM,
  editor =	 {Kathryn McKinley and Martin Vechev},
  address =	 {Beijing, China},
  publisher =	 ACM,
  month =	 jun,
  year =	 2012,
}

@proceedings{ISMM13,
  key =		 "ISMM 2013",
  booktitle =	 {12th } # ISMM,
  title =	 {12th } # ISMM,
  editor =	 {Erez Petrank and Perry Cheng},
  address =	 {Seattle, WA},
  publisher =	 ACM,
  month =	 jun,
  year =	 2013,
}

@proceedings{ISMM14,
  key =		 "ISMM 2014",
  booktitle =	 {13th } # ISMM,
  title =	 {13th } # ISMM,
  editor =	 {Samuel Z. Guyer and David Grove},
  address =	 {Edinburgh, 2014},
  publisher =	 ACM,
  month =	 jun,
  year =	 2014,
}



@proceedings{ISORC01,
  key =           {ISORC 2001},
  booktitle =     {5th } # ISORC,
  title =         {5th } # ISORC,
  address =       {Washington, DC},
  publisher =     IEEE,
  month =         apr,
  year =          2001
}

@proceedings{ISORC03,
  key =           {ISORC 2003},
  booktitle =     {6th } # ISORC,
  title =         {6th } # ISORC,
  editor =        {P. Puschner and T. Nakajima and A. Ghafoor},
  publisher =     IEEE,
  month =         may,
  year =          2003
}

@proceedings{ISORC04,
  key =           {ISORC 2004},
  booktitle =     {7th } # ISORC,
  title =         {7th } # ISORC,
  address =       {Vienna},
  publisher =     IEEE,
  month =         may,
  year =          2004
}

@proceedings{ISORC05,
  key =           {ISORC 2005},
  booktitle =     {8th } # ISORC,
  title =         {8th } # ISORC,
  address =       {Vienna},
  publisher =     IEEE,
  month =         may,
  year =          2005
}

@proceedings{ISORC06,
  key =           {ISORC 2006},
  booktitle =     {9th } # ISORC,
  title =         {9th } # ISORC,
  address =       {Gyeongju, Korea},
  publisher =     IEEE,
  month =         apr,
  year =          2006
}

@proceedings{ISORC07,
  key =           {ISORC 2006},
  booktitle =     {10th } # ISORC,
  title =         {10th } # ISORC,
  publisher =     IEEE,
  year =          2007
}


@proceedings{ISORC08,
  key =           {ISORC 2008},
  booktitle =     {11th } # ISORC,
  title =         {11th } # ISORC,
  address =	 {Orlando, FL},
  publisher =     IEEE,
  year =          2008
}

@proceedings{IWOOOS91,
  key =		 "IWOOOS 1991",
  booktitle =	 IWOOS,
  title =	 IWOOS,
  editor =	 "Luis-Felipe Cabrera and Vincent Russo and Marc Shapiro",
  address =	 "Palo Alto, CA",
  month =	 oct,
  publisher =	 IEEE,
  year =	 1991,
  ISBN =	 "0-8186-2267-9"
}

@proceedings{IWOOOS92,
  key =		 "IWOOOS 1992",
  booktitle =	 IWOOS,
  title =	 IWOOS,
  editor =	 "Luis-Felipe Cabrera and Vince Russo and Marc Shapiro",
  address =	 "Paris",
  month =	 sep,
  publisher =	 IEEE,
  year =	 1992,
}

@proceedings{IWOOOS93,
  key =		 "IWOOOS 1993",
  booktitle =	 IWOOS,
  title =	 IWOOS,
  year =	 1993,
  publisher =	 IEEE,
}

@proceedings{JTRES03,
  key =          {JTRES 2003},
  booktitle =    JTRES # { (JTRES)},
  title =        JTRES # { (JTRES)},
  year =         2003,
  series =	 LNCS,
  volume =	 2889,
  publisher =	 {Springer},
}

@proceedings{JTRES04,
  key =          {JTRES 2004},
  booktitle =    {2nd } # JTRES # { (JTRES)},
  title =        {2nd } # JTRES # { (JTRES)},
  editor =       {R. Meersman and Z. Tari and A. Corsaro},
  address =      {Heidelburg, Germany},
  month =        oct,
  year =         2004,
  series =	 LNCS,
  volume =	 3292,
  publisher =	 {Springer},
}

@proceedings{JTRES05,
  key =          {JTRES 2005},
  booktitle =    {3rd } # JTRES # { (JTRES)},
  title =        {3rd } # JTRES # { (JTRES)},
  address =      {San Diego, CA},
  year =         2005,
}

@proceedings{JTRES07,
  key =          {JTRES 2007},
  booktitle =    {5th } # JTRES # { (JTRES)},
  title =        {5th } # JTRES # { (JTRES)},
  address =	 {Vienna, Austria},
  month =        sep,
  year =         2007,
  isbn =	 {978-59593-813-8},
  publisher =    ACM,
}

@proceedings{JTRES08,
  key =          {JTRES 2008},
  booktitle =    {6th } # JTRES # { (JTRES)},
  title =        {6th } # JTRES # { (JTRES)},
  address =      {Santa Clara, CA},
  month =        sep,
  year =         2008,
  isbn =         {978-1-60558-337-2},
  publisher =    ACM,
}

@proceedings{JTRES09,
  key =		 {JTRES 2009},
  booktitle =	 {7th } # JTRES # { (JTRES)},
  title =	 {7th } # JTRES # { (JTRES)},
  month =	 sep,
  address =	 {Madrid, Spain},
  year =	 2009,
  publisher =	 ACM,
}

@proceedings{JTRES10,
  key =		 {JTRES 2010},
  booktitle =	 {10th } # JTRES # { (JTRES)},
  title =	 {10th } # JTRES # { (JTRES)},
  month =	 sep,
  address =	 {Prague},
  year =	 2010,
  publisher =	 ACM,
}

@proceedings{JTRES11,
  key =		 {JTRES 2011},
  booktitle =	 {9th } # JTRES # { (JTRES)},
  title =	 {9th } # JTRES # { (JTRES)},
  month =	 sep,
  address =	 {York},
  year =	 2011,
  publisher =	 ACM,
}


@proceedings{POS85,
  key =		 {POS 1985},
  title =	 "1st " # POS # " (" # aug # ", 1985)",
  booktitle =	 "1st " # POS # " (" # aug # ", 1985)",
  address =	 {Appin, Scotland},
  year =	 1988,
  series =	 {Data Types and Persistence},
  editor =	 {Malcolm P. Atkinson and Peter Buneman and Ronald Morrison},
  publisher =	 SV
}

@proceedings{POS87,
  key =		 "POS 1987",
  title =	 "2nd " # POS,
  booktitle =	 "2nd " # POS,
  address =	 "Appin, Scotland",
  editor =	 {Raymund Carrick and Richard Cooper},
  publisher =	 "Universities of Glasgow and St Andrews",
  month =	 aug,
  year =	 1987
}

@proceedings{POS89,
  key =		 {POS 1989},
  title =	 "3rd " # POS # " (" # jan # ", 1989)",
  booktitle =	 "3rd " # POS # " (" # jan # ", 1989)",
  year =	 1989,
  editor =	 {John Rosenberg and David Koch},
  series =	 {Workshops in Computing},
  address =	 {Newcastle, NSW, Australia},
  publisher =	 {Springer}
}

@proceedings{POS90,
  key =		 "POS 1990",
  title =	 {4th } # POS # " (" # sep # ", 1990)",
  booktitle =	 {4th } # POS # " (" # sep # ", 1990)",
  address =	 "Martha's Vineyard, MA",
  series =	 "Implementing Persistent Object Bases: Principles and
                  Practice",
  editor =	 "Alan Dearle and Gail M. Shaw and Stanley B. Zdonik",
  publisher =	 "Morgan Kaufman",
  year =	 1991
}

@proceedings{POS92,
  key =		 "POS 1992",
  title =	 {5th } # POS # " (" # sep # ", 1992)",
  booktitle =	 {5th } # POS # " (" # sep # ", 1992)",
  address =	 "San Miniato, Italy",
  editor =	 "Antonio Albano and Ronald Morrison",
  publisher =	 "Springer",
  series =	 {Workshops in Computing},
  year =	 1992,
}

@proceedings{POS94,
  key =		 "POS 1994",
  title =	 "6th " # POS # " (" # sep # ", 1994)",
  booktitle =	 "6th " # POS # " (" # sep # ", 1994)",
  address =	 "Tarascon, Provence, France",
  editor =	 {Malcolm P. Atkinson and David Maier and V{\'e}ronique
                  Benzaken},
  publisher =	 {Springer and British Computer Society},
  series =	 {Workshops in Computing},
  year =	 1995,
}

@proceedings{POS96,
  key =		 "POS 1996",
  title =	 {7th } # POS # " (" # may # ", 1996)",
  booktitle =	 {7th } # POS # " (" # may # ", 1996)",
  address =	 {Cape May, NJ},
  editor =	 {Richard C. H. Connor and Scott Nettles},
  series =	 {Persistent Object Systems: Principles and Practice},
  publisher =	 {Morgan Kaufmann},
  year =	 1997,
}

@proceedings{POS98,
  key =		 "POS 1998",
  title =	 {8th } # POS # " (" # aug # ", 1998)",
  booktitle =	 {8th } # POS # " (" # aug # ", 1998)",
  address =	 {Tiburon, CA},
  editor =	 {Ronald Morrison and Mick J. Jordan and Malcolm P. Atkinson},
  series =	 {Advances in Persistent Object Systems},
  publisher =	 {Morgan Kaufmann},
  year =	 1999,
}

@proceedings{POS00,
  key =		 "POS 2000",
  title =	 "9th " # POS # " (" # sep # ", 2000)",
  booktitle =	 "9th " # POS # " (" # sep # ", 2000)",
  editor =	 {Graham N. C. Kirby and Alan Dearle and Dag I. K. Sj\/{o}berg},
  address =	 "Lillehammer, Norway",
  series =	 LNCS,
  volume =	 2135,
  publisher =	 {Springer},
  year =	 2001,
}

@proceedings{JVM01,
  key =		 "JVM 2001",
  title =	 {1st } # JVM,
  booktitle =	 {1st } # JVM,
  address =	 {Monterey, CA},
  publisher =	 {USENIX},
  month =	 apr,
  year =	 2001,
}

@proceedings{JVM02,
  key =		 "JVM 2002",
  title =	 {2nd } # JVM,
  booktitle =	 {2nd } # JVM,
  address =	 {San Francisco, CA},
  publisher =	 {USENIX},
  month =	 aug,
  year =	 2002,
  url =		 {http://www.usenix.org/event/jvm02}
}

@proceedings{JVM04,
  key =		 "JVM 2004",
  title =	 {3rd } # JVM,
  booktitle =	 {3rd } # JVM,
  address =	 {San Jose, CA},
  publisher =	 {USENIX},
  month =	 may,
  year =	 2004,
  url =		 {http://www.usenix.org/event/vm04}
}

@proceedings{LCPC01,
  key =         {LCPC 2001},
  title =       {14th } # LCPC,
  booktitle =   {14th } # LCPC,
  address =	{Cumberland Falls, KT},
  series =	LNCS,
  volume =	2624,
  publisher =	SV,
  month =	aug,
  year =        2001
}

@proceedings{LCPC07,
  key =         {LCPC 2007},
  title =       {20th } # LCPC,
  booktitle =   {20th } # LCPC,
  address =     {Urbana, IL},
  month =       oct,
  year =        2007
}

@proceedings{LCPC08,
  key =         {LCPC 2008},
  title =       {21st } # LCPC,
  booktitle =   {21st } # LCPC,
  address =     {University of Alberta},
  year =        2008
}

@proceedings{LCTES94,
  key =		 {LCT-RTS 1994},
  title =	 {PLDI Workshop on Language, Compiler, and
                  Tool Support for Real-Time Systems},
  booktitle =	 {PLDI Workshop on Language, Compiler, and
                  Tool Support for Real-Time Systems},
  address =	 {Orlando, FL},
  month =	 jun,
  year =	 1994,
  publisher =    ACM,
}

@proceedings{LCTES95,
  key =		 {LCT-RTS 1995},
  title =	 {ACM SIGPLAN Workshop on Languages, Compilers, and Tools for
                  Real-Time Systems (LCT-RTS)},
  booktitle =	 {ACM SIGPLAN Workshop on Languages, Compilers, and Tools for
                  Real-Time Systems (LCT-RTS)},
  address =	 {La Jolla, CA},
  month =	 jun,
  year =	 1995,
  series =	 SIGPLAN # { 30(11)},
  publisher =	 ACM,
  doi =		 {10.1145/216636}
}

@proceedings{LCTES99,
  key =		 "LCTES 1999",
  title =	 "ACM SIGPLAN Workshop on Languages, Compilers, and Tools for
                  Embedded Systems (LCTES)",
  booktitle =	 "ACM SIGPLAN Workshop on Languages, Compilers, and Tools for
                  Embedded Systems (LCTES)",
  address =	 {Atlanta, GA},
  month =	 may,
  year =	 1999,
  series =	 SIGPLAN # { 34(7)},
  publisher =	 ACM,
  doi =		 {10.1145/314403}
}

@proceedings{LCTES00,
  key =		 "LCTES 2000",
  title =	 "ACM SIGPLAN Workshop on Languages, Compilers, and Tools for
                  Embedded Systems (LCTES)",
  booktitle =	 "ACM SIGPLAN Workshop on Languages, Compilers, and Tools for
                  Embedded Systems (LCTES)",
  address =	 {Vancouver, Canada},
  month =	 jun,
  year =	 2000,
  series =	 LNCS,
  volume =	 1985,
  publisher =	 {Springer},
  doi =		 {10.1007/3-540-45245-1}
}

@proceedings{LCTES01,
  key =		 "LCTES 2001",
  title =	 "ACM SIGPLAN Workshop on Languages, Compilers, and Tools for
                  Embedded Systems (LCTES)",
  booktitle =	 "ACM SIGPLAN Workshop on Languages, Compilers, and Tools for
                  Embedded Systems (LCTES)",
  address =	 {Snowbird, UT},
  month =	 jun,
  year =	 2001,
  series =	 SIGPLAN # { 36(8)},
  publisher =	 ACM,
  doi =		 {10.1145/384197}
}

@proceedings{LCTES02,
  key =		 "LCTES/SCOPES 2002",
  title =	 "Joint Conference on Languages, Compilers, and Tools for
                  Embedded Systems (LCTES) and Software and Compilers for
                  Embedded Systems (SCOPES)",
  booktitle =	 "Joint Conference on Languages, Compilers, and Tools for
                  Embedded Systems (LCTES) and Software and Compilers for
                  Embedded Systems (SCOPES)",
  address =	 {Berlin, Germany},
  month =	 jun,
  year =	 2002,
  series =	 SIGPLAN # { 37(7)},
  publisher =	 ACM,
  doi =		 {10.1145/513829}
}

@proceedings{LCTES03,
  key =		 "LCTES 2003",
  title =	 LCTES,
  booktitle =	 LCTES,
  address =	 {San Diego, CA},
  month =	 jun,
  year =	 2003,
  series =	 SIGPLAN # { 38(7)},
  publisher =	 ACM,
  doi =		 {10.1145/780732}
}

@proceedings{LCTES04,
  key =		 "LCTES 2004",
  title =	 LCTES,
  booktitle =	 LCTES,
  address =	 {Washington, DC},
  month =	 jun,
  year =	 2004,
  series =	 SIGPLAN # { 39(7)},
  publisher =	 ACM,
  doi =		 {10.1145/997163}
}

@proceedings{LCTES05,
  key =		 "LCTES 2005",
  title =	 LCTES,
  booktitle =	 LCTES,
  address =	 {Chicago, IL},
  month =	 jun,
  year =	 2005,
  series =	 SIGPLAN # { 40(7)},
  publisher =	 ACM,
  doi =		 {10.1145/1065910}
}

@proceedings{LCTES06,
  key =		 "LCTES 2006",
  title =	 LCTES,
  booktitle =	 LCTES,
  address =	 {Ottawa, Canada},
  month =	 jun,
  year =	 2006,
  series =	 SIGPLAN # { 41(7)},
  publisher =	 ACM,
  doi =		 {10.1145/1134650}
}

@proceedings{LCTES07,
  key =		 "LCTES 2007",
  title =	 LCTES,
  booktitle =	 LCTES,
  address =	 {San Diego, CA},
  month =	 jun,
  year =	 2007,
  series =	 SIGPLAN # { 42(7)},
  publisher =	 ACM,
  doi =		 {10.1145/1254766}
}

@proceedings{LCTES08,
  key =		 "LCTES 2008",
  title =	 LCTES,
  booktitle =	 LCTES,
  address =	 {Tucson, AZ},
  month =	 jun,
  year =	 2008,
  series =	 SIGPLAN # { 43(7)},
  publisher =	 ACM,
  doi =		 {10.1145/1375657}
}

@proceedings{LCTES09,
  key =		 "LCTES 2009",
  title =	 LCTES,
  booktitle =	 LCTES,
  address =	 {Dublin, Ireland},
  month =	 jun,
  year =	 2009,
  series =	 SIGPLAN # { 44(7)},
  publisher =	 ACM,
  doi =		 {10.1145/1542452}
}

@proceedings{LCTES10,
  key =		 "LCTES 2010",
  title =	 LCTES,
  booktitle =	 LCTES,
  address =	 {Stockholm, Sweden},
  month =	 apr,
  year =	 2010,
  series =	 SIGPLAN # { 45(4)},
  publisher =	 ACM,
  doi =		 {10.1145/1755888}
}

@proceedings{LCTES11,
  key =		 "LCTES 2011",
  title =	 LCTES,
  booktitle =	 LCTES,
  address =	 {Chicago, IL},
  month =	 apr,
  year =	 2011,
  publisher =	 ACM,
  doi =		 {10.1145/1967677}
}

@proceedings{LFP80,
  key =		 {LFP 1980},
  title =	 {LISP Conference},
  booktitle =	 {LISP Conference},
  address =	 {Stanford University, CA},
  month =	 aug,
  year =	 1980,
  publisher =	 ACM,
  doi =		 {10.1145/800087}
}

@proceedings{LFP82,
  key =		 "LFP 1982",
  title =	 "ACM Symposium on LISP and Functional Programming",
  booktitle =	 "ACM Symposium on LISP and Functional Programming",
  address =	 "Pittsburgh, PA",
  month =	 aug,
  year =	 1982,
  publisher =	 ACM,
  doi =		 {10.1145/800068}
}

@proceedings{LFP84,
  key =		 "LFP 1984",
  title =	 LFP,
  booktitle =	 LFP,
  editor =	 "Steele, Guy L.",
  address =	 "Austin, TX",
  publisher =	 ACM,
  month =	 aug,
  year =	 1984,
  doi =		 {10.1145/800055}
}

@proceedings{LFP86,
  key =		 "LFP 1986",
  title =	 LFP,
  booktitle =	 LFP,
  address =	 "Cambridge, MA",
  publisher =	 ACM,
  month =	 aug,
  year =	 1986,
  doi =		 {10.1145/319838}
}

@proceedings{LFP88,
  key =		 "LFP 1988",
  title =	 LFP,
  booktitle =	 LFP,
  publisher =	 ACM,
  address =	 "Snowbird, UT",
  month =	 jul,
  year =	 1988,
  doi =		 {10.1145/62678}
}

@proceedings{LFP90,
  key =		 "LFP 1990",
  title =	 LFP,
  booktitle =	 LFP,
  address =	 "Nice, France",
  publisher =	 ACM,
  month =	 jun,
  year =	 1990,
  doi =		 {10.1145/91556}
}

@proceedings{LFP92,
  key =		 "LFP 1992",
  title =	 LFP,
  booktitle =	 LFP,
  address =	 "San Francisco, CA",
  publisher =	 ACM,
  month =	 jun,
  year =	 1992,
  doi =		 {10.1145/141471}
}

@proceedings{LFP94,
  key =		 "LFP 1994",
  title =	 LFP,
  booktitle =	 LFP,
  address =	 {Orlando, FL},
  publisher =	 ACM,
  month =	 jun,
  year =	 1994,
  doi =		 {10.1145/182409}
}

@proceedings{MSP02,
  key =		 "MSP 2002",
  title =	 MSP,
  booktitle =	 MSP,
  address =	 {Berlin, Germany},
  month =	 jun,
  year =	 2002,
  series =	 SIGPLAN # { 38(2 supplement)},
  publisher =	 ACM,
  doi =		 {10.1145/773146}
}

@proceedings{MSP04,
  title =	 MSP,
  year =	 2004,
  key =		 {MSP 2004},
  booktitle =	 MSP,
  editor =	 {Chen Ding and Stephen Blackburn},
  address =	 {Washington, DC},
  month =	 jun,
  doi =		 {10.1145/1065895}
}

@proceedings{MSP05,
  title =	 MSP,
  year =	 2005,
  key =		 {MSP 2005},
  booktitle =	 MSP,
  editor =	 {Brad Calder and Benjamin G. Zorn},
  address =	 {Chicago, IL},
  month =	 jun,
  doi =		 {10.1145/1111583}
}

@proceedings{MSPC06,
  title =	 MSPC,
  year =	 2006,
  booktitle =	 MSPC,
  editor =	 {Antony L. Hosking and Ali-Reza Adl-Tabatabai},
  address =	 {San Jose, CA},
  month =	 oct,
  doi =		 {10.1145/1178597}
}

@proceedings{MSPC08,
  title =	 MSPC,
  year =	 2008,
  booktitle =	 MSPC,
  editor =	 {Emery Berger and Brad Chen},
  address =	 {Seattle, WA},
  month =	 mar,
  doi =		 {10.1145/1353522}
}

@proceedings{MSPC11,
  title =	 MSPC,
  year =	 2011,
  booktitle =	 MSPC,
  editor =	 {Jeffrey Vetter and Madanlal Musuvathi and Xipeng Shen},
  address =	 {San Jose, CA},
  month =	 jun,
  doi =		 {10.1145/1988915}
}

@proceedings{MSPC12,
  title =	 MSPC,
  year =	 2012,
  booktitle =	 MSPC,
  editor =	 {Onur Mutlu and Lixin Zhang},
  address =	 {Beijing, China},
  month =	 jun,
}

@proceedings{MSPC13,
  key =          "MSPC 2013",
  title =	 MSPC,
  year =	 2013,
  booktitle =	 MSPC,
  address =	 {Seattle, WA},
  month =	 jun,
}

@proceedings{MSPC14,
  key =          "MSPC 2014",
  title =	 MSPC,
  year =	 2014,
  booktitle =	 MSPC,
  address =	 {Edinburgh, UK},
  month =	 jun,
}

@proceedings{OOPSLA86,
  key =		 "OOPSLA 1986",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Portland, OR},
  month =	 nov,
  year =	 1986,
  publisher =	 ACM,
  series =	 SIGPLAN # { 21(11)},
  doi =		 {10.1145/28697}
}

@proceedings{OOPSLA87,
  key =		 "OOPSLA 1987",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Orlando, FL},
  month =	 dec,
  year =	 1987,
  series =	 SIGPLAN # { 22(12)},
  publisher =	 ACM,
  doi =		 {10.1145/38765}
}

@proceedings{OOPSLA88,
  key =		 "OOPSLA 1988",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {San Diego, CA},
  month =	 nov,
  year =	 1988,
  publisher =	 ACM,
  series =	 SIGPLAN # { 23(11)},
  doi =		 {10.1145/62083}
}

@proceedings{OOPSLA89,
  key =		 "OOPSLA 1989",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {New Orleans, LA},
  month =	 oct,
  year =	 1989,
  series =	 SIGPLAN # { 24(10)},
  publisher =	 ACM,
  doi =		 {10.1145/74877}
}

@proceedings{OOPSLA90,
  key =		 "OOPSLA 1990",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 "Ottawa, Canada",
  series =	 SIGPLAN # { 25(10)},
  publisher =	 ACM,
  month =	 oct,
  year =	 1990,
  doi =		 {10.1145/97945}
}

@proceedings{OOPSLA91,
  key =		 "OOPSLA 1991",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 "Phoenix, AZ",
  month =	 nov,
  year =	 1991,
  series =	 SIGPLAN # { 26(11)},
  publisher =	 ACM,
  doi =		 {10.1145/117954}
}

@proceedings{OOPSLA92,
  key =		 "OOPSLA 1992",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 "Vancouver, Canada",
  month =	 oct,
  year =	 1992,
  series =	 SIGPLAN # { 27(10)},
  publisher =	 ACM,
  doi =		 {10.1145/141936}
}

@proceedings{OOPSLA93,
  key =		 "OOPSLA 1993",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 "Washington, DC",
  month =	 oct,
  year =	 1993,
  series =	 SIGPLAN # { 28(10)},
  publisher =	 ACM,
  doi =		 {10.1145/165854}
}

@proceedings{OOPSLA94,
  key =		 "OOPSLA 1994",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Portland, OR},
  month =	 oct,
  year =	 1994,
  series =	 SIGPLAN # { 29(10)},
  publisher =	 ACM,
  doi =		 {10.1145/191080}
}

@proceedings{OOPSLA95,
  key =		 "OOPSLA 1995",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Austin, TX},
  month =	 oct,
  year =	 1995,
  series =	 SIGPLAN # { 30(10)},
  publisher =	 ACM,
  doi =		 {10.1145/217838}
}

@proceedings{OOPSLA96,
  key =		 "OOPSLA 1996",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {San Jose, CA},
  month =	 oct,
  year =	 1996,
  series =	 SIGPLAN # { 31(10)},
  publisher =	 ACM,
  doi =		 {10.1145/236337}
}

@proceedings{OOPSLA97,
  key =		 "OOPSLA 1997",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Atlanta, GA},
  month =	 oct,
  year =	 1997,
  series =	 SIGPLAN # { 32(10)},
  publisher =	 ACM,
  doi =		 {10.1145/263698}
}

@proceedings{OOPSLA98,
  key =		 "OOPSLA 1998",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Vancouver, Canada},
  month =	 oct,
  year =	 1998,
  series =	 SIGPLAN # { 33(10)},
  publisher =	 ACM,
  doi =		 {10.1145/286936}
}

@proceedings{OOPSLA99,
  key =		 "OOPSLA 1999",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Denver, CO},
  month =	 oct,
  year =	 1999,
  series =	 SIGPLAN # { 34(10)},
  publisher =	 ACM,
  doi =		 {10.1145/320384}
}

@proceedings{OOPSLA00,
  key =		 "OOPSLA 2000",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Minneapolis, MN},
  month =	 oct,
  year =	 2000,
  series =	 SIGPLAN # { 35(10)},
  publisher =	 ACM,
  doi =		 {10.1145/353171}
}

@proceedings{OOPSLA01,
  key =		 "OOPSLA 2001",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Tampa, FL},
  month =	 nov,
  year =	 2001,
  series =	 SIGPLAN # { 36(11)},
  publisher =	 ACM,
  doi =		 {10.1145/504282}
}

@proceedings{OOPSLA02,
  key =		 "OOPSLA 2002",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Seattle, WA},
  month =	 nov,
  year =	 2002,
  series =	 SIGPLAN # { 37(11)},
  publisher =	 ACM,
  isbn =	 {1-58113-626-9},
  doi =		 {10.1145/582419}
}

@proceedings{OOPSLA03,
  key =		 "OOPSLA 2003",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Anaheim, CA},
  month =	 nov,
  year =	 2003,
  series =	 SIGPLAN # { 38(11)},
  publisher =	 ACM,
  doi =		 {10.1145/949305}
}

@proceedings{OOPSLA04,
  key =		 "OOPSLA 2004",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Vancouver, Canada},
  month =	 oct,
  year =	 2004,
  series =	 SIGPLAN # { 39(10)},
  publisher =	 ACM,
  doi =		 {10.1145/1028976}
}

@proceedings{OOPSLA05,
  key =		 "OOPSLA 2005",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {San Diego, CA},
  month =	 oct,
  year =	 2005,
  series =	 SIGPLAN # { 40(10)},
  publisher =	 ACM,
  doi =		 {10.1145/1094811}
}

@proceedings{OOPSLA06,
  key =		 "OOPSLA 2006",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Portland, OR},
  month =	 oct,
  year =	 2006,
  series =	 SIGPLAN # { 41(10)},
  publisher =	 ACM,
  doi =		 {10.1145/1167473}
}

@proceedings{OOPSLA07,
  key =		 "OOPSLA 2007",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Montr{\'e}al, Canada},
  month =	 oct,
  year =	 2007,
  series =	 SIGPLAN # { 42(10)},
  publisher =	 ACM,
  doi =		 {10.1145/1297027}
}

@proceedings{OOPSLA08,
  key =		 "OOPSLA 2008",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Nashville, TN},
  month =	 oct,
  year =	 2008,
  series =	 SIGPLAN # { 43(10)},
  publisher =	 ACM,
  doi =		 {10.1145/1449764}
}

@proceedings{OOPSLA09,
  key =		 "OOPSLA 2009",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Orlando, FL},
  month =	 oct,
  year =	 2009,
  series =	 SIGPLAN # { 44(10)},
  publisher =	 ACM,
  doi =		 {10.1145/1640089}
}

@proceedings{OOPSLA10,
  key =		 "OOPSLA 2010",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Reno, NV},
  month =	 oct,
  year =	 2010,
  publisher =	 ACM,
  doi =		 {10.1145/1869459}
}

@proceedings{OOPSLA12,
  key =		 "OOPSLA 2012",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Tuscon, AZ},
  month =	 oct,
  year =	 2012,
  publisher =	 ACM,
}

@proceedings{OOPSLA13,
  key =		 "OOPSLA 2013",
  title =	 OOPSLA,
  booktitle =	 OOPSLA,
  address =	 {Indianapolis, IN},
  month =	 oct,
  year =	 2013,
  publisher =	 ACM,
}

@proceedings{OOPSLA90-gc,
  key =		 "GC 1990",
  title =	 "OOPSLA/ECOOP " # WGCOOS,
  booktitle =	 "OOPSLA/ECOOP " # WGCOOS,
  address =	 {Ottawa, Canada},
  editor =	 "Eric Jul and Niels-Christian Juul",
  month =	 oct,
  year =	 1990,
  URL =		 "ftp://ftp.cs.utexas.edu/pub/garbage/GC90/",
}

@proceedings{OOPSLA91-gc,
  key =		 "GC 1991",
  title =	 "OOPSLA " # WGCOOS,
  booktitle =	 "OOPSLA " # WGCOOS,
  editor =	 "Paul R. Wilson and Barry Hayes",
  month =	 oct,
  year =	 1991,
  URL =		 "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/",
}

@proceedings{OOPSLA93-gc,
  key =		 "GC 1993",
  booktitle =	 "OOPSLA " # WGCOOS,
  title =	 "OOPSLA " # WGCOOS,
  editor =	 "J. Eliot B. Moss and Paul R. Wilson and Benjamin Zorn",
  month =	 oct,
  year =	 1993,
  URL =		 "ftp://ftp.cs.utexas.edu/pub/garbage/GC93/",
}

@proceedings{OOPSLA97-gc,
  key =		 "GC 1997",
  booktitle =	 "OOPSLA Workshop on Garbage Collection and Memory Management",
  title =	 "OOPSLA Workshop on Garbage Collection and Memory Management",
  editor =	 "Peter Dickman and Paul R. Wilson",
  month =	 oct,
  year =	 1997,
  URL =		 "http://www.dcs.gla.ac.uk/~huw/oopsla97/gc/papers.html",
}

@proceedings{PARLE87, key = "PARLE 1987",
booktitle = PARLE,
title = PARLE,
address = "Eindhoven, The Netherlands",
editor = "de Bakker, Jacobus W. and A. J. Nijman and Philip C. Treleaven",
month = jun,
year = 1987,
publisher = SV,
series = LNCS,
volume = "258/259",
}

@proceedings{PARLE89, key = "PARLE 1989",
booktitle = PARLE,
title = PARLE,
editor = "Eddy Odijk and Martin Rem and Jean-Claude Syre",
address = "Eindhoven, The Netherlands",
month = jun,
year = 1989,
publisher = SV,
series = LNCS,
volume = "365/366"
}

@proceedings{PARLE91, key = "PARLE 1991",
booktitle = PARLE,
title = PARLE,
editor = "Emile H. L. Aarts and Jan van Leeuwen and Martin Rem",
address = {Eindhoven, The Netherlands},
month = jun,
year = 1991,
publisher = SV,
series = LNCS,
volume = {505/506},
}

@proceedings{PARLE93, key = "PARLE 1993",
booktitle = PARLE,
title = PARLE,
editor = "Arndt Bode and Mike Reeve and Gottfried Wolf",
address = {Munich},
month = jun,
year = 1993,
publisher = SV,
series = LNCS,
volume = 694,
doi = {10.1007/3-540-56891-3}
}

@proceedings{PARLE94, key = "PARLE 1994",
booktitle = PARLE,
title = PARLE,
editor = {Costas Halatsis and Dimitrios Maritsas and George Philokyprou and Sergios Theodoridis},
address = {Athens},
month = jul,
year = 1994,
publisher = SV,
volume = 817,
series = LNCS,
doi = {10.1007/3-540-58184-7}
}

@proceedings{PASTE98,
  key =		 "PASTE 1998",
  title =	 PASTE,
  booktitle =	 PASTE,
  address =	 {Montr\'{e}al, Canada},
  year =	 1998,
  series =	 SIGPLAN # { 33(7)},
  publisher =	 ACM,
}

@proceedings{PASTE01,
  key =		 {PASTE 2001},
  title =	 PASTE,
  booktitle =	 PASTE,
  year =	 2001,
  address =	 {Snowbird, UT},
  month =	 jun,
  publisher =	 ACM
}

@proceedings{PLILP92, key = "PLILP92",
booktitle = "4th International Symposium on Programming Language Implementation and Logic Programming",
title = "4th International Symposium on Programming Language Implementation and Logic Programming",
month = aug,
year = 1992,
address = "Leuven, Belgium",
publisher = SV,
series = LNCS,
volume = 631,
editor = {Maurice Bruynooghe and Martin Wirsing},
doi = {10.1007/3-540-55844-6}
}

@proceedings{PLDI79,
  key =		 "SIGPLAN 1979",
  booktitle =	 "ACM SIGPLAN Symposium on Compiler Construction",
  title =	 "ACM SIGPLAN Symposium on Compiler Construction",
  address =	 "Denver, CO",
  month =	 aug,
  year =	 1979,
  series =	 SIGPLAN # { 14(7)},
  publisher =	 ACM,
  doi =		 {10.1145/800229}
}

@proceedings{PLDI86,
  key =		 "SIGPLAN 1986",
  booktitle =	 "ACM SIGPLAN Symposium on Compiler Construction",
  title =	 "ACM SIGPLAN Symposium on Compiler Construction",
  year =	 1986,
  month =	 jun,
  address =	 "Palo Alto, CA",
  series =	 SIGPLAN # { 21(7)},
  publisher =	 ACM,
  doi =		 {10.1145/12276}
}

@proceedings{PLDI87,
  key =		 {SIGPLAN 1987},
  title =	 {Symposium on Interpreters and Interpretive Techniques},
  booktitle =	 {Symposium on Interpreters and Interpretive Techniques},
  address =	 {St Paul, MN},
  month =	 jun,
  year =	 1987,
  series =	 SIGPLAN # { 22(7)},
  publisher =	 ACM,
  doi =		 {10.1145/29650}
}

@proceedings{PLDI88,
  key =		 "PLDI 1988",
  title =	 PLDI,
  booktitle =	 PLDI,
  address =	 "Atlanta",
  month =	 jun,
  year =	 1988,
  series =	 SIGPLAN # { 23(7)},
  publisher =	 ACM,
  doi =		 {10.1145/53990}
}

@proceedings{PLDI89,
  key =		 "PLDI 1989",
  title =	 PLDI,
  booktitle =	 PLDI,
  address =	 "Portland, OR",
  month =	 jun,
  year =	 1989,
  series =	 SIGPLAN # { 24(7)},
  publisher =	 ACM,
  doi =		 {10.1145/73141}
}

@proceedings{PLDI90,
  key =		 "PLDI 1990",
  title =	 PLDI,
  booktitle =	 PLDI,
  address =	 "White Plains, NY",
  month =	 jun,
  year =	 1990,
  series =	 SIGPLAN # { 25(6)},
  publisher =	 ACM,
  doi =		 {10.1145/93542}
}

@proceedings{PLDI91,
  key =		 "PLDI 1991",
  booktitle =	 PLDI,
  title =	 PLDI,
  address =	 "Toronto, Canada",
  month =	 jun,
  year =	 1991,
  series =	 SIGPLAN # { 26(6)},
  publisher =	 ACM,
  doi =		 {10.1145/113445}
}

@proceedings{PLDI92,
  key =		 "PLDI 1992",
  title =	 PLDI,
  booktitle =	 PLDI,
  address =	 "San Francisco, CA",
  month =	 jun,
  year =	 1992,
  series =	 SIGPLAN # { 27(7)},
  publisher =	 ACM,
  doi =		 {10.1145/143095}
}

@proceedings{PLDI93,
  key =		 "PLDI 1993",
  booktitle =	 PLDI,
  title =	 PLDI,
  address =	 "Albuquerque, NM",
  month =	 jun,
  year =	 1993,
  series =	 SIGPLAN # { 28(6)},
  publisher =	 ACM,
  doi =		 {10.1145/155090}
}

@proceedings{PLDI94,
  key =		 "PLDI 1994",
  title =	 PLDI,
  booktitle =	 PLDI,
  address =	 "Orlando, FL",
  month =	 jun,
  year =	 1994,
  series =	 SIGPLAN # { 29(6)},
  publisher =	 ACM,
  doi =		 {10.1145/178243}
}

@proceedings{PLDI95,
  key =		 "PLDI 1995",
  title =	 PLDI,
  booktitle =	 PLDI,
  address =	 "La Jolla, CA",
  month =	 jun,
  year =	 1995,
  series =	 SIGPLAN # { 30(6)},
  publisher =	 ACM,
  doi =		 {10.1145/207110}
}

@proceedings{PLDI96,
  key =		 "PLDI 1996",
  title =	 PLDI,
  booktitle =	 PLDI,
  address =	 "Philadelphia, PA",
  month =	 may,
  year =	 1996,
  series =	 SIGPLAN # { 31(5)},
  publisher =	 ACM,
  doi =		 {10.1145/231379}
}

@proceedings{PLDI97,
  key =		 "PLDI 1997",
  title =	 PLDI,
  booktitle =	 PLDI,
  address =	 {Las Vegas, NV},
  month =	 jun,
  year =	 1997,
  series =	 SIGPLAN # { 32(5)},
  publisher =	 ACM,
  doi =		 {10.1145/258915}
}

@proceedings{PLDI98,
  key =		 "PLDI 1998",
  title =	 PLDI,
  booktitle =	 PLDI,
  address =	 {Montreal, Canada},
  month =	 jun,
  year =	 1998,
  series =	 SIGPLAN # { 33(5)},
  publisher =	 ACM,
  doi =		 {10.1145/277650}
}

@proceedings{PLDI99,
  key =		 "PLDI 1999",
  title =	 PLDI,
  booktitle =	 PLDI,
  address =	 {Atlanta, GA},
  month =	 may,
  year =	 1999,
  series =	 SIGPLAN # { 34(5)},
  publisher =	 ACM,
  doi =		 {10.1145/301618}
}

@proceedings{PLDI00,
  key =		 "PLDI 2000",
  title =	 PLDI,
  booktitle =	 PLDI,
  address =	 {Vancouver, Canada},
  month =	 jun,
  year =	 2000,
  series =	 SIGPLAN # { 35(5)},
  publisher =	 ACM,
  doi =		 {10.1145/349299}
}

@proceedings{PLDI01,
  key =		 "PLDI 2001",
  title =	 PLDI,
  booktitle =	 PLDI,
  address =	 {Snowbird, UT},
  month =	 jun,
  year =	 2001,
  series =	 SIGPLAN # { 36(5)},
  publisher =	 ACM,
  doi =		 {10.1145/378795}
}

@proceedings{PLDI02,
  key =		 "PLDI 2002",
  title =	 PLDI,
  booktitle =	 PLDI,
  address =	 {Berlin, Germany},
  month =	 jun,
  year =	 2002,
  series =	 SIGPLAN # { 37(5)},
  publisher =	 ACM,
  doi =		 {10.1145/512529}
}

@proceedings{PLDI03,
  key =		 "PLDI 2003",
  title =	 PLDI,
  booktitle =	 PLDI,
  address =	 {San Diego, CA},
  month =	 jun,
  year =	 2003,
  series =	 SIGPLAN # { 38(5)},
  publisher =	 ACM,
  doi =		 {10.1145/781131}
}

@proceedings{PLDI04,
  key =		 "PLDI 2004",
  title =	 PLDI,
  booktitle =	 PLDI,
  editor =	 {William Pugh and Craig Chambers},
  address =	 {Washington, DC},
  month =	 jun,
  year =	 2004,
  series =	 SIGPLAN # { 39(6)},
  publisher =	 ACM,
  doi =		 {10.1145/996841}
}

@proceedings{PLDI05,
  key =		 "PLDI 2005",
  title =	 PLDI,
  booktitle =	 PLDI,
  editor =	 {Vivek Sarkar and Mary W. Hall},
  address =	 {Chicago, IL},
  month =	 jun,
  year =	 2005,
  series =	 SIGPLAN # { 40(6)},
  publisher =	 ACM,
  doi =		 {10.1145/1065010}
}

@proceedings{PLDI06,
  key =		 "PLDI 2006",
  title =	 PLDI,
  booktitle =	 PLDI,
  editor =	 {Michael I. Schwartzbach and Thomas Ball},
  address =	 {Ottawa, Canada},
  month =	 jun,
  year =	 2006,
  series =	 SIGPLAN # { 41(6)},
  publisher =	 ACM,
  doi =		 {10.1145/1133981}
}

@proceedings{PLDI07,
  key =		 "PLDI 2007",
  title =	 PLDI,
  booktitle =	 PLDI,
  editor =	 {Jeanne Ferrante and Kathryn S. McKinley},
  address =	 {San Diego, CA},
  month =	 jun,
  year =	 2007,
  series =	 SIGPLAN # { 42(6)},
  publisher =	 ACM,
  doi =		 {10.1145/1250734}
}

@proceedings{PLDI08,
  key =		 "PLDI 2008",
  title =	 PLDI,
  booktitle =	 PLDI,
  editor =	 {Rajiv Gupta and Saman P. Amarasinghe},
  address =	 {Tucson, AZ},
  month =	 jun,
  year =	 2008,
  series =	 SIGPLAN # { 43(6)},
  publisher =	 ACM,
  doi =		 {10.1145/1375581}
}

@proceedings{PLDI09,
  key =		 "PLDI 2009",
  title =	 PLDI,
  booktitle =	 PLDI,
  address =	 {Dublin, Ireland},
  month =	 jun,
  year =	 2009,
  series =	 SIGPLAN # { 44(6)},
  publisher =	 ACM,
  doi =		 {10.1145/1542476}
}

@proceedings{PLDI10,
  key =		 "PLDI 2010",
  title =	 PLDI,
  editors =	 {Benjamin G. Zorn and Alexander Aiken},
  booktitle =	 PLDI,
  address =	 {Toronto, Canada},
  month =	 jun,
  year =	 2010,
  series =	 SIGPLAN # { 45(6)},
  publisher =	 ACM,
  doi =		 {10.1145/1806596}
}

@proceedings{PLDI11,
  key =		 "PLDI 2011",
  title =	 PLDI,
  booktitle =	 PLDI,
  address =	 {San Jose, CA},
  month =	 jun,
  year =	 2011,
  series =	 SIGPLAN # { 46(6)},
  publisher =	 ACM,
  doi =		 {10.1145/1993498}
}

@proceedings{PLDI12,
  key =		 "PLDI 2012",
  title =	 PLDI,
  booktitle =	 PLDI,
  address =	 {Beijing, China},
  month =	 jun,
  year =	 2012,
  publisher =	 ACM,
}

@proceedings{PLDI13,
  key =		 "PLDI 2013",
  title =	 PLDI,
  booktitle =	 PLDI,
  address =	 {Seattle, WA},
  month =	 jun,
  year =	 2013,
  publisher =	 ACM,
}


@proceedings{PPoPP90,
  key =		 "PPOPP 1990",
  title =	 "2nd " # PPoPP,
  booktitle =	 "2nd " # PPoPP,
  address =	 {Seattle, WA},
  month =	 mar,
  year =	 1990,
  series =	 SIGPLAN # { 25(3)},
  publisher =    ACM
}

@proceedings{PPoPP91,
  key =		 "PPOPP 1991",
  title =	 "3rd " # PPoPP,
  booktitle =	 "3rd " # PPoPP,
  address =	 "Williamsburg, VA",
  month =	 apr,
  year =	 1991,
  series =	 SIGPLAN # { 26(7)},
  publisher =    ACM
}

@proceedings{PPoPP93,
  key =		 "PPOPP 1993",
  title =	 "4th " # PPoPP,
  booktitle =	 "4th " # PPoPP,
  address =	 "San Diego, CA",
  month =	 may,
  year =	 1993,
  series =	 SIGPLAN # { 28(7)},
  publisher =    ACM
}

@proceedings{PPoPP95,
  key =		 "PPOPP 1995",
  title =	 "5th " # PPoPP,
  booktitle =	 "5th " # PPoPP,
  address =	 "Santa Barbara, CA",
  month =	 jul,
  year =	 1995,
  series =	 SIGPLAN # { 30(8)},
  publisher =    ACM
}

@proceedings{PPoPP97,
  key =		 "PPOPP 1997",
  title =	 "6th " # PPoPP,
  booktitle =	 "6th " # PPoPP,
  address =	 "Las Vegas, NV",
  month =	 jun,
  year =	 1997,
  series =	 SIGPLAN # { 32(7)},
  publisher =    ACM
}

@proceedings{PPoPP99,
  key =		 "PPOPP 1999",
  title =	 "" # PPoPP,
  booktitle =	 "" # PPoPP,
  address =	 "Atlanta, GA",
  month =	 may,
  year =	 1999,
  series =	 SIGPLAN # { 34(8)},
  publisher =    ACM
}

@proceedings{PPoPP01,
  key =		 "PPOPP 2001",
  title =	 "" # PPoPP,
  booktitle =	 "" # PPoPP,
  address =	 "Snowbird, UT",
  month =	 jun,
  year =	 2001,
  series =	 SIGPLAN # { 36(7)},
  publisher =    ACM
}

@proceedings{PPoPP07,
  key =		 "PPOPP 2007",
  title =	 "" # PPoPP,
  booktitle =	 "" # PPoPP,
  year =	 2007,
  publisher =	 ACM,
  address =	 {San Jose, CA},
  month =	 mar,
  doi =		 {10.1145/1229428}
}

@proceedings{PPoPP08,
  key =		 "PPOPP 2008",
  title =	 "" # PPoPP,
  booktitle =	 "" # PPoPP,
  year =	 2008,
  publisher =	 ACM,
  address =	 {Salt Lake City, UT},
  month =	 feb,
  doi =		 {10.1145/1345206}
}

@proceedings{POPL81,
  key =		 "POPL 1981",
  title =	 "8th Annual " # POPL,
  booktitle =	 "8th Annual " # POPL,
  address =	 "Williamsburg, VA",
  month =	 jan,
  year =	 1981,
  publisher =	 ACM,
  doi =		 {10.1145/567532}
}

@proceedings{POPL82,
  key =		 "POPL 1982",
  title =	 "9th Annual " # POPL,
  booktitle =	 "9th Annual " # POPL,
  address =	 "Albuquerque, NM",
  month =	 jan,
  year =	 1982,
  publisher =	 ACM,
  doi =		 {10.1145/582153}
}

@proceedings{POPL83,
  key =		 "POPL 1983",
  title =	 "10th Annual " # POPL,
  booktitle =	 "10th Annual " # POPL,
  address =	 "Austin, TX",
  month =	 jan,
  year =	 1983,
  publisher =	 ACM,
  doi =		 {10.1145/567067}
}

@proceedings{POPL84,
  key =		 "POPL 1984",
  title =	 "11th Annual " # POPL,
  booktitle =	 "11th Annual " # POPL,
  address =	 "Salt Lake City, UT",
  month =	 jan,
  year =	 1984,
  publisher =	 ACM,
  doi =		 {10.1145/800017}
}

@proceedings{POPL85,
  key =		 "POPL 1985",
  booktitle =	 "Twelfth Annual " # POPL,
  title =	 "Twelfth Annual " # POPL,
  address =	 "New Orleans, LA",
  month =	 jan,
  year =	 1985,
  publisher =	 ACM,
  doi =		 {10.1145/318593}
}

@proceedings{POPL86,
  key =		 "POPL 1986",
  booktitle =	 "13th Annual " # POPL,
  title =	 "13th Annual " # POPL,
  address =	 "St Petersburg Beach, FL",
  month =	 jan,
  year =	 1986,
  publisher =	 ACM,
  doi =		 {10.1145/512644}
}

@proceedings{POPL87,
  key =		 "POPL 1987",
  booktitle =	 "14th Annual " # POPL,
  title =	 "14th Annual " # POPL,
  address =	 "Munich, Germany",
  month =	 jan,
  year =	 1987,
  publisher =	 ACM,
  doi =		 {10.1145/41625}
}

@proceedings{POPL88,
  key =		 "POPL 1988",
  booktitle =	 "15th Annual " # POPL,
  title =	 "15th Annual " # POPL,
  address =	 "San Diego, CA",
  month =	 jan,
  year =	 1988,
  publisher =	 ACM,
  doi =		 {10.1145/73560}
}

@proceedings{POPL89,
  key =		 "POPL 1989",
  booktitle =	 "16th Annual " # POPL,
  title =	 "16th Annual " # POPL,
  address =	 "Austin, TX",
  month =	 jan,
  year =	 1989,
  publisher =	 ACM,
  doi =		 {10.1145/75277}
}

@proceedings{POPL90,
  key =		 "POPL 1990",
  booktitle =	 "17th Annual " # POPL,
  title =	 "17th Annual " # POPL,
  address =	 "San Francisco, CA",
  month =	 jan,
  year =	 1990,
  publisher =	 ACM,
  doi =		 {10.1145/96709}
}

@proceedings{POPL91,
  key =		 "POPL 1991",
  booktitle =	 "18th Annual " # POPL,
  title =	 "18th Annual " # POPL,
  address =	 "Orlando, FL",
  month =	 jan,
  year =	 1991,
  publisher =	 ACM,
  doi =		 {10.1145/99583}
}

@proceedings{POPL92,
  key =		 "POPL 1992",
  booktitle =	 "19th Annual " # POPL,
  title =	 "19th Annual " # POPL,
  address =	 {Albuquerque, NM},
  month =	 jan,
  year =	 1992,
  publisher =	 ACM,
  doi =		 {10.1145/143165}
}

@proceedings{POPL93,
  key =		 "POPL 1993",
  booktitle =	 "20th Annual " # POPL,
  title =	 "20th Annual " # POPL,
  address =	 "Charleston, SC",
  month =	 jan,
  year =	 1993,
  publisher =	 ACM,
  doi =		 {10.1145/158511}
}

@proceedings{POPL94,
  key =		 "POPL 1994",
  booktitle =	 "21st Annual " # POPL,
  title =	 "21st Annual " # POPL,
  address =	 {Portland, OR},
  month =	 jan,
  year =	 1994,
  publisher =	 ACM,
  doi =		 {10.1145/174675},
  URL =		 {http://www.acm.org/sigplan/proceedings/popl94/homepage.html}
}

@proceedings{POPL95,
  key =		 "POPL 1995",
  booktitle =	 "22nd Annual " # POPL,
  title =	 "22nd Annual " # POPL,
  address =	 "San Francisco, CA",
  month =	 jan,
  year =	 1995,
  publisher =	 ACM,
  doi =		 {10.1145/199448}
}

@proceedings{POPL96,
  key =		 "POPL 1996",
  booktitle =	 "23rd Annual " # POPL,
  title =	 "23rd Annual " # POPL,
  address =	 {St Petersburg Beach, FL},
  month =	 jan,
  year =	 1996,
  publisher =	 ACM,
  doi =		 {10.1145/237721},
  URL =		 {http://www.acm.org/sigplan/proceedings/popl96/homepage.html}
}

@proceedings{POPL97,
  key =		 "POPL 1997",
  booktitle =	 "24th Annual " # POPL,
  title =	 "24th Annual " # POPL,
  address =	 {Paris, France},
  month =	 jan,
  year =	 1997,
  publisher =	 ACM,
  doi =		 {10.1145/263699}
}

@proceedings{POPL98,
  key =		 "POPL 1998",
  booktitle =	 "25th Annual " # POPL,
  title =	 "25th Annual " # POPL,
  address =	 {San Diego, CA},
  month =	 jan,
  year =	 1998,
  publisher =	 ACM,
  doi =		 {10.1145/268946}
}

@proceedings{POPL99,
  key =		 "POPL 1999",
  booktitle =	 "Twenty-sixth Annual " # POPL,
  title =	 "Twenty-sixth Annual " # POPL,
  address =	 {San Antonio, TX},
  month =	 jan,
  year =	 1999,
  publisher =	 ACM,
  doi =		 {10.1145/292540}
}

@proceedings{POPL00,
  key =		 "POPL 2000",
  booktitle =	 "Twenty-sixth Annual " # POPL,
  title =	 "Twenty-sixth Annual " # POPL,
  address =	 {Boston, MA},
  month =	 jan,
  year =	 2000,
  publisher =	 ACM,
  doi =		 {10.1145/325694}
}

@proceedings{POPL01,
  key =		 "POPL 2001",
  title =	 "Twenty-eighth Annual " # POPL,
  booktitle =	 "Twenty-eighth Annual " # POPL,
  address =	 {London, England},
  month =	 jan,
  year =	 2001,
  series =	 SIGPLAN # { 36(3)},
  publisher =	 ACM,
  doi =		 {10.1145/360204}
}

@proceedings{POPL02,
  key =		 "POPL 2002",
  title =	 "Twenty-ninth Annual " # POPL,
  booktitle =	 "Twenty-ninth Annual " # POPL,
  address =	 "Portland, OR",
  month =	 jan,
  year =	 2002,
  series =	 SIGPLAN # { 37(1)},
  publisher =	 ACM,
  doi =		 {10.1145/503272}
}

@proceedings{POPL03,
  key =		 "POPL 2003",
  booktitle =	 "30th Annual " # POPL,
  title =	 "30th Annual " # POPL,
  address =	 {New Orleans, LA},
  month =	 jan,
  year =	 2003,
  series =	 SIGPLAN # { 38(1)},
  publisher =	 ACM,
  doi =		 {10.1145/604131}
}

@proceedings{POPL04,
  key =		 "POPL 2004",
  booktitle =	 "31st Annual " # POPL,
  title =	 "31st Annual " # POPL,
  address =	 {Venice, Italy},
  month =	 jan,
  year =	 2004,
  series =	 SIGPLAN # { 39(1)},
  publisher =	 ACM,
  doi =		 {10.1145/964001}
}

@proceedings{POPL05,
  key =		 "POPL 2005",
  booktitle =	 "32nd Annual " # POPL,
  title =	 "32nd Annual " # POPL,
  address =	 {Long Beach, CA},
  month =	 jan,
  year =	 2005,
  series =	 SIGPLAN # { 40(1)},
  publisher =	 ACM,
  doi =		 {10.1145/1040305}
}

@proceedings{POPL06,
  key =		 "POPL 2006",
  booktitle =	 "33rd Annual " # POPL,
  title =	 "33rd Annual " # POPL,
  address =	 {Charleston, SC},
  month =	 jan,
  year =	 2006,
  series =	 SIGPLAN # { 41(1)},
  publisher =	 ACM,
  doi =		 {10.1145/1111037}
}

@proceedings{POPL07,
  key =		 "POPL 2007",
  booktitle =	 "34th Annual " # POPL,
  title =	 "34th Annual " # POPL,
  address =	 {Nice, France},
  month =	 jan,
  year =	 2007,
  series =	 SIGPLAN # { 42(1)},
  publisher =	 ACM,
  doi =		 {10.1145/1190216}
}

@proceedings{POPL08,
  key =		 "POPL 2008",
  booktitle =	 "35th Annual " # POPL,
  title =	 "35th Annual " # POPL,
  address =	 {San Francisco, CA},
  month =	 jan,
  year =	 2008,
  series =	 SIGPLAN # { 43(1)},
  publisher =	 ACM,
  doi =		 {10.1145/1328438}
}

@proceedings{POPL09,
  key =		 "POPL 2009",
  booktitle =	 "36th Annual " # POPL,
  title =	 "36th Annual " # POPL,
  address =	 {Savannah, GA},
  month =	 jan,
  year =	 2009,
  publisher =	 ACM,
  doi =		 {10.1145/1480881}
}

@proceedings{POPL10,
  key =		 "POPL 2010",
  booktitle =	 "37th Annual " # POPL,
  title =	 "37th Annual " # POPL,
  address =	 {Madrid},
  month =	 jan,
  year =	 2010,
  publisher =	 ACM,
  doi =		 {10.1145/1706299}
}

@proceedings{POPL11,
  key =		 "POPL 2011",
  booktitle =	 "38th Annual " # POPL,
  title =	 "38th Annual " # POPL,
  address =	 {Austin, TX},
  month =	 jan,
  year =	 2011,
  publisher =	 ACM,
  doi =		 {10.1145/1926385}
}

@proceedings{PPPJ02,
  key =		 "PPPJ 2002",
  title =	 PPPJ,
  booktitle =	 PPPJ,
  address =	 {Dublin, Ireland},
  month =	 jun,
  year =	 2002,
  series =	 {ACM International Conference Proceeding Series},
  volume =	 25,
  isbn =	 {0-901519-87-1},
}

@proceedings{PPPJ03,
  key =		 "PPPJ 2003",
  booktitle =	 PPPJ,
  title =	 PPPJ,
  address =	 {Kilkenny City, Ireland},
  month =	 jun,
  year =	 2003,
  series =	 {ACM International Conference Proceeding Series},
  volume =	 42,
  isbn =	 {0-9544145-1-9},
}

@proceedings{PPPJ04,
  key =		 "PPPJ 2004",
  booktitle =	 PPPJ,
  title =	 PPPJ,
  address =	 {Las Vegas, NV},
  month =	 jun,
  year =	 2004,
  series =	 {ACM International Conference Proceeding Series},
  volume =	 91,
  isbn =	 {1-59593-171-6},
}

@proceedings{PPPJ06,
  key =		 "PPPJ 2006",
  booktitle =	 PPPJ,
  title =	 PPPJ,
  address =	 {Mannheim, Germany},
  month =	 sep,
  year =	 2006,
  series =	 {ACM International Conference Proceeding Series},
  volume =	 178,
  isbn =	 {3-939352-05-5},
}

@proceedings{PPPJ07,
  key =		 "PPPJ 2007",
  booktitle =	 PPPJ,
  title =	 PPPJ,
  address =	 {Lisbon, Portugal},
  month =	 sep,
  year =	 2007,
  series =	 {ACM International Conference Proceeding Series},
  volume =	 272,
  isbn =	 {978-1-59593-672-1},
  doi =		 {10.1145/1294325}
}

@proceedings{PPPJ08,
  key =		 "PPPJ 2008",
  booktitle =	 PPPJ,
  title =	 PPPJ,
  address =	 {Modena, Italy},
  month =	 sep,
  year =	 2008,
  series =	 {ACM International Conference Proceeding Series},
  volume =	 347,
  isbn =	 {978-1-60558-223-8},
}

@proceedings{PPPJ10,
  key =		 "PPPJ 2010",
  booktitle =	 PPPJ,
  title =	 PPPJ,
  address =	 {Vienna, Austria},
  month =	 sep,
  year =	 2010,
  series =	 {ACM International Conference Proceeding Series},
  volume =	 347,
  isbn = {978-1-4503-0269-2},
}

@proceedings{RTCSA99,
  key =		 "RTCSA 1999",
  booktitle =	 "6th " # RTCSAW,
  title =	 "6th " # RTCSAW,
  address = {Hong Kong},
  year =	 1999,
  organization = IEEE,
  publisher = IEEEcomp,
  issn = {1533-2306},
}

@proceedings{RTCSA00,
  key =		 "RTCSA 2000",
  booktitle =	 "7th " # RTCSAW,
  title =	 "7th " # RTCSAW,
  year =	 2000,
  organization = IEEE,
  publisher = IEEEcomp,
  issn = {1533-2306},
}

@proceedings{RTCSA02,
  key =		 "RTCSA 2002",
  booktitle =	 "8th " # RTCSA,
  title =	 "8th " # RTCSA,
  month =	 mar,
  year =	 2002,
  organization = IEEE,
  publisher = IEEEcomp,
}

@proceedings{RTCSA03,
  key =		 "RTCSA 2003",
  booktitle =	 "9th " # RTCSA,
  title =	 "9th " # RTCSA,
  month =	 aug,
  year =	 2003,
  organization = IEEE,
  publisher = IEEEcomp,
}

@proceedings{RTCSA05,
  key =		 "RTCSA 2005",
  booktitle =	 "11th " # RTCSA,
  title =	 "11th " # RTCSA,
  month =	 aug,
  year =	 2005,
  organization = IEEE,
  publisher = IEEEcomp,
}

@proceedings{RTCSA07,
  key =		 "RTCSA 2007",
  booktitle =	 "13th " # RTCSA,
  title =	 "13th " # RTCSA,
  address = {Daegu, Korea},
  month =	 aug,
  year =	 2005,
  organization = IEEE,
  publisher = IEEEcomp,
}

@proceedings{SIGMOD89,
  key =		 "SIGMOD 1989",
  title =	 SIGMOD,
  booktitle =	 SIGMOD,
  address =	 "Snowbird, Utah",
  month =	 jun,
  year =	 1989,
  series =	 {ACM SIGMOD Record 18(2)},
}

@proceedings{SOSP93,
  key =		 "SOSP 1993",
  title =	 "14th " # SOSP,
  booktitle =	 "14th " # SOSP,
  address =	 "Asheville, NC",
  month =	 dec,
  year =	 1993,
  series =	 SIGOPS # { 27(5)},
  publisher =    ACM,
  doi =		 {10.1145/168619},
}

@proceedings{SPACE01,
  key =		 "SPACE 2001",
  title =	 {1st } # SPACE,
  booktitle =	 {1st } # SPACE,
  address =	 {London, England},
  month =	 jan,
  year =	 2001,
  URL =		 {http://www.diku.dk/topps/space2001}
}

@proceedings{SPACE04,
  key =		 "SPACE 2004",
  booktitle =	 {2nd } # SPACE,
  title =	 {2nd } # SPACE,
  address =	 {Venice, Italy},
  month =	 jan,
  year =	 2004,
  URL =		 {http://www.diku.dk/topps/space2004}
}

@proceedings{SPACE06,
  key =		 "SPACE 2006",
  booktitle =	 {3rd } # SPACE,
  title =	 {3rd } # SPACE,
  address =	 {Charleston, SC},
  month =	 jan,
  year =	 2006,
  URL =		 {http://www.itu.dk/research/plt/space2006/}
}

@proceedings{TLDI03,
  key =		 "TLDI 2003",
  title =	 TLDI,
  booktitle =	 TLDI,
  editor =	 {Zhong Shao and Peter Lee},
  address =	 "New Orleans, LA",
  month =	 jan,
  year =	 2003,
  series =	 SIGPLAN # { 38(3)},
  publisher =    ACM
}

@proceedings{VEE05,
  key =		 "VEE 2005",
  title =	 {1st } # VEE,
  booktitle =	 {1st } # VEE,
  editor =	 {Michael Hind and Jan Vitek},
  address =	 {Chicago, IL},
  month =	 jun,
  year =	 2005,
  publisher =	 ACM,
  doi =		 {10.1145/1064979}
}

@proceedings{VEE06,
  key =		 "VEE 2006",
  title =	 {2nd } # VEE,
  booktitle =	 {2nd } # VEE,
  editor =	 {Jans-J. Boehm and David Grove},
  address =	 {Ottawa, Canada},
  month =	 jun,
  year =	 2006,
  publisher =	 ACM,
  doi =		 {10.1145/1134760}
}

@proceedings{VEE07,
  key =		 "VEE 2007",
  title =	 {3rd } # VEE,
  booktitle =	 {3rd } # VEE,
  editor =	 {Chandra Krintz and Steven Hand and David Tarditi},
  address =	 {San Diego, CA},
  month =	 jun,
  year =	 2007,
  publisher =	 ACM,
  doi =		 {10.1145/1254810}
}

@proceedings{VEE08,
  key =		 "VEE 2008",
  title =	 {4th } # VEE,
  booktitle =	 {4th } # VEE,
  editor =	 {David Gregg and Vikram Adve and Brian Bershad},
  address =	 {Seattle, WA},
  month =	 mar,
  year =	 2008,
  publisher =	 ACM,
  doi =		 {10.1145/1346256}
}

@proceedings{VEE09,
  key =		 "VEE 2009",
  title =	 {5th } # VEE,
  booktitle =	 {5th } # VEE,
  editor =	 {Antony L. Hosking and David Bacon and Orran Krieger},
  address =	 {Washington, DC},
  month =	 mar,
  year =	 2009,
  publisher =	 ACM,
  doi =		 {10.1145/1508293}
}

@proceedings{VEE10,
  key =		 "VEE 2010",
  title =	 {6th } # VEE,
  booktitle =	 {6th } # VEE,
  editor =	 {Marc E. Fiuczynski and Emery Berger and Andrew Warfield},
  address =	 {Pittsburgh, PA},
  month =	 mar,
  year =	 2010,
  publisher =	 ACM,
  doi =		 {10.1145/1735997}
}

@proceedings{VEE11,
  key =		 "VEE 2011",
  title =	 {7th } # VEE,
  booktitle =	 {7th } # VEE,
  editor =	 {Erez Petrank and Doug Lea},
  address =	 {Newport Beach, CA},
  month =	 mar,
  year =	 2011,
  publisher =	 ACM,
  doi =		 {10.1145/1952682}
}

@proceedings{VEE12,
  key =		 "VEE 2012",
  title =	 {8th } # VEE,
  booktitle =	 {8th } # VEE,
  editor =	 {Steven Hand and da Silva, Dilma},
  address =	 {London, UK},
  month =	 mar,
  year =	 2012,
  publisher =	 ACM,
}


@proceedings{WDAG96,
  key =		 "WDAG 1996",
  title =	 "10th International Workshop on
                  Distributed Algorithms",
  booktitle =	 "10th International Workshop on
                  Distributed Algorithms",
  editor =	 "{\"O}zalp Babaoglu and Keith Marzullo",
  address =	 "Bologna, Italy",
  month =	 oct,
  year =	 1996,
  series =	 LNCS,
  volume =	 1151,
  publisher =	 "Springer",
  doi =		 {10.1007/3-540-61769-8}
}

@misc{GCpage,
  author =	 {Richard Jones},
  title =	 {The Garbage Collection Page},
  URL =		 {http://www.cs.ukc.ac.uk/people/staff/rej/gc.html},
  note =	 {The definitive on-line resource for garbage collection
                  material}
}

@misc{GCbib,
  author =	 {Richard Jones},
  title =	 {The Garbage Collection Bibliography},
  URL =		 {http://www.cs.ukc.ac.uk/people/staff/rej/gcbib/gcbib.html},
  year =	 {1996--2009}
}

%END
