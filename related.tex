QED~\cite{ElmasQT09} is a refinement-oriented proof system for concurrent programs built on iterative use of abstraction and reduction.
Although \civl draws inspiration from QED, it has two important advantages that are key to 
the construction of proofs spanning a large abstraction gap, such as the proof of the concurrent garbage collector.
First, QED proof steps are smaller than those in \civl. 
They correspond to a single action being abstracted, or two statements being combined using reduction. 
\civl is designed to support larger proof steps in which a set of procedures are replaced by their atomic action specifications. 
Second, unlike QED which depends on global invariants, 
\civl supports the specification and verification of invariants for each program location, 
including non-interference verification through the use of linear variables. 

VCC~\cite{VCC} is a tool for verifying concurrent C programs using the Z3 SMT solver.  
Chalice~\cite{LM09} is a language and modular verification tool for concurrent programs. 
\civl is designed to verify refinement for concurrent programs.  
VCC does not support refinement and Chalice does so only for sequential programs. 
Neither VCC nor Chalice support movers and reduction reasoning.
VCC and Chalice base their invariant reasoning on objects, object ownership, and type invariants. 
Invariant reasoning in \civl is more primitive and based on assertions in yield statements. 
Although the approach in VCC and Chalice is more convenient when applicable, \civl's approach is more flexible. 
VCC and Chalice can reason sequentially about objects exclusively owned by a thread;
\civl accomplishes the same using linear variables.

Concurrent separation logic~\cite{OHearn07} is a way to reason about concurrency without having to 
explicitly check for non-interference between threads. 
Tools based on this logic, including ones that blend in explicit non-interference reasoning~\cite{SAGL,RGSep} have been developed. 
\civl's combination of interference checking and linear variables can be thought of as an extreme example of this trend, 
supplying very primitive abstractions and letting programmers mix and match these abstractions freely.

Most work on mechanical verification of garbage collectors has focused on sequential collectors~\cite{mccr07,hawb09},
with some support for incremental collection~\cite{mccr07},
but without the fine-grained interleaving that makes concurrent collection so challenging.
Gonthier~\cite{gont96} verified the invariants of a concurrent mark-sweep algorithm,
although not down to the level of individual statements and memory operations
(``it was necessary to abstract from control flow and list management details to have a manageable proof''~\cite{gont96}),
and without using refinement to prove simple atomic specifications.

More recently,
Jagannathan et al~\cite{Jagannathan14} used a refinement-style Coq proof to verify the atomicity of various GC-related operations,
such as free-list allocation,
part of a write barrier, and parts of a collector.
Furthermore, they built atomicity from a very low-level weak consistency (TSO) model rather than sequential consistency.
However, they don't yet fully verify the collector,
but rather assume invariants needed by the atomicity proofs
(``the proofs justifying the rely conditions as in the example above,
have not been fully carried out in Coq''~\cite{Jagannathan14}).
Nevertheless, combining their low-level TSO model with our complete,
higher-level proof could potentially produce a practical verified collector for modern hardware.

\section{Conclusions}

By combining a generalized implementation of interference checking, a powerful linear type checking system, and a refinement verification system that supports reduction and abstraction, 
\civl supports many forms of reasoning about concurrency without committing programmers to a particular methodology.
Two-state invariants in the style of rely-guarantee arise naturally from procedures that encapsulate one-state yield statements;
modular factoring of invariants arises naturally using parallel calls to procedures with yield statements;
and disjoint thread identifiers and monitors arise naturally from the linear type system. The combination of these techniques and reduction and abstraction supports refinement verification, allowing users to formally relate representations of their program described at different levels of abstraction and atomicity. 
The resulting system is sound, automated, efficient, and ready to use.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
