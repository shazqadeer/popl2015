Concurrent separation logic~\cite{OHearn07} started as a way to reason about concurrency without having to explicitly check for non-interference between threads.
In particular, the use of separating conjunction allows programs to partition heap locations and locked resources between threads so that only one thread has access at a time.
\civl's linear variables also express this sort of partitioning; for example, \civl can express linear maps for partitioning heaps among threads.
Linear type systems do impose a larger burden on programmers, since operations on linear variables make all separation and framing explicit, while separation logics can implicitly move resources between separating conjuncts using separation logic rules.
On the other hand, \civl does not require a theorem prover for separation logic, allowing it to work with existing fast classical logic solvers such as Z3.
Although systems like Smallfoot~\cite{Smallfoot}, CAVE~\cite{Cave}, and SLAyer~\cite{Slayer} provide some automated reasoning for separation logic formulas, these systems tend to support subsets of separation logic and datatypes rather than fully general support for separation logic.

In the absence of interference checking, the original work on concurrent separation logic~\cite{OHearn07} had to bake in abstractions for locking and resources.
More recent papers reintroduce reasoning about interference into separation logic using rely-guarantee reasoning~\cite{SAGL,RGSep}.
This allows programmers to encode their own locks and lock-free structures.
\civl's combination of interference checking and linear variables can be thought of as an extreme example of this trend, supplying very primitive abstractions and letting programmers mix and match these abstractions freely.
Parkinson~\cite{SepLog700} points that reintroducing interference checking for state, even in the relatively controlled form of rely-guarantee reasoning, may break valuable modularity properties, and advocates deny-guarantee reasoning instead.
It remains to be seen whether automated tools for logics like deny-guarantee will emerge.

VCC~\cite{VCC} is a tool for verifying concurrent C programs using the Z3 SMT solver.  VCC's reasoning is based on objects, and the VCC implementation builds in a notion of object ownership and VCC programs attach invariants directly to object types.  Chalice~\cite{LM09} is a language and modular verification tool for concurrent programs. Chalice also makes use of  object invariants, permissions and ownership transfer between threads. It supports a limited form of rely-guarantee reasoning on a per-object basis using two-state monitor invariants referring to the states the monitor is released and acquired. 

By contrast, \civl's reasoning is based on more primitive abstractions.  \civl does not build invariants directly into types or modules; programs in \civl use yield statements to express invariants and encapsulate yield statements in procedures to express invariants shared among many program points. \civl's method for verifying non-interference is more powerful than those of VCC and Chalice, as \civl makes use of yield annotations of other threads while doing so. 

\civl is designed to carry out hierarchical proofs of concurrent programs, where a program is represented at several different levels of abstraction, each with its own annotations.  Mover actions, abstract atomicity, variable and procedure hiding are key reasoning tools that support such hierarchical reasoning. By contrast, VCC is designed to reason only at the level of the concrete C program. Chalice supports refinement but only for sequential programs. Neither VCC nor Chalice support movers and reduction reasoning. They provide limited support for atomicity, i.e., sequential reasoning about objects owned exclusively by a thread. 

\civl also differs from VCC and Chalice in how framing is supported for variables that are not under exclusive control of a thread throughout a code block. In \civl, the abstract atomic action specification precisely describes the set of variables modified by an abstract-atomic procedure in the high-level program in which calls to such procedures have been replaced by their atomic action specifications and some variables may have been hidden. This high-level program may have completely new {\tt yield} predicates and invariants that are useful for reasoning at that level, as was the case in the garbage collector. Such an approach for concurrent programs is not possible in Chalice or VCC because the program representation is flat.  

QED~\cite{ElmasQT09} is a proof system for concurrent programs written using a variant of Boogie. QED supports abstraction and reduction to simplify concurrent programs and to carry out refinement proofs. Key differences between QED and \civl are as follows.
\begin{itemize}
\item Owicki-Gries and rely-guarantee-style reasoning, as well as linear variables are powerful additional features in \civl useful for verifying refinement. 
\item In QED, a global invariant is part of the proof state and can only be strengthened. In \civl, yield annotations (therefore invariants) are per proof phase. Combined with variable hiding, this allows completely different invariants at different levels of abstraction
\item QED proof steps are small. They correspond to a single action being abstracted, or two statements being combined using reduction. \civl is designed to support larger proof steps in which a set of procedures are replaced by their atomic action specifications. This facilitates larger proofs of the scale of the garbage collector.  
\item Modularity is a primary concern in \civl. In QED, procedure calls can only be inlined or replaced with atomic action specifications. \civl provides procedure-level modularity for procedures without atomic specifications as well. This allows \civl to be more efficient at lower levels of the proof where most procedures have not yet been proven atomic. 
\end{itemize}

Most work on mechanical verification of garbage collectors has focused on sequential collectors~\cite{mccr07,hawb09},
with some support for incremental collection~\cite{mccr07},
but without the fine-grained interleaving that makes concurrent collection so challenging.
Gonthier~\cite{gont96} verified the invariants of a concurrent mark-sweep algorithm,
although not down to the level of individual statements and memory operations
(``it was necessary to abstract from control flow and list management details to have a manageable proof''~\cite{gont96}),
and without using refinement to prove simple atomic specifications.

More recently,
Jagannathan et al~\cite{Jagannathan14} used a refinement style of proof in Coq to verify the atomicity of various GC-related operations,
such as free-list allocation,
part of a write barrier, and parts of a collector.
Furthermore, they build atomicity from a very low-level model assuming weak consistency (TSO) rather than sequential consistency.
However, they don't yet fully verify the collector,
but rather assume invariants needed by the atomicity proofs
(``the proofs justifying the rely conditions as in the example above,
have not been fully carried out in Coq''~\cite{Jagannathan14}).
Nevertheless, combining their low-level TSO model with our complete,
higher-level proof could potentially produce a practical verified collector for modern hardware.

\section{Conclusions}

By combining a generalized implementation of interference checking, a powerful linear type checking system, and a refinement verification system that supports reduction and abstraction, 
\civl supports many forms of reasoning about concurrency without committing programmers to a particular methodology.
Two-state invariants in the style of rely-guarantee arise naturally from procedures that encapsulate one-state yield statements;
modular factoring of invariants arises naturally using parallel calls to procedures with yield statements;
and disjoint thread identifiers and monitors arise naturally from the linear type system. The combination of these techniques and reduction and abstraction supports refinement verification, allowing users to formally relate representations of their program described at different levels of abstraction and atomicity. 
The resulting system is sound, automated, efficient, and ready to use.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
